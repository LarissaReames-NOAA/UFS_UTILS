diff --git a/CMakeLists.txt b/CMakeLists.txt
index ddbbd27..7ae7980 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -5,8 +5,7 @@ file(STRINGS "VERSION" pVersion)
 project(
   ufs_util
   VERSION ${pVersion}
-  LANGUAGES Fortran)
-
+  LANGUAGES C Fortran)
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules/")
 
 if(NOT CMAKE_BUILD_TYPE MATCHES "^(Debug|Release|RelWithDebInfo|MinSizeRel)$")
@@ -22,30 +21,47 @@ if(NOT CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel|GNU|Clang|AppleClang)$")
   message(WARNING "Compiler not officially supported: ${CMAKE_Fortran_COMPILER_ID}")
 endif()
 
-if(POLICY CMP0054)
-  cmake_policy(SET CMP0054 NEW)
+if(NOT CMAKE_C_COMPILER_ID MATCHES "^(Intel|GNU)$")
+  message(WARNING "Compiler not officially supported: ${CMAKE_C_COMPILER_ID}")
 endif()
-if(POLICY CMP0012)
-  cmake_policy(SET CMP0012 NEW)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "-g -traceback")
+  set(CMAKE_Fortran_FLAGS_RELEASE "-O3 -fp-model precise")
+  set(CMAKE_Fortran_FLAGS_DEBUG "-O0 -check -check noarg_temp_created -check nopointer -fp-stack-check -fstack-protector-all -fpe0 -debug -ftrapuv")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "-g -fbacktrace")
+  set(CMAKE_Fortran_FLAGS_RELEASE "-O3")
+  set(CMAKE_Fortran_FLAGS_DEBUG "-O0 -ggdb -fno-unsafe-math-optimizations -frounding-math -fsignaling-nans -ffpe-trap=invalid,zero,overflow -fbounds-check")
 endif()
 
-option(OPENMP "use OpenMP threading" OFF)
+if(CMAKE_C_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_C_FLAGS "-g -traceback")
+  set(CMAKE_C_FLAGS_RELEASE "-O2")
+  set(CMAKE_C_FLAGS_DEBUG "-O0")
+elseif(CMAKE_C_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_C_FLAGS " ")
+  set(CMAKE_C_FLAGS_RELEASE " ")
+  set(CMAKE_C_FLAGS_DEBUG " ")
+endif()
 
-find_package(NetCDF MODULE REQUIRED)
-find_package(MPI REQUIRED COMPONENTS Fortran)
-find_package(Jasper REQUIRED)
 find_package(PNG REQUIRED)
+find_package(ZLIB REQUIRED)
+find_package(Jasper REQUIRED)
+find_package(NetCDF REQUIRED C Fortran)
+find_package(MPI REQUIRED )
 find_package(ESMF MODULE REQUIRED)
 find_package(WGRIB2 REQUIRED)
 
+option(OPENMP "use OpenMP threading" ON)
 if(OPENMP)
   find_package(OpenMP REQUIRED COMPONENTS Fortran)
 endif()
 
 set(CMAKE_FIND_PACKAGE_PREFER_CONFIG true)
 
-if(NOT TARGET landsfcutil_4)
-  find_package(landsfcutil REQUIRED)
+if(NOT TARGET gfsio_4)
+  find_package(gfsio REQUIRED)
 endif()
 
 if(NOT TARGET sfcio_4)
@@ -56,6 +72,10 @@ if(NOT TARGET w3nco_d)
   find_package(w3nco REQUIRED)
 endif()
 
+if(NOT TARGET landsfcutil_d)
+  find_package(landsfcutil REQUIRED)
+endif()
+
 if(NOT TARGET bacio_4)
   find_package(bacio REQUIRED)
 endif()
@@ -64,6 +84,10 @@ if(NOT TARGET nemsio)
   find_package(nemsio REQUIRED)
 endif()
 
+if(NOT TARGET nemsiogfs)
+  find_package(nemsiogfs REQUIRED)
+endif()
+
 if(NOT TARGET sigio_4)
   find_package(sigio REQUIRED)
 endif()
@@ -72,6 +96,22 @@ if(NOT TARGET sp_d)
   find_package(sp REQUIRED)
 endif()
 
-add_subdirectory(sorc)
+if(NOT TARGET ip_d)
+  find_package(ip REQUIRED)
+endif()
+
+if(NOT TARGET w3emc_d)
+  find_package(w3emc REQUIRED)
+endif()
 
-install(FILES parm/varmap_tables/GFSphys_var_map.txt DESTINATION share)
+if(NOT TARGET g2_d)
+  find_package(g2 REQUIRED)
+endif()
+
+# EMC requires executables in ./exec
+set(exec_dir bin)
+if(EMC_EXEC_DIR)
+  set(exec_dir exec)
+endif()
+
+add_subdirectory(sorc)
diff --git a/LICENSE.md b/LICENSE.md
new file mode 100644
index 0000000..b7395d3
--- /dev/null
+++ b/LICENSE.md
@@ -0,0 +1,17 @@
+Copyright 2020 National Oceanic and Atmospheric Administration (by assignment from I. M. Systems Group)
+ 
+The ufs_utils code incorporated in the Unified Forecast System (UFS) was jointly developed by the 
+National Oceanic and Atmospheric Administration and the I. M. Systems Group. The gold standard copy
+of the Code will be maintained by NOAA at https://github.com/NOAA-EMC/UFS_UTILS
+ 
+The National Oceanic and Atmospheric Administration is releasing this code under the GNU Lesser 
+General Public License v3.0 (the "License"); you may not use this code except in compliance 
+with the License. 
+
+You may obtain a copy of the License at
+    https://www.gnu.org/licenses/lgpl-3.0.en.html
+ 
+Unless required by applicable law or agreed to in writing, software distributed under the License 
+is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either 
+express or implied. See the License for the specific language governing permissions and 
+limitations under the License.
diff --git a/build_all.sh b/build_all.sh
new file mode 100755
index 0000000..854538b
--- /dev/null
+++ b/build_all.sh
@@ -0,0 +1,32 @@
+#! /usr/bin/env bash
+set -eux
+
+target=${target:-"NULL"}
+
+if [[ $target == "linux.gnu" || $target == "linux.intel" ]]; then
+ unset -f module
+else
+ source ./sorc/machine-setup.sh > /dev/null 2>&1
+fi
+
+export MOD_PATH
+source ./modulefiles/build.$target             > /dev/null 2>&1
+
+#
+# --- Build all programs.
+#
+
+rm -fr ./build
+mkdir ./build
+cd ./build
+
+if [[ $target == "wcoss_cray" ]]; then
+  cmake .. -DCMAKE_INSTALL_PREFIX=../ -DEMC_EXEC_DIR=ON
+else
+  cmake .. -DCMAKE_Fortran_COMPILER=ifort -DCMAKE_C_COMPILER=icc -DCMAKE_INSTALL_PREFIX=../ -DEMC_EXEC_DIR=ON
+fi
+
+make -j 8 VERBOSE=1
+make install
+
+exit
diff --git a/cmake b/cmake
index b605db0..fece613 160000
--- a/cmake
+++ b/cmake
@@ -1 +1 @@
-Subproject commit b605db0df4f8fb1110aaba989dbffad5312752b9
+Subproject commit fece613c2968bf1000e9b57e6bfc526169063a7f
diff --git a/driver_scripts/driver_grid.cray.sh b/driver_scripts/driver_grid.cray.sh
index 6e8708a..f0defe5 100755
--- a/driver_scripts/driver_grid.cray.sh
+++ b/driver_scripts/driver_grid.cray.sh
@@ -49,8 +49,8 @@
 #
 #-----------------------------------------------------------------------
 
-. $MODULESHOME/init/sh
-module load PrgEnv-intel cfp-intel-sandybridge/1.1.0
+source ../sorc/machine-setup.sh > /dev/null 2>&1
+source ../modulefiles/build.$target
 module list
 
 #-----------------------------------------------------------------------
diff --git a/driver_scripts/driver_grid.dell.sh b/driver_scripts/driver_grid.dell.sh
index f193c40..67ebbef 100755
--- a/driver_scripts/driver_grid.dell.sh
+++ b/driver_scripts/driver_grid.dell.sh
@@ -51,13 +51,8 @@
 #
 #-----------------------------------------------------------------------
 
-module purge
-module load EnvVars/1.0.2
-module load lsf/10.1
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load NetCDF/4.5.0
-module load HDF5-serial/1.10.1
+source ../sorc/machine-setup.sh > /dev/null 2>&1
+source ../modulefiles/build.$target
 module list
 
 #-----------------------------------------------------------------------
diff --git a/driver_scripts/driver_grid.hera.sh b/driver_scripts/driver_grid.hera.sh
index ad93e30..0bf50e2 100755
--- a/driver_scripts/driver_grid.hera.sh
+++ b/driver_scripts/driver_grid.hera.sh
@@ -51,12 +51,8 @@
 
 set -x
 
-. /apps/lmod/lmod/init/sh
-module purge
-module load intel/18.0.5.274
-module load impi/2018.0.4
-module load hdf5/1.10.5
-module load netcdf/4.7.0
+source ../sorc/machine-setup.sh > /dev/null 2>&1
+source ../modulefiles/build.$target
 module list
 
 #-----------------------------------------------------------------------
diff --git a/driver_scripts/driver_grid.jet.sh b/driver_scripts/driver_grid.jet.sh
index 7035b33..a71d5e1 100755
--- a/driver_scripts/driver_grid.jet.sh
+++ b/driver_scripts/driver_grid.jet.sh
@@ -52,13 +52,8 @@
 
 set -x
 
-. /apps/lmod/lmod/init/sh
-module purge
-module load intel/18.0.5.274
-module load impi/2018.4.274
-module load szip
-module load hdf5
-module load netcdf/4.2.1.1
+source ../sorc/machine-setup.sh > /dev/null 2>&1
+source ../modulefiles/build.$target
 module list
 
 #-----------------------------------------------------------------------
@@ -92,8 +87,8 @@ fi
 #-----------------------------------------------------------------------
 
 export home_dir=$SLURM_SUBMIT_DIR/..
-export TMPDIR=/mnt/lfs3/projects/emcda/$LOGNAME/stmp/fv3_grid.$gtype
-export out_dir=/mnt/lfs3/projects/emcda/$LOGNAME/stmp/C${res}
+export TMPDIR=/lfs4/HFIP/emcda/$LOGNAME/stmp/fv3_grid.$gtype
+export out_dir=/lfs4/HFIP/emcda/$LOGNAME/stmp/C${res}
 
 #-----------------------------------------------------------------------
 # Should not need to change anything below here.
diff --git a/fix/.gitignore b/fix/.gitignore
index e69de29..4636ed7 100644
--- a/fix/.gitignore
+++ b/fix/.gitignore
@@ -0,0 +1,5 @@
+fix_am
+fix_fv3
+fix_fv3_gmted2010
+fix_orog
+fix_sfc_climo
diff --git a/fix/fix_chgres/latlon_grid3.32769-corners.nc b/fix/fix_chgres/latlon_grid3.32769-corners.nc
new file mode 100644
index 0000000..67e2a6d
Binary files /dev/null and b/fix/fix_chgres/latlon_grid3.32769-corners.nc differ
diff --git a/fix/fix_chgres/latlon_grid3.32769.nc b/fix/fix_chgres/latlon_grid3.32769.nc
new file mode 100644
index 0000000..67e2a6d
Binary files /dev/null and b/fix/fix_chgres/latlon_grid3.32769.nc differ
diff --git a/fix/link_fixdirs.sh b/fix/link_fixdirs.sh
new file mode 100755
index 0000000..7186923
--- /dev/null
+++ b/fix/link_fixdirs.sh
@@ -0,0 +1,52 @@
+#!/bin/ksh
+set -ex
+
+#--Make symbolic links to 'fixed' directories.
+
+RUN_ENVIR=${1}
+machine=${2}
+
+if [ $# -lt 2 ]; then
+    set +x
+    echo '***ERROR*** must specify two arguements: (1) RUN_ENVIR, (2) machine'
+    echo ' Syntax: link_fv3gfs.sh ( nco | emc ) ( cray | dell | hera  | jet )'
+    exit 1
+fi
+
+if [ $RUN_ENVIR != emc -a $RUN_ENVIR != nco ]; then
+    set +x
+    echo '***ERROR*** unsupported run environment'
+    echo 'Syntax: link_fv3gfs.sh ( nco | emc ) ( cray | dell | hera | jet )'
+    exit 1
+fi
+if [ $machine != cray -a $machine != hera -a $machine != dell -a $machine != jet ]; then
+    set +x
+    echo '***ERROR*** unsupported machine'
+    echo 'Syntax: link_fv3gfs.sh ( nco | emc ) ( cray | dell | hera | jet )'
+    exit 1
+fi
+
+LINK="ln -fs"
+SLINK="ln -fs"
+[[ $RUN_ENVIR = nco ]] && LINK="cp -rp"
+
+pwd=$(pwd -P)
+
+#------------------------------
+#--model fix fields
+#------------------------------
+if [ $machine == "cray" ]; then
+    FIX_DIR="/gpfs/hps3/emc/global/noscrub/emc.glopara/git/fv3gfs/fix"
+elif [ $machine = "dell" ]; then
+    FIX_DIR="/gpfs/dell2/emc/modeling/noscrub/emc.glopara/git/fv3gfs/fix"
+elif [ $machine = "hera" ]; then
+    FIX_DIR="/scratch1/NCEPDEV/global/glopara/fix"
+elif [ $machine = "jet" ]; then
+    FIX_DIR="/lfs4/HFIP/hfv3gfs/glopara/git/fv3gfs/fix"
+fi
+for dir in fix_am fix_fv3 fix_orog fix_fv3_gmted2010 fix_sfc_climo; do
+    [[ -d $dir ]] && rm -rf $dir
+    $LINK $FIX_DIR/$dir  .
+done
+
+exit 0
diff --git a/modulefiles/fv3gfs/global_chgres.hera b/modulefiles/build.hera
similarity index 62%
rename from modulefiles/fv3gfs/global_chgres.hera
rename to modulefiles/build.hera
index 564a51b..d7068c3 100644
--- a/modulefiles/fv3gfs/global_chgres.hera
+++ b/modulefiles/build.hera
@@ -1,24 +1,28 @@
 #%Module#####################################################
-## global_chgres component - hera
+## Build and run module for Hera
 #############################################################
 
-# Loading Intel Compiler Suite
+module load hpss
+module load cmake/3.16.1
 module load intel/18.0.5.274
 module load impi/2018.0.4
 
-# Loding nceplibs modules
-module use -a $MOD_PATH
-module load sigio/2.1.0
+module use -a /scratch2/NCEPDEV/nwprod/NCEPLIBS/modulefiles
+module load prod_util/1.1.0
 module load w3nco/2.0.6
 module load w3emc/2.3.0
-module load sp/2.0.2
-module load bacio/2.0.2
 module load nemsio/2.2.3
-module load nemsiogfs/2.2.0
+module load bacio/2.0.2
+module load sp/2.0.2
 module load ip/3.0.1
 module load sfcio/1.1.0
+module load sigio/2.1.0
 module load gfsio/1.1.0
+module load nemsiogfs/2.2.0
 module load landsfcutil/2.1.0
+module load g2/2.5.0
+
 module load netcdf_parallel/4.7.4
+module load esmf/8.0.0_ParallelNetCDF
 
-set FCMP ifort
+export WGRIB2_ROOT="/scratch1/NCEPDEV/da/George.Gayno/noscrub/wgrib2"
diff --git a/modulefiles/build.jet b/modulefiles/build.jet
new file mode 100644
index 0000000..5b55269
--- /dev/null
+++ b/modulefiles/build.jet
@@ -0,0 +1,30 @@
+#%Module#####################################################
+## Build and run module for Jet
+#############################################################
+
+module use /lfs4/HFIP/hfv3gfs/nwprod/NCEPLIBS/modulefiles
+module load cmake/3.16.1
+module load intel/18.0.5.274
+module load impi/2018.4.274
+module load szip/2.1
+module load hdf5/1.10.4
+module load netcdf/4.6.1
+export NETCDF="/apps/netcdf/4.6.1/intel/18.0.5.274"
+module load w3nco/v2.0.6
+module load w3emc/v2.2.0
+module load sp/v2.0.2
+module load ip/v3.0.0
+module load bacio/v2.0.2
+module load sigio/v2.1.0
+module load sfcio/v1.0.0
+module load nemsio/v2.2.3
+module load nemsiogfs/v2.0.1
+module load gfsio/v1.1.0
+module load landsfcutil/v2.1.0
+module load g2/v3.1.0
+
+# Use DTCs version of esmf v8.  POC Dom H.
+module use -a /lfs4/HFIP/hfv3gfs/software/modulefiles/intel-18.0.5.274/impi-2018.4.274
+module load esmf/8.0.0
+ 
+export WGRIB2_ROOT="/lfs4/HFIP/hwrfv3/Jili.Dong/wgrib2-2.0.8/grib2/lib"
diff --git a/modulefiles/build.orion b/modulefiles/build.orion
new file mode 100644
index 0000000..0adf7b9
--- /dev/null
+++ b/modulefiles/build.orion
@@ -0,0 +1,31 @@
+#############################################################
+## Build module for Orion
+#############################################################
+
+module load cmake/3.15.4
+module load intel/2020
+module load impi/2020
+
+module use -a /apps/contrib/NCEPLIBS/orion/modulefiles
+module load w3nco/2.1.0
+module load nemsio/2.3.0
+module load bacio/2.2.0
+module load sp/2.1.0
+module load sfcio/1.2.0
+module load sigio/2.2.0
+module load gfsio/1.2.0
+module load w3emc/2.5.0
+module load ip/3.1.0
+module load nemsiogfs/2.3.0
+module load landsfcutil/2.2.0
+
+# George V's version.
+module use -a /apps/contrib/NCEPLIBS/lib/modulefiles
+module load g2-intel-sandybridge/2.5.0
+
+export Jasper_ROOT="/apps/jasper-1.900.1"
+
+module load netcdf/4.7.2-parallel
+module load esmf/8.0.0_ParallelNetCDF
+
+export WGRIB2_ROOT="/work/noaa/da/ggayno/save/wgrib2"
diff --git a/modulefiles/build.wcoss_cray b/modulefiles/build.wcoss_cray
new file mode 100644
index 0000000..14506ef
--- /dev/null
+++ b/modulefiles/build.wcoss_cray
@@ -0,0 +1,40 @@
+#%Module#####################################################
+## Build and run module for WCOSS-Cray
+#############################################################
+
+module load prod_util/1.1.0
+module load hpss/4.1.0.3
+module load xt-lsfhpc/9.1.3
+module load cfp-intel-sandybridge/1.1.0
+module load cmake/3.16.2
+module load PrgEnv-intel/5.2.56
+module rm intel
+module load intel/16.3.210
+module load cray-mpich/7.2.0
+module load craype-haswell
+module load alps/5.2.4-2.0502.9822.32.1.ari
+module load cray-netcdf/4.3.3.1
+module load cray-hdf5/1.8.14
+module load w3nco-intel/2.0.6
+module load nemsio-intel/2.2.3
+module load bacio-intel/2.0.2
+module load sp-intel/2.0.2
+module load ip-intel/3.0.0
+module load sigio-intel/2.1.0
+module load sfcio-intel/1.0.0
+module load landsfcutil-intel/2.1.0
+module load gfsio-intel/1.1.0
+module load w3emc-intel/2.2.0
+module load nemsiogfs-intel/2.0.1
+module load g2-intel/2.5.0
+export ZLIB_ROOT=/usrx/local/prod/zlib/1.2.7/intel/haswell
+export PNG_ROOT=/usrx/local/prod//png/1.2.49/intel/haswell
+export Jasper_ROOT=/usrx/local/prod/jasper/1.900.1/intel/haswell
+
+module use /gpfs/hps3/emc/nems/noscrub/emc.nemspara/soft/modulefiles
+module load esmf/8.0.0
+export NETCDF=/opt/cray/netcdf/4.3.3.1/INTEL/14.0
+module rm gcc
+module load gcc/6.3.0
+
+export WGRIB2_ROOT=/gpfs/hps3/emc/global/noscrub/George.Gayno/wgrib2
diff --git a/modulefiles/fv3gfs/global_chgres.wcoss_dell_p3 b/modulefiles/build.wcoss_dell_p3
similarity index 50%
rename from modulefiles/fv3gfs/global_chgres.wcoss_dell_p3
rename to modulefiles/build.wcoss_dell_p3
index 56de3b7..338663c 100644
--- a/modulefiles/fv3gfs/global_chgres.wcoss_dell_p3
+++ b/modulefiles/build.wcoss_dell_p3
@@ -1,25 +1,34 @@
 #%Module#####################################################
-## global_chgres component - wcoss_dell_p3
+## Build and run module for WCOSS-Dell P3
 #############################################################
+
+module load lsf/10.1
+module load HPSS/5.0.2.5
+module load cmake/3.16.2
 module load ips/18.0.1.163
 module load impi/18.0.1
-
 module load w3nco/2.0.6
 module load w3emc/2.3.0
 module load sp/2.0.2
 module load nemsio/2.2.3
-module load nemsiogfs/2.0.1
+module load bacio/2.0.2
 module load ip/3.0.1
 module load sfcio/1.0.0
+module load sigio/2.1.0
 module load gfsio/1.1.0
 module load landsfcutil/2.1.0
-module load bacio/2.0.2
-module load  sigio/2.1.0 
+module load nemsiogfs/2.0.1
+module load g2/3.1.0
+module load jasper/1.900.29
+export Jasper_ROOT="/usrx/local/prod/packages/gnu/4.8.5/jasper/1.900.29"
 
 module use /usrx/local/nceplibs/dev/NCEPLIBS/modulefiles
 module load netcdf_parallel/4.7.4
 
-#
-export FCMP=ifort
-export LDFLAGSM="-qopenmp -auto"
-export OMPFLAGM="-qopenmp -auto"
+module use /gpfs/dell2/emc/modeling/noscrub/emc.nemspara/soft/modulefiles
+module load esmf/8.0.0_ParallelNetCDF
+
+export WGRIB2_ROOT=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/wgrib2
+
+module use /usrx/local/dev/modulefiles
+module load prod_util/1.1.3
diff --git a/modulefiles/chgres_cube.hera b/modulefiles/chgres_cube.hera
deleted file mode 100644
index 8fbd5ba..0000000
--- a/modulefiles/chgres_cube.hera
+++ /dev/null
@@ -1,28 +0,0 @@
-#%Module#####################################################
-## Build module for Hera
-#############################################################
-
-module load intel/18.0.5.274
-module load impi/2018.0.4
-#module use -a $MOD_PATH
-module use -a /contrib/da/spack/share/spack/modules/linux-centos7-skylake_avx512
-module load cmake/3.15.3-intel-19.0.4.243
-module load w3nco/v2.0.6-intel-19.0.4.243-impi
-module load nemsio/v2.2.3-intel-19.0.4.243-impi
-module load nemsiogfs/v2.2.1-intel-19.0.4.243-impi
-module load ip/v3.0.0-intel-19.0.4.243
-module load g2/v3.1.0-intel-19.0.4.243
-module load landsfcutil/v2.1.0-intel-19.0.4.243
-module load bacio/v2.1.0-intel-19.0.4.243
-module load sp/v2.0.2-intel-19.0.4.243
-module load sfcio//v1.1.0-intel-19.0.4.243
-module load sigio/v2.1.0-intel-19.0.4.243-impi
-module load esmf/8.0.0-intel-19.0.4.243-impi
-
-export WGRIB2API_INC="/apps/wgrib2/2.0.8/intel/18.0.3.222/lib"
-export WGRIB2_LIB="/apps/wgrib2/2.0.8/intel/18.0.3.222/lib/libwgrib2.a"
-
-export FCOMP=mpiifort
-export FFLAGS="-O3 -fp-model precise -g -traceback -r8 -i4 -qopenmp -convert big_endian -assume byterecl"
-# for debugging
-#export FFLAGS="-O0 -g -traceback -r8 -i4 -qopenmp -convert big_endian -check bounds -warn unused -assume byterecl"
diff --git a/modulefiles/chgres_cube.jet b/modulefiles/chgres_cube.jet
deleted file mode 100644
index 6a1f934..0000000
--- a/modulefiles/chgres_cube.jet
+++ /dev/null
@@ -1,27 +0,0 @@
-#%Module#####################################################
-## chgres build module for Jet
-#############################################################
-
-module load intel/18.0.5.274
-module load impi/2018.4.274
-module load szip/2.1
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
-
-module load w3nco/v2.0.6
-module load sp/v2.0.2
-module load bacio/v2.0.2
-module load sigio/v2.1.0
-module load sfcio/v1.0.0
-module load nemsio/v2.2.3
-
-module use /mnt/lfs3/projects/hfv3gfs/gwv/ljtjet/lib/modulefiles
-module load esmflocal/ESMF_8_0_0_beta_snapshot_21
-
-export FCOMP=mpiifort
-export FFLAGS="-O3 -fp-model precise -g -traceback -r8 -i4 -qopenmp -convert big_endian -assume byterecl"
-#debug
-#export FFLAGS="-O0 -g -traceback -r8 -i4 -qopenmp -convert big_endian -check bounds -warn unused -assume byterecl"
- 
-export WGRIB2API_INC="/mnt/lfs3/projects/hwrfv3/Jili.Dong/wgrib2-2.0.8/grib2/lib"
-export WGRIB2_LIB="/mnt/lfs3/projects/hwrfv3/Jili.Dong/wgrib2-2.0.8/grib2/lib/libwgrib2.a"
diff --git a/modulefiles/chgres_cube.linux.gnu b/modulefiles/chgres_cube.linux.gnu
deleted file mode 100644
index ba76044..0000000
--- a/modulefiles/chgres_cube.linux.gnu
+++ /dev/null
@@ -1,24 +0,0 @@
-#############################################################
-## chgres_cube component - linux.gnu
-#############################################################
-
-export IP_INCd=${NCEPLIBS}/ip/include_d
-export NEMSIO_INC=${NCEPLIBS}/nemsio/include
-export SFCIO_INC4=${NCEPLIBS}/sfcio/include_4
-export SIGIO_INC4=${NCEPLIBS}/sigio/include_4
-
-export BACIO_LIB4=${NCEPLIBS}/bacio/lib/libbacio_v2.1.0_4.a
-export IP_LIBd=${NCEPLIBS}/ip/lib/libip_v3.0.0_d.a
-export NEMSIO_LIB=${NCEPLIBS}/nemsio/lib/libnemsio_v2.2.3.a
-export SFCIO_LIB4=${NCEPLIBS}/sfcio/lib/libsfcio_v1.1.0_4.a
-export SIGIO_LIB4=${NCEPLIBS}/sigio/lib/libsigio_v2.1.0_4.a
-export SP_LIBd=${NCEPLIBS}/sp/lib/libsp_v2.0.2_d.a
-export W3NCO_LIBd=${NCEPLIBS}/w3nco/lib/libw3nco_v2.0.6_d.a
-
-export WGRIB2API_INC=${WGRIB2_DIR}/include
-export WGRIB2_LIB=${WGRIB2_DIR}/lib/libwgrib2.a
-
-export FCOMP=mpif90
-export FFLAGS="-O3 -g -fbacktrace -fdefault-real-8 -ffree-line-length-none -fopenmp -fconvert=big-endian"
-# for debugging
-#export FFLAGS="-O0 -g -fbacktrace -fdefault-real-8 -ffree-line-length-none -fopenmp -fconvert=big-endian"
diff --git a/modulefiles/chgres_cube.linux.intel b/modulefiles/chgres_cube.linux.intel
deleted file mode 100644
index 9af64a3..0000000
--- a/modulefiles/chgres_cube.linux.intel
+++ /dev/null
@@ -1,24 +0,0 @@
-#############################################################
-## chgres_cube component - linux.intel
-#############################################################
-
-export IP_INCd=${NCEPLIBS}/ip/include_d
-export NEMSIO_INC=${NCEPLIBS}/nemsio/include
-export SFCIO_INC4=${NCEPLIBS}/sfcio/include_4
-export SIGIO_INC4=${NCEPLIBS}/sigio/include_4
-
-export BACIO_LIB4=${NCEPLIBS}/bacio/lib/libbacio_v2.1.0_4.a
-export IP_LIBd=${NCEPLIBS}/ip/lib/libip_v3.0.0_d.a
-export NEMSIO_LIB=${NCEPLIBS}/nemsio/lib/libnemsio_v2.2.3.a
-export SFCIO_LIB4=${NCEPLIBS}/sfcio/lib/libsfcio_v1.1.0_4.a
-export SIGIO_LIB4=${NCEPLIBS}/sigio/lib/libsigio_v2.1.0_4.a
-export SP_LIBd=${NCEPLIBS}/sp/lib/libsp_v2.0.2_d.a
-export W3NCO_LIBd=${NCEPLIBS}/w3nco/lib/libw3nco_v2.0.6_d.a
-
-export WGRIB2API_INC=${WGRIB2_DIR}/include
-export WGRIB2_LIB=${WGRIB2_DIR}/lib/libwgrib2.a
-
-export FCOMP=mpif90
-export FFLAGS="-O3 -fp-model source -g -traceback -r8 -i4 -qopenmp -convert big_endian -assume byterecl"
-# for debugging
-#export FFLAGS="-O0 -g -traceback -r8 -i4 -qopenmp -convert big_endian -check bounds -warn unused -assume byterecl"
diff --git a/modulefiles/chgres_cube.wcoss_cray b/modulefiles/chgres_cube.wcoss_cray
deleted file mode 100644
index d80eaaa..0000000
--- a/modulefiles/chgres_cube.wcoss_cray
+++ /dev/null
@@ -1,31 +0,0 @@
-#%Module#####################################################
-## chgres build module for WCOSS-Cray
-#############################################################
-
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf/4.3.3.1
-module load cray-hdf5/1.8.14
-module load w3nco-intel/2.0.6
-module load nemsio-intel/2.2.3
-module load bacio-intel/2.0.2
-module load sp-intel/2.0.2
-module load sigio-intel/2.1.0
-module load sfcio-intel/1.0.0
-
-module use /gpfs/hps3/emc/nems/noscrub/emc.nemspara/soft/modulefiles
-module load esmf/8.0.0
-module rm gcc
-module load gcc/4.9.2
-
-
-export WGRIB2API_INC=/gpfs/hps3/emc/global/noscrub/George.Gayno/wgrib2/include
-export WGRIB2_LIB=/gpfs/hps3/emc/global/noscrub/George.Gayno/wgrib2/lib/libwgrib2.a
-
-export FCOMP=ftn
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4 -qopenmp -convert big_endian -assume byterecl"
-# for debugging
-#export FFLAGS="-O0 -g -r8 -i4 -qopenmp -convert big_endian -check bounds -assume byterecl -warn unused"
diff --git a/modulefiles/chgres_cube.wcoss_dell_p3 b/modulefiles/chgres_cube.wcoss_dell_p3
deleted file mode 100644
index 02c8e36..0000000
--- a/modulefiles/chgres_cube.wcoss_dell_p3
+++ /dev/null
@@ -1,24 +0,0 @@
-#%Module#####################################################
-## chgres build module for WCOSS-Dell P3
-#############################################################
-
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load NetCDF/4.5.0
-module load w3nco/2.0.6
-module load sp/2.0.2
-module load nemsio/2.2.3
-module load bacio/2.0.2
-module load sfcio/1.0.0
-module load sigio/2.1.0
-
-module use /gpfs/dell2/emc/modeling/noscrub/emc.nemspara/soft/modulefiles
-module load esmf/8.0.0
-
-export WGRIB2API_INC=/u/Wesley.Ebisuzaki/home/grib2.v2.0.8.intel/lib
-export WGRIB2_LIB=/u/Wesley.Ebisuzaki/home/grib2.v2.0.8.intel/lib/libwgrib2.a
-
-export FCOMP=mpif90
-export FFLAGS="-O3 -fp-model precise -g -traceback -r8 -i4 -qopenmp -convert big_endian -assume byterecl"
-# for debugging
-#export FFLAGS="-O0 -g -traceback -r8 -i4 -qopenmp -convert big_endian -check bounds -warn unused -assume byterecl"
diff --git a/modulefiles/fv3gfs/fre-nctools.gaea b/modulefiles/fv3gfs/fre-nctools.gaea
deleted file mode 100644
index edce663..0000000
--- a/modulefiles/fv3gfs/fre-nctools.gaea
+++ /dev/null
@@ -1,10 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools
-#############################################################
-   module rm PrgEnv-pgi PrgEnv-pathscale PrgEnv-intel PrgEnv-cray PrgEnv-gnu
-   module load PrgEnv-intel
-   module swap intel intel/15.0.2.164
-   module load cray-hdf5
-   module load cray-netcdf
-   #setenv LIBRARY_PATH ${LIBRARY_PATH}:${NETCDF_DIR}/lib:${HDF5}/lib
-
diff --git a/modulefiles/fv3gfs/fre-nctools.hera b/modulefiles/fv3gfs/fre-nctools.hera
deleted file mode 100644
index e035db2..0000000
--- a/modulefiles/fv3gfs/fre-nctools.hera
+++ /dev/null
@@ -1,9 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools
-#############################################################
-
-module load intel/18.0.5.274
-module load impi/2018.0.4
-
-module load netcdf/4.7.0
-module load hdf5/1.10.5
diff --git a/modulefiles/fv3gfs/fre-nctools.jet b/modulefiles/fv3gfs/fre-nctools.jet
deleted file mode 100644
index 9ba89bf..0000000
--- a/modulefiles/fv3gfs/fre-nctools.jet
+++ /dev/null
@@ -1,8 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools
-#############################################################
-module load intel/18.0.5.274
-module load impi/2018.4.274
-module load szip/2.1
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
diff --git a/modulefiles/fv3gfs/fre-nctools.wcoss b/modulefiles/fv3gfs/fre-nctools.wcoss
deleted file mode 100644
index ce886dc..0000000
--- a/modulefiles/fv3gfs/fre-nctools.wcoss
+++ /dev/null
@@ -1,6 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools
-#############################################################
-
-module load ics/16.0.3
-module load NetCDF/4.2/serial
diff --git a/modulefiles/fv3gfs/fre-nctools.wcoss_cray b/modulefiles/fv3gfs/fre-nctools.wcoss_cray
deleted file mode 100644
index c143b3a..0000000
--- a/modulefiles/fv3gfs/fre-nctools.wcoss_cray
+++ /dev/null
@@ -1,9 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools
-#############################################################
-module load PrgEnv-intel
-module rm intel
-module load intel/16.3.210
-module load craype-haswell
-module load cray-netcdf
-module load cray-hdf5
diff --git a/modulefiles/fv3gfs/fre-nctools.wcoss_dell_p3 b/modulefiles/fv3gfs/fre-nctools.wcoss_dell_p3
deleted file mode 100644
index 75a933a..0000000
--- a/modulefiles/fv3gfs/fre-nctools.wcoss_dell_p3
+++ /dev/null
@@ -1,9 +0,0 @@
-#%Module#####################################################
-## Module file for fre-nctools, wcoss_dell_p3
-#############################################################
-#
-module load ips/18.0.1.163
-module load impi/18.0.1
-
-module load NetCDF/4.5.0
-module load HDF5-serial/1.10.1  
diff --git a/modulefiles/fv3gfs/global_chgres.jet b/modulefiles/fv3gfs/global_chgres.jet
deleted file mode 100644
index 0880235..0000000
--- a/modulefiles/fv3gfs/global_chgres.jet
+++ /dev/null
@@ -1,26 +0,0 @@
-#%Module#####################################################
-## global_chgres component - jet
-#############################################################
-
-module purge
-module load intel/18.0.5.274
-module load szip/2.1
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
-
-module load ip/v3.0.0
-module load sp/v2.0.2
-module load w3emc/v2.2.0
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load sigio/v2.1.0
-module load nemsio/v2.2.3
-module load nemsiogfs/v2.0.1
-module load sfcio/v1.0.0
-module load gfsio/v1.1.0
-module load landsfcutil/v2.1.0
- 
-export NETCDF_INCLUDE="-I${NETCDF}/include"
-export NETCDF_LDFLAGS_F="-L${NETCDF}/lib -lnetcdf -lnetcdff -L${HDF5}/lib -lhdf5 -lhdf5_fortran"
-
-set FCMP ifort
diff --git a/modulefiles/fv3gfs/global_chgres.wcoss b/modulefiles/fv3gfs/global_chgres.wcoss
deleted file mode 100644
index 1d30465..0000000
--- a/modulefiles/fv3gfs/global_chgres.wcoss
+++ /dev/null
@@ -1,22 +0,0 @@
-#%Module#####################################################
-## global_chgres component - wcoss
-#############################################################
-
-# Loading Intel Compiler Suite
-module load ics/15.0.6
-
-# Loading nceplibs modules
-module load sigio/v2.1.0
-module load w3nco/v2.0.6
-module load w3emc/v2.2.0
-module load sp/v2.0.2
-module load bacio/v2.0.2
-module load nemsio/v2.2.1
-module load nemsiogfs/v2.0.1     
-module load ip/v3.0.0
-module load sfcio/v1.0.0
-module load gfsio/v1.1.0
-module load landsfcutil/v2.1.0
-module load NetCDF/4.2/serial
-
-export FCMP=ifort
diff --git a/modulefiles/fv3gfs/global_chgres.wcoss_cray b/modulefiles/fv3gfs/global_chgres.wcoss_cray
deleted file mode 100644
index e24138b..0000000
--- a/modulefiles/fv3gfs/global_chgres.wcoss_cray
+++ /dev/null
@@ -1,27 +0,0 @@
-#%Module#####################################################
-## global_chgres component - wcoss
-#############################################################
-module load ncep/1.0
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-# Load NCEPLIBS modules
-module load sigio-intel/2.1.0
-module load w3nco-intel/2.0.6
-module load w3emc-intel/2.2.0
-module load sp-intel/2.0.2
-module load nemsio-intel/2.2.2
-module load nemsiogfs-intel/2.0.1
-module load ip-intel/3.0.0
-module load sfcio-intel/1.0.0
-module load gfsio-intel/1.1.0
-module load landsfcutil-intel/2.1.0
-module load bacio-intel/2.0.1
-
-export FCMP=ftn
-export NETCDF_INCLUDE=""
-export NETCDF_LDFLAGS_F=""
diff --git a/modulefiles/fv3gfs/global_chgres.wcoss_cray_userlib b/modulefiles/fv3gfs/global_chgres.wcoss_cray_userlib
deleted file mode 100644
index 79f19b3..0000000
--- a/modulefiles/fv3gfs/global_chgres.wcoss_cray_userlib
+++ /dev/null
@@ -1,29 +0,0 @@
-#%Module#####################################################
-## global_chgres component - wcoss
-#############################################################
-module load ncep/1.0
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-module load nemsiogfs/v2.0.1
-module load sigio/v2.0.1
-module load w3nco/v2.0.6
-module load w3emc/v2.2.0
-module load sp/v2.0.2
-module load bacio/v2.0.2
-module load nemsio/v2.2.3
-
-module load ip/v3.0.0
-module load sfcio/v1.0.0
-module load gfsio/v1.1.0
-module load landsfcutil/v2.1.0
-
-export FCMP=ftn
-export NETCDF_INCLUDE=""
-export NETCDF_LDFLAGS_F=""
diff --git a/modulefiles/fv3gfs/global_cycle.hera b/modulefiles/fv3gfs/global_cycle.hera
deleted file mode 100644
index db85174..0000000
--- a/modulefiles/fv3gfs/global_cycle.hera
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## global_cycle component - hera
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-module load impi/2018.0.4
-
-# Loding nceplibs modules
-module use -a $MOD_PATH
-module load w3nco/2.0.6
-module load sp/2.0.2
-module load bacio/2.0.2
-module load ip/3.0.1
-module load netcdf_parallel/4.7.4
-
-export FCMP=mpiifort
diff --git a/modulefiles/fv3gfs/global_cycle.jet b/modulefiles/fv3gfs/global_cycle.jet
deleted file mode 100644
index fc12b53..0000000
--- a/modulefiles/fv3gfs/global_cycle.jet
+++ /dev/null
@@ -1,19 +0,0 @@
-#%Module#####################################################
-## global_cycle component - jet
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-module load impi/2018.4.274
-
-module load w3nco/v2.0.6
-module load sp/v2.0.2
-module load bacio/v2.0.2
-module load ip/v3.0.0
-module load szip
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
-export NETCDF_INCLUDE="-I${NETCDF}/include"
-export NETCDF_LDFLAGS_F="-L${NETCDF}/lib -lnetcdf -lnetcdff -L${HDF5}/lib -lhdf5 -lhdf5_fortran"
-
-export FCMP=mpiifort
diff --git a/modulefiles/fv3gfs/global_cycle.wcoss b/modulefiles/fv3gfs/global_cycle.wcoss
deleted file mode 100644
index fbab1cc..0000000
--- a/modulefiles/fv3gfs/global_cycle.wcoss
+++ /dev/null
@@ -1,16 +0,0 @@
-#%Module#####################################################
-## global_cycle component - wcoss
-#############################################################
-
-# Loading Intel Compiler Suite
-module load ics/16.0.3
-module load ibmpe/1.3.0.12
-
-# Loading nceplibs modules
-module load w3nco/v2.0.6
-module load sp/v2.0.2
-module load bacio/v2.0.2
-module load ip/v3.0.0
-module load NetCDF/4.2/serial
-
-export FCMP=mpfort
diff --git a/modulefiles/fv3gfs/global_cycle.wcoss_cray b/modulefiles/fv3gfs/global_cycle.wcoss_cray
deleted file mode 100644
index e1a4ed9..0000000
--- a/modulefiles/fv3gfs/global_cycle.wcoss_cray
+++ /dev/null
@@ -1,21 +0,0 @@
-#%Module#####################################################
-## global_cycle component - wcoss_cray
-#############################################################
-# Load ncep environment
-module load ncep/1.0
-
-# Load Intel environment
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-# Load NCEPLIBS modules
-module load w3nco-intel/2.0.6
-module load sp-intel/2.0.2
-module load ip-intel/3.0.0
-module load bacio-intel/2.0.1
-
-export FCMP=ftn
diff --git a/modulefiles/fv3gfs/global_cycle.wcoss_cray_userlib b/modulefiles/fv3gfs/global_cycle.wcoss_cray_userlib
deleted file mode 100644
index de700b6..0000000
--- a/modulefiles/fv3gfs/global_cycle.wcoss_cray_userlib
+++ /dev/null
@@ -1,24 +0,0 @@
-#%Module#####################################################
-## global_cycle component - wcoss_cray
-#############################################################
-module purge
-# Load ncep environment
-module load ncep/1.0
-
-# Load Intel environment
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-# Load NCEPLIBS modules
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-module load w3nco-intel/2.0.6
-module load sp-intel/2.0.2
-module load ip-intel/3.0.0
-module load bacio-intel/2.0.1
-
-export FCMP=ftn
diff --git a/modulefiles/fv3gfs/global_cycle.wcoss_dell_p3 b/modulefiles/fv3gfs/global_cycle.wcoss_dell_p3
deleted file mode 100644
index eb9681d..0000000
--- a/modulefiles/fv3gfs/global_cycle.wcoss_dell_p3
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## global_cycle component - wcoss_dell_p3
-#############################################################
-
-module load ips/18.0.1.163
-module load impi/18.0.1
-
-module load w3nco/2.0.6
-module load sp/2.0.2
-module load ip/3.0.1
-module load bacio/2.0.2
-
-module use /usrx/local/nceplibs/dev/NCEPLIBS/modulefiles
-module load netcdf_parallel/4.7.4
-
-export FCMP=mpif90
-
diff --git a/modulefiles/fv3gfs/nst_tf_chg.hera b/modulefiles/fv3gfs/nst_tf_chg.hera
deleted file mode 100644
index 2bbd3a8..0000000
--- a/modulefiles/fv3gfs/nst_tf_chg.hera
+++ /dev/null
@@ -1,21 +0,0 @@
-#%Module#####################################################
-## Build module for Hera
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-
-# Loding nceplibs modules
-module use -a $MOD_PATH
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load nemsio/2.2.3
-module load netcdf/4.6.1
-module load hdf5/1.10.4
-export NETCDF_INCLUDE="-I${NETCDF}/include"
-export NETCDF_LDFLAGS_F="-L${NETCDF}/lib -lnetcdf -lnetcdff -L${HDF5}/lib -lhdf5 -lhdf5_fortran"
-
-export FCOMP=ifort
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4"
-# for debugging
-#export FFLAGS="-g -r8 -i4 -warn unused -check bounds"
diff --git a/modulefiles/fv3gfs/nst_tf_chg.jet b/modulefiles/fv3gfs/nst_tf_chg.jet
deleted file mode 100644
index 67bd8a0..0000000
--- a/modulefiles/fv3gfs/nst_tf_chg.jet
+++ /dev/null
@@ -1,20 +0,0 @@
-#%Module#####################################################
-## gaussian_sfcanl build module for Jet
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load nemsio/v2.2.3
-module load szip
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
-export NETCDF_INCLUDE="-I${NETCDF}/include"
-export NETCDF_LDFLAGS_F="-L${NETCDF}/lib -lnetcdf -lnetcdff -L${HDF5}/lib -lhdf5 -lhdf5_fortran"
-
-export FCOMP=ifort
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4"
-# for debugging
-#export FFLAGS="-g -r8 -i4 -warn unused -check bounds"
diff --git a/modulefiles/fv3gfs/nst_tf_chg.wcoss b/modulefiles/fv3gfs/nst_tf_chg.wcoss
deleted file mode 100644
index 7065248..0000000
--- a/modulefiles/fv3gfs/nst_tf_chg.wcoss
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## gaussian_sfcanl build module  - wcoss
-#############################################################
-
-# Loading Intel Compiler Suite
-module load ics/16.0.3
-
-# Loading nceplibs modules
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load nemsio/v2.2.3
-module load NetCDF/4.2/serial
-
-export FCOMP=ifort
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4"
-# for debugging
-#export FFLAGS="-g -r8 -i4 -warn unused -check bounds"
diff --git a/modulefiles/fv3gfs/nst_tf_chg.wcoss_cray b/modulefiles/fv3gfs/nst_tf_chg.wcoss_cray
deleted file mode 100644
index f0a7b6f..0000000
--- a/modulefiles/fv3gfs/nst_tf_chg.wcoss_cray
+++ /dev/null
@@ -1,22 +0,0 @@
-#%Module#####################################################
-## gaussian_sfcanl component of fv3gfs - cray
-#############################################################
-
-set ver v15.0.0
-
-# Load Intel environment
-module load PrgEnv-intel/5.2.56
-module rm intel
-module rm NetCDF-intel-sandybridge/4.2
-module load intel/16.3.210
-module load cray-netcdf
-module load craype-haswell
-
-module load nemsio-intel/2.2.3
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.2
-
-export FCOMP=ftn
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4"
-# for debugging
-#export FFLAGS="-g -r8 -i4 -warn unused -check bounds"
diff --git a/modulefiles/fv3gfs/nst_tf_chg.wcoss_dell_p3 b/modulefiles/fv3gfs/nst_tf_chg.wcoss_dell_p3
deleted file mode 100644
index 1342c5b..0000000
--- a/modulefiles/fv3gfs/nst_tf_chg.wcoss_dell_p3
+++ /dev/null
@@ -1,20 +0,0 @@
-#%Module#####################################################
-## gaussian_sfcanl component of fv3gfs - wcoss_dell_p3
-#############################################################
-
-set ver v15.0.0
-
-# Load Intel environment
-module load ips/18.0.1.163
-module load impi/18.0.1
-
-module load NetCDF/4.5.0
-module load HDF5-serial/1.10.1
-module load nemsio/2.2.3
-module load w3nco/2.0.6
-module load bacio/2.0.2
-
-export FCOMP=ifort
-export FFLAGS="-O3 -fp-model precise -g -r8 -i4"
-# for debugging
-#export FFLAGS="-g -r8 -i4 -warn unused -check bounds"
diff --git a/modulefiles/fv3gfs/orog.hera b/modulefiles/fv3gfs/orog.hera
deleted file mode 100644
index 0780cec..0000000
--- a/modulefiles/fv3gfs/orog.hera
+++ /dev/null
@@ -1,15 +0,0 @@
-#%Module#####################################################
-## Module file for orog
-#############################################################
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-
-module load netcdf/4.7.0
-
-# Loding nceplibs modules
-module use -a $MOD_PATH
-module load ip/3.0.1
-module load sp/2.0.2
-module load w3emc/2.3.0
-module load w3nco/2.0.6
-module load bacio/2.0.2
diff --git a/modulefiles/fv3gfs/orog.jet b/modulefiles/fv3gfs/orog.jet
deleted file mode 100644
index 8934571..0000000
--- a/modulefiles/fv3gfs/orog.jet
+++ /dev/null
@@ -1,18 +0,0 @@
-#%Module#####################################################
-## Module file for orog
-#############################################################
-# Loading Intel Compiler Suite
-#
-module purge
-
-module load intel/18.0.5.274
-module load szip/2.1
-module load hdf5/1.8.9
-module load netcdf/4.2.1.1
-
-# Loding nceplibs modules
-module load ip/v2.0.0
-module load sp/v2.0.2
-module load w3emc/v2.3.0
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
diff --git a/modulefiles/fv3gfs/orog.wcoss b/modulefiles/fv3gfs/orog.wcoss
deleted file mode 100644
index 9aa30c5..0000000
--- a/modulefiles/fv3gfs/orog.wcoss
+++ /dev/null
@@ -1,16 +0,0 @@
-#%Module#####################################################
-## Module file for orog
-#############################################################
-
-# Loading Intel Compiler Suite
-module load ics/16.0.3
-
-# Loding nceplibs modules
-module load w3nco/v2.0.6
-module load w3emc/v2.2.0
-module load sp/v2.0.2
-module load ip/v2.0.0
-module load bacio/v2.0.2
-module load NetCDF
-
-export FCMP=ifort
diff --git a/modulefiles/fv3gfs/orog.wcoss_cray b/modulefiles/fv3gfs/orog.wcoss_cray
deleted file mode 100644
index 51cb66a..0000000
--- a/modulefiles/fv3gfs/orog.wcoss_cray
+++ /dev/null
@@ -1,18 +0,0 @@
-#%Module#####################################################
-## Module file for orog
-#############################################################
-module load ncep/1.0
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-module load w3emc-intel/2.2.0
-module load ip-intel/2.0.0
-module load sp-intel/2.0.2
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-
-export FCMP=ftn
diff --git a/modulefiles/fv3gfs/orog.wcoss_cray_userlib b/modulefiles/fv3gfs/orog.wcoss_cray_userlib
deleted file mode 100644
index 4698b9c..0000000
--- a/modulefiles/fv3gfs/orog.wcoss_cray_userlib
+++ /dev/null
@@ -1,20 +0,0 @@
-#%Module#####################################################
-## Module file for orog
-#############################################################
-module load ncep/1.0
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-module load ip/v2.0.0
-module load sp/v2.0.2
-module load w3emc/v2.2.0
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-
-export FCMP=ftn
diff --git a/modulefiles/fv3gfs/orog.wcoss_dell_p3 b/modulefiles/fv3gfs/orog.wcoss_dell_p3
deleted file mode 100644
index adde9c2..0000000
--- a/modulefiles/fv3gfs/orog.wcoss_dell_p3
+++ /dev/null
@@ -1,14 +0,0 @@
-#%Module#####################################################
-## Module file for orog, wcoss_dell_p3
-#############################################################
-module load ips/18.0.1.163
-module load impi/18.0.1
-
-module load NetCDF/4.5.0
-module load w3emc/2.3.0
-module load w3nco/2.0.6
-module load sp/2.0.2
-module load ip/3.0.1
-module load bacio/2.0.2
-
-export FCMP=ifort
diff --git a/modulefiles/module-setup.sh.inc b/modulefiles/module-setup.sh.inc
index d4faa4f..48d2cd7 100644
--- a/modulefiles/module-setup.sh.inc
+++ b/modulefiles/module-setup.sh.inc
@@ -16,7 +16,7 @@ else
     __ms_shell=sh
 fi
 
-if [[ -d /lfs3 ]] ; then
+if [[ -d /lfs4 ]] ; then
     # We are on NOAA Jet
     if ( ! eval module help > /dev/null 2>&1 ) ; then
         source /apps/lmod/lmod/init/$__ms_shell
diff --git a/modulefiles/module_base.jet b/modulefiles/module_base.jet
index 00e997a..1a2df69 100644
--- a/modulefiles/module_base.jet
+++ b/modulefiles/module_base.jet
@@ -9,7 +9,7 @@ proc ModulesHelp {} {
 
 module load intel/15.0.3.187 impi/2018.4.274 szip hdf5 netcdf4/4.2.1.1
 
-module use /lfs3/projects/hfv3gfs/nwprod/NCEPLIBS/modulefiles
+module use /lfs4/HFIP/hfv3gfs/nwprod/NCEPLIBS/modulefiles
 module load bacio/v2.0.2
 module load sp/v2.0.2
 module load ip/v2.0.0
@@ -17,7 +17,7 @@ module load w3nco/v2.0.6
 module load w3emc/v2.3.0
 module load nemsio/v2.2.3
 
-module use /lfs3/projects/hwrf-vd/soft/modulefiles
+module use /lfs4/HFIP/hwrf-vd/soft/modulefiles
 module load prod_util
 module load grib_util
 module load hpss
diff --git a/modulefiles/module_nemsutil.hera b/modulefiles/module_nemsutil.hera
deleted file mode 100644
index 4d1bfd5..0000000
--- a/modulefiles/module_nemsutil.hera
+++ /dev/null
@@ -1,15 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-module load impi/2018.0.4
-
-# Loding nceplibs modules
-module use -a $MOD_PATH
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load nemsio/2.2.3
-
-export FCMP=ifort
diff --git a/modulefiles/module_nemsutil.jet b/modulefiles/module_nemsutil.jet
deleted file mode 100644
index c1ff574..0000000
--- a/modulefiles/module_nemsutil.jet
+++ /dev/null
@@ -1,14 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-# Loading Intel Compiler Suite
-module load intel/18.0.5.274
-module load impi/5.0.3.048
-
-# Loding nceplibs modules
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load nemsio/v2.2.3
-
-export FCMP=ifort
diff --git a/modulefiles/module_nemsutil.wcoss b/modulefiles/module_nemsutil.wcoss
deleted file mode 100644
index f421c1a..0000000
--- a/modulefiles/module_nemsutil.wcoss
+++ /dev/null
@@ -1,13 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-# Loading Intel Compiler Suite
-module load ics/14.0.1
-
-# Loding nceplibs modules
-module load w3nco/v2.0.6
-module load bacio/v2.0.1
-module load nemsio/v2.2.1
-
-export FCMP=ifort
diff --git a/modulefiles/module_nemsutil.wcoss_cray b/modulefiles/module_nemsutil.wcoss_cray
deleted file mode 100644
index 371c8e0..0000000
--- a/modulefiles/module_nemsutil.wcoss_cray
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-module purge
-module load modules
-module load PrgEnv-intel
-module load cray-mpich
-module load craype-sandybridge
-
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-
-export NEMSIO_INC=/usrx/local/nceplibs/nemsio/nemsio_v2.2.3/incmod
-export NEMSIO_LIB=/usrx/local/nceplibs/nemsio/nemsio_v2.2.3/libnemsio_v2.2.3.a
-
-export FCMP=ftn
diff --git a/modulefiles/module_nemsutil.wcoss_cray_userlib b/modulefiles/module_nemsutil.wcoss_cray_userlib
deleted file mode 100644
index 53fad47..0000000
--- a/modulefiles/module_nemsutil.wcoss_cray_userlib
+++ /dev/null
@@ -1,19 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-# Load Intel environment
-module purge
-module load modules
-module load PrgEnv-intel
-module load cray-mpich
-module load craype-sandybridge
-
-# Load NCEPLIBS modules
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use $MOD_PATH
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load nemsio/v2.2.3
-
-export FCMP=ftn
diff --git a/modulefiles/module_nemsutil.wcoss_dell_p3 b/modulefiles/module_nemsutil.wcoss_dell_p3
deleted file mode 100644
index e93d581..0000000
--- a/modulefiles/module_nemsutil.wcoss_dell_p3
+++ /dev/null
@@ -1,12 +0,0 @@
-#%Module#####################################################
-## Module file for nemsutil
-#############################################################
-
-module load ips/18.0.1.163
-module load impi/18.0.1
-
-module load bacio/2.0.2
-module load w3nco/2.0.6
-module load nemsio/2.2.3 
-
-export FCMP=ifort
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.hera b/modulefiles/modulefile.global_emcsfc_ice_blend.hera
deleted file mode 100644
index 2305392..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.hera
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## emcsfc_ice_blend build module for Hera
-#############################################################
-
-module load intel/18.0.5.274
-export FCOMP=ifort
-export FFLAGS="-O0 -i4"
-
-# load ncep library modules
-
-module use -a $MOD_PATH
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load jasper/1.900.1
-module load z/1.2.11
-module load png/1.2.44
-module load g2/2.5.0
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.jet b/modulefiles/modulefile.global_emcsfc_ice_blend.jet
deleted file mode 100644
index 2e094dc..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.jet
+++ /dev/null
@@ -1,16 +0,0 @@
-#%Module#####################################################
-## emcsfc_ice_blend build module for Jet
-#############################################################
-
-module load intel/18.0.5.274
-export FCOMP=ifort
-export FFLAGS="-O0 -i4"
-
-# load ncep library modules
-
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load jasper/v1.900.1
-module load z/v1.2.6
-module load png/v1.2.44
-module load g2/v3.1.0
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss b/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss
deleted file mode 100644
index c4ccccf..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss
+++ /dev/null
@@ -1,14 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_ice_blend
-#############################################################
-
-module load ics/12.1
-export FCOMP=ifort
-export FFLAGS="-O0 -i4"
-
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load jasper/v1.900.1
-module load z/v1.2.6
-module load png/v1.2.44
-module load g2/v2.5.0
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray b/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray
deleted file mode 100644
index 76f18d2..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_ice_blend
-#############################################################
-
-# intel compiler
-
-module load PrgEnv-intel
-module load craype-haswell
-export FCOMP=ftn
-export FFLAGS="-O0 -i4 -craype-verbose"
-
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-export JASPER_LIB=/usrx/local/prod/jasper/1.900.1/intel/haswell/lib/libjasper.a
-module load zlib-intel-haswell/1.2.7
-module load png-intel-haswell/1.2.49
-module load g2-intel/2.5.0
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray_userlib b/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray_userlib
deleted file mode 100644
index ca64e02..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_cray_userlib
+++ /dev/null
@@ -1,20 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_ice_blend
-#############################################################
-
-# intel compiler
-
-module load PrgEnv-intel
-module load craype-haswell
-export FCOMP=ftn
-export FFLAGS="-O0 -i4 -craype-verbose"
-
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-export JASPER_LIB=/usrx/local/prod/jasper/1.900.1/intel/haswell/lib/libjasper.a
-module load zlib-intel-haswell/1.2.7
-module load png-intel-haswell/1.2.49
-module load g2-intel/2.5.0
diff --git a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_dell_p3 b/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_dell_p3
deleted file mode 100644
index 369695e..0000000
--- a/modulefiles/modulefile.global_emcsfc_ice_blend.wcoss_dell_p3
+++ /dev/null
@@ -1,17 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_ice_blend
-#############################################################
-
-# intel compiler
-
-module load ips/18.0.1.163
-
-export FCOMP=ifort
-export FFLAGS="-O0 -i4"
-
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load jasper/1.900.1
-module load libpng/1.2.59
-module load zlib/1.2.11
-module load g2/3.1.0
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.hera b/modulefiles/modulefile.global_emcsfc_snow2mdl.hera
deleted file mode 100644
index 193f624..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.hera
+++ /dev/null
@@ -1,23 +0,0 @@
-#%Module#####################################################
-## emcsfc_snow2mdl build module for Hera
-#############################################################
-
-# load intel compiler
-
-module load intel/18.0.5.274
-
-# load ncep library modules
-
-module use -a $MOD_PATH
-module load ip/3.0.1
-module load sp/2.0.2
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load landsfcutil/2.1.0
-module load jasper/1.900.1
-module load z/1.2.11
-module load png/1.2.44
-module load g2/2.5.0
-
-export FCOMP=ifort
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -qopenmp -convert big_endian -assume byterecl"
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.jet b/modulefiles/modulefile.global_emcsfc_snow2mdl.jet
deleted file mode 100644
index 0b88ae7..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.jet
+++ /dev/null
@@ -1,22 +0,0 @@
-#%Module#####################################################
-## emcsfc_snow2mdl build module for Jet
-#############################################################
-
-# load intel compiler
-
-module load intel/18.0.5.274
-
-# load ncep library modules
-
-module load ip/v3.0.0
-module load sp/v2.0.2
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load jasper/v1.900.1
-module load z/v1.2.6
-module load png/v1.2.44
-module load g2/v3.1.0
-module load landsfcutil/v2.1.0
-
-export FCOMP=ifort
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -qopenmp -convert big_endian -assume byterecl"
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss b/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss
deleted file mode 100644
index 8a6a883..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss
+++ /dev/null
@@ -1,18 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_snow2mdl
-#############################################################
-
-module load ics/12.1
-
-module load ip/v3.0.0
-module load sp/v2.0.2
-module load w3nco/v2.0.6
-module load bacio/v2.0.2
-module load jasper/v1.900.1
-module load z/v1.2.6
-module load png/v1.2.44
-module load g2/v2.5.0
-module load landsfcutil/v2.1.0
-
-export FCOMP=ifort
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -openmp -convert big_endian -assume byterecl"
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray b/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray
deleted file mode 100644
index de17f85..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray
+++ /dev/null
@@ -1,21 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_snow2mdl
-#############################################################
-
-# intel compiler
-
-module load PrgEnv-intel
-module load craype-haswell
-
-module load ip-intel/3.0.0
-module load sp-intel/2.0.2
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-export JASPER_LIB=/usrx/local/prod/jasper/1.900.1/intel/haswell/lib/libjasper.a
-module load zlib-intel-haswell/1.2.7
-module load png-intel-haswell/1.2.49
-module load g2-intel/2.5.0
-module load landsfcutil-intel/2.1.0
-
-export FCOMP=ftn
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -openmp -convert big_endian -assume byterecl -craype-verbose"
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray_userlib b/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray_userlib
deleted file mode 100644
index 192136a..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_cray_userlib
+++ /dev/null
@@ -1,24 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_snow2mdl
-#############################################################
-
-# intel compiler
-
-module load PrgEnv-intel
-module load craype-haswell
-
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-
-module load ip-intel/3.0.0
-module load sp-intel/2.0.2
-module load w3nco-intel/2.0.6
-module load bacio-intel/2.0.1
-export JASPER_LIB=/usrx/local/prod/jasper/1.900.1/intel/haswell/lib/libjasper.a
-module load zlib-intel-haswell/1.2.7
-module load png-intel-haswell/1.2.49
-module load g2-intel/2.5.0
-module load landsfcutil-intel/2.1.0
-
-export FCOMP=ftn
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -openmp -convert big_endian -assume byterecl -craype-verbose"
diff --git a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_dell_p3 b/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_dell_p3
deleted file mode 100644
index 207c6f8..0000000
--- a/modulefiles/modulefile.global_emcsfc_snow2mdl.wcoss_dell_p3
+++ /dev/null
@@ -1,20 +0,0 @@
-#%Module#####################################################
-## Module file for emcsfc_snow2mdl
-#############################################################
-
-# intel compiler
-
-module load ips/18.0.1.163
-
-module load w3nco/2.0.6
-module load bacio/2.0.2
-module load ip/3.0.1
-module load sp/2.0.2
-module load jasper/1.900.1
-module load libpng/1.2.59
-module load zlib/1.2.11
-module load g2/3.1.0
-module load landsfcutil/2.1.0
-
-export FCOMP=ifort
-export FFLAGS="-O0 -r8 -i4 -FR -I${IP_INCd} -qopenmp -convert big_endian -assume byterecl "
diff --git a/modulefiles/modulefile.sfc_climo_gen.hera b/modulefiles/modulefile.sfc_climo_gen.hera
deleted file mode 100644
index 93aff0a..0000000
--- a/modulefiles/modulefile.sfc_climo_gen.hera
+++ /dev/null
@@ -1,13 +0,0 @@
-#%Module#####################################################
-## Module file for sfc_climo_gen (Hera)
-#############################################################
-
-module load intel/18.0.5.274
-module load impi/2018.0.4
-
-export NCEPLIBS=/scratch1/NCEPDEV/global/gwv/l819/lib
-module use -a $NCEPLIBS/modulefiles
-module load esmflocal/8_0_48b.netcdf47
-
-export FCOMP=mpiifort
-export FFLAGS="-O3 -fp-model=precise -g -traceback -r8 -i4 -convert big_endian"
diff --git a/modulefiles/modulefile.sfc_climo_gen.jet b/modulefiles/modulefile.sfc_climo_gen.jet
deleted file mode 100644
index 4969d85..0000000
--- a/modulefiles/modulefile.sfc_climo_gen.jet
+++ /dev/null
@@ -1,16 +0,0 @@
-#%Module#####################################################
-## Module file for sfc_climo_gen
-#############################################################
-
-module use /mnt/lfs3/projects/hfv3gfs/gwv/ljtjet/lib/modulefiles
-
-module load intel/18.0.5.274
-module load impi/2018.4.274
-module load szip
-module load hdf5
-module load netcdf/4.2.1.1
-
-module load esmflocal/ESMF_8_0_0_beta_snapshot_21
-
-export FCOMP=mpiifort
-export FFLAGS="-O3 -fp-model=precise -g -traceback -r8 -i4 -convert big_endian"
diff --git a/modulefiles/modulefile.sfc_climo_gen.wcoss_cray b/modulefiles/modulefile.sfc_climo_gen.wcoss_cray
deleted file mode 100644
index 9fdbae9..0000000
--- a/modulefiles/modulefile.sfc_climo_gen.wcoss_cray
+++ /dev/null
@@ -1,16 +0,0 @@
-#%Module#####################################################
-## Module file sfc_climo_gen
-#############################################################
-
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-module use /gpfs/hps3/emc/nems/noscrub/emc.nemspara/soft/modulefiles
-module load esmf/7.1.0r
-
-export FCOMP=ftn
-export FFLAGS="-O3 -fp-model=precise -g -r8 -i4 -convert big_endian -craype-verbose"
diff --git a/modulefiles/modulefile.sfc_climo_gen.wcoss_cray_userlib b/modulefiles/modulefile.sfc_climo_gen.wcoss_cray_userlib
deleted file mode 100644
index d5e46a8..0000000
--- a/modulefiles/modulefile.sfc_climo_gen.wcoss_cray_userlib
+++ /dev/null
@@ -1,18 +0,0 @@
-#%Module#####################################################
-## Module file for sfc_climo_gen
-#############################################################
-
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf
-
-module unuse /gpfs/hps/nco/ops/nwprod/lib/modulefiles
-module use -a $MOD_PATH
-
-module load esmf/7.1.0r
-
-export FCOMP=ftn
-export FFLAGS="-O3 -fp-model=precise -g -r8 -i4 -convert big_endian -craype-verbose"
diff --git a/modulefiles/modulefile.sfc_climo_gen.wcoss_dell_p3 b/modulefiles/modulefile.sfc_climo_gen.wcoss_dell_p3
deleted file mode 100644
index c485316..0000000
--- a/modulefiles/modulefile.sfc_climo_gen.wcoss_dell_p3
+++ /dev/null
@@ -1,11 +0,0 @@
-#%Module#####################################################
-## Module file for sfc_climo_gen
-#############################################################
-
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load NetCDF/4.5.0
-module load ESMF/7_1_0r
-
-export FCOMP=mpif90
-export FFLAGS="-O3 -fp-model=precise -g -traceback -r8 -i4 -convert big_endian"
diff --git a/parm/varmap_tables/GSDphys_var_map.txt b/parm/varmap_tables/GSDphys_var_map.txt
new file mode 100644
index 0000000..7546cfd
--- /dev/null
+++ b/parm/varmap_tables/GSDphys_var_map.txt
@@ -0,0 +1,27 @@
+dzdt                dzdt      set_to_fill   0         D
+delta_p             delp      skip          0         D
+sphum               sphum     set_to_fill   1E-7      T
+liq_wat             liq_wat   set_to_fill   0         T
+o3mr                o3mr      set_to_fill   1E-7      T
+rainwat             rainwat   set_to_fill   0         T
+ice_wat             ice_wat   stop          0         T
+snowwat             snowwat   set_to_fill   0         T
+graupel             graupel   set_to_fill   0         T
+ice_nc              ice_nc    set_to_fill   -1.0      T
+rain_nc             rain_nc   set_to_fill   -1.0      T
+water_nc            water_nc  set_to_fill   -1.0      T
+liq_aero            liq_aero  set_to_fill   0         T
+ice_aero            ice_aero  set_to_fill   0         T
+sgs_tke             sgs_tke   set_to_fill   0         T
+vtype               vtype     skip          0         S
+sotype              stype     skip          0         S
+vfrac               vfrac     skip          0         S
+fricv               uustar    skip          0         S
+sfcr                zorl      set_to_fill   0.01      S
+soilw               smc       stop          0         S
+soilt               stc       stop          0         S
+cnwat               cnwat     set_to_fill   0.0       S
+icetk               icetk     set_to_fill   265.0     S
+weasd               weasd     set_to_fill   0.0       S
+snod                snod      set_to_fill   0.0       S
+tprcp               tprcp     set_to_fill   0.0       S       	
diff --git a/reg_tests/chgres_cube/c192.fv3.history.sh b/reg_tests/chgres_cube/c192.fv3.history.sh
index 9ffb439..b29c663 100755
--- a/reg_tests/chgres_cube/c192.fv3.history.sh
+++ b/reg_tests/chgres_cube/c192.fv3.history.sh
@@ -29,7 +29,7 @@ export TRACERS_INPUT='"spfh","clwmr","o3mr"'
 
 export CDATE=2018100300
 
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -41,6 +41,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C192 FV3 HISTORY TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c192.gfs.grib2.sh b/reg_tests/chgres_cube/c192.gfs.grib2.sh
index 2c382c7..1ec7682 100755
--- a/reg_tests/chgres_cube/c192.gfs.grib2.sh
+++ b/reg_tests/chgres_cube/c192.gfs.grib2.sh
@@ -24,7 +24,7 @@ export CONVERT_NST=".false."
 
 export CDATE=2019110400
 
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -36,6 +36,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C192 GFS GRIB2 TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c96.fv3.nemsio.sh b/reg_tests/chgres_cube/c96.fv3.nemsio.sh
index a056eab..43da0dc 100755
--- a/reg_tests/chgres_cube/c96.fv3.nemsio.sh
+++ b/reg_tests/chgres_cube/c96.fv3.nemsio.sh
@@ -20,7 +20,7 @@ export VCOORD_FILE=${HOMEufs}/fix/fix_am/global_hyblev.l64.txt
 
 export CDATE=2019070412
 
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -32,6 +32,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C96 FV3 GAUSSIAN NEMSIO TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c96.fv3.netcdf.sh b/reg_tests/chgres_cube/c96.fv3.netcdf.sh
new file mode 100755
index 0000000..8000f59
--- /dev/null
+++ b/reg_tests/chgres_cube/c96.fv3.netcdf.sh
@@ -0,0 +1,69 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+# Invoke chgres to create C96 coldstart files using FV3 gaussian netcdf files
+# (gfs v16) as input.  The coldstart files are then compared to baseline files
+# using the 'nccmp' utility.  This script is run by the machine specific
+# driver script.
+#-----------------------------------------------------------------------------
+
+set -x
+
+export DATA=$OUTDIR/c96_fv3_netcdf
+rm -fr $DATA
+
+export FIXfv3=${HOMEreg}/fix/C96
+export COMIN=${HOMEreg}/input_data/fv3.netcdf
+export ATM_FILES_INPUT=gfs.t00z.atmf000.nc
+export SFC_FILES_INPUT=gfs.t00z.sfcf000.nc
+export VCOORD_FILE=${HOMEufs}/fix/fix_am/global_hyblev.l64.txt
+export INPUT_TYPE="gaussian_netcdf"
+
+export CDATE=2020020200
+
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
+
+#-----------------------------------------------------------------------------
+# Invoke chgres program.
+#-----------------------------------------------------------------------------
+
+echo "Starting at: " `date`
+
+${HOMEufs}/ush/chgres_cube.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< C96 FV3 GAUSSIAN NETCDF TEST FAILED. <<<"
+  exit $iret
+fi
+
+echo "Ending at: " `date`
+
+#-----------------------------------------------------------------------------
+# Compare output from chgres to baseline set of data.
+#-----------------------------------------------------------------------------
+
+cd $DATA
+
+test_failed=0
+for files in *.nc
+do
+  if [ -f $files ]; then
+    echo CHECK $files
+    $NCCMP -dmfqS $files $HOMEreg/baseline_data/c96_fv3_netcdf/$files
+    iret=$?
+    if [ $iret -ne 0 ]; then
+      test_failed=1
+    fi
+  fi
+done
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo "<<< C96 FV3 GAUSSIAN NETCDF TEST FAILED. >>>"
+else
+  echo "<<< C96 FV3 GAUSSIAN NETCDF TEST PASSED. >>>"
+fi
+
+exit 0
diff --git a/reg_tests/chgres_cube/c96.fv3.restart.sh b/reg_tests/chgres_cube/c96.fv3.restart.sh
index e16f5f2..6e7107e 100755
--- a/reg_tests/chgres_cube/c96.fv3.restart.sh
+++ b/reg_tests/chgres_cube/c96.fv3.restart.sh
@@ -30,7 +30,7 @@ export TRACERS_INPUT='"sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","gr
 
 export CDATE=2019070612
 
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -42,6 +42,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C96 FV3 GAUSSIAN NEMSIO TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c96.gfs.nemsio.sh b/reg_tests/chgres_cube/c96.gfs.nemsio.sh
index a3d3a4d..a6d51a0 100755
--- a/reg_tests/chgres_cube/c96.gfs.nemsio.sh
+++ b/reg_tests/chgres_cube/c96.gfs.nemsio.sh
@@ -18,13 +18,13 @@ export ATM_FILES_INPUT=gfnanl.gdas.2017071700
 export SFC_FILES_INPUT=sfnanl.gdas.2017071700
 export NST_FILES_INPUT=nsnanl.gdas.2017071700
 export VCOORD_FILE=${HOMEufs}/fix/fix_am/global_hyblev.l64.txt
-export INPUT_TYPE="gfs_gaussian"
+export INPUT_TYPE="gfs_gaussian_nemsio"
 
 # dont start/end with double quotes.
 export TRACERS_TARGET='"sphum","liq_wat","o3mr"'
 export TRACERS_INPUT='"spfh","clwmr","o3mr"'
 export CDATE=2017071700
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -36,6 +36,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C96 GFS GAUSSIAN NEMSIO TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c96.gfs.sigio.sh b/reg_tests/chgres_cube/c96.gfs.sigio.sh
index c2ea31e..840dbf9 100755
--- a/reg_tests/chgres_cube/c96.gfs.sigio.sh
+++ b/reg_tests/chgres_cube/c96.gfs.sigio.sh
@@ -18,13 +18,13 @@ export ATM_FILES_INPUT=gdas.t00z.sanl
 export SFC_FILES_INPUT=gdas.t00z.sfcanl
 export CONVERT_NST='.false.'
 export VCOORD_FILE=${HOMEufs}/fix/fix_am/global_hyblev.l64.txt
-export INPUT_TYPE="gfs_spectral"
+export INPUT_TYPE="gfs_sigio"
 
 # dont start/end with double quotes
 export TRACERS_TARGET='"sphum","o3mr","liq_wat"'
 export TRACERS_INPUT='"spfh","o3mr","clwmr"'
 export CDATE=2017071700
-export OMP_NUM_THREADS_CY=6
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 echo "Starting at: " `date`
 
@@ -32,6 +32,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C96 GFS SIGIO TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/c96.regional.sh b/reg_tests/chgres_cube/c96.regional.sh
index 51a201f..9d15e95 100755
--- a/reg_tests/chgres_cube/c96.regional.sh
+++ b/reg_tests/chgres_cube/c96.regional.sh
@@ -26,7 +26,7 @@ export HALO_BNDY=4
 
 export CDATE=2019070412
 
-export OMP_NUM_THREADS_CY=1
+export OMP_NUM_THREADS_CH=${OMP_NUM_THREADS:-1}
 
 #-----------------------------------------------------------------------------
 # Invoke chgres program.
@@ -38,6 +38,7 @@ ${HOMEufs}/ush/chgres_cube.sh
 
 iret=$?
 if [ $iret -ne 0 ]; then
+  set +x
   echo "<<< C96 REGIONAL TEST FAILED. <<<"
   exit $iret
 fi
diff --git a/reg_tests/chgres_cube/driver.cray.sh b/reg_tests/chgres_cube/driver.cray.sh
index 2ffd353..cae83b1 100755
--- a/reg_tests/chgres_cube/driver.cray.sh
+++ b/reg_tests/chgres_cube/driver.cray.sh
@@ -22,14 +22,8 @@
 
 set -x
 
-module purge
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf/4.3.3.1
-module load xt-lsfhpc/9.1.3
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 module list
 
 export OUTDIR=/gpfs/hps3/stmp/$LOGNAME/chgres_reg_tests
@@ -112,6 +106,15 @@ export APRUN="aprun -j 1 -n 6 -N 6 -d ${OMP_NUM_THREADS} -cc depth"
 bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.regional -M 1000 -W 0:15 -extsched 'CRAYLINUX[]' \
         -w 'ended(c96.gfs.nemsio)' "export NODES=1; $PWD/c96.regional.sh"
 
+#-----------------------------------------------------------------------------
+# Initialize C96 using FV3 gaussian netcdf files.
+#-----------------------------------------------------------------------------
+
+export OMP_NUM_THREADS=1
+export APRUN="aprun -j 1 -n 12 -N 6 -d ${OMP_NUM_THREADS} -cc depth"
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.fv3.netcdf -M 1000 -W 0:15 -extsched 'CRAYLINUX[]' \
+        -w 'ended(c96.regional)' "export NODES=2; $PWD/c96.fv3.netcdf.sh"
+
 #-----------------------------------------------------------------------------
 # Initialize global C192 using GFS GRIB2 data.
 #-----------------------------------------------------------------------------
@@ -119,7 +122,7 @@ bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.regional -M 100
 export OMP_NUM_THREADS=1
 export APRUN="aprun -j 1 -n 6 -N 6 -d ${OMP_NUM_THREADS} -cc depth"
 bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c192.gfs.grib2 -M 1000 -W 0:05 -extsched 'CRAYLINUX[]' \
-        -w 'ended(c96.regional)' "export NODES=1; $PWD/c192.gfs.grib2.sh"
+        -w 'ended(c96.fv3.netcdf)' "export NODES=1; $PWD/c192.gfs.grib2.sh"
 
 #-----------------------------------------------------------------------------
 # Create summary log.
diff --git a/reg_tests/chgres_cube/driver.dell.sh b/reg_tests/chgres_cube/driver.dell.sh
index 6b17d0b..4cbd483 100755
--- a/reg_tests/chgres_cube/driver.dell.sh
+++ b/reg_tests/chgres_cube/driver.dell.sh
@@ -22,14 +22,8 @@
 
 set -x
 
-module purge
-module load EnvVars/1.0.2
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load lsf/10.1
-module use /usrx/local/dev/modulefiles
-module load NetCDF/4.5.0
-module list
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 
 export OUTDIR=/gpfs/dell1/stmp/$LOGNAME/chgres_reg_tests
 QUEUE="debug"
@@ -51,7 +45,7 @@ SUM_FILE=summary.log
 
 rm -f $LOG_FILE $SUM_FILE
 
-export NCCMP=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/util/nccmp/nccmp-1.8.5.0/src/nccmp
+export NCCMP=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/util/nccmp/nccmp-nc4.7.4/src/nccmp
 
 export OMP_STACKSIZE=1024M
 
@@ -105,12 +99,20 @@ export OMP_NUM_THREADS=1
 bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.regional -W  0:15 -x -n 6 -w 'ended(c96.gfs.nemsio)' \
         -R "span[ptile=6]" -R "affinity[core(${OMP_NUM_THREADS}):distribute=balance]" "$PWD/c96.regional.sh"
 
+#-----------------------------------------------------------------------------
+# Initialize C96 using FV3 gaussian netcdf files.
+#-----------------------------------------------------------------------------
+
+export OMP_NUM_THREADS=1
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.fv3.netcdf -W 0:15 -x -n 12 -w 'ended(c96.regional)' \
+        -R "span[ptile=6]" -R "affinity[core(${OMP_NUM_THREADS}):distribute=balance]" "$PWD/c96.fv3.netcdf.sh"
+
 #-----------------------------------------------------------------------------
 # Initialize global C192 using GFS GRIB2 file.
 #-----------------------------------------------------------------------------
 
 export OMP_NUM_THREADS=1
-bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c192.gfs.grib2 -W 0:05 -x -n 6 -w 'ended(c96.regional)' \
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c192.gfs.grib2 -W 0:05 -x -n 6 -w 'ended(c96.fv3.netcdf)' \
         -R "span[ptile=6]" -R "affinity[core(${OMP_NUM_THREADS}):distribute=balance]" "$PWD/c192.gfs.grib2.sh"
 
 #-----------------------------------------------------------------------------
diff --git a/reg_tests/chgres_cube/driver.hera.sh b/reg_tests/chgres_cube/driver.hera.sh
index 5ae2882..fa09e79 100755
--- a/reg_tests/chgres_cube/driver.hera.sh
+++ b/reg_tests/chgres_cube/driver.hera.sh
@@ -24,16 +24,12 @@
 
 set -x
 
-source /apps/lmod/lmod/init/sh
-module purge
-module load intel/18.0.5.274
-module load impi/2018.0.4
-module load netcdf/4.7.0
-module list
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 
 export OUTDIR=/scratch2/NCEPDEV/stmp1/$LOGNAME/chgres_reg_tests
 PROJECT_CODE="fv3-cpu"
-QUEUE="debug"
+QUEUE="batch"
 
 #-----------------------------------------------------------------------------
 # Should not have to change anything below here.  HOMEufs is the root
@@ -61,6 +57,7 @@ rm -fr $OUTDIR
 # Initialize C96 using FV3 warm restart files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1   # should match cpus-per-task
 TEST1=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.restart \
       -o $LOG_FILE -e $LOG_FILE ./c96.fv3.restart.sh)
 
@@ -68,6 +65,7 @@ TEST1=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_C
 # Initialize C192 using FV3 tiled history files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1   # should match cpus-per-task
 TEST2=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c192.fv3.history \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST1 ./c192.fv3.history.sh)
 
@@ -75,6 +73,7 @@ TEST2=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_C
 # Initialize C96 using FV3 gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1   # should match cpus-per-task
 TEST3=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.nemsio \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST2 ./c96.fv3.nemsio.sh)
 
@@ -82,13 +81,15 @@ TEST3=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_C
 # Initialize C96 using spectral GFS sigio/sfcio files.
 #-----------------------------------------------------------------------------
 
-TEST4=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.gfs.sigio \
+export OMP_NUM_THREADS=6   # should match cpus-per-task
+TEST4=$(sbatch --parsable --ntasks-per-node=3 --cpus-per-task=6 --nodes=2 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.gfs.sigio \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST3 ./c96.gfs.sigio.sh)
 
 #-----------------------------------------------------------------------------
 # Initialize C96 using spectral GFS gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1   # should match cpus-per-task
 TEST5=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.gfs.nemsio \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST4 ./c96.gfs.nemsio.sh)
 
@@ -96,22 +97,32 @@ TEST5=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_C
 # Initialize regional C96 using FV3 gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1   # should match cpus-per-task
 TEST6=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.regional \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST5 ./c96.regional.sh)
 
+#-----------------------------------------------------------------------------
+# Initialize C96 using FV3 gaussian netcdf files.
+#-----------------------------------------------------------------------------
+
+export OMP_NUM_THREADS=1   # should match cpus-per-task
+TEST7=$(sbatch --parsable --ntasks-per-node=12 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.netcdf \
+      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST6 ./c96.fv3.netcdf.sh)
+
 #-----------------------------------------------------------------------------
 # Initialize global C192 using GFS GRIB2 files.
 #-----------------------------------------------------------------------------
 
-TEST7=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:05:00 -A $PROJECT_CODE -q $QUEUE -J c192.gfs.grib2 \
-      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST6 ./c192.gfs.grib2.sh)
+export OMP_NUM_THREADS=1   # should match cpus-per-task
+TEST8=$(sbatch --parsable --ntasks-per-node=6 --nodes=1 -t 0:05:00 -A $PROJECT_CODE -q $QUEUE -J c192.gfs.grib2 \
+      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST7 ./c192.gfs.grib2.sh)
 
 #-----------------------------------------------------------------------------
 # Create summary log.
 #-----------------------------------------------------------------------------
 
 sbatch --nodes=1 -t 0:01:00 -A $PROJECT_CODE -J chgres_summary -o $LOG_FILE -e $LOG_FILE \
-       --open-mode=append -q $QUEUE -d afterok:$TEST7 << EOF
+       --open-mode=append -q $QUEUE -d afterok:$TEST8 << EOF
 #!/bin/sh
 grep -a '<<<' $LOG_FILE  > $SUM_FILE
 EOF
diff --git a/reg_tests/chgres_cube/driver.jet.sh b/reg_tests/chgres_cube/driver.jet.sh
index 0b97ec2..b173539 100755
--- a/reg_tests/chgres_cube/driver.jet.sh
+++ b/reg_tests/chgres_cube/driver.jet.sh
@@ -24,16 +24,10 @@
 
 set -x
 
-source /apps/lmod/lmod/init/sh
-module purge
-module load intel/18.0.5.274
-module load impi/2018.4.274
-module load szip
-module load hdf5
-module load netcdf/4.2.1.1
-module list
-
-export OUTDIR=/mnt/lfs3/projects/emcda/$LOGNAME/stmp/chgres_reg_tests
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export OUTDIR=/lfs4/HFIP/emcda/$LOGNAME/stmp/chgres_reg_tests
 PROJECT_CODE="hfv3gfs"
 QUEUE="debug"
 
@@ -45,9 +39,9 @@ QUEUE="debug"
 
 export HOMEufs=$PWD/../..
 
-export HOMEreg=/mnt/lfs3/projects/emcda/George.Gayno/reg_tests/chgres_cube
+export HOMEreg=/lfs4/HFIP/emcda/George.Gayno/reg_tests/chgres_cube
 
-export NCCMP=/apps/nccmp/1.8.2.1/intel/18.0.3.222/bin/nccmp
+export NCCMP=/apps/nccmp/1.8.5/intel/18.0.5.274/bin/nccmp
 
 LOG_FILE=regression.log
 SUM_FILE=summary.log
@@ -63,6 +57,7 @@ rm -fr $OUTDIR
 # Initialize C96 using FV3 warm restart files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1
 TEST1=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.restart \
       -o $LOG_FILE -e $LOG_FILE ./c96.fv3.restart.sh)
 
@@ -70,6 +65,7 @@ TEST1=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10
 # Initialize C192 using FV3 tiled history files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1
 TEST2=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c192.fv3.history \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST1 ./c192.fv3.history.sh)
 
@@ -77,6 +73,7 @@ TEST2=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10
 # Initialize C96 using FV3 gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1
 TEST3=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.nemsio \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST2 ./c96.fv3.nemsio.sh)
 
@@ -84,6 +81,7 @@ TEST3=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10
 # Initialize C96 using spectral GFS sigio/sfcio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=6   # should match cpus-per-task
 TEST4=$(sbatch --parsable --partition=xjet --nodes=2 --ntasks-per-node=3 --cpus-per-task=6 -t 0:15:00 \
       -A $PROJECT_CODE -q $QUEUE -J c96.gfs.sigio -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST3 ./c96.gfs.sigio.sh)
 
@@ -91,6 +89,7 @@ TEST4=$(sbatch --parsable --partition=xjet --nodes=2 --ntasks-per-node=3 --cpus-
 # Initialize C96 using spectral GFS gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1
 TEST5=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.gfs.nemsio \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST4 ./c96.gfs.nemsio.sh)
 
@@ -98,22 +97,32 @@ TEST5=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10
 # Initialize regional C96 using FV3 gaussian nemsio files.
 #-----------------------------------------------------------------------------
 
+export OMP_NUM_THREADS=1
 TEST6=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.regional \
       -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST5 ./c96.regional.sh)
 
+#-----------------------------------------------------------------------------
+# Initialize C96 using FV3 gaussian netcdf files.
+#-----------------------------------------------------------------------------
+
+export OMP_NUM_THREADS=1
+TEST7=$(sbatch --parsable --partition=xjet --nodes=2 --ntasks-per-node=6 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.fv3.netcdf \
+      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST6 ./c96.fv3.netcdf.sh)
+
 #-----------------------------------------------------------------------------
 # Initialize C192 using GFS GRIB2 data.
 #-----------------------------------------------------------------------------
 
-TEST7=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:05:00 -A $PROJECT_CODE -q $QUEUE -J c192.gfs.grib2 \
-      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST6 ./c192.gfs.grib2.sh)
+export OMP_NUM_THREADS=1
+TEST8=$(sbatch --parsable --partition=xjet --nodes=1 --ntasks-per-node=6 -t 0:05:00 -A $PROJECT_CODE -q $QUEUE -J c192.gfs.grib2 \
+      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST7 ./c192.gfs.grib2.sh)
 
 #-----------------------------------------------------------------------------
 # Create summary log.
 #-----------------------------------------------------------------------------
 
 sbatch --partition=xjet --nodes=1  -t 0:01:00 -A $PROJECT_CODE -J chgres_summary -o $LOG_FILE -e $LOG_FILE \
-       --open-mode=append -q $QUEUE -d afterok:$TEST7 << EOF
+       --open-mode=append -q $QUEUE -d afterok:$TEST8 << EOF
 #!/bin/sh
 grep -a '<<<' $LOG_FILE  > $SUM_FILE
 EOF
diff --git a/reg_tests/global_cycle/C768.fv3gfs.sh b/reg_tests/global_cycle/C768.fv3gfs.sh
new file mode 100755
index 0000000..20909b6
--- /dev/null
+++ b/reg_tests/global_cycle/C768.fv3gfs.sh
@@ -0,0 +1,82 @@
+#!/bin/bash
+
+#------------------------------------------------------------------
+# Run global_cycle for a C768 test case.  Compare output
+# to a baseline set of files using the 'nccmp' utility.
+#------------------------------------------------------------------
+
+set -x
+
+export MAX_TASKS_CY=6
+
+export HOMEgfs=$NWPROD
+export BASE_GSM=$NWPROD
+
+export CYCLEXEC=$BASE_GSM/exec/global_cycle
+
+export CDATE=2019073000
+export FHOUR=00
+export DELTSFC=6
+
+export CASE=C768
+
+export COMIN=$HOMEreg/input_data
+export FNTSFA=$COMIN/gdas.t00z.rtgssthr.grb
+export FNSNOA=$COMIN/gdas.t00z.snogrb_t1534.3072.1536
+export FNACNA=$COMIN/gdas.t00z.seaice.5min.blend.grb
+export GSI_FILE=$COMIN/gdas.t00z.dtfanl.nc
+
+export JCAP=1534
+export LONB=3072
+export LATB=1536
+
+export FIXgsm=$BASE_GSM/fix/fix_am
+
+export DONST="YES"
+export use_ufo=.true.
+
+export VERBOSE=YES
+export CYCLVARS=FSNOL=-2.,FSNOS=99999.,
+
+
+$BASE_GSM/ush/global_cycle_driver.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< GLOBAL CYCLE TEST FAILED. <<<"
+  echo "<<< GLOBAL CYCLE TEST FAILED. <<<"  > ./summary.log
+  exit $iret
+fi
+
+test_failed=0
+
+cd $DATA
+for files in *tile*.nc
+do
+  if [ -f $files ]; then
+    echo CHECK $files
+    $NCCMP -dmfqS $files $HOMEreg/baseline_data/$files
+    iret=$?
+    if [ $iret -ne 0 ]; then
+      test_failed=1
+    fi
+  fi
+done
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo
+  echo "*********************************"
+  echo "<<< GLOBAL CYCLE TEST FAILED. >>>"
+  echo "*********************************"
+  echo "<<< GLOBAL CYCLE TEST FAILED. >>>" > ./summary.log
+else
+  echo
+  echo "*********************************"
+  echo "<<< GLOBAL CYCLE TEST PASSED. >>>"
+  echo "*********************************"
+  echo "<<< GLOBAL CYCLE TEST PASSED. >>>" > ./summary.log
+fi
+
+exit
diff --git a/reg_tests/global_cycle/driver.cray.sh b/reg_tests/global_cycle/driver.cray.sh
new file mode 100755
index 0000000..ffd5048
--- /dev/null
+++ b/reg_tests/global_cycle/driver.cray.sh
@@ -0,0 +1,62 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run global_cycle regression test on WCOSS-Cray.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline files
+# as determined by the 'nccmp' utility.  This baseline files are
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -oo regression.log
+#BSUB -eo regression.log
+#BSUB -q debug
+#BSUB -P GDAS-T2O
+#BSUB -J cycle_regt
+#BSUB -M 2400
+#BSUB -W 00:05
+#BSUB -extsched 'CRAYLINUX[]'
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+module list
+
+export DATA=/gpfs/hps3/stmp/$LOGNAME/reg_tests.cycle
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export NODES=1
+
+export HOMEreg=/gpfs/hps3/emc/global/noscrub/George.Gayno/ufs_utils.git/reg_tests/global_cycle
+
+export OMP_NUM_THREADS_CY=4
+
+export KMP_AFFINITY=disabled
+
+export APRUNCY="aprun -n 6 -N 6 -j 1 -d $OMP_NUM_THREADS_CY -cc depth"
+
+export NWPROD=$PWD/../..
+
+export COMOUT=$DATA
+
+export NCCMP=/gpfs/hps3/emc/global/noscrub/George.Gayno/util/netcdf/nccmp
+
+reg_dir=$PWD
+
+./C768.fv3gfs.sh
+
+cp $DATA/summary.log  $reg_dir
+
+exit
diff --git a/reg_tests/global_cycle/driver.dell.sh b/reg_tests/global_cycle/driver.dell.sh
new file mode 100755
index 0000000..3831242
--- /dev/null
+++ b/reg_tests/global_cycle/driver.dell.sh
@@ -0,0 +1,62 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run global_cycle regression test on WCOSS-Dell.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline files
+# as determined by the 'nccmp' utility.  This baseline files are
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -W 00:05
+#BSUB -n 6
+#BSUB -R span[ptile=6]
+#BSUB -x
+#BSUB -o regression.log
+#BSUB -e regression.log
+#BSUB -R "affinity[core(1)]"
+#BSUB -M 2400
+#BSUB -J glc_regt
+#BSUB -q debug
+#BSUB -P GFS-DEV
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA=/gpfs/dell1/stmp/$LOGNAME/reg_tests.cycle
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/ufs_utils.git/reg_tests/global_cycle
+
+export OMP_NUM_THREADS_CY=2
+
+export APRUNCY="mpirun -l"
+
+export NWPROD=$PWD/../..
+
+export COMOUT=$DATA
+
+export NCCMP=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/util/nccmp/nccmp-nc4.7.4/src/nccmp
+
+reg_dir=$PWD
+
+./C768.fv3gfs.sh
+
+cp $DATA/summary.log  $reg_dir
+
+exit
diff --git a/reg_tests/global_cycle/driver.hera.sh b/reg_tests/global_cycle/driver.hera.sh
new file mode 100755
index 0000000..ecc05cd
--- /dev/null
+++ b/reg_tests/global_cycle/driver.hera.sh
@@ -0,0 +1,59 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run global_cycle regression test on Hera.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline files
+# as determined by the 'nccmp' utility.  This baseline files are
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH -J cycle_reg_test
+#SBATCH -A fv3-cpu
+#SBATCH --open-mode=truncate
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+#SBATCH --nodes=1 --ntasks-per-node=6
+#SBATCH -q debug
+#SBATCH -t 00:05:00
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA=/scratch2/NCEPDEV/stmp1/$LOGNAME/reg_tests.cycle
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/scratch1/NCEPDEV/da/George.Gayno/noscrub/reg_tests/global_cycle
+
+export OMP_NUM_THREADS_CY=2
+
+export APRUNCY="srun"
+
+export NWPROD=$PWD/../..
+
+export COMOUT=$DATA
+
+export NCCMP=/apps/nccmp/1.8.5/intel/18.0.3.051/bin/nccmp
+
+reg_dir=$PWD
+
+./C768.fv3gfs.sh
+
+cp $DATA/summary.log  $reg_dir
+
+exit
diff --git a/reg_tests/global_cycle/driver.jet.sh b/reg_tests/global_cycle/driver.jet.sh
new file mode 100755
index 0000000..74183c5
--- /dev/null
+++ b/reg_tests/global_cycle/driver.jet.sh
@@ -0,0 +1,60 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run global_cycle regression test on Jet.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline files
+# as determined by the 'nccmp' utility.  This baseline files are
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH -J cycle_reg_test
+#SBATCH -A emcda
+#SBATCH --open-mode=truncate
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+#SBATCH --nodes=1 --ntasks-per-node=6
+#SBATCH --partition=xjet
+#SBATCH -q windfall
+#SBATCH -t 00:05:00
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA=/lfs4/HFIP/emcda/$LOGNAME/stmp/reg_tests.cycle
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/lfs4/HFIP/emcda/George.Gayno/reg_tests/global_cycle
+
+export OMP_NUM_THREADS_CY=2
+
+export APRUNCY="srun"
+
+export NWPROD=$PWD/../..
+
+export COMOUT=$DATA
+
+export NCCMP=/apps/nccmp/1.8.5/intel/18.0.5.274/bin/nccmp
+
+reg_dir=$PWD
+
+./C768.fv3gfs.sh
+
+cp $DATA/summary.log  $reg_dir
+
+exit
diff --git a/reg_tests/grid_gen/c96.regional.sh b/reg_tests/grid_gen/c96.regional.sh
new file mode 100755
index 0000000..39a7e54
--- /dev/null
+++ b/reg_tests/grid_gen/c96.regional.sh
@@ -0,0 +1,69 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------
+# Create a C96 regional grid.  Compare output to a set
+# of baseline files using the 'nccmp' utility.  This script is
+# run by the machine specific driver script.
+#-----------------------------------------------------------------------
+
+set -x
+
+export TMPDIR=${WORK_DIR}/c96.regional.work
+export out_dir=${WORK_DIR}/c96.regional
+
+export res=96
+export gtype=regional
+export stretch_fac=1.5       # Stretching factor for the grid
+export target_lon=-97.5      # Center longitude of the highest resolution tile
+export target_lat=35.5       # Center latitude of the highest resolution tile
+export refine_ratio=3        # The refinement ratio
+export istart_nest=27        # Starting i-direction index of nest grid in parent tile supergrid
+export jstart_nest=37        # Starting j-direction index of nest grid in parent tile supergrid
+export iend_nest=166         # Ending i-direction index of nest grid in parent tile supergrid
+export jend_nest=164         # Ending j-direction index of nest grid in parent tile supergrid
+export halo=3
+
+#-----------------------------------------------------------------------
+# Start script.
+#-----------------------------------------------------------------------
+
+echo "Starting at: " `date`
+
+$home_dir/ush/fv3gfs_driver_grid.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< C96 REGIONAL TEST FAILED. <<<"
+  exit $iret
+fi
+
+echo "Ending at: " `date`
+
+#-----------------------------------------------------------------------------
+# Compare output to baseline set of data.
+#-----------------------------------------------------------------------------
+
+cd $out_dir
+
+test_failed=0
+for files in *tile*.nc ./fix_sfc/*tile*.nc
+do
+  if [ -f $files ]; then
+    echo CHECK $files
+    $NCCMP -dmfqS $files $HOMEreg/c96.regional/$files
+    iret=$?
+    if [ $iret -ne 0 ]; then
+      test_failed=1
+    fi
+  fi
+done
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo "<<< C96 REGIONAL TEST FAILED. >>>"
+else
+  echo "<<< C96 REGIONAL TEST PASSED. >>>"
+fi
+
+exit 0
diff --git a/reg_tests/grid_gen/c96.uniform.sh b/reg_tests/grid_gen/c96.uniform.sh
new file mode 100755
index 0000000..61f2800
--- /dev/null
+++ b/reg_tests/grid_gen/c96.uniform.sh
@@ -0,0 +1,60 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------
+# Create a C96 global uniform grid.  Compare output to a set
+# of baseline files using the 'nccmp' utility.  This script is
+# run by the machine specific driver script.
+#-----------------------------------------------------------------------
+
+set -x
+
+export TMPDIR=${WORK_DIR}/c96.uniform.work
+export out_dir=${WORK_DIR}/c96.uniform
+
+export res=96
+export gtype=uniform
+
+#-----------------------------------------------------------------------
+# Start script.
+#-----------------------------------------------------------------------
+
+echo "Starting at: " `date`
+
+$home_dir/ush/fv3gfs_driver_grid.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< C96 UNIFORM TEST FAILED. <<<"
+  exit $iret
+fi
+
+echo "Ending at: " `date`
+
+#-----------------------------------------------------------------------------
+# Compare output to baseline set of data.
+#-----------------------------------------------------------------------------
+
+cd $out_dir
+
+test_failed=0
+for files in *tile*.nc ./fix_sfc/*tile*.nc
+do
+  if [ -f $files ]; then
+    echo CHECK $files
+    $NCCMP -dmfqS $files $HOMEreg/c96.uniform/$files
+    iret=$?
+    if [ $iret -ne 0 ]; then
+      test_failed=1
+    fi
+  fi
+done
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo "<<< C96 UNIFORM TEST FAILED. >>>"
+else
+  echo "<<< C96 UNIFORM TEST PASSED. >>>"
+fi
+
+exit 0
diff --git a/reg_tests/grid_gen/driver.cray.sh b/reg_tests/grid_gen/driver.cray.sh
new file mode 100755
index 0000000..40267ad
--- /dev/null
+++ b/reg_tests/grid_gen/driver.cray.sh
@@ -0,0 +1,73 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run grid generation regression tests on WCOSS-Cray.
+#
+# Set WORK_DIR to your working directory. Set the PROJECT_CODE and QUEUE
+# as appropriate.
+#
+# Invoke the script with no arguments.  A series of daily-
+# chained jobs will be submitted.  To check the queue, type: "bjobs".
+#
+# Log output from the suite will be in LOG_FILE.  Once the suite
+# has completed, a summary is placed in SUM_FILE.
+#
+# A test fails when its output does not match the baseline files as
+# determined by the "nccmp" utility.  The baseline files are stored in
+# HOMEreg
+#
+#-----------------------------------------------------------------------------
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+module list
+
+set -x
+
+QUEUE="debug"
+PROJECT_CODE="GFS-DEV"
+export WORK_DIR=/gpfs/hps3/stmp/$LOGNAME/reg_tests.grid
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below here.
+#-----------------------------------------------------------------------------
+
+export home_dir=$PWD/../..
+LOG_FILE=regression.log
+SUM_FILE=summary.log
+export APRUN="aprun -n 1 -N 1 -j 1 -d 1 -cc depth"
+export APRUN_SFC="aprun -j 1 -n 24 -N 24"
+export OMP_STACKSIZE=2048m
+export OMP_NUM_THREADS=6
+export machine=WCOSS_C
+export KMP_AFFINITY=disabled
+export NCCMP=/gpfs/hps3/emc/global/noscrub/George.Gayno/util/netcdf/nccmp
+export HOMEreg=/gpfs/hps3/emc/global/noscrub/George.Gayno/ufs_utils.git/reg_tests/grid_gen/baseline_data
+
+rm -fr $WORK_DIR
+
+ulimit -a
+ulimit -s unlimited
+
+#-----------------------------------------------------------------------------
+# C96 uniform grid
+#-----------------------------------------------------------------------------
+
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.uniform -W 0:15 -M 2400 \
+        -extsched 'CRAYLINUX[]' "export NODES=1; $PWD/c96.uniform.sh"
+
+#-----------------------------------------------------------------------------
+# C96 regional grid
+#-----------------------------------------------------------------------------
+
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.regional -W 0:10 -M 2400 \
+        -w 'ended(c96.uniform)' -extsched 'CRAYLINUX[]' "export NODES=1; $PWD/c96.regional.sh"
+
+#-----------------------------------------------------------------------------
+# Create summary log.
+#-----------------------------------------------------------------------------
+
+bsub -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J summary -R "rusage[mem=100]" -W 0:01 -w 'ended(c96.regional)' "grep -a '<<<' $LOG_FILE >> $SUM_FILE"
+
+exit
diff --git a/reg_tests/grid_gen/driver.dell.sh b/reg_tests/grid_gen/driver.dell.sh
new file mode 100755
index 0000000..7ceac48
--- /dev/null
+++ b/reg_tests/grid_gen/driver.dell.sh
@@ -0,0 +1,70 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run grid generation regression tests on WCOSS-Dell.
+#
+# Set WORK_DIR to your working directory. Set the PROJECT_CODE and QUEUE
+# as appropriate. 
+#
+# Invoke the script with no arguments.  A series of daily-
+# chained jobs will be submitted.  To check the queue, type: "bjobs".
+#
+# Log output from the suite will be in LOG_FILE.  Once the suite
+# has completed, a summary is placed in SUM_FILE.
+#
+# A test fails when its output does not match the baseline files as
+# determined by the "nccmp" utility.  The baseline files are stored in
+# HOMEreg
+#
+#-----------------------------------------------------------------------------
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+set -x
+
+QUEUE="debug"
+PROJECT_CODE="GFS-DEV"
+export WORK_DIR=/gpfs/dell1/stmp/$LOGNAME/reg_tests.grid
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below here.
+#-----------------------------------------------------------------------------
+
+LOG_FILE=regression.log
+SUM_FILE=summary.log
+export home_dir=$PWD/../..
+export APRUN=time
+export APRUN_SFC="mpirun -l"
+export OMP_STACKSIZE=2048m
+export machine=WCOSS_DELL_P3
+export NCCMP=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/util/nccmp/nccmp-nc4.7.4/src/nccmp
+export HOMEreg=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/ufs_utils.git/reg_tests/grid_gen/baseline_data
+export OMP_NUM_THREADS=24
+
+rm -fr $WORK_DIR
+
+ulimit -a
+ulimit -s unlimited
+
+#-----------------------------------------------------------------------------
+# C96 uniform grid
+#-----------------------------------------------------------------------------
+
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.uniform -W 0:15 -x -n 24 \
+        -R "span[ptile=24]" -R "affinity[core(1):distribute=balance]" "$PWD/c96.uniform.sh"
+
+#-----------------------------------------------------------------------------
+# C96 regional grid
+#-----------------------------------------------------------------------------
+
+bsub -e $LOG_FILE -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J c96.regional -W 0:10 -x -n 24 -w 'ended(c96.uniform)' \
+        -R "span[ptile=24]" -R "affinity[core(1):distribute=balance]" "$PWD/c96.regional.sh"
+
+#-----------------------------------------------------------------------------
+# Create summary log.
+#-----------------------------------------------------------------------------
+
+bsub -o $LOG_FILE -q $QUEUE -P $PROJECT_CODE -J summary -R "affinity[core(1)]" -R "rusage[mem=100]" -W 0:01 \
+     -w 'ended(c96.regional)' "grep -a '<<<' $LOG_FILE >> $SUM_FILE"
diff --git a/reg_tests/grid_gen/driver.hera.sh b/reg_tests/grid_gen/driver.hera.sh
new file mode 100755
index 0000000..3483bfb
--- /dev/null
+++ b/reg_tests/grid_gen/driver.hera.sh
@@ -0,0 +1,76 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run grid generation regression tests on Hera.
+#
+# Set WORK_DIR to your working directory. Set the PROJECT_CODE and QUEUE
+# as appropriate.  To see which projects you are authorized to use,
+# type "account_params".
+#
+# Invoke the script with no arguments.  A series of daily-
+# chained jobs will be submitted.  To check the queue, type:
+# "squeue -u USERNAME".
+#
+# Log output from the suite will be in LOG_FILE.  Once the suite
+# has completed, a summary is placed in SUM_FILE.
+#
+# A test fails when its output does not match the baseline files as
+# determined by the "nccmp" utility.  The baseline files are stored in
+# HOMEreg
+#
+#-----------------------------------------------------------------------------
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+set -x
+
+export WORK_DIR=/scratch2/NCEPDEV/stmp1/$LOGNAME/reg_tests.grid
+QUEUE="batch"
+PROJECT_CODE="fv3-cpu"
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below here.
+#-----------------------------------------------------------------------------
+
+LOG_FILE=regression.log
+SUM_FILE=summary.log
+export home_dir=$PWD/../..
+export APRUN=time
+export APRUN_SFC=srun
+export OMP_STACKSIZE=2048m
+export machine=HERA
+export NCCMP=/apps/nccmp/1.8.5/intel/18.0.3.051/bin/nccmp
+export HOMEreg=/scratch1/NCEPDEV/da/George.Gayno/noscrub/reg_tests/grid_gen/baseline_data
+
+ulimit -a
+#ulimit -s unlimited
+
+rm -fr $WORK_DIR
+
+export OMP_NUM_THREADS=24
+
+#-----------------------------------------------------------------------------
+# C96 uniform grid
+#-----------------------------------------------------------------------------
+
+TEST1=$(sbatch --parsable --ntasks-per-node=24 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.uniform \
+      -o $LOG_FILE -e $LOG_FILE ./c96.uniform.sh)
+
+#-----------------------------------------------------------------------------
+# C96 regional grid
+#-----------------------------------------------------------------------------
+
+TEST2=$(sbatch --parsable --ntasks-per-node=24 --nodes=1 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.regional \
+      -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST1 ./c96.regional.sh)
+
+#-----------------------------------------------------------------------------
+# Create summary log.
+#-----------------------------------------------------------------------------
+
+sbatch --nodes=1 -t 0:01:00 -A $PROJECT_CODE -J grid_summary -o $LOG_FILE -e $LOG_FILE \
+       --open-mode=append -q $QUEUE -d afterok:$TEST2 << EOF
+#!/bin/sh
+grep -a '<<<' $LOG_FILE  > $SUM_FILE
+EOF
diff --git a/reg_tests/grid_gen/driver.jet.sh b/reg_tests/grid_gen/driver.jet.sh
new file mode 100755
index 0000000..3ec9726
--- /dev/null
+++ b/reg_tests/grid_gen/driver.jet.sh
@@ -0,0 +1,76 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run grid generation regression tests on Jet.
+#
+# Set WORK_DIR to your working directory. Set the PROJECT_CODE and QUEUE
+# as appropriate.  To see which projects you are authorized to use,
+# type "account_params".
+#
+# Invoke the script with no arguments.  A series of daily-
+# chained jobs will be submitted.  To check the queue, type:
+# "squeue -u USERNAME".
+#
+# Log output from the suite will be in LOG_FILE.  Once the suite
+# has completed, a summary is placed in SUM_FILE.
+#
+# A test fails when its output does not match the baseline files as
+# determined by the "nccmp" utility.  The baseline files are stored in
+# HOMEreg
+#
+#-----------------------------------------------------------------------------
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+set -x
+
+QUEUE="windfall"
+PROJECT_CODE="emcda"
+export WORK_DIR=/lfs4/HFIP/emcda/$LOGNAME/stmp/reg_tests.grid
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below here.
+#-----------------------------------------------------------------------------
+
+LOG_FILE=regression.log
+SUM_FILE=summary.log
+export home_dir=$PWD/../..
+export APRUN=time
+export APRUN_SFC=srun
+export OMP_STACKSIZE=2048m
+export machine=JET
+export NCCMP=/apps/nccmp/1.8.5/intel/18.0.5.274/bin/nccmp
+export HOMEreg=/lfs4/HFIP/emcda/George.Gayno/reg_tests/grid_gen/baseline_data
+
+ulimit -a
+ulimit -s unlimited
+
+rm -fr $WORK_DIR
+
+export OMP_NUM_THREADS=24
+
+#-----------------------------------------------------------------------------
+# C96 uniform grid
+#-----------------------------------------------------------------------------
+
+TEST1=$(sbatch --parsable --ntasks-per-node=24 --nodes=1 -t 0:15:00 -A $PROJECT_CODE -q $QUEUE -J c96.uniform \
+      --partition=xjet -o $LOG_FILE -e $LOG_FILE ./c96.uniform.sh)
+
+#-----------------------------------------------------------------------------
+# C96 regional grid
+#-----------------------------------------------------------------------------
+
+TEST2=$(sbatch --parsable --ntasks-per-node=24 --nodes=1 -t 0:10:00 -A $PROJECT_CODE -q $QUEUE -J c96.regional \
+      --partition=xjet -o $LOG_FILE -e $LOG_FILE -d afterok:$TEST1 ./c96.regional.sh)
+
+#-----------------------------------------------------------------------------
+# Create summary log.
+#-----------------------------------------------------------------------------
+
+sbatch --partition=xjet --nodes=1  -t 0:01:00 -A $PROJECT_CODE -J grid_summary -o $LOG_FILE -e $LOG_FILE \
+       --open-mode=append -q $QUEUE -d afterok:$TEST2 << EOF
+#!/bin/sh
+grep -a '<<<' $LOG_FILE  > $SUM_FILE
+EOF
diff --git a/reg_tests/ice_blend/driver.cray.sh b/reg_tests/ice_blend/driver.cray.sh
new file mode 100755
index 0000000..f2904b0
--- /dev/null
+++ b/reg_tests/ice_blend/driver.cray.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run ice_blend regression test on WCOSS-Cray.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log.
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -W 0:02
+#BSUB -o regression.log
+#BSUB -e regression.log
+#BSUB -J iceb_regt
+#BSUB -q debug
+#BSUB -R "rusage[mem=2000]"
+#BSUB -P GFS-DEV
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+module list
+
+export DATA=/gpfs/hps3/stmp/$LOGNAME/reg_tests.ice_blend
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export WGRIB=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.5/exec/wgrib
+export WGRIB2=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.5/exec/wgrib2
+export COPYGB2=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.5/exec/copygb2
+export COPYGB=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.5/exec/copygb
+export CNVGRIB=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.5/exec/cnvgrib
+
+export HOMEreg=/gpfs/hps3/emc/global/noscrub/George.Gayno/ufs_utils.git/reg_tests/ice_blend
+export HOMEgfs=$PWD/../..
+
+rm -fr $DATA
+
+./ice_blend.sh
+
+exit 0
diff --git a/reg_tests/ice_blend/driver.dell.sh b/reg_tests/ice_blend/driver.dell.sh
new file mode 100755
index 0000000..9ca96d1
--- /dev/null
+++ b/reg_tests/ice_blend/driver.dell.sh
@@ -0,0 +1,53 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run ice_blend regression test on WCOSS-Dell.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -W 0:02
+#BSUB -o regression.log
+#BSUB -e regression.log
+#BSUB -J iceb_regt
+#BSUB -q debug
+#BSUB -R "affinity[core(1)]"
+#BSUB -P GFS-DEV
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+set -x
+
+export DATA=/gpfs/dell1/stmp/$LOGNAME/reg_tests.ice_blend
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export WGRIB="/gpfs/dell1/nco/ops/nwprod/grib_util.v1.1.1/exec/wgrib"
+export WGRIB2="/gpfs/dell1/nco/ops/nwprod/grib_util.v1.1.1/exec/wgrib2"
+export COPYGB2="/gpfs/dell1/nco/ops/nwprod/grib_util.v1.1.1/exec/copygb2"
+export COPYGB="/gpfs/dell1/nco/ops/nwprod/grib_util.v1.1.1/exec/copygb"
+export CNVGRIB="/gpfs/dell1/nco/ops/nwprod/grib_util.v1.1.1/exec/cnvgrib"
+
+export HOMEreg=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/ufs_utils.git/reg_tests/ice_blend
+export HOMEgfs=$PWD/../..
+
+rm -fr $DATA
+
+./ice_blend.sh
+
+exit 0
diff --git a/reg_tests/ice_blend/driver.hera.sh b/reg_tests/ice_blend/driver.hera.sh
new file mode 100755
index 0000000..4866e79
--- /dev/null
+++ b/reg_tests/ice_blend/driver.hera.sh
@@ -0,0 +1,54 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run ice_blend regression test on Hera.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH -J ice_blend
+#SBATCH -A fv3-cpu
+#SBATCH --open-mode=truncate
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+#SBATCH --ntasks=1
+#SBATCH -q debug
+#SBATCH -t 00:03:00
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA="/scratch2/NCEPDEV/stmp1/$LOGNAME/reg_test.ice_blend"
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export WGRIB=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/wgrib
+export WGRIB2=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/wgrib2
+export COPYGB=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/copygb
+export COPYGB2=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/copygb2
+export CNVGRIB=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/cnvgrib
+
+export HOMEreg=/scratch1/NCEPDEV/da/George.Gayno/noscrub/reg_tests/ice_blend
+export HOMEgfs=$PWD/../..
+
+rm -fr $DATA
+
+./ice_blend.sh
+
+exit 0
diff --git a/reg_tests/ice_blend/driver.jet.sh b/reg_tests/ice_blend/driver.jet.sh
new file mode 100755
index 0000000..bc55aa2
--- /dev/null
+++ b/reg_tests/ice_blend/driver.jet.sh
@@ -0,0 +1,53 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run ice_blend regression test on Jet.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH --nodes=1
+#SBATCH --partition=sjet
+#SBATCH --time 0:01
+#SBATCH --account=emcda
+#SBATCH --job-name=ice_blnd
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA="/lfs4/HFIP/emcda/$LOGNAME/stmp/reg_test.ice_blend"
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export WGRIB=/apps/wgrib/1.8.1.0b/bin/wgrib
+export WGRIB2=/apps/wgrib2/0.1.9.6a/bin/wgrib2
+export COPYGB=/lfs4/HFIP/emcda/George.Gayno/ufs_utils.git/jet_port/grib_util/copygb
+export COPYGB2=/lfs4/HFIP/emcda/George.Gayno/ufs_utils.git/jet_port/grib_util/copygb2
+export CNVGRIB=/apps/cnvgrib/1.4.0/bin/cnvgrib
+
+export HOMEreg=/lfs4/HFIP/emcda/George.Gayno/reg_tests/ice_blend
+export HOMEgfs=$PWD/../..
+
+rm -fr $DATA
+
+./ice_blend.sh
+
+exit 0
diff --git a/reg_tests/ice_blend/ice_blend.sh b/reg_tests/ice_blend/ice_blend.sh
new file mode 100755
index 0000000..94c9e84
--- /dev/null
+++ b/reg_tests/ice_blend/ice_blend.sh
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+# Run ice_blend regression test.  This script called from it machine-specific
+# driver script.
+#-----------------------------------------------------------------------------
+
+export IMS_FILE=$HOMEreg/input_data/imssnow96.grib2.gdas.2018120618
+export FIVE_MIN_ICE_FILE=$HOMEreg/input_data/seaice.5min.grib2.gdas.2018120618
+
+${HOMEgfs}/ush/emcsfc_ice_blend.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< ICE_BLEND TEST FAILED. <<<"
+  echo "<<< ICE_BLEND TEST FAILED. <<<"  > ./summary.log
+  exit $iret
+fi
+
+cmp ${DATA}/seaice.5min.blend $HOMEreg/baseline_data/seaice.5min.blend
+iret=$?
+test_failed=0
+if [ $iret -ne 0 ]; then
+  test_failed=1
+fi
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo
+  echo "*********************************"
+  echo "<<< ICE BLEND TEST FAILED. >>>"
+  echo "*********************************"
+  echo "<<< ICE BLEND TEST FAILED. >>>" > ./summary.log
+else
+  echo
+  echo "*********************************"
+  echo "<<< ICE BLEND TEST PASSED. >>>"
+  echo "*********************************"
+  echo "<<< ICE BLEND TEST PASSED. >>>" > ./summary.log
+fi
+
+exit 0
diff --git a/reg_tests/snow2mdl/driver.cray.sh b/reg_tests/snow2mdl/driver.cray.sh
new file mode 100755
index 0000000..f39c5b3
--- /dev/null
+++ b/reg_tests/snow2mdl/driver.cray.sh
@@ -0,0 +1,50 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run snow2mdl regression test on WCOSS-Cray.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -W 0:02
+#BSUB -o regression.log
+#BSUB -e regression.log
+#BSUB -J s2m_regt
+#BSUB -q debug
+#BSUB -R "rusage[mem=2000]"
+#BSUB -P GFS-DEV
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+module list
+
+export DATA=/gpfs/hps3/stmp/$LOGNAME/reg_tests.snow2mdl
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/gpfs/hps3/emc/global/noscrub/George.Gayno/ufs_utils.git/reg_tests/snow2mdl
+export HOMEgfs=$PWD/../..
+export WGRIB=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.2/exec/wgrib
+export WGRIB2=/gpfs/hps/nco/ops/nwprod/grib_util.v1.0.2/exec/wgrib2
+
+rm -fr $DATA
+
+./snow2mdl.sh
+
+exit 0
diff --git a/reg_tests/snow2mdl/driver.dell.sh b/reg_tests/snow2mdl/driver.dell.sh
new file mode 100755
index 0000000..610f726
--- /dev/null
+++ b/reg_tests/snow2mdl/driver.dell.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run snow2mdl regression test on WCOSS-Dell.
+#
+# Set $DATA to your working directory.  Set the project code (BSUB -P)
+# and queue (BSUB -q) as appropriate.
+#
+# Invoke the script as follows:  cat $script | bsub
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is 
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#BSUB -W 0:02
+#BSUB -o regression.log
+#BSUB -e regression.log
+#BSUB -J s2m_regt
+#BSUB -q debug
+#BSUB -R "affinity[core(1)]"
+#BSUB -P GFS-DEV
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+set -x
+
+export DATA=/gpfs/dell1/stmp/$LOGNAME/reg_tests.snow2mdl
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/gpfs/dell2/emc/modeling/noscrub/George.Gayno/ufs_utils.git/reg_tests/snow2mdl
+export HOMEgfs=$PWD/../..
+export WGRIB=/gpfs/dell1/nco/ops/nwprod/grib_util.v1.0.6/exec/wgrib
+export WGRIB2=/gpfs/dell1/nco/ops/nwprod/grib_util.v1.0.6/exec/wgrib2
+
+rm -fr $DATA
+
+./snow2mdl.sh
+
+exit 0
diff --git a/reg_tests/snow2mdl/driver.hera.sh b/reg_tests/snow2mdl/driver.hera.sh
new file mode 100755
index 0000000..cd04571
--- /dev/null
+++ b/reg_tests/snow2mdl/driver.hera.sh
@@ -0,0 +1,50 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run snow2mdl regression test on Hera.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH -J snow
+#SBATCH -A fv3-cpu
+#SBATCH --open-mode=truncate
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+#SBATCH --ntasks=1
+#SBATCH -q debug
+#SBATCH -t 00:03:00
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA="/scratch2/NCEPDEV/stmp1/$LOGNAME/reg_tests.snow2mdl"
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+rm -fr $DATA
+
+export HOMEreg=/scratch1/NCEPDEV/da/George.Gayno/noscrub/reg_tests/snow2mdl
+export HOMEgfs=$PWD/../..
+export WGRIB=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/wgrib
+export WGRIB2=/scratch2/NCEPDEV/nwprod/NCEPLIBS/utils/grib_util.v1.1.1/exec/wgrib2
+
+./snow2mdl.sh
+
+exit 0
diff --git a/reg_tests/snow2mdl/driver.jet.sh b/reg_tests/snow2mdl/driver.jet.sh
new file mode 100755
index 0000000..c467903
--- /dev/null
+++ b/reg_tests/snow2mdl/driver.jet.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+#-----------------------------------------------------------------------------
+#
+# Run snow2mdl regression test on Jet.
+#
+# Set $DATA to your working directory.  Set the project code (SBATCH -A)
+# and queue (SBATCH -q) as appropriate.
+#
+# Invoke the script as follows:  sbatch $script
+#
+# Log output is placed in regression.log.  A summary is
+# placed in summary.log
+#
+# The test fails when its output does not match the baseline file
+# as determined by the 'cmp' command.  The baseline file is
+# stored in HOMEreg.
+#
+#-----------------------------------------------------------------------------
+
+#SBATCH --nodes=1
+#SBATCH --partition=sjet
+#SBATCH --time 0:01
+#SBATCH --account=emcda
+#SBATCH --job-name=snow2mdl
+#SBATCH -o regression.log
+#SBATCH -e regression.log
+
+set -x
+
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
+
+export DATA="/lfs4/HFIP/emcda/$LOGNAME/stmp/reg_tests.snow2mdl"
+
+#-----------------------------------------------------------------------------
+# Should not have to change anything below.
+#-----------------------------------------------------------------------------
+
+export HOMEreg=/lfs4/HFIP/emcda/George.Gayno/reg_tests/snow2mdl
+export HOMEgfs=$PWD/../..
+export WGRIB=/apps/wgrib/1.8.1.0b/bin/wgrib
+export WGRIB2=/apps/wgrib2/0.1.9.6a/bin/wgrib2
+
+rm -fr $DATA
+
+./snow2mdl.sh
+
+exit 0
diff --git a/reg_tests/snow2mdl/snow2mdl.sh b/reg_tests/snow2mdl/snow2mdl.sh
new file mode 100755
index 0000000..4acec05
--- /dev/null
+++ b/reg_tests/snow2mdl/snow2mdl.sh
@@ -0,0 +1,55 @@
+#!/bin/bash
+
+#--------------------------------------------------------------------------
+# Create a T1534 snow file.  This script is run from its machine-specific
+# driver.
+#--------------------------------------------------------------------------
+
+set -x
+
+export IMS_FILE=$HOMEreg/input_data/imssnow96.grb
+export AFWA_NH_FILE=$HOMEreg/input_data/NPR.SNWN.SP.S1200.MESH16
+export AFWA_SH_FILE=$HOMEreg/input_data/NPR.SNWS.SP.S1200.MESH16
+
+export MODEL_LATITUDE_FILE=$HOMEgfs/fix/fix_am/global_latitudes.t1534.3072.1536.grb
+export MODEL_LONGITUDE_FILE=$HOMEgfs/fix/fix_am/global_longitudes.t1534.3072.1536.grb
+export MODEL_SLMASK_FILE=$HOMEgfs/fix/fix_am/global_slmask.t1534.3072.1536.grb
+export GFS_LONSPERLAT_FILE=$HOMEgfs/fix/fix_am/global_lonsperlat.t1534.3072.1536.txt
+
+export OMP_NUM_THREADS=1
+export OUTPUT_GRIB2=.false.
+
+${HOMEgfs}/ush/emcsfc_snow.sh
+
+iret=$?
+if [ $iret -ne 0 ]; then
+  set +x
+  echo "<<< SNOW2MDL TEST FAILED. <<<"
+  echo "<<< SNOW2MDL TEST FAILED. <<<"  > ./summary.log
+  exit $iret
+fi
+
+test_failed=0
+
+cmp ${DATA}/snogrb_model $HOMEreg/baseline_data/snogrb_model
+iret=$?
+if [ $iret -ne 0 ]; then
+  test_failed=1
+fi
+
+set +x
+if [ $test_failed -ne 0 ]; then
+  echo
+  echo "*********************************"
+  echo "<<< SNOW2MDL TEST FAILED. >>>"
+  echo "*********************************"
+  echo "<<< SNOW2MDL TEST FAILED. >>>" > ./summary.log
+else
+  echo
+  echo "*********************************"
+  echo "<<< SNOW2MDL TEST PASSED. >>>"
+  echo "*********************************"
+  echo "<<< SNOW2MDL TEST PASSED. >>>" > ./summary.log
+fi
+
+exit
diff --git a/sorc/CMakeLists.txt b/sorc/CMakeLists.txt
index c10b32f..b5c8884 100644
--- a/sorc/CMakeLists.txt
+++ b/sorc/CMakeLists.txt
@@ -1 +1,18 @@
+add_subdirectory(emcsfc_ice_blend.fd)
+add_subdirectory(emcsfc_snow2mdl.fd)
+if (OpenMP_FOUND)
+  add_subdirectory(global_chgres.fd)
+  add_subdirectory(global_cycle.fd)
+else()
+  message(STATUS "OpenMP is required for global_chgres.fd and was NOT found, skipping ...")
+  message(STATUS "OpenMP is required for global_cycle.fd and was NOT found, skipping ...")
+endif()
+add_subdirectory(nst_tf_chg.fd)
+add_subdirectory(nemsio_read.fd)
+add_subdirectory(nemsio_get.fd)
+add_subdirectory(nemsio_chgdate.fd)
+add_subdirectory(mkgfsnemsioctl.fd)
+add_subdirectory(fre-nctools.fd)
 add_subdirectory(chgres_cube.fd)
+add_subdirectory(orog.fd)
+add_subdirectory(sfc_climo_gen.fd)
diff --git a/sorc/chgres_cube.fd/CMakeLists.txt b/sorc/chgres_cube.fd/CMakeLists.txt
index 2df389e..d1eb874 100644
--- a/sorc/chgres_cube.fd/CMakeLists.txt
+++ b/sorc/chgres_cube.fd/CMakeLists.txt
@@ -12,23 +12,13 @@ set(fortran_src
     write_data.F90)
 
 if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
-  set(CMAKE_Fortran_FLAGS "-g -traceback")
-  set(CMAKE_Fortran_FLAGS_RELEASE "-O3")
-  set(CMAKE_Fortran_FLAGS_DEBUG
-      "-O0 -check -check noarg_temp_created -check nopointer -warn -warn noerrors -fp-stack-check -fstack-protector-all -fpe0 -debug -ftrapuv"
-  )
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -convert big_endian -assume byterecl")
 elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
-  set(CMAKE_Fortran_FLAGS "-g -fbacktrace -ffree-form -ffree-line-length-0")
-  set(CMAKE_Fortran_FLAGS_RELEASE "-O3")
-  set(CMAKE_Fortran_FLAGS_DEBUG
-      "-O0 -ggdb -fno-unsafe-math-optimizations -frounding-math -fsignaling-nans -ffpe-trap=invalid,zero,overflow -fbounds-check"
-  )
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -ffree-line-length-0 -fdefault-real-8 -fconvert=big-endian")
 endif()
 
-set(exe_name chgres_cube.exe)
+set(exe_name chgres_cube)
 add_executable(${exe_name} ${fortran_src})
-target_include_directories(
-  ${exe_name} PRIVATE ${ESMF_INC} ${WGRIB2_INCLUDES} ${NETCDF_INCLUDES})
 target_link_libraries(
   ${exe_name}
   nemsio
@@ -38,11 +28,11 @@ target_link_libraries(
   sp_d
   w3nco_d
   esmf
+  wgrib2
   MPI::MPI_Fortran
-  ${WGRIB2_LIBRARIES}
-  ${NETCDF_LIBRARIES})
+  NetCDF::NetCDF_Fortran)
 if(OpenMP_Fortran_FOUND)
   target_link_libraries(${exe_name} OpenMP::OpenMP_Fortran)
 endif()
 
-install(TARGETS ${exe_name} RUNTIME DESTINATION bin)
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/chgres_cube.fd/input_data.F90 b/sorc/chgres_cube.fd/input_data.F90
index ddd2266..5292da9 100644
--- a/sorc/chgres_cube.fd/input_data.F90
+++ b/sorc/chgres_cube.fd/input_data.F90
@@ -153,19 +153,62 @@
 
  integer, intent(in)             :: localpet
 
+!-------------------------------------------------------------------------------
+! Read the tiled 'warm' restart files.
+!-------------------------------------------------------------------------------
+
  if (trim(input_type) == "restart") then
+
    call read_input_atm_restart_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read the gaussian history files in netcdf format.
+!-------------------------------------------------------------------------------
+
+ elseif (trim(input_type) == "gaussian_netcdf") then
+
+   call read_input_atm_gaussian_netcdf_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read the tiled history files in netcdf format.
+!-------------------------------------------------------------------------------
+
  elseif (trim(input_type) == "history") then
-   call read_input_atm_history_file(localpet)
- elseif (trim(input_type) == "gaussian") then  ! fv3gfs gaussian nemsio
-   call read_input_atm_gaussian_file(localpet)
- elseif (trim(input_type) == "gfs_gaussian") then ! spectral gfs gaussian 
-                                                  ! nemsio.
-   call read_input_atm_gfs_gaussian_file(localpet)
- elseif (trim(input_type) == "gfs_spectral") then ! spectral gfs sigio format.
-   call read_input_atm_gfs_spectral_file(localpet)
+
+   call read_input_atm_tiled_history_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read the gaussian history files in nemsio format.
+!-------------------------------------------------------------------------------
+
+ elseif (trim(input_type) == "gaussian_nemsio") then  ! fv3gfs gaussian nemsio
+
+   call read_input_atm_gaussian_nemsio_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read the spectral gfs gaussian history files in nemsio format.
+!-------------------------------------------------------------------------------
+
+ elseif (trim(input_type) == "gfs_gaussian_nemsio") then ! spectral gfs gaussian 
+                                                         ! nemsio.
+   call read_input_atm_gfs_gaussian_nemsio_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read the spectral gfs gaussian history files in sigio format.
+!-------------------------------------------------------------------------------
+
+ elseif (trim(input_type) == "gfs_sigio") then ! spectral gfs sigio format.
+ 
+   call read_input_atm_gfs_sigio_file(localpet)
+
+!-------------------------------------------------------------------------------
+! Read fv3gfs data in grib2 format.
+!-------------------------------------------------------------------------------
+
  elseif (trim(input_type) == "grib2") then
+
    call read_input_atm_grib2_file(localpet)
+
  endif
 
  end subroutine read_input_atm_data
@@ -310,10 +353,24 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
    call error_handler("IN FieldCreate", rc)
  
- if (trim(input_type) == "gaussian" .or. trim(input_type) == "gfs_gaussian") then
-   call read_input_nst_gaussian_file(localpet)
+!--------------------------------------------------------------------------
+! Read input grid nst data from a fv3 gaussian nemsio history file or
+! spectral GFS nemsio file.
+!--------------------------------------------------------------------------
+
+ if (trim(input_type) == "gaussian_nemsio" .or. trim(input_type) == "gfs_gaussian_nemsio") then
+
+   call read_input_nst_nemsio_file(localpet)
+
+!---------------------------------------------------------------------------
+! Read nst data from these netcdf formatted fv3 files: tiled history,
+! tiled warm restart, and gaussian history.
+!---------------------------------------------------------------------------
+
  else
-   call read_input_nst_tile_file(localpet)
+
+   call read_input_nst_netcdf_file(localpet)
+
  endif
 
  end subroutine read_input_nst_data
@@ -526,85 +583,80 @@
     call error_handler("IN FieldCreate", rc)
  endif
 
+!-------------------------------------------------------------------------------
+! Read the tiled 'warm' restart files.
+!-------------------------------------------------------------------------------
+
  if (trim(input_type) == "restart") then
+
    call read_input_sfc_restart_file(localpet)
- elseif (trim(input_type) == "history") then
-   call read_input_sfc_history_file(localpet)
- elseif (trim(input_type) == "gaussian") then
-   call read_input_sfc_gaussian_file(localpet)
- elseif (trim(input_type) == "gfs_gaussian") then
-   call read_input_sfc_gfs_gaussian_file(localpet)
- elseif (trim(input_type) == "gfs_spectral") then
-   call read_input_sfc_gfs_sfcio_file(localpet)
- elseif (trim(input_type) == "grib2") then
-   call read_input_sfc_grib2_file(localpet)
- endif
 
- end subroutine read_input_sfc_data
+!-------------------------------------------------------------------------------
+! Read the tiled or gaussian history files in netcdf format.
+!-------------------------------------------------------------------------------
 
-!---------------------------------------------------------------------------
-! Read input atmospheric data from spectral gfs (old sigio format).
-! Used prior to July 19, 2017.
-!---------------------------------------------------------------------------
+ elseif (trim(input_type) == "history" .or. trim(input_type) ==  &
+         "gaussian_netcdf") then
 
- subroutine read_input_atm_gfs_spectral_file(localpet)
+   call read_input_sfc_netcdf_file(localpet)
 
- use sigio_module
+!-------------------------------------------------------------------------------
+! Read the gaussian history files in nemsio format.
+!-------------------------------------------------------------------------------
 
- implicit none
+ elseif (trim(input_type) == "gaussian_nemsio") then
 
- integer, intent(in)                   :: localpet
+   call read_input_sfc_gaussian_nemsio_file(localpet)
 
- character(len=300)                    :: the_file
+!-------------------------------------------------------------------------------
+! Read the spectral gfs gaussian history files in nemsio format.
+!-------------------------------------------------------------------------------
 
- integer(sigio_intkind)                :: iret
- integer                               :: rc, i, j, k
- integer                               :: clb(3), cub(3)
+ elseif (trim(input_type) == "gfs_gaussian_nemsio") then
 
- real(esmf_kind_r8)                    :: ak, bk
- real(esmf_kind_r8), allocatable       :: dummy2d(:,:)
- real(esmf_kind_r8), allocatable       :: dummy3d(:,:,:)
- real(esmf_kind_r8), allocatable       :: dummy3d2(:,:,:)
- real(esmf_kind_r8), pointer           :: pptr(:,:,:), psptr(:,:)
- real(esmf_kind_r8), allocatable       :: pi(:,:,:)
+   call read_input_sfc_gfs_gaussian_nemsio_file(localpet)
 
- type(sigio_head)                      :: sighead
- type(sigio_dbta)                      :: sigdata
+!-------------------------------------------------------------------------------
+! Read the spectral gfs gaussian history files in sfcio format.
+!-------------------------------------------------------------------------------
 
- the_file = trim(data_dir_input_grid) // "/" // trim(atm_files_input_grid(1))
+ elseif (trim(input_type) == "gfs_sigio") then
 
- print*,"- ATMOSPHERIC DATA IN SIGIO FORMAT."
- print*,"- OPEN AND READ: ", trim(the_file)
+   call read_input_sfc_gfs_sfcio_file(localpet)
 
- call sigio_sropen(21, trim(the_file), iret)
- if (iret /= 0) then
-   rc = iret
-   call error_handler("OPENING SPECTRAL GFS SIGIO FILE.", rc)
- endif
- call sigio_srhead(21, sighead, iret)
- if (iret /= 0) then
-   rc = iret
-   call error_handler("READING SPECTRAL GFS SIGIO FILE.", rc)
- endif
+!-------------------------------------------------------------------------------
+! Read fv3gfs surface data in grib2 format.
+!-------------------------------------------------------------------------------
 
- lev_input = sighead%levs
- levp1_input = lev_input + 1
+ elseif (trim(input_type) == "grib2") then
 
- if (num_tracers /= sighead%ntrac) then
-   call error_handler("WRONG NUMBER OF TRACERS EXPECTED.", 99)
- endif
+   call read_input_sfc_grib2_file(localpet)
 
- if (sighead%idvt == 0 .or. sighead%idvt == 21) then
-   if (trim(tracers_input(1)) /= 'spfh'  .or.  &
-       trim(tracers_input(2)) /= 'o3mr'   .or.  &
-       trim(tracers_input(3)) /= 'clwmr') then 
-     call error_handler("TRACERS SELECTED DO NOT MATCH FILE CONTENTS.", 99)
-   endif
- else
-   print*,'- UNRECOGNIZED IDVT: ', sighead%idvt
-   call error_handler("UNRECOGNIZED IDVT", 99)
  endif
 
+ end subroutine read_input_sfc_data
+
+!---------------------------------------------------------------------------
+! Create atmospheric esmf fields.
+!---------------------------------------------------------------------------
+
+ subroutine init_atm_esmf_fields
+ 
+ implicit none
+
+ integer                                  :: i, rc
+
+ print*,"- INITIALIZE ATMOSPHERIC ESMF FIELDS."
+
+ print*,"- CALL FieldCreate FOR INPUT GRID 3-D WIND."
+ wind_input_grid = ESMF_FieldCreate(input_grid, &
+                                   typekind=ESMF_TYPEKIND_R8, &
+                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
+                                   ungriddedLBound=(/1,1/), &
+                                   ungriddedUBound=(/lev_input,3/), rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldCreate", rc)
+
  print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
  ps_input_grid = ESMF_FieldCreate(input_grid, &
                                   typekind=ESMF_TYPEKIND_R8, &
@@ -668,6 +720,86 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldCreate", rc)
 
+ print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
+ pres_input_grid = ESMF_FieldCreate(input_grid, &
+                                   typekind=ESMF_TYPEKIND_R8, &
+                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
+                                   ungriddedLBound=(/1/), &
+                                   ungriddedUBound=(/lev_input/), rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldCreate", rc)
+ 
+ end subroutine init_atm_esmf_fields
+
+!---------------------------------------------------------------------------
+! Read input atmospheric data from spectral gfs (old sigio format).
+! Used prior to July 19, 2017.
+!---------------------------------------------------------------------------
+
+ subroutine read_input_atm_gfs_sigio_file(localpet)
+
+ use sigio_module
+
+ implicit none
+
+ integer, intent(in)                   :: localpet
+
+ character(len=300)                    :: the_file
+
+ integer(sigio_intkind)                :: iret
+ integer                               :: rc, i, j, k
+ integer                               :: clb(3), cub(3)
+
+ real(esmf_kind_r8)                    :: ak, bk
+ real(esmf_kind_r8), allocatable       :: dummy2d(:,:)
+ real(esmf_kind_r8), allocatable       :: dummy3d(:,:,:)
+ real(esmf_kind_r8), allocatable       :: dummy3d2(:,:,:)
+ real(esmf_kind_r8), pointer           :: pptr(:,:,:), psptr(:,:)
+ real(esmf_kind_r8), allocatable       :: pi(:,:,:)
+
+ type(sigio_head)                      :: sighead
+ type(sigio_dbta)                      :: sigdata
+
+ the_file = trim(data_dir_input_grid) // "/" // trim(atm_files_input_grid(1))
+
+ print*,"- ATMOSPHERIC DATA IN SIGIO FORMAT."
+ print*,"- OPEN AND READ: ", trim(the_file)
+
+ call sigio_sropen(21, trim(the_file), iret)
+ if (iret /= 0) then
+   rc = iret
+   call error_handler("OPENING SPECTRAL GFS SIGIO FILE.", rc)
+ endif
+ call sigio_srhead(21, sighead, iret)
+ if (iret /= 0) then
+   rc = iret
+   call error_handler("READING SPECTRAL GFS SIGIO FILE.", rc)
+ endif
+
+ lev_input = sighead%levs
+ levp1_input = lev_input + 1
+
+ if (num_tracers /= sighead%ntrac) then
+   call error_handler("WRONG NUMBER OF TRACERS EXPECTED.", 99)
+ endif
+
+ if (sighead%idvt == 0 .or. sighead%idvt == 21) then
+   if (trim(tracers_input(1)) /= 'spfh'  .or.  &
+       trim(tracers_input(2)) /= 'o3mr'   .or.  &
+       trim(tracers_input(3)) /= 'clwmr') then 
+     call error_handler("TRACERS SELECTED DO NOT MATCH FILE CONTENTS.", 99)
+   endif
+ else
+   print*,'- UNRECOGNIZED IDVT: ', sighead%idvt
+   call error_handler("UNRECOGNIZED IDVT", 99)
+ endif
+
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
+
+ call init_atm_esmf_fields
+
  if (localpet == 0) then
    allocate(dummy2d(i_input,j_input))
    allocate(dummy3d(i_input,j_input,lev_input))
@@ -782,14 +914,6 @@
 
  print*,"- COMPUTE 3-D PRESSURE."
 
- print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-
  print*,"- CALL FieldGet FOR 3-D PRES."
  nullify(pptr)
  call ESMF_FieldGet(pres_input_grid, &
@@ -844,14 +968,14 @@
    print*,'pres ',psptr(clb(1),clb(2)),pptr(clb(1),clb(2),:)
  endif
 
- end subroutine read_input_atm_gfs_spectral_file
+ end subroutine read_input_atm_gfs_sigio_file
 
 !---------------------------------------------------------------------------
 ! Read input atmospheric data from spectral gfs (global gaussian in
 ! nemsio format. Starting July 19, 2017).  
 !---------------------------------------------------------------------------
 
- subroutine read_input_atm_gfs_gaussian_file(localpet)
+ subroutine read_input_atm_gfs_gaussian_nemsio_file(localpet)
 
  implicit none
 
@@ -894,68 +1018,11 @@
  call nemsio_getfilehead(gfile, iret=iret, vcoord=vcoord)
  if (iret /= 0) call error_handler("READING VERTICAL COORDINATE INFO.", iret)
 
- print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
- ps_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID TEMPERATURE."
- temp_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- allocate(tracers_input_grid(num_tracers))
-
- do i = 1, num_tracers
-   print*,"- CALL FieldCreate FOR INPUT GRID TRACER ", trim(tracers_input(i))
-   tracers_input_grid(i) = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
-   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-     call error_handler("IN FieldCreate", rc)
- enddo
-
- print*,"- CALL FieldCreate FOR INPUT GRID U."
- u_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID V."
- v_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID DZDT."
- dzdt_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID TERRAIN."
- terrain_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+ call init_atm_esmf_fields
 
  if (localpet == 0) then
    allocate(dummy(i_input*j_input))
@@ -1107,14 +1174,6 @@
 
  print*,"- COMPUTE 3-D PRESSURE."
 
- print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-
  print*,"- CALL FieldGet FOR 3-D PRES."
  nullify(pptr)
  call ESMF_FieldGet(pres_input_grid, &
@@ -1163,13 +1222,13 @@
 
  deallocate(pi)
 
- end subroutine read_input_atm_gfs_gaussian_file
+ end subroutine read_input_atm_gfs_gaussian_nemsio_file
 
 !---------------------------------------------------------------------------
-! Read input grid atmospheric fv3 gaussian history files (nemsio format).
+! Read input grid atmospheric fv3 gaussian nemsio files.
 !---------------------------------------------------------------------------
 
- subroutine read_input_atm_gaussian_file(localpet)
+ subroutine read_input_atm_gaussian_nemsio_file(localpet)
 
  implicit none
 
@@ -1212,52 +1271,11 @@
  call nemsio_getfilehead(gfile, iret=iret, vcoord=vcoord)
  if (iret /= 0) call error_handler("READING VERTICAL COORDINATE INFO.", iret)
 
- print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
- ps_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID TEMPERATURE."
- temp_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- allocate(tracers_input_grid(num_tracers))
-
- do i = 1, num_tracers
-   print*,"- CALL FieldCreate FOR INPUT GRID TRACER ", trim(tracers_input(i))
-   tracers_input_grid(i) = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
-   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-     call error_handler("IN FieldCreate", rc)
- enddo
-
- print*,"- CALL FieldCreate FOR INPUT GRID U."
- u_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID V."
- v_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+ call init_atm_esmf_fields
 
  print*,"- CALL FieldCreate FOR INPUT DPRES."
  dpres_input_grid = ESMF_FieldCreate(input_grid, &
@@ -1268,22 +1286,6 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldCreate", rc)
 
- print*,"- CALL FieldCreate FOR INPUT GRID DZDT."
- dzdt_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID TERRAIN."
- terrain_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  if (localpet == 0) then
    allocate(dummy(i_input*j_input))
    allocate(dummy2d(i_input,j_input))
@@ -1441,15 +1443,6 @@
 
  print*,"- COMPUTE 3-D PRESSURE."
 
- print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  print*,"- CALL FieldGet FOR DELTA PRESSURE."
  nullify(dpresptr)
  call ESMF_FieldGet(dpres_input_grid, &
@@ -1508,10 +1501,10 @@
 
  call ESMF_FieldDestroy(dpres_input_grid, rc=rc)
 
- end subroutine read_input_atm_gaussian_file
+ end subroutine read_input_atm_gaussian_nemsio_file
 
 !---------------------------------------------------------------------------
-! Read input grid fv3 atmospheric data restart files.
+! Read input grid fv3 atmospheric data 'warm' restart files.
 !
 ! Routine reads tiled files in parallel.  Tile 1 is read by 
 ! localpet 0; tile 2 by localpet 1, etc.  The number of pets
@@ -1564,41 +1557,11 @@
 
  error = nf90_close(ncid)
 
- print*,"- CALL FieldCreate FOR INPUT GRID U."
- u_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID V."
- v_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID DZDT."
- dzdt_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID TEMPERATURE."
- temp_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+ call init_atm_esmf_fields
 
  print*,"- CALL FieldCreate FOR INPUT GRID DELTA PRESSURE."
  dpres_input_grid = ESMF_FieldCreate(input_grid, &
@@ -1609,28 +1572,6 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldCreate", rc)
 
- print*,"- CALL FieldCreate FOR INPUT GRID TERRAIN."
- terrain_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- allocate(tracers_input_grid(num_tracers))
-
- do i = 1, num_tracers
-
-   print*,"- CALL FieldCreate FOR INPUT GRID TRACER ", trim(tracers_input(i))
-   tracers_input_grid(i) = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
-   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-     call error_handler("IN FieldCreate", rc)
-
- enddo
-
  if (localpet < num_tiles_input_grid) then
    allocate(data_one_tile_3d(i_input,j_input,lev_input))
    allocate(data_one_tile(i_input,j_input))
@@ -1738,38 +1679,408 @@
    call ESMF_FieldScatter(v_input_grid, data_one_tile_3d, rootpet=tile-1, tile=tile, rc=rc)
    if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
       call error_handler("IN FieldScatter", rc)
- enddo
+ enddo
+
+ if (localpet < num_tiles_input_grid)  error = nf90_close(ncid)
+
+ if (localpet < num_tiles_input_grid) then
+   tile = localpet+1
+   tilefile= trim(data_dir_input_grid) // "/" // trim(atm_tracer_files_input_grid(tile))
+   print*,"- READ ATMOSPHERIC TRACER FILE: ", trim(tilefile)
+   error=nf90_open(trim(tilefile),nf90_nowrite,ncid)
+   call netcdf_err(error, 'opening: '//trim(tilefile) )
+ endif
+
+ do i = 1, num_tracers
+
+   if (localpet < num_tiles_input_grid) then
+     error=nf90_inq_varid(ncid, tracers_input(i), id_var)
+     call netcdf_err(error, 'reading field id' )
+     error=nf90_get_var(ncid, id_var, data_one_tile_3d)
+     call netcdf_err(error, 'reading field' )
+     data_one_tile_3d(:,:,1:lev_input) = data_one_tile_3d(:,:,lev_input:1:-1)
+   endif
+
+   do tile = 1, num_tiles_input_grid
+     print*,"- CALL FieldScatter FOR INPUT ", trim(tracers_input(i))
+     call ESMF_FieldScatter(tracers_input_grid(i), data_one_tile_3d, rootpet=tile-1, tile=tile, rc=rc)
+     if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldScatter", rc)
+   enddo
+
+ enddo
+
+ if (localpet < num_tiles_input_grid) error=nf90_close(ncid)
+
+!---------------------------------------------------------------------------
+! Convert from 2-d to 3-d cartesian winds.
+!---------------------------------------------------------------------------
+
+ call convert_winds
+
+!---------------------------------------------------------------------------
+! Compute pressures
+!---------------------------------------------------------------------------
+
+ print*,"- CALL FieldGet FOR SURFACE PRESSURE."
+ call ESMF_FieldGet(ps_input_grid, &
+                    farrayPtr=psptr, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldGet", rc)
+
+ print*,"- CALL FieldGet FOR PRESSURE."
+ call ESMF_FieldGet(pres_input_grid, &
+                    computationalLBound=clb, &
+                    computationalUBound=cub, &
+                    farrayPtr=presptr, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldGet", rc)
+
+ print*,"- CALL FieldGet FOR DELTA PRESSURE."
+ call ESMF_FieldGet(dpres_input_grid, &
+                    farrayPtr=dpresptr, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldGet", rc)
+
+ allocate(pres_interface(levp1_input))
+
+ do i = clb(1), cub(1)
+   do j = clb(2), cub(2)
+     pres_interface(levp1_input) = ak(1)  ! model top in Pa
+     do k = (levp1_input-1), 1, -1
+       pres_interface(k) = pres_interface(k+1) + dpresptr(i,j,k)
+     enddo
+     do k = 1, lev_input
+       presptr(i,j,k) = (pres_interface(k) + pres_interface(k+1)) / 2.0_8
+     enddo
+     psptr(i,j) = pres_interface(1)
+   enddo
+ enddo
+
+ deallocate(ak)
+ deallocate(pres_interface)
+
+ call ESMF_FieldDestroy(dpres_input_grid, rc=rc)
+
+ deallocate(data_one_tile_3d, data_one_tile)
+
+ end subroutine read_input_atm_restart_file
+
+!---------------------------------------------------------------------------
+! Read fv3 netcdf gaussian history file.  Each task reads a horizontal
+! slice.
+!---------------------------------------------------------------------------
+
+ subroutine read_input_atm_gaussian_netcdf_file(localpet)
+
+ implicit none
+
+ include 'mpif.h'
+
+ integer, intent(in)               :: localpet
+
+ character(len=500)                :: tilefile
+
+ integer                           :: start(3), count(3), iscnt
+ integer                           :: error, ncid, num_tracers_file
+ integer                           :: id_dim, idim_input, jdim_input
+ integer                           :: id_var, rc, nprocs, max_procs
+ integer                           :: kdim, remainder, myrank, i, j, k, n
+ integer                           :: clb(3), cub(3)
+ integer, allocatable              :: kcount(:), startk(:), displ(:)
+ integer, allocatable              :: ircnt(:)
+
+ real(esmf_kind_r8), allocatable   :: phalf(:)
+ real(esmf_kind_r8), allocatable   :: pres_interface(:)
+ real(kind=4), allocatable         :: dummy3d(:,:,:)
+ real(kind=4), allocatable         :: dummy3dall(:,:,:)
+ real(esmf_kind_r8), allocatable   :: dummy3dflip(:,:,:)
+ real(esmf_kind_r8), allocatable   :: dummy(:,:)
+ real(esmf_kind_r8), pointer       :: presptr(:,:,:), dpresptr(:,:,:)
+ real(esmf_kind_r8), pointer       :: psptr(:,:)
+
+ print*,"- READ INPUT ATMOS DATA FROM GAUSSIAN NETCDF FILE."
+
+ tilefile = trim(data_dir_input_grid) // "/" // trim(atm_files_input_grid(1))
+ error=nf90_open(trim(tilefile),nf90_nowrite,ncid)
+ call netcdf_err(error, 'opening: '//trim(tilefile) )
+
+ error=nf90_inq_dimid(ncid, 'grid_xt', id_dim)
+ call netcdf_err(error, 'reading grid_xt id' )
+ error=nf90_inquire_dimension(ncid,id_dim,len=idim_input)
+ call netcdf_err(error, 'reading grid_xt value' )
+
+ error=nf90_inq_dimid(ncid, 'grid_yt', id_dim)
+ call netcdf_err(error, 'reading grid_yt id' )
+ error=nf90_inquire_dimension(ncid,id_dim,len=jdim_input)
+ call netcdf_err(error, 'reading grid_yt value' )
+
+ if (idim_input /= i_input .or. jdim_input /= j_input) then
+   call error_handler("DIMENSION MISMATCH BETWEEN SFC AND OROG FILES.", 2)
+ endif
+
+ error=nf90_inq_dimid(ncid, 'pfull', id_dim)
+ call netcdf_err(error, 'reading pfull id' )
+ error=nf90_inquire_dimension(ncid,id_dim,len=lev_input)
+ call netcdf_err(error, 'reading pfull value' )
+
+ error=nf90_inq_dimid(ncid, 'phalf', id_dim)
+ call netcdf_err(error, 'reading phalf id' )
+ error=nf90_inquire_dimension(ncid,id_dim,len=levp1_input)
+ call netcdf_err(error, 'reading phalf value' )
+ allocate(phalf(levp1_input))
+ error=nf90_inq_varid(ncid, 'phalf', id_var)
+ call netcdf_err(error, 'getting phalf varid' )
+ error=nf90_get_var(ncid, id_var, phalf)
+ call netcdf_err(error, 'reading phalf varid' )
+
+ error=nf90_get_att(ncid, nf90_global, 'ncnsto', num_tracers_file)
+ call netcdf_err(error, 'reading ntracer value' )
+
+ call mpi_comm_size(mpi_comm_world, nprocs, error)
+ print*,'- Running with ', nprocs, ' processors'
+
+ call mpi_comm_rank(mpi_comm_world, myrank, error)
+ print*,'- myrank/localpet is ',myrank,localpet
+
+ max_procs = nprocs
+ if (nprocs > lev_input) then
+   max_procs = lev_input
+ endif
+
+ kdim = lev_input / max_procs
+ remainder = lev_input - (max_procs*kdim)
+
+ allocate(kcount(0:nprocs-1))
+ kcount=0
+ allocate(startk(0:nprocs-1))
+ startk=0
+ allocate(displ(0:nprocs-1))
+ displ=0
+ allocate(ircnt(0:nprocs-1))
+ ircnt=0
+
+ do k = 0, max_procs-2
+   kcount(k) = kdim
+ enddo
+ kcount(max_procs-1) = kdim + remainder
+
+ startk(0) = 1
+ do k = 1, max_procs-1
+   startk(k) = startk(k-1) + kcount(k-1)
+ enddo
+
+ ircnt(:) = idim_input * jdim_input * kcount(:)
+
+ displ(0) = 0
+ do k = 1, max_procs-1
+   displ(k) = displ(k-1) + ircnt(k-1)
+ enddo
+
+ iscnt=idim_input*jdim_input*kcount(myrank)
+
+! Account for case if number of tasks exceeds the number of vert levels.
+
+ if (myrank <= max_procs-1) then
+   allocate(dummy3d(idim_input,jdim_input,kcount(myrank)))
+ else
+   allocate(dummy3d(0,0,0))
+ endif
+
+ if (myrank == 0) then
+  allocate(dummy3dall(idim_input,jdim_input,lev_input))
+  dummy3dall = 0.0
+  allocate(dummy3dflip(idim_input,jdim_input,lev_input))
+  dummy3dflip = 0.0
+  allocate(dummy(idim_input,jdim_input))
+  dummy = 0.0
+ else
+  allocate(dummy3dall(0,0,0))
+  allocate(dummy3dflip(0,0,0))
+  allocate(dummy(0,0))
+ endif
+
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
+
+ call init_atm_esmf_fields
+
+ print*,"- CALL FieldCreate FOR INPUT GRID DELTA PRESSURE."
+ dpres_input_grid = ESMF_FieldCreate(input_grid, &
+                                   typekind=ESMF_TYPEKIND_R8, &
+                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
+                                   ungriddedLBound=(/1/), &
+                                   ungriddedUBound=(/lev_input/), rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldCreate", rc)
+
+! Temperature 
+
+ if (myrank <= max_procs-1) then
+   start = (/1,1,startk(myrank)/)
+   count = (/idim_input,jdim_input,kcount(myrank)/)
+   error=nf90_inq_varid(ncid, 'tmp', id_var)
+   call netcdf_err(error, 'reading tmp field id' )
+   error=nf90_get_var(ncid, id_var, dummy3d, start=start, count=count)
+   call netcdf_err(error, 'reading tmp field' )
+ endif
+
+ call mpi_gatherv(dummy3d, iscnt, mpi_real, &
+                  dummy3dall, ircnt, displ, mpi_real, &
+                  0, mpi_comm_world, error)
+ if (error /= 0) call error_handler("IN mpi_gatherv of temperature", error)
+
+ if (myrank == 0) then
+   dummy3dflip(:,:,1:lev_input) = dummy3dall(:,:,lev_input:1:-1)
+ endif
+   
+ print*,"- CALL FieldScatter FOR INPUT GRID TEMPERATURE "
+ call ESMF_FieldScatter(temp_input_grid, dummy3dflip, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
+
+! dpres
+
+ if (myrank <= max_procs-1) then
+   error=nf90_inq_varid(ncid, 'dpres', id_var)
+   call netcdf_err(error, 'reading dpres field id' )
+   error=nf90_get_var(ncid, id_var, dummy3d, start=start, count=count)
+   call netcdf_err(error, 'reading dpres field' )
+ endif
+
+ call mpi_gatherv(dummy3d, iscnt, mpi_real, &
+                  dummy3dall, ircnt, displ, mpi_real, &
+                  0, mpi_comm_world, error)
+ if (error /= 0) call error_handler("IN mpi_gatherv of dpres", error)
+
+ if (myrank == 0) then
+   dummy3dflip(:,:,1:lev_input) = dummy3dall(:,:,lev_input:1:-1)
+ endif
+
+ print*,"- CALL FieldScatter FOR INPUT GRID DPRES "
+ call ESMF_FieldScatter(dpres_input_grid, dummy3dflip, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
+
+! ugrd
+
+ if (myrank <= max_procs-1) then
+   error=nf90_inq_varid(ncid, 'ugrd', id_var)
+   call netcdf_err(error, 'reading ugrd field id' )
+   error=nf90_get_var(ncid, id_var, dummy3d, start=start, count=count)
+   call netcdf_err(error, 'reading ugrd field' )
+ endif
+
+ call mpi_gatherv(dummy3d, iscnt, mpi_real, &
+                  dummy3dall, ircnt, displ, mpi_real, &
+                  0, mpi_comm_world, error)
+ if (error /= 0) call error_handler("IN mpi_gatherv of ugrd", error)
+
+ if (myrank == 0) then
+   dummy3dflip(:,:,1:lev_input) = dummy3dall(:,:,lev_input:1:-1)
+ endif
+
+ print*,"- CALL FieldScatter FOR INPUT GRID UGRD "
+ call ESMF_FieldScatter(u_input_grid, dummy3dflip, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldScatter", rc)
+
+! vgrd
+
+ if (myrank <= max_procs-1) then
+   error=nf90_inq_varid(ncid, 'vgrd', id_var)
+   call netcdf_err(error, 'reading vgrd field id' )
+   error=nf90_get_var(ncid, id_var, dummy3d, start=start, count=count)
+   call netcdf_err(error, 'reading vgrd field' )
+ endif
+
+ call mpi_gatherv(dummy3d, iscnt, mpi_real, &
+                  dummy3dall, ircnt, displ, mpi_real, &
+                  0, mpi_comm_world, error)
+ if (error /= 0) call error_handler("IN mpi_gatherv of vgrd", error)
+
+ if (myrank == 0) then
+   dummy3dflip(:,:,1:lev_input) = dummy3dall(:,:,lev_input:1:-1)
+ endif
+
+ print*,"- CALL FieldScatter FOR INPUT GRID VGRD "
+ call ESMF_FieldScatter(v_input_grid, dummy3dflip, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldScatter", rc)
+
+! tracers
+
+ do n = 1, num_tracers
+
+   if (myrank <= max_procs-1) then
+     error=nf90_inq_varid(ncid, tracers_input(n), id_var)
+     call netcdf_err(error, 'reading tracer field id' )
+     error=nf90_get_var(ncid, id_var, dummy3d, start=start, count=count)
+     call netcdf_err(error, 'reading tracer field' )
+   endif
+
+   call mpi_gatherv(dummy3d, iscnt, mpi_real, &
+                    dummy3dall, ircnt, displ, mpi_real, &
+                    0, mpi_comm_world, error)
+   if (error /= 0) call error_handler("IN mpi_gatherv of tracer", error)
+
+   if (myrank == 0) then
+     dummy3dflip(:,:,1:lev_input) = dummy3dall(:,:,lev_input:1:-1)
+     where(dummy3dflip < 0.0) dummy3dflip = 0.0
+   endif
+
+   print*,"- CALL FieldScatter FOR INPUT GRID ", tracers_input(n)
+   call ESMF_FieldScatter(tracers_input_grid(n), dummy3dflip, rootpet=0, rc=rc)
+   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldScatter", rc)
+
+ enddo
+
+! dzdt   set to zero for now.
+
+ if (myrank == 0) then
+   dummy3dflip = 0.0
+ endif
+
+ print*,"- CALL FieldScatter FOR INPUT GRID DZDT"
+ call ESMF_FieldScatter(dzdt_input_grid, dummy3dflip, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
+ 
+ deallocate(dummy3dflip, dummy3dall, dummy3d)
 
- if (localpet < num_tiles_input_grid)  error = nf90_close(ncid)
+! terrain 
 
- if (localpet < num_tiles_input_grid) then
-   tile = localpet+1
-   tilefile= trim(data_dir_input_grid) // "/" // trim(atm_tracer_files_input_grid(tile))
-   print*,"- READ ATMOSPHERIC TRACER FILE: ", trim(tilefile)
-   error=nf90_open(trim(tilefile),nf90_nowrite,ncid)
-   call netcdf_err(error, 'opening: '//trim(tilefile) )
+ if (myrank==0) then
+   print*,"- READ TERRAIN."
+   error=nf90_inq_varid(ncid, 'hgtsfc', id_var)
+   call netcdf_err(error, 'reading hgtsfc field id' )
+   error=nf90_get_var(ncid, id_var, dummy)
+   call netcdf_err(error, 'reading hgtsfc field' )
  endif
 
- do i = 1, num_tracers
+ print*,"- CALL FieldScatter FOR INPUT GRID TERRAIN."
+ call ESMF_FieldScatter(terrain_input_grid, dummy, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
 
-   if (localpet < num_tiles_input_grid) then
-     error=nf90_inq_varid(ncid, tracers_input(i), id_var)
-     call netcdf_err(error, 'reading field id' )
-     error=nf90_get_var(ncid, id_var, data_one_tile_3d)
-     call netcdf_err(error, 'reading field' )
-     data_one_tile_3d(:,:,1:lev_input) = data_one_tile_3d(:,:,lev_input:1:-1)
-   endif
+! surface pressure
 
-   do tile = 1, num_tiles_input_grid
-     print*,"- CALL FieldScatter FOR INPUT ", trim(tracers_input(i))
-     call ESMF_FieldScatter(tracers_input_grid(i), data_one_tile_3d, rootpet=tile-1, tile=tile, rc=rc)
-     if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-        call error_handler("IN FieldScatter", rc)
-   enddo
+ if (myrank==0) then
+   print*,"- READ SURFACE P."
+   error=nf90_inq_varid(ncid, 'pressfc', id_var)
+   call netcdf_err(error, 'reading pressfc field id' )
+   error=nf90_get_var(ncid, id_var, dummy)
+   call netcdf_err(error, 'reading pressfc field' )
+ endif
 
- enddo
+ print*,"- CALL FieldScatter FOR INPUT GRID SURFACE P."
+ call ESMF_FieldScatter(ps_input_grid, dummy, rootpet=0, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
 
- if (localpet < num_tiles_input_grid) error=nf90_close(ncid)
+ deallocate(kcount, startk, displ, ircnt, dummy)
 
 !---------------------------------------------------------------------------
 ! Convert from 2-d to 3-d cartesian winds.
@@ -1778,31 +2089,9 @@
  call convert_winds
 
 !---------------------------------------------------------------------------
-! Compute pressures
+! Compute pressure.
 !---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
- ps_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldGet FOR SURFACE PRESSURE."
- call ESMF_FieldGet(ps_input_grid, &
-                    farrayPtr=psptr, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldGet", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  print*,"- CALL FieldGet FOR PRESSURE."
  call ESMF_FieldGet(pres_input_grid, &
                     computationalLBound=clb, &
@@ -1817,40 +2106,55 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldGet", rc)
 
+ print*,"- CALL FieldGet FOR SURFACE PRESSURE."
+ call ESMF_FieldGet(ps_input_grid, &
+                    farrayPtr=psptr, rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldGet", rc)
+
  allocate(pres_interface(levp1_input))
 
+!---------------------------------------------------------------------------
+! Compute 3-d pressure.
+!---------------------------------------------------------------------------
+
+!---------------------------------------------------------------------------
+!  When ingesting gaussian netcdf files, the mid-layer
+!  surface pressure are computed top down from delta-p
+!  The surface pressure in the file is not used.  According
+!  to Jun Wang, after the model's write component interpolates from the
+!  cubed-sphere grid to the gaussian grid, the surface pressure is
+!  no longer consistent with the delta p.
+!---------------------------------------------------------------------------
+
  do i = clb(1), cub(1)
    do j = clb(2), cub(2)
-     pres_interface(levp1_input) = ak(1)  ! model top in Pa
-     do k = (levp1_input-1), 1, -1
+     pres_interface(levp1_input) = phalf(1) * 100.0_8
+     do k = lev_input, 1, -1
        pres_interface(k) = pres_interface(k+1) + dpresptr(i,j,k)
      enddo
+     psptr(i,j) = pres_interface(1)
      do k = 1, lev_input
        presptr(i,j,k) = (pres_interface(k) + pres_interface(k+1)) / 2.0_8
      enddo
-     psptr(i,j) = pres_interface(1)
    enddo
  enddo
 
- deallocate(ak)
- deallocate(pres_interface)
+ deallocate(pres_interface, phalf)
 
  call ESMF_FieldDestroy(dpres_input_grid, rc=rc)
 
- deallocate(data_one_tile_3d, data_one_tile)
-
- end subroutine read_input_atm_restart_file
+ end subroutine read_input_atm_gaussian_netcdf_file
 
 !---------------------------------------------------------------------------
-! Read input grid fv3 atmospheric history files.
+! Read input grid fv3 atmospheric tiled history files in netcdf format.
 !
 ! Routine reads tiled files in parallel.  Tile 1 is read by 
 ! localpet 0; tile 2 by localpet 1, etc.  The number of pets
 ! must be equal to or greater than the number of tiled files.  
-! Logic only tested with global input data of six tiles.
 !---------------------------------------------------------------------------
 
- subroutine read_input_atm_history_file(localpet)
+ subroutine read_input_atm_tiled_history_file(localpet)
 
  implicit none
 
@@ -1869,7 +2173,7 @@
  real(esmf_kind_r8), allocatable :: data_one_tile_3d(:,:,:)
  real(esmf_kind_r8), pointer     :: presptr(:,:,:), dpresptr(:,:,:)
  real(esmf_kind_r8), pointer     :: psptr(:,:)
- real(esmf_kind_r8), allocatable :: pres_interface(:)
+ real(esmf_kind_r8), allocatable :: pres_interface(:), phalf(:)
 
  print*,"- READ INPUT ATMOS DATA FROM TILED HISTORY FILES."
 
@@ -1900,6 +2204,11 @@
  call netcdf_err(error, 'reading phalf id' )
  error=nf90_inquire_dimension(ncid,id_dim,len=levp1_input)
  call netcdf_err(error, 'reading phalf value' )
+ allocate(phalf(levp1_input))
+ error=nf90_inq_varid(ncid, 'phalf', id_var)
+ call netcdf_err(error, 'getting phalf varid' )
+ error=nf90_get_var(ncid, id_var, phalf)
+ call netcdf_err(error, 'reading phalf varid' )
 
  error=nf90_get_att(ncid, nf90_global, 'ncnsto', num_tracers_file)
  call netcdf_err(error, 'reading ntracer value' )
@@ -1909,29 +2218,11 @@
  print*,'- FILE HAS ', num_tracers_file, ' TRACERS.'
  print*,'- WILL PROCESS ', num_tracers, ' TRACERS.'
 
- allocate(tracers_input_grid(num_tracers))
-
- do i = 1, num_tracers
-
-   print*,"- CALL FieldCreate FOR INPUT GRID TRACER ", trim(tracers_input(i))
-   tracers_input_grid(i) = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
-   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-     call error_handler("IN FieldCreate", rc)
-
- enddo
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID DZDT."
- dzdt_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+ call init_atm_esmf_fields
 
  print*,"- CALL FieldCreate FOR INPUT GRID DELTA PRESSURE."
  dpres_input_grid = ESMF_FieldCreate(input_grid, &
@@ -1942,47 +2233,6 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldCreate", rc)
 
- print*,"- CALL FieldCreate FOR INPUT GRID TEMPERATURE."
- temp_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID U."
- u_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID V."
- v_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
- ps_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- print*,"- CALL FieldCreate FOR INPUT GRID TERRAIN."
- terrain_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  if (localpet < num_tiles_input_grid) then
    allocate(data_one_tile(i_input,j_input))
    allocate(data_one_tile_3d(i_input,j_input,lev_input))
@@ -2147,15 +2397,6 @@
 ! Compute pressure.
 !---------------------------------------------------------------------------
 
- print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  print*,"- CALL FieldGet FOR PRESSURE."
  call ESMF_FieldGet(pres_input_grid, &
                     computationalLBound=clb, &
@@ -2178,9 +2419,9 @@
 
  allocate(pres_interface(levp1_input))
 
- if (localpet == 0) then
-   print*,'dpres is ',dpresptr(1,1,:)
- endif
+!---------------------------------------------------------------------------
+! Compute 3-d pressure.
+!---------------------------------------------------------------------------
 
  do i = clb(1), cub(1)
    do j = clb(2), cub(2)
@@ -2194,18 +2435,14 @@
    enddo
  enddo
 
- if (localpet == 0) then
-   print*,'pres is ',presptr(1,1,:)
- endif
-
- deallocate(pres_interface)
+ deallocate(pres_interface, phalf)
 
  call ESMF_FieldDestroy(dpres_input_grid, rc=rc)
 
- end subroutine read_input_atm_history_file
+ end subroutine read_input_atm_tiled_history_file
  
 !---------------------------------------------------------------------------
-! Read input grid atmospheric grib2 files.
+! Read input grid atmospheric fv3gfs grib2 files.
 !---------------------------------------------------------------------------
 
  subroutine read_input_atm_grib2_file(localpet)
@@ -2401,69 +2638,11 @@
 
  if (localpet==0) print*, "- NUMBER OF TRACERS IN FILE = ", num_tracers
 
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID SURFACE PRESSURE."
- ps_input_grid = ESMF_FieldCreate(input_grid, &
-                                  typekind=ESMF_TYPEKIND_R8, &
-                                  staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID TEMPERATURE."
- temp_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- allocate(tracers_input_grid(num_tracers))
-
- do i = 1,num_tracers
-   if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID TRACER ", trim(tracers_input(i))
-
-   tracers_input_grid(i) = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
-   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-     call error_handler("IN FieldCreate", rc)
- enddo
-
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID U."
- u_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID V."
- v_input_grid = ESMF_FieldCreate(input_grid, &
-                                 typekind=ESMF_TYPEKIND_R8, &
-                                 staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                 ungriddedLBound=(/1/), &
-                                 ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-    
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID DZDT."
- dzdt_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+!---------------------------------------------------------------------------
+! Initialize esmf atmospheric fields.
+!---------------------------------------------------------------------------
 
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID TERRAIN."
- terrain_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
+ call init_atm_esmf_fields
 
  if (localpet == 0) then
    allocate(dummy2d(i_input,j_input))
@@ -2619,13 +2798,6 @@ call read_winds(the_file,inv_file,u_tmp_3d,v_tmp_3d, localpet)
  call ESMF_FieldScatter(terrain_input_grid, dummy2d_8, rootpet=0, rc=rc)
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldScatter", rc)
- 
- if (localpet == 0) print*,"- CALL FieldCreate FOR INPUT GRID PRESSURE."
- pres_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1/), &
-                                   ungriddedUBound=(/lev_input/), rc=rc)
 
  deallocate(dummy2d, dummy2d_8)
  
@@ -3013,7 +3185,7 @@ else
 ! Format used by gfs starting July 19, 2017.
 !---------------------------------------------------------------------------
 
- subroutine read_input_sfc_gfs_gaussian_file(localpet)
+ subroutine read_input_sfc_gfs_gaussian_nemsio_file(localpet)
  
  implicit none
 
@@ -3356,13 +3528,13 @@ else
 
  if (localpet == 0) call nemsio_close(gfile)
 
- end subroutine read_input_sfc_gfs_gaussian_file
+ end subroutine read_input_sfc_gfs_gaussian_nemsio_file
 
 !---------------------------------------------------------------------------
-! Read input grid surface data from an fv3 gaussian history file.
+! Read input grid surface data from an fv3 gaussian nemsio file.
 !---------------------------------------------------------------------------
 
- subroutine read_input_sfc_gaussian_file(localpet)
+ subroutine read_input_sfc_gaussian_nemsio_file(localpet)
 
  implicit none
 
@@ -3705,10 +3877,10 @@ else
 
  if (localpet == 0) call nemsio_close(gfile)
 
- end subroutine read_input_sfc_gaussian_file
+ end subroutine read_input_sfc_gaussian_nemsio_file
 
 !---------------------------------------------------------------------------
-! Read input grid surface data tiled 'restart' files.
+! Read input grid surface data tiled warm 'restart' files.
 !---------------------------------------------------------------------------
 
  subroutine read_input_sfc_restart_file(localpet)
@@ -4024,10 +4196,11 @@ else
  end subroutine read_input_sfc_restart_file
 
 !---------------------------------------------------------------------------
-! Read input grid surface tiled 'history' files.
+! Read input grid surface data from tiled 'history' files (netcdf) or 
+! gaussian netcdf files.
 !---------------------------------------------------------------------------
 
- subroutine read_input_sfc_history_file(localpet)
+ subroutine read_input_sfc_netcdf_file(localpet)
 
  implicit none
 
@@ -4078,6 +4251,14 @@ else
 
  TERRAIN_LOOP: do tile = 1, num_tiles_input_grid
 
+   if (trim(input_type) == "gaussian_netcdf") then
+    if (localpet == 0) then
+      call read_fv3_grid_data_netcdf('orog', tile, idim_input, jdim_input, &
+                                   lsoil_input, sfcdata=data_one_tile)
+    endif
+
+  else
+   
    if (localpet == 0) then
      tilefile = trim(orog_dir_input_grid) // trim(orog_files_input_grid(tile))
      print*,'- OPEN OROGRAPHY FILE: ', trim(tilefile)
@@ -4091,6 +4272,8 @@ else
      error=nf90_close(ncid)
    endif
 
+   endif
+
    print*,"- CALL FieldScatter FOR INPUT TERRAIN."
    call ESMF_FieldScatter(terrain_input_grid, data_one_tile, rootpet=0, tile=tile, rc=rc)
    if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
@@ -4372,7 +4555,11 @@ else
 
  deallocate(data_one_tile, data_one_tile_3d)
 
- end subroutine read_input_sfc_history_file
+ end subroutine read_input_sfc_netcdf_file
+
+!---------------------------------------------------------------------------
+! Read surface data from an fv3gfs grib2 file.
+!---------------------------------------------------------------------------
 
  subroutine read_input_sfc_grib2_file(localpet)
 
@@ -4617,14 +4804,24 @@ if (localpet == 0) then
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__))&
     call error_handler("IN FieldScatter", rc)
     
-if (localpet == 0) then
+ if (localpet == 0) then
    print*,"- READ SKIN TEMPERATURE."
    rc = grb2_inq(the_file, inv_file, ':TMP:',':surface:', data2=dummy2d)
    if (rc <= 0 ) call error_handler("READING SKIN TEMPERATURE.", rc)
    tsk_save(:,:) = dummy2d
    dummy2d_8 = real(dummy2d,esmf_kind_r8)
-   
-   print*,'tsk ',maxval(dummy2d),minval(dummy2d)
+   do j = 1, j_input
+     do i = 1, i_input
+       if(slmsk_save(i,j) == 0 .and. dummy2d(i,j) < 271.2) then
+!        print*,'too cool SST ',i,j,dummy2d(i,j)
+         dummy2d(i,j) = 271.2
+       endif
+       if(slmsk_save(i,j) == 0 .and. dummy2d(i,j) > 310.) then
+!        print*,'too hot SST ',i,j,dummy2d(i,j)
+         dummy2d(i,j) = 310.0
+       endif
+     enddo
+   enddo
  endif
 
  print*,"- CALL FieldScatter FOR INPUT GRID SKIN TEMPERATURE"
@@ -5137,10 +5334,11 @@ if (localpet == 0) then
  end subroutine read_input_sfc_grib2_file
    
 !---------------------------------------------------------------------------
-! Read nst data from tiled history or restart files.
+! Read nst data from these netcdf formatted fv3 files: tiled history,
+! tiled warm restart, and gaussian history.
 !---------------------------------------------------------------------------
 
- subroutine read_input_nst_tile_file(localpet)
+ subroutine read_input_nst_netcdf_file(localpet)
 
  implicit none
 
@@ -5413,7 +5611,7 @@ if (localpet == 0) then
 
  deallocate(data_one_tile)
 
- end subroutine read_input_nst_tile_file
+ end subroutine read_input_nst_netcdf_file
 
 !--------------------------------------------------------------------------
 ! Read input grid nst data from fv3 gaussian nemsio history file or
@@ -5422,7 +5620,7 @@ if (localpet == 0) then
 ! single file.
 !--------------------------------------------------------------------------
 
- subroutine read_input_nst_gaussian_file(localpet)
+ subroutine read_input_nst_nemsio_file(localpet)
 
  implicit none
 
@@ -5437,8 +5635,8 @@ if (localpet == 0) then
 
  type(nemsio_gfile)                     :: gfile
 
- if (trim(input_type) == "gfs_gaussian") then ! spectral gfs nemsio in
-                                              ! separate file.
+ if (trim(input_type) == "gfs_gaussian_nemsio") then ! spectral gfs nemsio in
+                                                     ! separate file.
    the_file = trim(data_dir_input_grid) // "/" // trim(nst_files_input_grid)
  else
    the_file = trim(data_dir_input_grid) // "/" // trim(sfc_files_input_grid(1))
@@ -5685,7 +5883,7 @@ if (localpet == 0) then
 
  if (localpet == 0) call nemsio_close(gfile)
 
- end subroutine read_input_nst_gaussian_file
+ end subroutine read_input_nst_nemsio_file
 
  SUBROUTINE READ_FV3_GRID_DATA_NETCDF(FIELD,TILE_NUM,IMO,JMO,LMO, &
                                       SFCDATA, SFCDATA_3D)
@@ -5917,15 +6115,6 @@ end subroutine read_winds
  real(esmf_kind_r8), pointer     :: latptr(:,:)
  real(esmf_kind_r8), pointer     :: lonptr(:,:)
 
- print*,"- CALL FieldCreate FOR INPUT GRID 3-D WIND."
- wind_input_grid = ESMF_FieldCreate(input_grid, &
-                                   typekind=ESMF_TYPEKIND_R8, &
-                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
-                                   ungriddedLBound=(/1,1/), &
-                                   ungriddedUBound=(/lev_input,3/), rc=rc)
- if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
-    call error_handler("IN FieldCreate", rc)
-
  print*,"- CALL FieldGet FOR 3-D WIND."
  call ESMF_FieldGet(wind_input_grid, &
                     computationalLBound=clb, &
diff --git a/sorc/chgres_cube.fd/model_grid.F90 b/sorc/chgres_cube.fd/model_grid.F90
index 6f0e433..e848986 100644
--- a/sorc/chgres_cube.fd/model_grid.F90
+++ b/sorc/chgres_cube.fd/model_grid.F90
@@ -119,9 +119,10 @@
 
  integer, intent(in)          :: localpet, npets
 
- if (trim(input_type) == "gaussian" .or. &
-     trim(input_type) == "gfs_gaussian" .or. &
-     trim(input_type) == "gfs_spectral") then
+ if (trim(input_type) == "gaussian_nemsio" .or. &
+     trim(input_type) == "gfs_gaussian_nemsio" .or. &
+     trim(input_type) == "gfs_sigio" .or. &
+     trim(input_type) == "gaussian_netcdf") then
    call define_input_grid_gaussian(localpet, npets)
  elseif (trim(external_model) == "GFS" .and. trim(input_type) == "grib2") then
    call define_input_grid_gfs_grib2(localpet,npets)
@@ -155,6 +156,7 @@
 
  use sfcio_module
  use sigio_module
+ use netcdf
 
  implicit none
 
@@ -162,7 +164,7 @@
 
  character(len=250)               :: the_file
 
- integer                          :: i, j, rc, clb(2), cub(2)
+ integer                          :: i, j, rc, clb(2), cub(2), ncid, id_grid
  integer(sfcio_intkind)           :: rc2
  integer(sigio_intkind)           :: rc3
 
@@ -190,7 +192,7 @@
    the_file=trim(data_dir_input_grid) // "/" // trim(atm_files_input_grid(1))
  endif
 
- if (trim(input_type) == "gfs_spectral") then  ! sigio/sfcio format, used by
+ if (trim(input_type) == "gfs_sigio") then  ! sigio/sfcio format, used by
                                                ! spectral gfs prior to 7/19/2017.
 
    if (convert_sfc) then   ! sfcio format
@@ -213,6 +215,26 @@
      j_input = sighead%latb
    endif
 
+ elseif (trim(input_type) == "gaussian_netcdf") then
+
+   print*,'- OPEN AND READ: ',trim(the_file)
+   rc=nf90_open(trim(the_file),nf90_nowrite,ncid)
+   call netcdf_err(rc, 'opening file')
+
+   print*,"- READ grid_xt"
+   rc=nf90_inq_dimid(ncid, 'grid_xt', id_grid)
+   call netcdf_err(rc, 'reading grid_xt id')
+   rc=nf90_inquire_dimension(ncid,id_grid,len=i_input)
+   call netcdf_err(rc, 'reading grid_xt')
+
+   print*,"- READ grid_yt"
+   rc=nf90_inq_dimid(ncid, 'grid_yt', id_grid)
+   call netcdf_err(rc, 'reading grid_yt id')
+   rc=nf90_inquire_dimension(ncid,id_grid,len=j_input)
+   call netcdf_err(rc, 'reading grid_yt')
+
+   rc = nf90_close(ncid)
+
  else ! nemsio format
 
    call nemsio_init(iret=rc)
diff --git a/sorc/chgres_cube.fd/program_setup.f90 b/sorc/chgres_cube.fd/program_setup.f90
index deb4367..e15bcd7 100644
--- a/sorc/chgres_cube.fd/program_setup.f90
+++ b/sorc/chgres_cube.fd/program_setup.f90
@@ -12,12 +12,15 @@
 !
 ! Public variables:
 ! -----------------
-! atm_file_input_grid             File names of input atmospheric data.
-!                                 History or gaussian input type only.
+! atm_files_input_grid            File names of input atmospheric data.
+!                                 Not used for "grib2" or "restart"
+!                                 input types.
 ! atm_core_files_input_grid       File names of input atmospheric restart
-!                                 core files.
+!                                 core files.  Only used for 'restart'
+!                                 input type.
 ! atm_tracer_files_input_grid     File names of input atmospheric restart
-!                                 tracer files.
+!                                 tracer files.  Only used for 'restart'
+!                                 input type.
 ! atm_weight_file                 File containing pre-computed weights
 !                                 to horizontally interpolate
 !                                 atmospheric fields.
@@ -33,6 +36,10 @@
 !                                 target grids.
 ! fix_dir_target_grid             Directory containing target grid
 !                                 pre-computed fixed data (ex: soil type)
+! grib2_file_input_grid           File name of grib2 input data.
+!                                 Assumes atmospheric and surface data
+!                                 are in a single file. 'grib2' input
+!                                 type only.
 ! halo_blend                      Number of row/cols of blending halo,
 !                                 where model tendencies and lateral
 !                                 boundary tendencies are applied.
@@ -40,30 +47,36 @@
 ! halo_bndy                       Number of row/cols of lateral halo,
 !                                 where pure lateral bndy conditions are 
 !                                 applied (regional target grids).
-! input_type                      Input data type: "restart" for fv3
-!                                 tiled restart files; "history" for fv3
-!                                 tiled history files; "gaussian"
-!                                 for fv3 gaussian nemsio files;
-!                                 "gfs_gaussian" for spectral gfs gaussian
-!                                 nemsio files.
+! input_type                      Input data type: 
+!                                 (1) "restart" for fv3 tiled warm restart
+!                                     files (netcdf).
+!                                 (2) "history" for fv3 tiled history files
+!                                     (netcdf).
+!                                 (3) "gaussian_nemsio" for fv3 gaussian
+!                                     nemsio files;
+!                                 (4) "gaussian_netcdf" for fv3 gaussian
+!                                     netcdf files.
+!                                 (5) "grib2" for fv3gfs grib2 files.
+!                                 (6) "gfs_gaussian_nemsio" for spectral gfs
+!                                     gaussian nemsio files
+!                                 (7) "gfs_sigio" for spectral gfs
+!                                     gfs sigio/sfcio files.
 ! max_tracers                     Maximum number of atmospheric tracers
 !                                 processed
 ! maxsmc_input/target             Maximum soil moisture content input/
 !                                 target grids
-! mosaic_file_input_grid          Input grid mosaic file.  Not used
-!                                 with "gaussian" or "gfs_gaussian"
-!                                 input type.
+! mosaic_file_input_grid          Input grid mosaic file.  Only used for
+!                                 "restart" or "history" input type.
 ! mosaic_file_target_grid         Target grid mosaic file
 ! nst_files_input_grid            File name of input nst data.  Only
-!                                 used for input_type "gfs_gaussian".
+!                                 used for input_type "gfs_gaussian_nemsio".
 ! num_tracers                     Number of atmospheric tracers to
 !                                 be processed.
 ! orog_dir_input_grid             Directory containing the input grid
-!                                 orography files.  Not used for "gaussian"
-!                                 or "gfs_gaussian" input types.
-! orog_files_input_grid           Input grid orography files.  Not used
-!                                 for "gaussian" or "gfs_gaussian"
-!                                 input types.
+!                                 orography files.  Only used for "restart"
+!                                 or "history" input types.
+! orog_files_input_grid           Input grid orography files.  Only used for
+!                                 "restart" or "history" input types.
 ! orog_dir_target_grid            Directory containing the target grid
 !                                 orography files.
 ! orog_files_target_grid          Target grid orography files.
@@ -78,6 +91,7 @@
 !                                 Default is '0' (global grids).
 ! satpsi_target                   Saturated soil potential, target grid
 ! sfc_files_input_grid            File names containing input surface data.
+!                                 Not used for 'grib2' input type.
 ! tracers                         Name of each atmos tracer to be processed.
 !                                 These names will be used to identify
 !                                 the tracer records in the output files.
@@ -114,7 +128,7 @@
  character(len=500), public      :: vcoord_file_target_grid = "NULL"
  character(len=6),   public      :: cres_target_grid = "NULL"
  character(len=500), public      :: atm_weight_file="NULL"
- character(len=20),  public      :: input_type="restart"
+ character(len=25),  public      :: input_type="restart"
  character(len=20), public       :: phys_suite="GFS"      !Default to gfs physics suite
  character(len=20),  public      :: external_model="GFS"  !Default assume gfs data
  
@@ -292,12 +306,14 @@
      print*,'- INPUT DATA FROM FV3 TILED RESTART FILES.'
    case ("history")
      print*,'- INPUT DATA FROM FV3 TILED HISTORY FILES.'
-   case ("gaussian")
+   case ("gaussian_nemsio")
      print*,'- INPUT DATA FROM FV3 GAUSSIAN NEMSIO FILE.'
-   case ("gfs_gaussian")
+   case ("gfs_gaussian_nemsio")
      print*,'- INPUT DATA FROM SPECTRAL GFS GAUSSIAN NEMSIO FILE.'
-   case ("gfs_spectral")
+   case ("gfs_sigio")
      print*,'- INPUT DATA FROM SPECTRAL GFS SIGIO/SFCIO FILE.'
+   case ("gaussian_netcdf")
+     print*,'- INPUT DATA FROM FV3 GAUSSIAN NETCDF FILE.'
    case ("grib2")
      print*,'- INPUT DATA FROM A GRIB2 FILE'
    case default
@@ -503,7 +519,7 @@ end subroutine get_var_cond
 !-------------------------------------------------------------------------
 
  select case (trim(input_type))
-   case ("gfs_spectral")
+   case ("gfs_sigio")
      print*,'- INPUT GRID USED ZOBLER SOIL TYPES.'
      num_soil_cats = num_zobler
    case default
@@ -522,7 +538,7 @@ end subroutine get_var_cond
  allocate(f11(num_soil_cats))
 
  select case (trim(input_type))
-   case ("gfs_spectral")
+   case ("gfs_sigio")
      smlow  = smlow_zobler
      smhigh = smhigh_zobler
      maxsmc_input = maxsmc_zobler
diff --git a/sorc/chgres_cube.fd/run/config.C1152.l91.atm.theia.nml b/sorc/chgres_cube.fd/run/config.C1152.l91.atm.theia.nml
deleted file mode 100644
index f4c3f64..0000000
--- a/sorc/chgres_cube.fd/run/config.C1152.l91.atm.theia.nml
+++ /dev/null
@@ -1,26 +0,0 @@
-
-# Convert atmosphere from C768 L64 to C1152 L91.
-# Uses lots of memory.  Use six nodes, six tasks per node.
-# When using -O3, takes 8 1/2 minutes
-
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152/C1152_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C1152"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152"
- orog_files_target_grid="C1152_oro_data.tile1.nc","C1152_oro_data.tile2.nc","C1152_oro_data.tile3.nc","C1152_oro_data.tile4.nc","C1152_oro_data.tile5.nc","C1152_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l91.txt"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2018082906"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- cycle_mon=08
- cycle_day=29
- cycle_hour=6
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C1152.l91.dell.nml b/sorc/chgres_cube.fd/run/config.C1152.l91.dell.nml
deleted file mode 100644
index 79a1130..0000000
--- a/sorc/chgres_cube.fd/run/config.C1152.l91.dell.nml
+++ /dev/null
@@ -1,25 +0,0 @@
-
-# C768 L64 to C1152 L91
-# Spread across six nodes.
-
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C1152"
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152/C1152_mosaic.nc"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152"
- orog_files_target_grid="C1152_oro_data.tile1.nc","C1152_oro_data.tile2.nc","C1152_oro_data.tile3.nc","C1152_oro_data.tile4.nc","C1152_oro_data.tile5.nc","C1152_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2018082906"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l91.txt"
- cycle_mon=8
- cycle_day=29
- cycle_hour=6
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C1152.theia.nml b/sorc/chgres_cube.fd/run/config.C1152.theia.nml
deleted file mode 100644
index 89234d7..0000000
--- a/sorc/chgres_cube.fd/run/config.C1152.theia.nml
+++ /dev/null
@@ -1,17 +0,0 @@
-&config
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C1152"
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152/C1152_mosaic.nc"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C1152"
- orog_files_target_grid="C1152_oro_data.tile1.nc","C1152_oro_data.tile2.nc","C1152_oro_data.tile3.nc","C1152_oro_data.tile4.nc","C1152_oro_data.tile5.nc","C1152_oro_data.tile6.nc"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
-/
diff --git a/sorc/chgres_cube.fd/run/config.C384.cray.nml b/sorc/chgres_cube.fd/run/config.C384.cray.nml
deleted file mode 100644
index 20f9f4f..0000000
--- a/sorc/chgres_cube.fd/run/config.C384.cray.nml
+++ /dev/null
@@ -1,17 +0,0 @@
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C384"
- mosaic_file_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_target_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
-/
diff --git a/sorc/chgres_cube.fd/run/config.C384.dell.nml b/sorc/chgres_cube.fd/run/config.C384.dell.nml
deleted file mode 100644
index fb2ff02..0000000
--- a/sorc/chgres_cube.fd/run/config.C384.dell.nml
+++ /dev/null
@@ -1,24 +0,0 @@
-
-# Fits on one node
-
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C384"
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_target_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2018082906"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- cycle_mon=8
- cycle_day=29
- cycle_hour=6
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C384.gaussian.dell.nml b/sorc/chgres_cube.fd/run/config.C384.gaussian.dell.nml
deleted file mode 100644
index 73b9655..0000000
--- a/sorc/chgres_cube.fd/run/config.C384.gaussian.dell.nml
+++ /dev/null
@@ -1,24 +0,0 @@
-
-# Fits on one node
-
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C384"
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_target_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- mosaic_file_input_grid="NULL"
- orog_dir_input_grid="NULL"
- orog_files_input_grid="NULL"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C384_2018092800_gaussian"
- atm_files_input_grid="gdas.t00z.atmf000.nemsio"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- cycle_mon=9
- cycle_day=28
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- input_type="gaussian"
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="spfh","clwmr","o3mr","icmr","rwmr","snmr","grle"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C384.theia.nml b/sorc/chgres_cube.fd/run/config.C384.theia.nml
deleted file mode 100644
index 672b8a5..0000000
--- a/sorc/chgres_cube.fd/run/config.C384.theia.nml
+++ /dev/null
@@ -1,17 +0,0 @@
-&config
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C384"
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_target_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.cray.nml b/sorc/chgres_cube.fd/run/config.C48.cray.nml
deleted file mode 100644
index fc8f69d..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.cray.nml
+++ /dev/null
@@ -1,21 +0,0 @@
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C48"
- mosaic_file_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- orog_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96/C96_mosaic.nc"
- orog_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96"
- orog_files_input_grid="C96_oro_data.tile1.nc","C96_oro_data.tile2.nc","C96_oro_data.tile3.nc","C96_oro_data.tile4.nc","C96_oro_data.tile5.nc","C96_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C96_2018022000"
- atm_files_input_grid="dynf000.tile1.nc","dynf000.tile2.nc","dynf000.tile3.nc","dynf000.tile4.nc","dynf000.tile5.nc","dynf000.tile6.nc"
- vcoord_file_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- cycle_mon=2
- cycle_day=22
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- input_type="history"
- tracers="sphum","liq_wat","o3mr"
- tracers_input="spfh","clwmr","o3mr"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.dell.nml b/sorc/chgres_cube.fd/run/config.C48.dell.nml
deleted file mode 100644
index 5a980fd..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.dell.nml
+++ /dev/null
@@ -1,21 +0,0 @@
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C48"
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96/C96_mosaic.nc"
- orog_dir_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96"
- orog_files_input_grid="C96_oro_data.tile1.nc","C96_oro_data.tile2.nc","C96_oro_data.tile3.nc","C96_oro_data.tile4.nc","C96_oro_data.tile5.nc","C96_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C96_2018022000"
- atm_files_input_grid="dynf000.tile1.nc","dynf000.tile2.nc","dynf000.tile3.nc","dynf000.tile4.nc","dynf000.tile5.nc","dynf000.tile6.nc"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- cycle_mon=2
- cycle_day=22
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- input_type="history"
- tracers="sphum","liq_wat","o3mr"
- tracers_input="spfh","clwmr","o3mr"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.gaussian.theia.nml b/sorc/chgres_cube.fd/run/config.C48.gaussian.theia.nml
deleted file mode 100644
index d9707f7..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.gaussian.theia.nml
+++ /dev/null
@@ -1,22 +0,0 @@
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C48"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- mosaic_file_input_grid="NULL"
- orog_dir_input_grid="NULL"
- orog_files_input_grid="NULL"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2018091400_gaussian"
- atm_files_input_grid="gdas.t00z.atmf000.nemsio"
- sfc_files_input_grid="gdas.t00z.sfcf000.nemsio"
- cycle_mon=9
- cycle_day=14
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.false.
- input_type="gaussian"
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="spfh","clwmr","o3mr","icmr","rwmr","snmr","grle"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.gfs.gaussian.theia.nml b/sorc/chgres_cube.fd/run/config.C48.gfs.gaussian.theia.nml
deleted file mode 100644
index 7816683..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.gfs.gaussian.theia.nml
+++ /dev/null
@@ -1,23 +0,0 @@
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C48"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- mosaic_file_input_grid="NULL"
- orog_dir_input_grid="NULL"
- orog_files_input_grid="NULL"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_tutorial/nemsio"
- atm_files_input_grid="gfnanl.gdas.2017071700"
- nst_files_input_grid="nsnanl.gdas.2017071700"
- sfc_files_input_grid="sfnanl.gdas.2017071700"
- cycle_mon=7
- cycle_day=17
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.true.
- convert_nst=.true.
- input_type="gfs_gaussian"
- tracers="sphum","liq_wat","o3mr"
- tracers_input="spfh","clwmr","o3mr"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.dell.nml b/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.dell.nml
deleted file mode 100644
index eee9d16..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.dell.nml
+++ /dev/null
@@ -1,23 +0,0 @@
-&config
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C48"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l65.txt"
- mosaic_file_input_grid="NULL"
- orog_dir_input_grid="NULL"
- orog_files_input_grid="NULL"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/chgres_tutorial/old.fmt"
- atm_files_input_grid="gdas.t00z.sanl"
- nst_files_input_grid="NULL"
- sfc_files_input_grid="gdas.t00z.sfcanl"
- cycle_mon=7
- cycle_day=17
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.true.
- convert_nst=.false.
- input_type="gfs_spectral"
- tracers_input="spfh","o3mr","clwmr"
- tracers="sphum","o3mr","liq_wat"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.theia.nml b/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.theia.nml
deleted file mode 100644
index ccd66ce..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.gfs.spectral.theia.nml
+++ /dev/null
@@ -1,23 +0,0 @@
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C48"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l65.txt"
- mosaic_file_input_grid="NULL"
- orog_dir_input_grid="NULL"
- orog_files_input_grid="NULL"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_tutorial/old.fmt"
- atm_files_input_grid="gdas.t00z.sanl"
- nst_files_input_grid="NULL"
- sfc_files_input_grid="gdas.t00z.sfcanl"
- cycle_mon=7
- cycle_day=17
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.true.
- convert_nst=.false.
- input_type="gfs_spectral"
- tracers_input="spfh","o3mr","clwmr"
- tracers="sphum","o3mr","liq_wat"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C48.theia.nml b/sorc/chgres_cube.fd/run/config.C48.theia.nml
deleted file mode 100644
index 59c67a4..0000000
--- a/sorc/chgres_cube.fd/run/config.C48.theia.nml
+++ /dev/null
@@ -1,23 +0,0 @@
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48/C48_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C48"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C48"
- orog_files_target_grid="C48_oro_data.tile1.nc","C48_oro_data.tile2.nc","C48_oro_data.tile3.nc","C48_oro_data.tile4.nc","C48_oro_data.tile5.nc","C48_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96/C96_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C96"
- orog_files_input_grid="C96_oro_data.tile1.nc","C96_oro_data.tile2.nc","C96_oro_data.tile3.nc","C96_oro_data.tile4.nc","C96_oro_data.tile5.nc","C96_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/stmp3/George.Gayno/FV3_RT/rt_10604/fv3_control/"
- atm_files_input_grid="dynf000.tile1.nc","dynf000.tile2.nc","dynf000.tile3.nc","dynf000.tile4.nc","dynf000.tile5.nc","dynf000.tile6.nc"
- sfc_files_input_grid="phyf000.tile1.nc","phyf000.tile2.nc","phyf000.tile3.nc","phyf000.tile4.nc","phyf000.tile5.nc","phyf000.tile6.nc"
- input_type="history"
- cycle_mon=2
- cycle_day=22
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.true.
- convert_nst=.false.
- atm_weight_file="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/weights/C96_to_C48.bilinear.nc"
- tracers="sphum","liq_wat","o3mr"
- tracers_input="spfh","clwmr","o3mr"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.atm.theia.nml b/sorc/chgres_cube.fd/run/config.C768.atm.theia.nml
deleted file mode 100644
index da2bff2..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.atm.theia.nml
+++ /dev/null
@@ -1,26 +0,0 @@
-
-# Convert from C384 L64 to C768 L64.
-# Use two nodes, six tasks per node.
-
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C768"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_target_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_input_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C384_2003110700"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- cycle_mon=11
- cycle_day=7
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- atm_weight_file="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/weights/C384_to_C768.bilinear.nc"
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.l91.atm.theia.nml b/sorc/chgres_cube.fd/run/config.C768.l91.atm.theia.nml
deleted file mode 100644
index 172637b..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.l91.atm.theia.nml
+++ /dev/null
@@ -1,26 +0,0 @@
-
-# Convert atmosphere from C768 L64 to C768 L91.
-# Use three nodes, six tasks per node.
-# When using -O3, takes about 7 minutes.
-
-&config
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C768"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_target_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l91.txt"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2018082906"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- cycle_mon=08
- cycle_day=29
- cycle_hour=6
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.l91.dell.nml b/sorc/chgres_cube.fd/run/config.C768.l91.dell.nml
deleted file mode 100644
index 8ae9e73..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.l91.dell.nml
+++ /dev/null
@@ -1,25 +0,0 @@
-
-# C768 L64 to C768 L91.
-# Spread across three nodes.
-
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C768"
- mosaic_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_target_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2018082906"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- vcoord_file_target_grid="/gpfs/dell2/emc/modeling/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l91.txt"
- cycle_mon=8
- cycle_day=29
- cycle_hour=6
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.nest.atm.theia.nml b/sorc/chgres_cube.fd/run/config.C768.nest.atm.theia.nml
deleted file mode 100644
index 08fe980..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.nest.atm.theia.nml
+++ /dev/null
@@ -1,25 +0,0 @@
-# Takes lots of memory.  Use two nodes - six tasks per node.
-
-&config
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C768"
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix/C768_mosaic.nest.nc"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix"
- orog_files_target_grid="C768_oro_data.tile7.nc"
- vcoord_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_am/global_hyblev.l64.txt"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384/C384_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C384"
- orog_files_input_grid="C384_oro_data.tile1.nc","C384_oro_data.tile2.nc","C384_oro_data.tile3.nc","C384_oro_data.tile4.nc","C384_oro_data.tile5.nc","C384_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C384_2003110700"
- atm_core_files_input_grid="fv_core.res.tile1.nc","fv_core.res.tile2.nc","fv_core.res.tile3.nc","fv_core.res.tile4.nc","fv_core.res.tile5.nc","fv_core.res.tile6.nc","fv_core.res.nc"
- atm_tracer_files_input_grid="fv_tracer.res.tile1.nc","fv_tracer.res.tile2.nc","fv_tracer.res.tile3.nc","fv_tracer.res.tile4.nc","fv_tracer.res.tile5.nc","fv_tracer.res.tile6.nc"
- cycle_mon=11
- cycle_day=7
- cycle_hour=0
- convert_atm=.true.
- convert_sfc=.false.
- convert_nst=.false.
- regional=1
- halo_bndy=4
- tracers="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
- tracers_input="sphum","liq_wat","o3mr","ice_wat","rainwat","snowwat","graupel"
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.nest.cray.nml b/sorc/chgres_cube.fd/run/config.C768.nest.cray.nml
deleted file mode 100644
index 54196d8..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.nest.cray.nml
+++ /dev/null
@@ -1,18 +0,0 @@
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C768.nest"
- mosaic_file_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix/C768_mosaic.nest.nc"
- orog_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix"
- orog_files_target_grid="C768_oro_data.tile7.nc"
- mosaic_file_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
- regional=0
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.nest.theia.nml b/sorc/chgres_cube.fd/run/config.C768.nest.theia.nml
deleted file mode 100644
index 931c88d..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.nest.theia.nml
+++ /dev/null
@@ -1,18 +0,0 @@
-&config
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C768"
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix/C768_mosaic.nest.nc"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix"
- orog_files_target_grid="C768_oro_data.tile7.nc"
- mosaic_file_input_grid="/scratch4/NCEPDEV/global/save/glopara/svn/fv3gfs/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/global/save/glopara/svn/fv3gfs/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
- regional=0
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.stretch.cray.nml b/sorc/chgres_cube.fd/run/config.C768.stretch.cray.nml
deleted file mode 100644
index 46db7c6..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.stretch.cray.nml
+++ /dev/null
@@ -1,17 +0,0 @@
-&config
- fix_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/gridgen_sfc/C768.nest"
- mosaic_file_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix/C768_mosaic.6tiles.nc"
- orog_dir_target_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix"
- orog_files_target_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- mosaic_file_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/gpfs/hps3/emc/global/noscrub/George.Gayno/fv3gfs.git/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
-/
diff --git a/sorc/chgres_cube.fd/run/config.C768.stretch.theia.nml b/sorc/chgres_cube.fd/run/config.C768.stretch.theia.nml
deleted file mode 100644
index a00a7d4..0000000
--- a/sorc/chgres_cube.fd/run/config.C768.stretch.theia.nml
+++ /dev/null
@@ -1,17 +0,0 @@
-&config
- fix_dir_target_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/gridgen_sfc/C768"
- mosaic_file_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix/C768_mosaic.6tiles.nc"
- orog_dir_target_grid="/scratch4/NCEPDEV/da/save/George.Gayno/esmf_grid/albedo_test_ll_to_fv3_nest/fix"
- orog_files_target_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- mosaic_file_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768/C768_mosaic.nc"
- orog_dir_input_grid="/scratch4/NCEPDEV/da/save/George.Gayno/fv3gfs.git/global-workflow/fix/fix_fv3/C768"
- orog_files_input_grid="C768_oro_data.tile1.nc","C768_oro_data.tile2.nc","C768_oro_data.tile3.nc","C768_oro_data.tile4.nc","C768_oro_data.tile5.nc","C768_oro_data.tile6.nc"
- data_dir_input_grid="/scratch4/NCEPDEV/da/noscrub/George.Gayno/chgres_cube/fix/ICs/C768_2017082600"
- sfc_files_input_grid="sfc_data.tile1.nc","sfc_data.tile2.nc","sfc_data.tile3.nc","sfc_data.tile4.nc","sfc_data.tile5.nc","sfc_data.tile6.nc"
- cycle_mon=8
- cycle_day=26
- cycle_hour=0
- convert_atm=.false.
- convert_sfc=.true.
- convert_nst=.true.
-/
diff --git a/sorc/chgres_cube.fd/run/run.cray.sh b/sorc/chgres_cube.fd/run/run.cray.sh
deleted file mode 100755
index 4d3fd79..0000000
--- a/sorc/chgres_cube.fd/run/run.cray.sh
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/bin/sh
-
-#BSUB -oo log
-#BSUB -eo log
-#BSUB -q debug
-#BSUB -J chgres_fv3
-#BSUB -P FV3GFS-T2O
-#BSUB -W 0:10
-#BSUB -M 1000
-#BSUB -extsched 'CRAYLINUX[]'
-
-set -x
-
-export NODES=1
-# threads useful when using gfs sigio files as input
-export OMP_NUM_THREADS=1
-#export OMP_NUM_THREADS=4
-export OMP_STACKSIZE=1024M
-
-WORK_DIR=/gpfs/hps3/stmp/$LOGNAME/chgres_fv3
-rm -fr $WORK_DIR
-mkdir -p $WORK_DIR
-cd $WORK_DIR
-
-cp $LS_SUBCWD/config.C48.cray.nml ./fort.41
-
-EXEC_DIR=$LS_SUBCWD/../../../exec
-
-export KMP_AFFINITY=disabled
-aprun -j 1 -n 6 -N 6 -d${OMP_NUM_THREADS} -cc depth $EXEC_DIR/chgres_cube.exe
-#aprun -j 1 -n 18 -N 18 -d${OMP_NUM_THREADS} -cc depth $EXEC_DIR/chgres_cube.exe
-
-exit
diff --git a/sorc/chgres_cube.fd/run/run.dell.sh b/sorc/chgres_cube.fd/run/run.dell.sh
deleted file mode 100755
index dfbd6a2..0000000
--- a/sorc/chgres_cube.fd/run/run.dell.sh
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/bin/bash
-
-#BSUB -oo log
-#BSUB -eo log
-#BSUB -q debug
-#BSUB -P FV3GFS-T2O
-#BSUB -J chgres.fv3
-#BSUB -W 0:15
-#BSUB -x                 # run not shared
-#BSUB -n 6               # total tasks
-#BSUB -R span[ptile=6]   # tasks per node
-#BSUB -R affinity[core(1):distribute=balance]
-
-set -x
-
-module purge
-module load EnvVars/1.0.2
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load lsf/10.1
-module use /usrx/local/dev/modulefiles
-module load NetCDF/4.5.0
-
-# On Dell, always set environment variables AFTER any module loads.
-# Threads are only useful when using gfs sigio files.  Set OMP_NUM_THREADS
-# equal to "affinity[core(n)".
-
-export OMP_STACKSIZE=1024M
-export OMP_NUM_THREADS=1
-
-EXECDIR=${LS_SUBCWD}/../../../exec
-RUNDIR=$LS_SUBCWD
-
-WORKDIR=/gpfs/dell1/stmp/$LOGNAME/chgres.fv3
-rm -fr $WORKDIR
-mkdir -p $WORKDIR
-cd $WORKDIR
-
-#cp $RUNDIR/config.C1152.l91.dell.nml ./fort.41
-#cp $RUNDIR/config.C768.l91.dell.nml ./fort.41
-#cp $RUNDIR/config.C384.dell.nml ./fort.41
-cp $RUNDIR/config.C384.gaussian.dell.nml ./fort.41
-#cp $RUNDIR/config.C48.dell.nml ./fort.41
-#cp $RUNDIR/config.C48.gfs.spectral.dell.nml  ./fort.41
-
-mpirun $EXECDIR/chgres_cube.exe
-
-exit
diff --git a/sorc/chgres_cube.fd/run/run.theia.ksh b/sorc/chgres_cube.fd/run/run.theia.ksh
deleted file mode 100755
index 1cb9fd9..0000000
--- a/sorc/chgres_cube.fd/run/run.theia.ksh
+++ /dev/null
@@ -1,59 +0,0 @@
-#!/bin/ksh
-
-#-----------------------------------------------------------
-# Run test case on Theia.  MUST BE RUN WITH A 
-# MULTIPLE OF SIX MPI TASKS.  Could not get it to
-# work otherwise.
-#
-# Invoke as: sbatch $script
-#-----------------------------------------------------------
-
-#SBATCH --ntasks=12 --nodes=2
-#####SBATCH --ntasks=6 --nodes=1
-#SBATCH -t 0:15:00
-#SBATCH -A fv3-cpu
-#SBATCH -q debug
-#SBATCH -J fv3
-#SBATCH -o ./log
-#SBATCH -e ./log
-
-set -x
-
-source /apps/lmod/lmod/init/ksh
-module purge
-module load intel/18.1.163
-module load impi/5.1.1.109 
-module load netcdf/4.3.0
-
-# Threads useful when ingesting spectral gfs sigio files.
-# Otherwise set to 1.
-export OMP_NUM_THREADS=1
-export OMP_STACKSIZE=1024M
-
-WORKDIR=/scratch3/NCEPDEV/stmp1/$LOGNAME/chgres_fv3
-rm -fr $WORKDIR
-mkdir -p $WORKDIR
-cd $WORKDIR
-
-#ln -fs ${SLURM_SUBMIT_DIR}/test.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C48.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C48.gaussian.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C48.gfs.gaussian.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C48.gfs.spectral.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C384.theia.nml ./fort.41
-ln -fs ${SLURM_SUBMIT_DIR}/config.C768.nest.atm.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C768.nest.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C768.atm.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C768.l91.atm.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C1152.l91.atm.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C96.nest.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C768.stretch.theia.nml ./fort.41
-#ln -fs ${SLURM_SUBMIT_DIR}/config.C1152.theia.nml ./fort.41
-
-date
-
-srun ${SLURM_SUBMIT_DIR}/../../../exec/chgres_cube.exe
-
-date
-
-exit 0
diff --git a/sorc/chgres_cube.fd/write_data.F90 b/sorc/chgres_cube.fd/write_data.F90
index 2caf9af..d0db34e 100644
--- a/sorc/chgres_cube.fd/write_data.F90
+++ b/sorc/chgres_cube.fd/write_data.F90
@@ -471,16 +471,20 @@
    call netcdf_err(error, 'DEFINING V_S_LEFT')
 
 !--- define global attributes
-   if (trim(input_type) == "gaussian") then
+   if (trim(input_type) == "gaussian_nemsio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GAUSSIAN NEMSIO FILE')
-   elseif (trim(input_type) == "gfs_gaussian") then
+   elseif (trim(input_type) == "gfs_gaussian_nemsio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'SPECTRAL GFS GAUSSIAN NEMSIO FILE')
-   elseif (trim(input_type) == "gfs_spectral") then
+   elseif (trim(input_type) == "gfs_sigio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'SPECTRAL GFS SIGIO FILE')
    elseif (trim(input_type) == "history") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS TILED HISTORY FILE')
    elseif (trim(input_type) == "restart") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS TILED RESTART FILE')
+   elseif (trim(input_type) == "gaussian_netcdf") then
+     error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GAUSSIAN NETCDF FILE')
+   elseif (trim(input_type) == "grib2") then
+     error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GRIB2 FILE')
    endif
 
    error = nf90_enddef(ncid, header_buffer_val,4,0,4)
@@ -1106,7 +1110,11 @@
                                      i_target, j_target, &
                                      ip1_target, jp1_target, &
                                      longitude_target_grid, &
-                                     latitude_target_grid
+                                     latitude_target_grid, &
+                                     longitude_s_target_grid, &
+                                     latitude_s_target_grid, &
+                                     longitude_w_target_grid, &
+                                     latitude_w_target_grid
 
  implicit none
 
@@ -1122,6 +1130,8 @@
  integer                          :: dim_lev, dim_levp1, dim_ntracer
  integer, allocatable             :: id_tracers(:)
  integer                          :: id_lon, id_lat, id_ps
+ integer                          :: id_lat_s, id_lon_s
+ integer                          :: id_lat_w, id_lon_w
  integer                          :: id_w, id_zh, id_u_w
  integer                          :: id_v_w, id_u_s, id_v_s
  integer                          :: id_t, id_delp
@@ -1188,49 +1198,116 @@
    call netcdf_err(error, 'DEFINING NTRACER DIMENSION' )
 
 !--- define global attributes
-   if (trim(input_type) == "gaussian") then
+   if (trim(input_type) == "gaussian_nemsio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GAUSSIAN NEMSIO FILE')
-   elseif (trim(input_type) == "gfs_gaussian") then
+   elseif (trim(input_type) == "gaussian_netcdf") then
+     error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GAUSSIAN NETCDF FILE')
+   elseif (trim(input_type) == "gfs_gaussian_nemsio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'SPECTRAL GFS GAUSSIAN NEMSIO FILE')
-   elseif (trim(input_type) == "gfs_spectral") then
+   elseif (trim(input_type) == "gfs_sigio") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'SPECTRAL GFS SIGIO FILE')
    elseif (trim(input_type) == "history") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS TILED HISTORY FILE')
    elseif (trim(input_type) == "restart") then
      error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS TILED RESTART FILE')
+   elseif (trim(input_type) == "grib2") then
+     error = nf90_put_att(ncid, nf90_global, 'source', 'FV3GFS GRIB2 FILE')
    endif
 
 !--- define field
-   error = nf90_def_var(ncid, 'lon', NF90_FLOAT, (/dim_lon/), id_lon)
-   call netcdf_err(error, 'DEFINING LON FIELD' )
-   error = nf90_put_att(ncid, id_lon, "cartesian_axis", "X")
-   call netcdf_err(error, 'WRITING LON FIELD' )
-   error = nf90_def_var(ncid, 'lat', NF90_FLOAT, (/dim_lat/), id_lat)
-   call netcdf_err(error, 'DEFINING LAT FIELD' )
-   error = nf90_put_att(ncid, id_lat, "cartesian_axis", "Y")
-   call netcdf_err(error, 'WRITING LAT FIELD' )
+   error = nf90_def_var(ncid, 'geolon', NF90_FLOAT, (/dim_lon,dim_lat/), id_lon)
+   call netcdf_err(error, 'DEFINING GEOLON FIELD' )
+   error = nf90_put_att(ncid, id_lon, "long_name", "Longitude")
+   call netcdf_err(error, 'DEFINING GEOLON NAME' )
+   error = nf90_put_att(ncid, id_lon, "units", "degrees_east")
+   call netcdf_err(error, 'DEFINING GEOLON UNITS' )
+
+   error = nf90_def_var(ncid, 'geolat', NF90_FLOAT, (/dim_lon,dim_lat/), id_lat)
+   call netcdf_err(error, 'DEFINING GEOLAT FIELD' )
+   error = nf90_put_att(ncid, id_lat, "long_name", "Latitude")
+   call netcdf_err(error, 'DEFINING GEOLAT NAME' )
+   error = nf90_put_att(ncid, id_lat, "units", "degrees_north")
+   call netcdf_err(error, 'DEFINING GEOLAT UNITS' )
+
+   error = nf90_def_var(ncid, 'geolon_s', NF90_FLOAT, (/dim_lon,dim_latp/), id_lon_s)
+   call netcdf_err(error, 'DEFINING GEOLON_S FIELD' )
+   error = nf90_put_att(ncid, id_lon_s, "long_name", "Longitude_s")
+   call netcdf_err(error, 'DEFINING GEOLON_S NAME' )
+   error = nf90_put_att(ncid, id_lon_s, "units", "degrees_east")
+   call netcdf_err(error, 'DEFINING GEOLON_S UNITS' )
+
+   error = nf90_def_var(ncid, 'geolat_s', NF90_FLOAT, (/dim_lon,dim_latp/), id_lat_s)
+   call netcdf_err(error, 'DEFINING GEOLAT_S FIELD' )
+   error = nf90_put_att(ncid, id_lat_s, "long_name", "Latitude_s")
+   call netcdf_err(error, 'DEFINING GEOLAT_S NAME' )
+   error = nf90_put_att(ncid, id_lat_s, "units", "degrees_north")
+   call netcdf_err(error, 'DEFINING GEOLAT_S UNITS' )
+
+   error = nf90_def_var(ncid, 'geolon_w', NF90_FLOAT, (/dim_lonp,dim_lat/), id_lon_w)
+   call netcdf_err(error, 'DEFINING GEOLON_W FIELD' )
+   error = nf90_put_att(ncid, id_lon_w, "long_name", "Longitude_w")
+   call netcdf_err(error, 'DEFINING GEOLON_W NAME' )
+   error = nf90_put_att(ncid, id_lon_w, "units", "degrees_east")
+   call netcdf_err(error, 'DEFINING GEOLON_W UNITS' )
+
+   error = nf90_def_var(ncid, 'geolat_w', NF90_FLOAT, (/dim_lonp,dim_lat/), id_lat_w)
+   call netcdf_err(error, 'DEFINING GEOLAT_W FIELD' )
+   error = nf90_put_att(ncid, id_lat_w, "long_name", "Latitude_w")
+   call netcdf_err(error, 'DEFINING GEOLAT_W NAME' )
+   error = nf90_put_att(ncid, id_lat_w, "units", "degrees_north")
+   call netcdf_err(error, 'DEFINING GEOLAT_W UNITS' )
+
    error = nf90_def_var(ncid, 'ps', NF90_FLOAT, (/dim_lon,dim_lat/), id_ps)
-   call netcdf_err(error, 'WRITING PS' )
+   call netcdf_err(error, 'DEFINING PS' )
+   error = nf90_put_att(ncid, id_ps, "coordinates", "geolon geolat")
+   call netcdf_err(error, 'DEFINING PS COORD' )
+
    error = nf90_def_var(ncid, 'w', NF90_FLOAT, (/dim_lon,dim_lat,dim_lev/), id_w)
-   call netcdf_err(error, 'WRITING W' )
+   call netcdf_err(error, 'DEFINING W' )
+   error = nf90_put_att(ncid, id_w, "coordinates", "geolon geolat")
+   call netcdf_err(error, 'DEFINING W COORD' )
+
    error = nf90_def_var(ncid, 'zh', NF90_FLOAT, (/dim_lon,dim_lat,dim_levp1/), id_zh)
-   call netcdf_err(error, 'WRITING ZH' )
+   call netcdf_err(error, 'DEFINING ZH' )
+   error = nf90_put_att(ncid, id_zh, "coordinates", "geolon geolat")
+   call netcdf_err(error, 'DEFINING ZH COORD' )
+
    error = nf90_def_var(ncid, 't', NF90_FLOAT, (/dim_lon,dim_lat,dim_lev/), id_t)
-   call netcdf_err(error, 'WRITING T' )
+   call netcdf_err(error, 'DEFINING T' )
+   error = nf90_put_att(ncid, id_t, "coordinates", "geolon geolat")
+   call netcdf_err(error, 'DEFINING T COORD' )
+
    error = nf90_def_var(ncid, 'delp', NF90_FLOAT, (/dim_lon,dim_lat,dim_lev/), id_delp)
-   call netcdf_err(error, 'WRITING DELP' )
+   call netcdf_err(error, 'DEFINING DELP' )
+   error = nf90_put_att(ncid, id_delp, "coordinates", "geolon geolat")
+   call netcdf_err(error, 'DEFINING DELP COORD' )
+
    do n = 1, num_tracers
      error = nf90_def_var(ncid, tracers(n), NF90_FLOAT, (/dim_lon,dim_lat,dim_lev/), id_tracers(n))
-     call netcdf_err(error, 'WRITING TRACERS' )
+     call netcdf_err(error, 'DEFINING TRACERS' )
+     error = nf90_put_att(ncid, id_tracers(n), "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING TRACERS COORD' )
    enddo
+
    error = nf90_def_var(ncid, 'u_w', NF90_FLOAT, (/dim_lonp,dim_lat,dim_lev/), id_u_w)
-   call netcdf_err(error, 'WRITING U_W' )
+   call netcdf_err(error, 'DEFINING U_W' )
+   error = nf90_put_att(ncid, id_u_w, "coordinates", "geolon_w geolat_w")
+   call netcdf_err(error, 'DEFINING U_W COORD' )
+
    error = nf90_def_var(ncid, 'v_w', NF90_FLOAT, (/dim_lonp,dim_lat,dim_lev/), id_v_w)
-   call netcdf_err(error, 'WRITING V_W' )
+   call netcdf_err(error, 'DEFINING V_W' )
+   error = nf90_put_att(ncid, id_v_w, "coordinates", "geolon_w geolat_w")
+   call netcdf_err(error, 'DEFINING V_W COORD' )
+
    error = nf90_def_var(ncid, 'u_s', NF90_FLOAT, (/dim_lon,dim_latp,dim_lev/), id_u_s)
-   call netcdf_err(error, 'WRITING U_S' )
+   call netcdf_err(error, 'DEFINING U_S' )
+   error = nf90_put_att(ncid, id_u_s, "coordinates", "geolon_s geolat_s")
+   call netcdf_err(error, 'DEFINING U_S COORD' )
+
    error = nf90_def_var(ncid, 'v_s', NF90_FLOAT, (/dim_lon,dim_latp,dim_lev/), id_v_s)
-   call netcdf_err(error, 'WRITING V_S' )
+   call netcdf_err(error, 'DEFINING V_S' )
+   error = nf90_put_att(ncid, id_v_s, "coordinates", "geolon_s geolat_s")
+   call netcdf_err(error, 'DEFINING V_S COORD' )
 
    error = nf90_enddef(ncid, header_buffer_val,4,0,4)
    call netcdf_err(error, 'DEFINING HEADER' )
@@ -1248,7 +1325,7 @@
 
  if (localpet < num_tiles_target_grid) then
    dum2d(:,:) = data_one_tile(i_start:i_end, j_start:j_end)
-   error = nf90_put_var( ncid, id_lon, dum2d(:,1))
+   error = nf90_put_var( ncid, id_lon, dum2d)
    call netcdf_err(error, 'WRITING LONGITUDE RECORD' )
  endif
 
@@ -1263,7 +1340,7 @@
 
  if (localpet < num_tiles_target_grid) then
    dum2d(:,:) = data_one_tile(i_start:i_end, j_start:j_end)
-   error = nf90_put_var( ncid, id_lat, dum2d(1,:))
+   error = nf90_put_var( ncid, id_lat, dum2d)
    call netcdf_err(error, 'WRITING LATITUDE RECORD' )
  endif
 
@@ -1389,6 +1466,44 @@
 
  deallocate(dum3d, data_one_tile_3d)
 
+! lat/lon_s
+
+ if (localpet < num_tiles_target_grid) then
+   allocate(dum2d(i_target_out,jp1_target_out))
+   allocate(data_one_tile(i_target,jp1_target))
+ else
+   allocate(dum2d(0,0))
+   allocate(data_one_tile(0,0))
+ endif
+
+ do tile = 1, num_tiles_target_grid
+   print*,"- CALL FieldGather FOR TARGET GRID LON_S FOR TILE: ", tile
+   call ESMF_FieldGather(longitude_s_target_grid, data_one_tile, rootPet=tile-1, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+ enddo
+
+ if (localpet < num_tiles_target_grid) then
+   dum2d(:,:) = data_one_tile(i_start:i_end,j_start:jp1_end)
+   error = nf90_put_var( ncid, id_lon_s, dum2d)
+   call netcdf_err(error, 'WRITING LON_S RECORD' )
+ endif
+
+ do tile = 1, num_tiles_target_grid
+   print*,"- CALL FieldGather FOR TARGET GRID LAT_S FOR TILE: ", tile
+   call ESMF_FieldGather(latitude_s_target_grid, data_one_tile, rootPet=tile-1, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+ enddo
+
+ if (localpet < num_tiles_target_grid) then
+   dum2d(:,:) = data_one_tile(i_start:i_end,j_start:jp1_end)
+   error = nf90_put_var( ncid, id_lat_s, dum2d)
+   call netcdf_err(error, 'WRITING LAT_S RECORD' )
+ endif
+
+ deallocate(dum2d, data_one_tile)
+
 !  uwinds s
 
  if (localpet < num_tiles_target_grid) then
@@ -1433,6 +1548,44 @@
 
  deallocate(dum3d, data_one_tile_3d)
 
+! lat/lon_w
+
+ if (localpet < num_tiles_target_grid) then
+   allocate(dum2d(ip1_target_out,j_target_out))
+   allocate(data_one_tile(ip1_target,j_target))
+ else
+   allocate(dum2d(0,0))
+   allocate(data_one_tile(0,0))
+ endif
+
+ do tile = 1, num_tiles_target_grid
+   print*,"- CALL FieldGather FOR TARGET GRID LON_W FOR TILE: ", tile
+   call ESMF_FieldGather(longitude_w_target_grid, data_one_tile, rootPet=tile-1, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+ enddo
+
+ if (localpet < num_tiles_target_grid) then
+   dum2d(:,:) = data_one_tile(i_start:ip1_end,j_start:j_end)
+   error = nf90_put_var( ncid, id_lon_w, dum2d)
+   call netcdf_err(error, 'WRITING LON_W RECORD' )
+ endif
+
+ do tile = 1, num_tiles_target_grid
+   print*,"- CALL FieldGather FOR TARGET GRID LAT_W FOR TILE: ", tile
+   call ESMF_FieldGather(latitude_w_target_grid, data_one_tile, rootPet=tile-1, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+ enddo
+
+ if (localpet < num_tiles_target_grid) then
+   dum2d(:,:) = data_one_tile(i_start:ip1_end,j_start:j_end)
+   error = nf90_put_var( ncid, id_lat_w, dum2d)
+   call netcdf_err(error, 'WRITING LAT_W RECORD' )
+ endif
+
+ deallocate(dum2d, data_one_tile)
+
 !  uwinds w
 
  if (localpet < num_tiles_target_grid) then
@@ -1495,6 +1648,8 @@
 
  use model_grid, only            : num_tiles_target_grid, &
                                    landmask_target_grid, &
+                                   latitude_target_grid, &
+                                   longitude_target_grid, &
                                    i_target, j_target, lsoil_target
 
  use program_setup, only         : convert_nst, halo=>halo_bndy
@@ -1563,6 +1718,7 @@
  integer                        :: error, i, ncid, tile
  integer                        :: id_x, id_y, id_lsoil
  integer                        :: id_slmsk, id_time
+ integer                        :: id_lat, id_lon
  integer                        :: id_tsea, id_sheleg, id_tg3
  integer                        :: id_zorl, id_alvsf, id_alvwf
  integer                        :: id_alnsf, id_alnwf, id_vfrac
@@ -1695,12 +1851,28 @@
      error = nf90_put_att(ncid, id_time, "cartesian_axis", "T")
      call netcdf_err(error, 'WRITING TIME FIELD' )
 
+     error = nf90_def_var(ncid, 'geolon', NF90_DOUBLE, (/dim_x,dim_y/), id_lon)
+     call netcdf_err(error, 'DEFINING GEOLON' )
+     error = nf90_put_att(ncid, id_lon, "long_name", "Longitude")
+     call netcdf_err(error, 'DEFINING GEOLON LONG NAME' )
+     error = nf90_put_att(ncid, id_lon, "units", "degrees_east")
+     call netcdf_err(error, 'DEFINING GEOLON UNITS' )
+
+     error = nf90_def_var(ncid, 'geolat', NF90_DOUBLE, (/dim_x,dim_y/), id_lat)
+     call netcdf_err(error, 'DEFINING GEOLAT' )
+     error = nf90_put_att(ncid, id_lat, "long_name", "Latitude")
+     call netcdf_err(error, 'DEFINING GEOLAT LONG NAME' )
+     error = nf90_put_att(ncid, id_lat, "units", "degrees_north")
+     call netcdf_err(error, 'DEFINING GEOLAT UNITS' )
+
      error = nf90_def_var(ncid, 'slmsk', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_slmsk)
      call netcdf_err(error, 'DEFINING SLMSK' )
      error = nf90_put_att(ncid, id_slmsk, "long_name", "slmsk")
      call netcdf_err(error, 'DEFINING SLMSK LONG NAME' )
      error = nf90_put_att(ncid, id_slmsk, "units", "none")
      call netcdf_err(error, 'DEFINING SLMSK UNITS' )
+     error = nf90_put_att(ncid, id_slmsk, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SLMSK COORD' )
 
      error = nf90_def_var(ncid, 'tsea', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_tsea)
      call netcdf_err(error, 'DEFINING TSEA' )
@@ -1708,6 +1880,8 @@
      call netcdf_err(error, 'DEFINING TSEA LONG NAME' )
      error = nf90_put_att(ncid, id_tsea, "units", "none")
      call netcdf_err(error, 'DEFINING TSEA UNITS' )
+     error = nf90_put_att(ncid, id_tsea, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING TSEA COORD' )
 
      error = nf90_def_var(ncid, 'sheleg', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_sheleg)
      call netcdf_err(error, 'DEFINING SHELEG' )
@@ -1715,6 +1889,8 @@
      call netcdf_err(error, 'DEFINING SHELEG LONG NAME' )
      error = nf90_put_att(ncid, id_sheleg, "units", "none")
      call netcdf_err(error, 'DEFINING SHELEG UNITS' )
+     error = nf90_put_att(ncid, id_sheleg, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SHELEG COORD' )
 
      error = nf90_def_var(ncid, 'tg3', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_tg3)
      call netcdf_err(error, 'DEFINING TG3' )
@@ -1722,6 +1898,8 @@
      call netcdf_err(error, 'DEFINING TG3 LONG NAME' )
      error = nf90_put_att(ncid, id_tg3, "units", "none")
      call netcdf_err(error, 'DEFINING TG3 UNITS' )
+     error = nf90_put_att(ncid, id_tg3, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING TG3 COORD' )
 
      error = nf90_def_var(ncid, 'zorl', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_zorl)
      call netcdf_err(error, 'DEFINING ZORL' )
@@ -1729,6 +1907,8 @@
      call netcdf_err(error, 'DEFINING ZORL LONG NAME' )
      error = nf90_put_att(ncid, id_zorl, "units", "none")
      call netcdf_err(error, 'DEFINING ZORL UNITS' )
+     error = nf90_put_att(ncid, id_zorl, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING ZORL COORD' )
 
      error = nf90_def_var(ncid, 'alvsf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_alvsf)
      call netcdf_err(error, 'DEFINING ALVSF' )
@@ -1736,6 +1916,8 @@
      call netcdf_err(error, 'DEFINING ALVSF LONG NAME' )
      error = nf90_put_att(ncid, id_alvsf, "units", "none")
      call netcdf_err(error, 'DEFINING ALVSF UNITS' )
+     error = nf90_put_att(ncid, id_alvsf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING ALVSF COORD' )
 
      error = nf90_def_var(ncid, 'alvwf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_alvwf)
      call netcdf_err(error, 'DEFINING ALVWF' )
@@ -1743,6 +1925,8 @@
      call netcdf_err(error, 'DEFINING ALVWF LONG NAME' )
      error = nf90_put_att(ncid, id_alvwf, "units", "none")
      call netcdf_err(error, 'DEFINING ALVWF UNITS' )
+     error = nf90_put_att(ncid, id_alvwf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING ALVWF COORD' )
 
      error = nf90_def_var(ncid, 'alnsf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_alnsf)
      call netcdf_err(error, 'DEFINING ALNSF' )
@@ -1750,6 +1934,8 @@
      call netcdf_err(error, 'DEFINING ALNSF LONG NAME' )
      error = nf90_put_att(ncid, id_alnsf, "units", "none")
      call netcdf_err(error, 'DEFINING ALNSF UNITS' )
+     error = nf90_put_att(ncid, id_alnsf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING ALNSF COORD' )
 
      error = nf90_def_var(ncid, 'alnwf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_alnwf)
      call netcdf_err(error, 'DEFINING ALNWF' )
@@ -1757,6 +1943,8 @@
      call netcdf_err(error, 'DEFINING ALNWF LONG NAME' )
      error = nf90_put_att(ncid, id_alnwf, "units", "none")
      call netcdf_err(error, 'DEFINING ALNWF UNITS' )
+     error = nf90_put_att(ncid, id_alnwf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING ALNWF COORD' )
 
      error = nf90_def_var(ncid, 'facsf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_facsf)
      call netcdf_err(error, 'DEFINING FACSF' )
@@ -1764,6 +1952,8 @@
      call netcdf_err(error, 'DEFINING FACSF LONG NAME' )
      error = nf90_put_att(ncid, id_facsf, "units", "none")
      call netcdf_err(error, 'DEFINING FACSF UNITS' )
+     error = nf90_put_att(ncid, id_facsf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING FACSF COORD' )
 
      error = nf90_def_var(ncid, 'facwf', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_facwf)
      call netcdf_err(error, 'DEFINING FACWF' )
@@ -1771,6 +1961,8 @@
      call netcdf_err(error, 'DEFINING FACWF LONG NAME' )
      error = nf90_put_att(ncid, id_facwf, "units", "none")
      call netcdf_err(error, 'DEFINING FACWF UNITS' )
+     error = nf90_put_att(ncid, id_facwf, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING FACWF COORD' )
 
      error = nf90_def_var(ncid, 'vfrac', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_vfrac)
      call netcdf_err(error, 'DEFINING VFRAC' )
@@ -1778,6 +1970,8 @@
      call netcdf_err(error, 'DEFINING VFRAC LONG NAME' )
      error = nf90_put_att(ncid, id_vfrac, "units", "none")
      call netcdf_err(error, 'DEFINING VFRAC UNITS' )
+     error = nf90_put_att(ncid, id_vfrac, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING VFRAC COORD' )
 
      error = nf90_def_var(ncid, 'canopy', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_canopy)
      call netcdf_err(error, 'DEFINING CANOPY' )
@@ -1785,6 +1979,8 @@
      call netcdf_err(error, 'DEFINING CANOPY LONG NAME' )
      error = nf90_put_att(ncid, id_canopy, "units", "none")
      call netcdf_err(error, 'DEFINING CANOPY UNITS' )
+     error = nf90_put_att(ncid, id_canopy, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING CANOPY COORD' )
 
      error = nf90_def_var(ncid, 'f10m', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_f10m)
      call netcdf_err(error, 'DEFINING F10M' )
@@ -1792,6 +1988,8 @@
      call netcdf_err(error, 'DEFINING F10M LONG NAME' )
      error = nf90_put_att(ncid, id_f10m, "units", "none")
      call netcdf_err(error, 'DEFINING F10M UNITS' )
+     error = nf90_put_att(ncid, id_f10m, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING F10M COORD' )
 
      error = nf90_def_var(ncid, 't2m', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_t2m)
      call netcdf_err(error, 'DEFINING T2M' )
@@ -1799,6 +1997,8 @@
      call netcdf_err(error, 'DEFINING T2M LONG NAME' )
      error = nf90_put_att(ncid, id_t2m, "units", "none")
      call netcdf_err(error, 'DEFINING T2M UNITS' )
+     error = nf90_put_att(ncid, id_t2m, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING T2M COORD' )
 
      error = nf90_def_var(ncid, 'q2m', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_q2m)
      call netcdf_err(error, 'DEFINING Q2M' )
@@ -1806,6 +2006,8 @@
      call netcdf_err(error, 'DEFINING Q2M LONG NAME' )
      error = nf90_put_att(ncid, id_q2m, "units", "none")
      call netcdf_err(error, 'DEFINING Q2M UNITS' )
+     error = nf90_put_att(ncid, id_q2m, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING Q2M COORD' )
 
      error = nf90_def_var(ncid, 'vtype', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_vtype)
      call netcdf_err(error, 'DEFINING VTYPE' )
@@ -1813,6 +2015,8 @@
      call netcdf_err(error, 'DEFINING VTYPE LONG NAME' )
      error = nf90_put_att(ncid, id_vtype, "units", "none")
      call netcdf_err(error, 'DEFINING VTYPE UNITS' )
+     error = nf90_put_att(ncid, id_vtype, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING VTYPE COORD' )
 
      error = nf90_def_var(ncid, 'stype', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_stype)
      call netcdf_err(error, 'DEFINING STYPE' )
@@ -1820,6 +2024,8 @@
      call netcdf_err(error, 'DEFINING STYPE LONG NAME' )
      error = nf90_put_att(ncid, id_stype, "units", "none")
      call netcdf_err(error, 'DEFINING STYPE UNITS' )
+     error = nf90_put_att(ncid, id_stype, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING STYPE COORD' )
 
      error = nf90_def_var(ncid, 'uustar', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_uustar)
      call netcdf_err(error, 'DEFINING UUSTAR' )
@@ -1827,6 +2033,8 @@
      call netcdf_err(error, 'DEFINING UUSTAR LONG NAME' )
      error = nf90_put_att(ncid, id_uustar, "units", "none")
      call netcdf_err(error, 'DEFINING UUSTAR UNITS' )
+     error = nf90_put_att(ncid, id_uustar, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING UUSTAR COORD' )
 
      error = nf90_def_var(ncid, 'ffmm', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_ffmm)
      call netcdf_err(error, 'DEFINING FFMM' )
@@ -1834,6 +2042,8 @@
      call netcdf_err(error, 'DEFINING FFMM LONG NAME' )
      error = nf90_put_att(ncid, id_ffmm, "units", "none")
      call netcdf_err(error, 'DEFINING FFMM UNITS' )
+     error = nf90_put_att(ncid, id_ffmm, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING FFMM COORD' )
 
      error = nf90_def_var(ncid, 'ffhh', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_ffhh)
      call netcdf_err(error, 'DEFINING FFHH' )
@@ -1841,6 +2051,8 @@
      call netcdf_err(error, 'DEFINING FFHH LONG NAME' )
      error = nf90_put_att(ncid, id_ffhh, "units", "none")
      call netcdf_err(error, 'DEFINING FFHH UNITS' )
+     error = nf90_put_att(ncid, id_ffhh, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING FFHH COORD' )
 
      error = nf90_def_var(ncid, 'hice', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_hice)
      call netcdf_err(error, 'DEFINING HICE' )
@@ -1848,6 +2060,8 @@
      call netcdf_err(error, 'DEFINING HICE LONG NAME' )
      error = nf90_put_att(ncid, id_hice, "units", "none")
      call netcdf_err(error, 'DEFINING HICE UNITS' )
+     error = nf90_put_att(ncid, id_hice, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING HICE COORD' )
 
      error = nf90_def_var(ncid, 'fice', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_fice)
      call netcdf_err(error, 'DEFINING FICE' )
@@ -1855,6 +2069,8 @@
      call netcdf_err(error, 'DEFINING FICE LONG NAME' )
      error = nf90_put_att(ncid, id_fice, "units", "none")
      call netcdf_err(error, 'DEFINING FICE UNITS' )
+     error = nf90_put_att(ncid, id_fice, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING FICE COORD' )
 
      error = nf90_def_var(ncid, 'tisfc', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_tisfc)
      call netcdf_err(error, 'DEFINING TISFC' )
@@ -1862,6 +2078,8 @@
      call netcdf_err(error, 'DEFINING TISFC LONG NAME' )
      error = nf90_put_att(ncid, id_tisfc, "units", "none")
      call netcdf_err(error, 'DEFINING TISFC UNITS' )
+     error = nf90_put_att(ncid, id_tisfc, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING TISFC COORD' )
 
      error = nf90_def_var(ncid, 'tprcp', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_tprcp)
      call netcdf_err(error, 'DEFINING TPRCP' )
@@ -1869,6 +2087,8 @@
      call netcdf_err(error, 'DEFINING TPRCP LONG NAME' )
      error = nf90_put_att(ncid, id_tprcp, "units", "none")
      call netcdf_err(error, 'DEFINING TPRCP UNITS' )
+     error = nf90_put_att(ncid, id_tprcp, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING TPRCP COORD' )
 
      error = nf90_def_var(ncid, 'srflag', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_srflag)
      call netcdf_err(error, 'DEFINING SRFLAG' )
@@ -1876,6 +2096,8 @@
      call netcdf_err(error, 'DEFINING SRFLAG LONG NAME' )
      error = nf90_put_att(ncid, id_srflag, "units", "none")
      call netcdf_err(error, 'DEFINING SRFLAG UNITS' )
+     error = nf90_put_att(ncid, id_srflag, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SRFLAG COORD' )
 
      error = nf90_def_var(ncid, 'snwdph', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_snwdph)
      call netcdf_err(error, 'DEFINING SNWDPH' )
@@ -1883,6 +2105,8 @@
      call netcdf_err(error, 'DEFINING SNWDPH LONG NAME' )
      error = nf90_put_att(ncid, id_snwdph, "units", "none")
      call netcdf_err(error, 'DEFINING SNWDPH UNITS' )
+     error = nf90_put_att(ncid, id_snwdph, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SNWDPH COORD' )
 
      error = nf90_def_var(ncid, 'shdmin', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_shdmin)
      call netcdf_err(error, 'DEFINING SHDMIN' )
@@ -1890,6 +2114,8 @@
      call netcdf_err(error, 'DEFINING SHDMIN LONG NAME' )
      error = nf90_put_att(ncid, id_shdmin, "units", "none")
      call netcdf_err(error, 'DEFINING SHDMIN UNITS' )
+     error = nf90_put_att(ncid, id_shdmin, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SHDMIN COORD' )
 
      error = nf90_def_var(ncid, 'shdmax', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_shdmax)
      call netcdf_err(error, 'DEFINING SHDMAX' )
@@ -1897,6 +2123,8 @@
      call netcdf_err(error, 'DEFINING SHDMAX LONG NAME' )
      error = nf90_put_att(ncid, id_shdmax, "units", "none")
      call netcdf_err(error, 'DEFINING SHDMAX UNITS' )
+     error = nf90_put_att(ncid, id_shdmax, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SHDMAX COORD' )
 
      error = nf90_def_var(ncid, 'slope', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_slope)
      call netcdf_err(error, 'DEFINING SLOPE' )
@@ -1904,6 +2132,8 @@
      call netcdf_err(error, 'DEFINING SLOPE LONG NAME' )
      error = nf90_put_att(ncid, id_slope, "units", "none")
      call netcdf_err(error, 'DEFINING SLOPE UNITS' )
+     error = nf90_put_att(ncid, id_slope, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SLOPE COORD' )
 
      error = nf90_def_var(ncid, 'snoalb', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_snoalb)
      call netcdf_err(error, 'DEFINING SNOALB' )
@@ -1911,6 +2141,8 @@
      call netcdf_err(error, 'DEFINING SNOALB LONG NAME' )
      error = nf90_put_att(ncid, id_snoalb, "units", "none")
      call netcdf_err(error, 'DEFINING SNOALB UNITS' )
+     error = nf90_put_att(ncid, id_snoalb, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SNOALB COORD' )
      
      error = nf90_def_var(ncid, 'lai', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_lai)
      call netcdf_err(error, 'DEFINING LAI' )
@@ -1918,6 +2150,8 @@
      call netcdf_err(error, 'DEFINING LAI LONG NAME' )
      error = nf90_put_att(ncid, id_lai, "units", "none")
      call netcdf_err(error, 'DEFINING LAI UNITS' )
+     error = nf90_put_att(ncid, id_lai, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING LAI COORD' )
 
      error = nf90_def_var(ncid, 'stc', NF90_DOUBLE, (/dim_x,dim_y,dim_lsoil,dim_time/), id_stc)
      call netcdf_err(error, 'DEFINING STC' )
@@ -1925,6 +2159,8 @@
      call netcdf_err(error, 'DEFINING STC LONG NAME' )
      error = nf90_put_att(ncid, id_stc, "units", "none")
      call netcdf_err(error, 'DEFINING STC UNITS' )
+     error = nf90_put_att(ncid, id_stc, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING STC COORD' )
 
      error = nf90_def_var(ncid, 'smc', NF90_DOUBLE, (/dim_x,dim_y,dim_lsoil,dim_time/), id_smc)
      call netcdf_err(error, 'DEFINING SMC' )
@@ -1932,6 +2168,8 @@
      call netcdf_err(error, 'DEFINING SMC LONG NAME' )
      error = nf90_put_att(ncid, id_smc, "units", "none")
      call netcdf_err(error, 'DEFINING SMC UNITS' )
+     error = nf90_put_att(ncid, id_smc, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SMC COORD' )
 
      error = nf90_def_var(ncid, 'slc', NF90_DOUBLE, (/dim_x,dim_y,dim_lsoil,dim_time/), id_slc)
      call netcdf_err(error, 'DEFINING SLC' )
@@ -1939,6 +2177,8 @@
      call netcdf_err(error, 'DEFINING SLC LONG NAME' )
      error = nf90_put_att(ncid, id_slc, "units", "none")
      call netcdf_err(error, 'DEFINING SLC UNITS' )
+     error = nf90_put_att(ncid, id_slc, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING SLC COORD' )
 
      if (convert_nst) then
 
@@ -1948,6 +2188,8 @@
        call netcdf_err(error, 'DEFINING TREF LONG NAME' )
        error = nf90_put_att(ncid, id_tref, "units", "none")
        call netcdf_err(error, 'DEFINING TREF UNITS' )
+       error = nf90_put_att(ncid, id_tref, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING TREF COORD' )
 
        error = nf90_def_var(ncid, 'z_c', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_z_c)
        call netcdf_err(error, 'DEFINING Z_C' )
@@ -1955,6 +2197,8 @@
        call netcdf_err(error, 'DEFINING Z_C LONG NAME' )
        error = nf90_put_att(ncid, id_z_c, "units", "none")
        call netcdf_err(error, 'DEFINING Z_C UNITS' )
+       error = nf90_put_att(ncid, id_z_c, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING Z_C COORD' )
 
        error = nf90_def_var(ncid, 'c_0', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_c_0)
        call netcdf_err(error, 'DEFINING C_0' )
@@ -1962,6 +2206,8 @@
        call netcdf_err(error, 'DEFINING C_0 LONG NAME' )
        error = nf90_put_att(ncid, id_c_0, "units", "none")
        call netcdf_err(error, 'DEFINING C_0 UNITS' )
+       error = nf90_put_att(ncid, id_c_0, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING C_0 COORD' )
 
        error = nf90_def_var(ncid, 'c_d', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_c_d)
        call netcdf_err(error, 'DEFINING C_D' )
@@ -1969,6 +2215,8 @@
        call netcdf_err(error, 'DEFINING C_D LONG NAME' )
        error = nf90_put_att(ncid, id_c_d, "units", "none")
        call netcdf_err(error, 'DEFINING C_D UNITS' )
+       error = nf90_put_att(ncid, id_c_d, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING C_D COORD' )
 
        error = nf90_def_var(ncid, 'w_0', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_w_0)
        call netcdf_err(error, 'DEFINING W_0' )
@@ -1976,6 +2224,8 @@
        call netcdf_err(error, 'DEFINING W_0 LONG NAME' )
        error = nf90_put_att(ncid, id_w_0, "units", "none")
        call netcdf_err(error, 'DEFINING W_0 UNITS' )
+       error = nf90_put_att(ncid, id_w_0, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING W_0 COORD' )
 
        error = nf90_def_var(ncid, 'w_d', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_w_d)
        call netcdf_err(error, 'DEFINING W_D' )
@@ -1983,6 +2233,8 @@
        call netcdf_err(error, 'DEFINING W_D LONG NAME' )
        error = nf90_put_att(ncid, id_w_d, "units", "none")
        call netcdf_err(error, 'DEFINING W_D UNITS' )
+       error = nf90_put_att(ncid, id_w_d, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING W_D COORD' )
 
        error = nf90_def_var(ncid, 'xt', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xt)
        call netcdf_err(error, 'DEFINING XT' )
@@ -1990,6 +2242,8 @@
        call netcdf_err(error, 'DEFINING XT LONG NAME' )
        error = nf90_put_att(ncid, id_xt, "units", "none")
        call netcdf_err(error, 'DEFINING XT UNITS' )
+       error = nf90_put_att(ncid, id_xt, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XT COORD' )
 
        error = nf90_def_var(ncid, 'xs', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xs)
        call netcdf_err(error, 'DEFINING XS' )
@@ -1997,6 +2251,8 @@
        call netcdf_err(error, 'DEFINING XS LONG NAME' )
        error = nf90_put_att(ncid, id_xs, "units", "none")
        call netcdf_err(error, 'DEFINING XS UNITS' )
+       error = nf90_put_att(ncid, id_xs, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XS COORD' )
 
        error = nf90_def_var(ncid, 'xu', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xu)
        call netcdf_err(error, 'DEFINING XU' )
@@ -2004,6 +2260,8 @@
        call netcdf_err(error, 'DEFINING XU LONG NAME' )
        error = nf90_put_att(ncid, id_xu, "units", "none")
        call netcdf_err(error, 'DEFINING XU UNITS' )
+       error = nf90_put_att(ncid, id_xu, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XU COORD' )
 
        error = nf90_def_var(ncid, 'xv', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xv)
        call netcdf_err(error, 'DEFINING XV' )
@@ -2011,6 +2269,8 @@
        call netcdf_err(error, 'DEFINING XV LONG NAME' )
        error = nf90_put_att(ncid, id_xv, "units", "none")
        call netcdf_err(error, 'DEFINING XV UNITS' )
+       error = nf90_put_att(ncid, id_xv, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XV COORD' )
 
        error = nf90_def_var(ncid, 'xz', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xz)
        call netcdf_err(error, 'DEFINING XZ' )
@@ -2018,6 +2278,8 @@
        call netcdf_err(error, 'DEFINING XZ LONG NAME' )
        error = nf90_put_att(ncid, id_xz, "units", "none")
        call netcdf_err(error, 'DEFINING XZ UNITS' )
+       error = nf90_put_att(ncid, id_xz, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XZ COORD' )
 
        error = nf90_def_var(ncid, 'zm', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_zm)
        call netcdf_err(error, 'DEFINING ZM' )
@@ -2025,6 +2287,8 @@
        call netcdf_err(error, 'DEFINING ZM LONG NAME' )
        error = nf90_put_att(ncid, id_zm, "units", "none")
        call netcdf_err(error, 'DEFINING ZM UNITS' )
+       error = nf90_put_att(ncid, id_zm, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING ZM COORD' )
 
        error = nf90_def_var(ncid, 'xtts', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xtts)
        call netcdf_err(error, 'DEFINING XTTS' )
@@ -2032,6 +2296,8 @@
        call netcdf_err(error, 'DEFINING XTTS LONG NAME' )
        error = nf90_put_att(ncid, id_xtts, "units", "none")
        call netcdf_err(error, 'DEFINING XTTS UNITS' )
+       error = nf90_put_att(ncid, id_xtts, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XTTS COORD' )
 
        error = nf90_def_var(ncid, 'xzts', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_xzts)
        call netcdf_err(error, 'DEFINING XZTS' )
@@ -2039,6 +2305,8 @@
        call netcdf_err(error, 'DEFINING XZTS LONG NAME' )
        error = nf90_put_att(ncid, id_xzts, "units", "none")
        call netcdf_err(error, 'DEFINING XZTS UNITS' )
+       error = nf90_put_att(ncid, id_xzts, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING XZTS COORD' )
 
        error = nf90_def_var(ncid, 'd_conv', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_d_conv)
        call netcdf_err(error, 'DEFINING D_CONV' )
@@ -2046,6 +2314,8 @@
        call netcdf_err(error, 'DEFINING D_CONV LONG NAME' )
        error = nf90_put_att(ncid, id_d_conv, "units", "none")
        call netcdf_err(error, 'DEFINING D_CONV UNITS' )
+       error = nf90_put_att(ncid, id_d_conv, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING D_CONV COORD' )
 
        error = nf90_def_var(ncid, 'ifd', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_ifd)
        call netcdf_err(error, 'DEFINING IFD' )
@@ -2053,6 +2323,8 @@
        call netcdf_err(error, 'DEFINING IFD LONG NAME' )
        error = nf90_put_att(ncid, id_ifd, "units", "none")
        call netcdf_err(error, 'DEFINING IFD UNITS' )
+       error = nf90_put_att(ncid, id_ifd, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING IFD COORD' )
 
        error = nf90_def_var(ncid, 'dt_cool', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_dt_cool)
        call netcdf_err(error, 'DEFINING DT_COOL' )
@@ -2060,6 +2332,8 @@
        call netcdf_err(error, 'DEFINING DT_COOL LONG NAME' )
        error = nf90_put_att(ncid, id_dt_cool, "units", "none")
        call netcdf_err(error, 'DEFINING DT_COOL UNITS' )
+       error = nf90_put_att(ncid, id_dt_cool, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING DT_COOL COORD' )
 
        error = nf90_def_var(ncid, 'qrain', NF90_DOUBLE, (/dim_x,dim_y,dim_time/), id_qrain)
        call netcdf_err(error, 'DEFINING QRAIN' )
@@ -2067,6 +2341,8 @@
        call netcdf_err(error, 'DEFINING QRAIN LONG NAME' )
        error = nf90_put_att(ncid, id_qrain, "units", "none")
        call netcdf_err(error, 'DEFINING QRAIN UNITS' )
+       error = nf90_put_att(ncid, id_qrain, "coordinates", "geolon geolat")
+       call netcdf_err(error, 'DEFINING QRAIN COORD' )
 
      endif  ! nsst records
 
@@ -2087,6 +2363,28 @@
      call netcdf_err(error, 'WRITING TIME RECORD' )
    endif
 
+   print*,"- CALL FieldGather FOR TARGET GRID LATITUDE FOR TILE: ", tile
+   call ESMF_FieldGather(latitude_target_grid, data_one_tile, rootPet=0, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+
+   if (localpet == 0) then
+     dum2d(:,:) = data_one_tile(istart:iend, jstart:jend)
+     error = nf90_put_var( ncid, id_lat, dum2d)
+     call netcdf_err(error, 'WRITING LATITUDE RECORD' )
+   endif
+
+   print*,"- CALL FieldGather FOR TARGET GRID LONGITUDE FOR TILE: ", tile
+   call ESMF_FieldGather(longitude_target_grid, data_one_tile, rootPet=0, tile=tile, rc=error)
+   if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldGather", error)
+
+   if (localpet == 0) then
+     dum2d(:,:) = data_one_tile(istart:iend, jstart:jend)
+     error = nf90_put_var( ncid, id_lon, dum2d)
+     call netcdf_err(error, 'WRITING LONGITUDE RECORD' )
+   endif
+
    print*,"- CALL FieldGather FOR TARGET GRID SNOW LIQ EQUIV FOR TILE: ", tile
    call ESMF_FieldGather(snow_liq_equiv_target_grid, data_one_tile, rootPet=0, tile=tile, rc=error)
    if(ESMF_logFoundError(rcToCheck=error,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
diff --git a/sorc/emcsfc_ice_blend.fd/CMakeLists.txt b/sorc/emcsfc_ice_blend.fd/CMakeLists.txt
new file mode 100644
index 0000000..ecfe7af
--- /dev/null
+++ b/sorc/emcsfc_ice_blend.fd/CMakeLists.txt
@@ -0,0 +1,15 @@
+set(fortran_src
+    emcsfc_ice_blend.f90)
+
+set(exe_name emcsfc_ice_blend)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  bacio_4
+  g2_4
+  w3nco_4
+  ${JASPER_LIBRARIES}
+  PNG::PNG
+  ZLIB::ZLIB)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/emcsfc_snow2mdl.fd/CMakeLists.txt b/sorc/emcsfc_snow2mdl.fd/CMakeLists.txt
new file mode 100644
index 0000000..8a4561a
--- /dev/null
+++ b/sorc/emcsfc_snow2mdl.fd/CMakeLists.txt
@@ -0,0 +1,32 @@
+set(fortran_src
+    driver.f
+    grib_utils.f
+    model_grid.f
+    program_setup.f
+    snow2mdl.f
+    snowdat.f)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -FR -convert big_endian -assume byterecl")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -ffree-form -fdefault-real-8 -fconvert=big-endian")
+endif()
+
+set(exe_name emcsfc_snow2mdl)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  g2_d
+  ip_d
+  sp_d
+  landsfcutil_d
+  bacio_4
+  w3nco_d
+  ${JASPER_LIBRARIES}
+  PNG::PNG
+  ZLIB::ZLIB)
+if(OpenMP_Fortran_FOUND)
+  target_link_libraries(${exe_name} OpenMP::OpenMP_Fortran)
+endif()
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/fre-nctools.fd/CMakeLists.txt b/sorc/fre-nctools.fd/CMakeLists.txt
new file mode 100644
index 0000000..cec8e70
--- /dev/null
+++ b/sorc/fre-nctools.fd/CMakeLists.txt
@@ -0,0 +1,6 @@
+add_subdirectory(shared_lib)
+add_subdirectory(tools/fregrid)
+add_subdirectory(tools/make_solo_mosaic)
+add_subdirectory(tools/make_hgrid)
+add_subdirectory(tools/filter_topo)
+add_subdirectory(tools/shave.fd)
diff --git a/sorc/fre-nctools.fd/shared_lib/CMakeLists.txt b/sorc/fre-nctools.fd/shared_lib/CMakeLists.txt
new file mode 100644
index 0000000..6d19e30
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/CMakeLists.txt
@@ -0,0 +1,18 @@
+set(c_src
+    create_xgrid.c
+    gradient_c2l.c
+    interp.c
+    mosaic_util.c
+    mpp.c
+    mpp_domain.c
+    mpp_io.c
+    mpp_domain.c
+    read_mosaic.c
+    tool_util.c)
+
+add_library(shared_lib STATIC ${c_src})
+target_compile_definitions(shared_lib PRIVATE use_netCDF)
+
+target_include_directories(shared_lib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+
+target_link_libraries(shared_lib NetCDF::NetCDF_C)
diff --git a/sorc/fre-nctools.fd/shared_lib/COPYING b/sorc/fre-nctools.fd/shared_lib/COPYING
new file mode 100644
index 0000000..93a2219
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/COPYING
@@ -0,0 +1,159 @@
+TERMS AND CONDITIONS
+0. Definitions.
+
+“This License” refers to version 3 of the GNU General Public License.
+
+“Copyright” also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.
+
+“The Program” refers to any copyrightable work licensed under this License. Each licensee is addressed as “you”. “Licensees” and “recipients” may be individuals or organizations.
+
+To “modify” a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a “modified version” of the earlier work or a work “based on” the earlier work.
+
+A “covered work” means either the unmodified Program or a work based on the Program.
+
+To “propagate” a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.
+
+To “convey” a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.
+
+An interactive user interface displays “Appropriate Legal Notices” to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.
+1. Source Code.
+
+The “source code” for a work means the preferred form of the work for making modifications to it. “Object code” means any non-source form of a work.
+
+A “Standard Interface” means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.
+
+The “System Libraries” of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A “Major Component”, in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.
+
+The “Corresponding Source” for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.
+
+The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.
+
+The Corresponding Source for a work in source code form is that same work.
+2. Basic Permissions.
+
+All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.
+
+You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.
+
+Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.
+3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.
+
+When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.
+4. Conveying Verbatim Copies.
+
+You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.
+
+You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.
+5. Conveying Modified Source Versions.
+
+You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified it, and giving a relevant date.
+    b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to “keep intact all notices”.
+    c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.
+    d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.
+
+A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an “aggregate” if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.
+6. Conveying Non-Source Forms.
+
+You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.
+    b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.
+    c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.
+    d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.
+    e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.
+
+A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.
+
+A “User Product” is either (1) a “consumer product”, which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, “normally used” refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.
+
+“Installation Information” for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.
+
+If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).
+
+The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.
+
+Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.
+7. Additional Terms.
+
+“Additional permissions” are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.
+
+When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.
+
+Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or
+    b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or
+    c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or
+    d) Limiting the use for publicity purposes of names of licensors or authors of the material; or
+    e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or
+    f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.
+
+All other non-permissive additional terms are considered “further restrictions” within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.
+
+If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.
+
+Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.
+8. Termination.
+
+You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).
+
+However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.
+
+Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.
+
+Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.
+9. Acceptance Not Required for Having Copies.
+
+You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.
+10. Automatic Licensing of Downstream Recipients.
+
+Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.
+
+An “entity transaction” is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.
+
+You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.
+11. Patents.
+
+A “contributor” is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's “contributor version”.
+
+A contributor's “essential patent claims” are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, “control” includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.
+
+Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.
+
+In the following three paragraphs, a “patent license” is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To “grant” such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.
+
+If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. “Knowingly relying” means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.
+
+If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.
+
+A patent license is “discriminatory” if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.
+
+Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.
+12. No Surrender of Others' Freedom.
+
+If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.
+13. Use with the GNU Affero General Public License.
+
+Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.
+14. Revised Versions of this License.
+
+The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License “or any later version” applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.
+
+If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.
+
+Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.
+15. Disclaimer of Warranty.
+
+THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+16. Limitation of Liability.
+
+IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+17. Interpretation of Sections 15 and 16.
+
+If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.
diff --git a/sorc/fre-nctools.fd/shared_lib/affinity.c b/sorc/fre-nctools.fd/shared_lib/affinity.c
new file mode 100644
index 0000000..710edb0
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/affinity.c
@@ -0,0 +1,68 @@
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sched.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <sys/syscall.h>
+
+static pid_t gettid(void)
+{
+  return syscall(__NR_gettid);
+}
+
+/*
+ * Returns this thread's CPU affinity, if bound to a single core,
+ * or else -1.
+ */
+int get_cpu_affinity(void)
+{
+#ifdef use_libMPI
+  cpu_set_t coremask;		/* core affinity mask */
+
+  CPU_ZERO(&coremask);
+  if (sched_getaffinity(gettid(),sizeof(cpu_set_t),&coremask) != 0) {
+    fprintf(stderr,"Unable to get thread %d affinity. %s\n",gettid(),strerror(errno));
+  }
+
+  int cpu;
+  int first_cpu = -1;	/* first CPU in range */
+  int last_cpu = -1;	/* last CPU in range */
+  for (cpu=0;cpu < CPU_SETSIZE;cpu++) {
+    if (CPU_ISSET(cpu,&coremask)) {
+      if (first_cpu == -1) {
+         first_cpu = cpu;
+      } else {
+        last_cpu = cpu;
+      }
+    }
+  }
+
+  return (last_cpu == -1) ? first_cpu : -1;
+#else
+  return 0;
+#endif
+
+}
+
+int get_cpu_affinity_(void) { return get_cpu_affinity(); }	/* Fortran interface */
+
+
+/*
+ * Set CPU affinity to one core.
+ */
+void set_cpu_affinity( int cpu )
+{
+  cpu_set_t coremask;		/* core affinity mask */
+
+  CPU_ZERO(&coremask);
+  CPU_SET(cpu,&coremask);
+  if (sched_setaffinity(gettid(),sizeof(cpu_set_t),&coremask) != 0) {
+    fprintf(stderr,"Unable to set thread %d affinity. %s\n",gettid(),strerror(errno));
+  }
+}
+
+void set_cpu_affinity_(int *cpu) { set_cpu_affinity(*cpu); }	/* Fortran interface */
diff --git a/sorc/fre-nctools.fd/shared_lib/constant.h b/sorc/fre-nctools.fd/shared_lib/constant.h
new file mode 100644
index 0000000..619ae07
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/constant.h
@@ -0,0 +1,2 @@
+#define RADIUS        (6371000.)
+#define STRING        255
diff --git a/sorc/fre-nctools.fd/shared_lib/create_xgrid.c b/sorc/fre-nctools.fd/shared_lib/create_xgrid.c
new file mode 100644
index 0000000..9844d89
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/create_xgrid.c
@@ -0,0 +1,2800 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include "mosaic_util.h"
+#include "create_xgrid.h"
+#include "constant.h"
+
+#define AREA_RATIO_THRESH (1.e-6)  
+#define MASK_THRESH       (0.5)
+#define EPSLN8            (1.e-8)
+#define EPSLN30           (1.0e-30)
+#define EPSLN10           (1.0e-10)
+#define R2D (180/M_PI)
+#define TPI (2.0*M_PI)
+double grid_box_radius(const double *x, const double *y, const double *z, int n);
+double dist_between_boxes(const double *x1, const double *y1, const double *z1, int n1,
+			  const double *x2, const double *y2, const double *z2, int n2);
+int inside_edge(double x0, double y0, double x1, double y1, double x, double y);
+int line_intersect_2D_3D(double *a1, double *a2, double *q1, double *q2, double *q3,
+		         double *intersect, double *u_a, double *u_q, int *inbound);
+
+
+/*******************************************************************************
+  int get_maxxgrid
+  return constants MAXXGRID.
+*******************************************************************************/
+int get_maxxgrid(void)  
+{
+  return MAXXGRID;
+}
+
+int get_maxxgrid_(void)
+{
+  return get_maxxgrid();
+}
+
+/*******************************************************************************
+void get_grid_area(const int *nlon, const int *nlat, const double *lon, const double *lat, const double *area)
+  return the grid area.
+*******************************************************************************/
+#ifndef __AIX
+void get_grid_area_(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  get_grid_area(nlon, nlat, lon, lat, area);
+}
+#endif
+
+void get_grid_area(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  int nx, ny, nxp, i, j, n_in;
+  double x_in[20], y_in[20];
+  
+  nx = *nlon;
+  ny = *nlat;
+  nxp = nx + 1;
+
+  for(j=0; j<ny; j++) for(i=0; i < nx; i++) {
+    x_in[0] = lon[j*nxp+i];
+    x_in[1] = lon[j*nxp+i+1];
+    x_in[2] = lon[(j+1)*nxp+i+1];
+    x_in[3] = lon[(j+1)*nxp+i];
+    y_in[0] = lat[j*nxp+i];
+    y_in[1] = lat[j*nxp+i+1];
+    y_in[2] = lat[(j+1)*nxp+i+1];
+    y_in[3] = lat[(j+1)*nxp+i];
+    n_in = fix_lon(x_in, y_in, 4, M_PI);    
+    area[j*nx+i] = poly_area(x_in, y_in, n_in);
+  }
+
+};  /* get_grid_area */
+
+#ifndef __AIX
+void get_grid_great_circle_area_(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  get_grid_great_circle_area(nlon, nlat, lon, lat, area);
+
+}
+#endif
+
+void get_grid_great_circle_area(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  int nx, ny, nxp, nyp, i, j, n_in;
+  int n0, n1, n2, n3;
+  double x_in[20], y_in[20], z_in[20];
+  struct Node *grid=NULL;
+  double *x=NULL, *y=NULL, *z=NULL;
+
+
+  nx = *nlon;
+  ny = *nlat;
+  nxp = nx + 1;
+  nyp = ny + 1;
+
+  x = (double *)malloc(nxp*nyp*sizeof(double));
+  y = (double *)malloc(nxp*nyp*sizeof(double));
+  z = (double *)malloc(nxp*nyp*sizeof(double));
+
+  latlon2xyz(nxp*nyp, lon, lat, x, y, z);
+  
+  for(j=0; j<ny; j++) for(i=0; i < nx; i++) {
+    /* clockwise */
+    n0 = j*nxp+i;
+    n1 = (j+1)*nxp+i;
+    n2 = (j+1)*nxp+i+1;
+    n3 = j*nxp+i+1;
+    rewindList();
+    grid = getNext();
+    addEnd(grid, x[n0], y[n0], z[n0], 0, 0, 0, -1);
+    addEnd(grid, x[n1], y[n1], z[n1], 0, 0, 0, -1);
+    addEnd(grid, x[n2], y[n2], z[n2], 0, 0, 0, -1);
+    addEnd(grid, x[n3], y[n3], z[n3], 0, 0, 0, -1);
+    area[j*nx+i] = gridArea(grid);
+  }
+
+  free(x);
+  free(y);
+  free(z);
+  
+};  /* get_grid_great_circle_area */
+
+
+void get_grid_area_dimensionless(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  int nx, ny, nxp, i, j, n_in;
+  double x_in[20], y_in[20];
+  
+  nx = *nlon;
+  ny = *nlat;
+  nxp = nx + 1;
+
+  for(j=0; j<ny; j++) for(i=0; i < nx; i++) {
+    x_in[0] = lon[j*nxp+i];
+    x_in[1] = lon[j*nxp+i+1];
+    x_in[2] = lon[(j+1)*nxp+i+1];
+    x_in[3] = lon[(j+1)*nxp+i];
+    y_in[0] = lat[j*nxp+i];
+    y_in[1] = lat[j*nxp+i+1];
+    y_in[2] = lat[(j+1)*nxp+i+1];
+    y_in[3] = lat[(j+1)*nxp+i];
+    n_in = fix_lon(x_in, y_in, 4, M_PI);    
+    area[j*nx+i] = poly_area_dimensionless(x_in, y_in, n_in);
+  }
+
+};  /* get_grid_area */
+
+
+
+void get_grid_area_no_adjust(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area)
+{
+  int nx, ny, nxp, i, j, n_in;
+  double x_in[20], y_in[20];
+  
+  nx = *nlon;
+  ny = *nlat;
+  nxp = nx + 1;
+
+  for(j=0; j<ny; j++) for(i=0; i < nx; i++) {
+    x_in[0] = lon[j*nxp+i];
+    x_in[1] = lon[j*nxp+i+1];
+    x_in[2] = lon[(j+1)*nxp+i+1];
+    x_in[3] = lon[(j+1)*nxp+i];
+    y_in[0] = lat[j*nxp+i];
+    y_in[1] = lat[j*nxp+i+1];
+    y_in[2] = lat[(j+1)*nxp+i+1];
+    y_in[3] = lat[(j+1)*nxp+i];
+    n_in = 4;
+    area[j*nx+i] = poly_area_no_adjust(x_in, y_in, n_in);
+  }
+
+};  /* get_grid_area_no_adjust */
+
+/*******************************************************************************
+  void create_xgrid_1dx2d_order1
+  This routine generate exchange grids between two grids for the first order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_in,lat_in are 1-D grid bounds, lon_out,lat_out are geographic grid location of grid cell bounds. 
+*******************************************************************************/
+int create_xgrid_1dx2d_order1_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out, double *xgrid_area)
+{
+  int nxgrid;
+  
+  nxgrid = create_xgrid_1dx2d_order1(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in,
+			       i_in, j_in, i_out, j_out, xgrid_area);
+  return nxgrid;
+    
+};  
+
+int create_xgrid_1dx2d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out, const double *lon_in,
+			      const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area)
+{
+
+  int nx1, ny1, nx2, ny2, nx1p, nx2p;
+  int i1, j1, i2, j2, nxgrid;
+  double ll_lon, ll_lat, ur_lon, ur_lat, x_in[MV], y_in[MV], x_out[MV], y_out[MV];
+  double *area_in, *area_out, min_area;
+  double *tmpx, *tmpy;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;
+
+  nxgrid = 0;
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+
+  area_in = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out = (double *)malloc(nx2*ny2*sizeof(double));
+  tmpx = (double *)malloc((nx1+1)*(ny1+1)*sizeof(double));
+  tmpy = (double *)malloc((nx1+1)*(ny1+1)*sizeof(double));
+  for(j1=0; j1<=ny1; j1++) for(i1=0; i1<=nx1; i1++) {
+    tmpx[j1*nx1p+i1] = lon_in[i1];
+    tmpy[j1*nx1p+i1] = lat_in[j1];
+  }
+  /* This is just a temporary fix to solve the issue that there is one point in zonal direction */
+  if(nx1 > 1)
+     get_grid_area(nlon_in, nlat_in, tmpx, tmpy, area_in);
+  else
+    get_grid_area_no_adjust(nlon_in, nlat_in, tmpx, tmpy, area_in);
+  
+  get_grid_area(nlon_out, nlat_out, lon_out, lat_out, area_out);  
+  free(tmpx);
+  free(tmpy);  
+
+  for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+
+    ll_lon = lon_in[i1];   ll_lat = lat_in[j1];
+    ur_lon = lon_in[i1+1]; ur_lat = lat_in[j1+1];
+    for(j2=0; j2<ny2; j2++) for(i2=0; i2<nx2; i2++) {
+      int n_in, n_out;
+      double Xarea;
+      
+      y_in[0] = lat_out[j2*nx2p+i2];
+      y_in[1] = lat_out[j2*nx2p+i2+1];
+      y_in[2] = lat_out[(j2+1)*nx2p+i2+1];
+      y_in[3] = lat_out[(j2+1)*nx2p+i2];
+      if (  (y_in[0]<=ll_lat) && (y_in[1]<=ll_lat)
+	    && (y_in[2]<=ll_lat) && (y_in[3]<=ll_lat) ) continue;
+      if (  (y_in[0]>=ur_lat) && (y_in[1]>=ur_lat)
+	    && (y_in[2]>=ur_lat) && (y_in[3]>=ur_lat) ) continue;
+
+      x_in[0] = lon_out[j2*nx2p+i2];
+      x_in[1] = lon_out[j2*nx2p+i2+1];
+      x_in[2] = lon_out[(j2+1)*nx2p+i2+1];
+      x_in[3] = lon_out[(j2+1)*nx2p+i2];
+      n_in = fix_lon(x_in, y_in, 4, (ll_lon+ur_lon)/2);
+      
+      if ( (n_out = clip ( x_in, y_in, n_in, ll_lon, ll_lat, ur_lon, ur_lat, x_out, y_out )) > 0 ) {
+	Xarea = poly_area (x_out, y_out, n_out ) * mask_in[j1*nx1+i1];
+	min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	if( Xarea/min_area > AREA_RATIO_THRESH ) {
+      	  xgrid_area[nxgrid] = Xarea;
+	  i_in[nxgrid]    = i1;
+	  j_in[nxgrid]    = j1;
+	  i_out[nxgrid]   = i2;
+	  j_out[nxgrid]   = j2;
+	  ++nxgrid;
+	  if(nxgrid > MAXXGRID) error_handler("nxgrid is greater than MAXXGRID, increase MAXXGRID");
+	}
+      }
+    }
+  }
+
+  free(area_in);
+  free(area_out);
+  
+  return nxgrid;
+  
+}; /* create_xgrid_1dx2d_order1 */
+
+
+/********************************************************************************
+  void create_xgrid_1dx2d_order2
+  This routine generate exchange grids between two grids for the second order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_in,lat_in are 1-D grid bounds, lon_out,lat_out are geographic grid location of grid cell bounds.
+********************************************************************************/
+int create_xgrid_1dx2d_order2_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			       double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+  int nxgrid;
+  nxgrid = create_xgrid_1dx2d_order2(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in, i_in,
+                                     j_in, i_out, j_out, xgrid_area, xgrid_clon, xgrid_clat);
+  return nxgrid;
+
+};
+int create_xgrid_1dx2d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+
+  int nx1, ny1, nx2, ny2, nx1p, nx2p;
+  int i1, j1, i2, j2, nxgrid, n;
+  double ll_lon, ll_lat, ur_lon, ur_lat, x_in[MV], y_in[MV], x_out[MV], y_out[MV];
+  double *area_in, *area_out, min_area;
+  double *tmpx, *tmpy;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;
+
+  nxgrid = 0;
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+
+  area_in      = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out     = (double *)malloc(nx2*ny2*sizeof(double));
+  tmpx = (double *)malloc((nx1+1)*(ny1+1)*sizeof(double));
+  tmpy = (double *)malloc((nx1+1)*(ny1+1)*sizeof(double));
+  for(j1=0; j1<=ny1; j1++) for(i1=0; i1<=nx1; i1++) {
+    tmpx[j1*nx1p+i1] = lon_in[i1];
+    tmpy[j1*nx1p+i1] = lat_in[j1];
+  }
+  get_grid_area(nlon_in, nlat_in, tmpx, tmpy, area_in);     
+  get_grid_area(nlon_out, nlat_out, lon_out, lat_out, area_out);  
+  free(tmpx);
+  free(tmpy);    
+  
+  for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+
+    ll_lon = lon_in[i1];   ll_lat = lat_in[j1];
+    ur_lon = lon_in[i1+1]; ur_lat = lat_in[j1+1];
+    for(j2=0; j2<ny2; j2++) for(i2=0; i2<nx2; i2++) {
+      int n_in, n_out;
+      double xarea, lon_in_avg;
+      
+      y_in[0] = lat_out[j2*nx2p+i2];
+      y_in[1] = lat_out[j2*nx2p+i2+1];
+      y_in[2] = lat_out[(j2+1)*nx2p+i2+1];
+      y_in[3] = lat_out[(j2+1)*nx2p+i2];
+      if (  (y_in[0]<=ll_lat) && (y_in[1]<=ll_lat)
+	    && (y_in[2]<=ll_lat) && (y_in[3]<=ll_lat) ) continue;
+      if (  (y_in[0]>=ur_lat) && (y_in[1]>=ur_lat)
+	    && (y_in[2]>=ur_lat) && (y_in[3]>=ur_lat) ) continue;
+
+      x_in[0] = lon_out[j2*nx2p+i2];
+      x_in[1] = lon_out[j2*nx2p+i2+1];
+      x_in[2] = lon_out[(j2+1)*nx2p+i2+1];
+      x_in[3] = lon_out[(j2+1)*nx2p+i2];
+      n_in = fix_lon(x_in, y_in, 4, (ll_lon+ur_lon)/2);
+      lon_in_avg = avgval_double(n_in, x_in);
+      
+      if (  (n_out = clip ( x_in, y_in, n_in, ll_lon, ll_lat, ur_lon, ur_lat, x_out, y_out )) > 0 ) {
+	xarea = poly_area (x_out, y_out, n_out ) * mask_in[j1*nx1+i1];	
+        min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	if(xarea/min_area > AREA_RATIO_THRESH ) {	  
+	  xgrid_area[nxgrid] = xarea;
+	  xgrid_clon[nxgrid] = poly_ctrlon(x_out, y_out, n_out, lon_in_avg);
+	  xgrid_clat[nxgrid] = poly_ctrlat (x_out, y_out, n_out );
+	  i_in[nxgrid]    = i1;
+	  j_in[nxgrid]    = j1;
+	  i_out[nxgrid]   = i2;
+	  j_out[nxgrid]   = j2;
+	  ++nxgrid;
+	  if(nxgrid > MAXXGRID) error_handler("nxgrid is greater than MAXXGRID, increase MAXXGRID");
+	}
+      }
+    }
+  }
+  free(area_in);
+  free(area_out);
+  
+  return nxgrid;
+  
+}; /* create_xgrid_1dx2d_order2 */
+
+/*******************************************************************************
+  void create_xgrid_2dx1d_order1
+  This routine generate exchange grids between two grids for the first order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_out,lat_out are 1-D grid bounds, lon_in,lat_in are geographic grid location of grid cell bounds.
+  mask is on grid lon_in/lat_in. 
+*******************************************************************************/
+int create_xgrid_2dx1d_order1_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out,
+			       int *j_out, double *xgrid_area)
+{
+  int nxgrid;
+  
+  nxgrid = create_xgrid_2dx1d_order1(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in,
+			       i_in, j_in, i_out, j_out, xgrid_area);
+  return nxgrid;
+    
+};  
+int create_xgrid_2dx1d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out, const double *lon_in,
+			      const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area)
+{
+
+  int nx1, ny1, nx2, ny2, nx1p, nx2p;
+  int i1, j1, i2, j2, nxgrid;
+  double ll_lon, ll_lat, ur_lon, ur_lat, x_in[MV], y_in[MV], x_out[MV], y_out[MV];
+  double *area_in, *area_out, min_area;
+  double *tmpx, *tmpy;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;
+
+  nxgrid = 0;
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+  area_in = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out = (double *)malloc(nx2*ny2*sizeof(double));
+  tmpx = (double *)malloc((nx2+1)*(ny2+1)*sizeof(double));
+  tmpy = (double *)malloc((nx2+1)*(ny2+1)*sizeof(double));
+  for(j2=0; j2<=ny2; j2++) for(i2=0; i2<=nx2; i2++) {
+    tmpx[j2*nx2p+i2] = lon_out[i2];
+    tmpy[j2*nx2p+i2] = lat_out[j2];
+  }
+  get_grid_area(nlon_in, nlat_in, lon_in, lat_in, area_in);     
+  get_grid_area(nlon_out, nlat_out, tmpx, tmpy, area_out);  
+
+  free(tmpx);
+  free(tmpy);
+  
+  for(j2=0; j2<ny2; j2++) for(i2=0; i2<nx2; i2++) {
+
+    ll_lon = lon_out[i2];   ll_lat = lat_out[j2];
+    ur_lon = lon_out[i2+1]; ur_lat = lat_out[j2+1];
+    for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+      int n_in, n_out;
+      double Xarea;
+      
+      y_in[0] = lat_in[j1*nx1p+i1];
+      y_in[1] = lat_in[j1*nx1p+i1+1];
+      y_in[2] = lat_in[(j1+1)*nx1p+i1+1];
+      y_in[3] = lat_in[(j1+1)*nx1p+i1];
+      if (  (y_in[0]<=ll_lat) && (y_in[1]<=ll_lat)
+	    && (y_in[2]<=ll_lat) && (y_in[3]<=ll_lat) ) continue;
+      if (  (y_in[0]>=ur_lat) && (y_in[1]>=ur_lat)
+	    && (y_in[2]>=ur_lat) && (y_in[3]>=ur_lat) ) continue;
+
+      x_in[0] = lon_in[j1*nx1p+i1];
+      x_in[1] = lon_in[j1*nx1p+i1+1];
+      x_in[2] = lon_in[(j1+1)*nx1p+i1+1];
+      x_in[3] = lon_in[(j1+1)*nx1p+i1];
+
+      n_in = fix_lon(x_in, y_in, 4, (ll_lon+ur_lon)/2);
+      
+      if ( (n_out = clip ( x_in, y_in, n_in, ll_lon, ll_lat, ur_lon, ur_lat, x_out, y_out )) > 0 ) {
+	Xarea = poly_area ( x_out, y_out, n_out ) * mask_in[j1*nx1+i1];
+	min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	if( Xarea/min_area > AREA_RATIO_THRESH ) {
+      	  xgrid_area[nxgrid] = Xarea;
+	  i_in[nxgrid]    = i1;
+	  j_in[nxgrid]    = j1;
+	  i_out[nxgrid]   = i2;
+	  j_out[nxgrid]   = j2;
+	  ++nxgrid;
+	  if(nxgrid > MAXXGRID) error_handler("nxgrid is greater than MAXXGRID, increase MAXXGRID");
+	}
+      }
+    }
+  }
+
+  free(area_in);
+  free(area_out);
+  
+  return nxgrid;
+  
+}; /* create_xgrid_2dx1d_order1 */
+
+
+/********************************************************************************
+  void create_xgrid_2dx1d_order2
+  This routine generate exchange grids between two grids for the second order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_out,lat_out are 1-D grid bounds, lon_in,lat_in are geographic grid location of grid cell bounds.
+  mask is on grid lon_in/lat_in. 
+********************************************************************************/
+int create_xgrid_2dx1d_order2_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			       double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+  int nxgrid;
+  nxgrid = create_xgrid_2dx1d_order2(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in, i_in,
+                                     j_in, i_out, j_out, xgrid_area, xgrid_clon, xgrid_clat);
+  return nxgrid;
+
+};
+
+int create_xgrid_2dx1d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+
+  int nx1, ny1, nx2, ny2, nx1p, nx2p;
+  int i1, j1, i2, j2, nxgrid, n;
+  double ll_lon, ll_lat, ur_lon, ur_lat, x_in[MV], y_in[MV], x_out[MV], y_out[MV];
+  double *tmpx, *tmpy;
+  double *area_in, *area_out, min_area;
+  double  lon_in_avg;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;
+
+  nxgrid = 0;
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+
+  area_in      = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out     = (double *)malloc(nx2*ny2*sizeof(double));
+  tmpx = (double *)malloc((nx2+1)*(ny2+1)*sizeof(double));
+  tmpy = (double *)malloc((nx2+1)*(ny2+1)*sizeof(double));
+  for(j2=0; j2<=ny2; j2++) for(i2=0; i2<=nx2; i2++) {
+    tmpx[j2*nx2p+i2] = lon_out[i2];
+    tmpy[j2*nx2p+i2] = lat_out[j2];
+  }
+  get_grid_area(nlon_in, nlat_in, lon_in, lat_in, area_in);     
+  get_grid_area(nlon_out, nlat_out, tmpx, tmpy, area_out);  
+
+  free(tmpx);
+  free(tmpy);  
+  
+  for(j2=0; j2<ny2; j2++) for(i2=0; i2<nx2; i2++) {
+
+    ll_lon = lon_out[i2];   ll_lat = lat_out[j2];
+    ur_lon = lon_out[i2+1]; ur_lat = lat_out[j2+1];
+    for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+      int n_in, n_out;
+      double xarea;
+      
+      y_in[0] = lat_in[j1*nx1p+i1];
+      y_in[1] = lat_in[j1*nx1p+i1+1];
+      y_in[2] = lat_in[(j1+1)*nx1p+i1+1];
+      y_in[3] = lat_in[(j1+1)*nx1p+i1];
+      if (  (y_in[0]<=ll_lat) && (y_in[1]<=ll_lat)
+	    && (y_in[2]<=ll_lat) && (y_in[3]<=ll_lat) ) continue;
+      if (  (y_in[0]>=ur_lat) && (y_in[1]>=ur_lat)
+	    && (y_in[2]>=ur_lat) && (y_in[3]>=ur_lat) ) continue;
+
+      x_in[0] = lon_in[j1*nx1p+i1];
+      x_in[1] = lon_in[j1*nx1p+i1+1];
+      x_in[2] = lon_in[(j1+1)*nx1p+i1+1];
+      x_in[3] = lon_in[(j1+1)*nx1p+i1];
+
+      n_in = fix_lon(x_in, y_in, 4, (ll_lon+ur_lon)/2);
+      lon_in_avg = avgval_double(n_in, x_in);
+      
+      if (  (n_out = clip ( x_in, y_in, n_in, ll_lon, ll_lat, ur_lon, ur_lat, x_out, y_out )) > 0 ) {
+	xarea = poly_area (x_out, y_out, n_out ) * mask_in[j1*nx1+i1];	
+	min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	if(xarea/min_area > AREA_RATIO_THRESH ) {	  
+	  xgrid_area[nxgrid] = xarea;
+	  xgrid_clon[nxgrid] = poly_ctrlon(x_out, y_out, n_out, lon_in_avg);
+	  xgrid_clat[nxgrid] = poly_ctrlat (x_out, y_out, n_out );
+	  i_in[nxgrid]  = i1;
+	  j_in[nxgrid]  = j1;
+	  i_out[nxgrid] = i2;
+	  j_out[nxgrid] = j2;
+	  ++nxgrid;
+	  if(nxgrid > MAXXGRID) error_handler("nxgrid is greater than MAXXGRID, increase MAXXGRID");
+	}
+      }
+    }
+  }
+
+  free(area_in);
+  free(area_out);  
+  
+  return nxgrid;
+  
+}; /* create_xgrid_2dx1d_order2 */
+
+/*******************************************************************************
+  void create_xgrid_2DX2D_order1
+  This routine generate exchange grids between two grids for the first order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_in,lat_in, lon_out,lat_out are geographic grid location of grid cell bounds.
+  mask is on grid lon_in/lat_in.
+*******************************************************************************/
+#ifndef __AIX
+int create_xgrid_2dx2d_order1_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out,
+			       int *j_out, double *xgrid_area)
+{
+  int nxgrid;
+  
+  nxgrid = create_xgrid_2dx2d_order1(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in,
+			       i_in, j_in, i_out, j_out, xgrid_area);
+  return nxgrid;
+    
+};  
+#endif
+int create_xgrid_2dx2d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area)
+{
+
+#define MAX_V 8  
+  int nx1, nx2, ny1, ny2, nx1p, nx2p, nxgrid;
+  double *area_in, *area_out;
+  int nblocks =1;
+  int *istart2=NULL, *iend2=NULL;
+  int npts_left, nblks_left, pos, m, npts_my, ij;
+  double *lon_out_min_list,*lon_out_max_list,*lon_out_avg,*lat_out_min_list,*lat_out_max_list;  
+  double *lon_out_list, *lat_out_list;
+  int *pnxgrid=NULL, *pstart;
+  int *pi_in=NULL, *pj_in=NULL, *pi_out=NULL, *pj_out=NULL;
+  double *pxgrid_area=NULL;
+  int    *n2_list;
+  int nthreads, nxgrid_block_max;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;  
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+
+  area_in  = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out = (double *)malloc(nx2*ny2*sizeof(double));
+  get_grid_area(nlon_in, nlat_in, lon_in, lat_in, area_in);     
+  get_grid_area(nlon_out, nlat_out, lon_out, lat_out, area_out);
+
+  nthreads = 1;
+#if defined(_OPENMP)
+#pragma omp parallel
+  nthreads = omp_get_num_threads();
+#endif  
+
+  nblocks = nthreads;
+
+  istart2 = (int *)malloc(nblocks*sizeof(int));
+  iend2 = (int *)malloc(nblocks*sizeof(int));
+
+  pstart = (int *)malloc(nblocks*sizeof(int));
+  pnxgrid = (int *)malloc(nblocks*sizeof(int));
+
+  nxgrid_block_max = MAXXGRID/nblocks;
+  
+  for(m=0; m<nblocks; m++) {
+    pnxgrid[m] = 0;
+    pstart[m] = m*nxgrid_block_max;
+  }
+
+  if(nblocks == 1) {
+    pi_in = i_in;
+    pj_in = j_in;
+    pi_out = i_out;
+    pj_out = j_out;
+    pxgrid_area = xgrid_area;
+  }
+  else {
+    pi_in = (int *)malloc(MAXXGRID*sizeof(int));
+    pj_in = (int *)malloc(MAXXGRID*sizeof(int));
+    pi_out = (int *)malloc(MAXXGRID*sizeof(int));
+    pj_out = (int *)malloc(MAXXGRID*sizeof(int));
+    pxgrid_area = (double *)malloc(MAXXGRID*sizeof(double));
+  }
+  
+  npts_left = nx2*ny2;
+  nblks_left = nblocks;
+  pos = 0;
+  for(m=0; m<nblocks; m++) {
+    istart2[m] = pos;
+    npts_my = npts_left/nblks_left;
+    iend2[m] = istart2[m] + npts_my - 1;
+    pos = iend2[m] + 1;
+    npts_left -= npts_my;
+    nblks_left--;
+  }
+
+  lon_out_min_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lon_out_max_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lat_out_min_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lat_out_max_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lon_out_avg = (double *)malloc(nx2*ny2*sizeof(double));
+  n2_list     = (int *)malloc(nx2*ny2*sizeof(int));
+  lon_out_list = (double *)malloc(MAX_V*nx2*ny2*sizeof(double));
+  lat_out_list = (double *)malloc(MAX_V*nx2*ny2*sizeof(double));
+#if defined(_OPENMP)
+#pragma omp parallel for default(none) shared(nx2,ny2,nx2p,lon_out,lat_out,lat_out_min_list, \
+                                              lat_out_max_list,lon_out_min_list,lon_out_max_list, \
+                                              lon_out_avg,n2_list,lon_out_list,lat_out_list) 
+#endif                        
+  for(ij=0; ij<nx2*ny2; ij++){
+    int i2, j2, n, n0, n1, n2, n3, n2_in, l;
+    double x2_in[MV], y2_in[MV];
+    i2 = ij%nx2;
+    j2 = ij/nx2;
+    n = j2*nx2+i2;
+    n0 = j2*nx2p+i2; n1 = j2*nx2p+i2+1;
+    n2 = (j2+1)*nx2p+i2+1; n3 = (j2+1)*nx2p+i2;
+    x2_in[0] = lon_out[n0]; y2_in[0] = lat_out[n0];
+    x2_in[1] = lon_out[n1]; y2_in[1] = lat_out[n1];
+    x2_in[2] = lon_out[n2]; y2_in[2] = lat_out[n2];
+    x2_in[3] = lon_out[n3]; y2_in[3] = lat_out[n3];
+    
+    lat_out_min_list[n] = minval_double(4, y2_in);
+    lat_out_max_list[n] = maxval_double(4, y2_in);
+    n2_in = fix_lon(x2_in, y2_in, 4, M_PI);
+    if(n2_in > MAX_V) error_handler("create_xgrid.c: n2_in is greater than MAX_V");
+    lon_out_min_list[n] = minval_double(n2_in, x2_in);
+    lon_out_max_list[n] = maxval_double(n2_in, x2_in);
+    lon_out_avg[n] = avgval_double(n2_in, x2_in);
+    n2_list[n] = n2_in;
+    for(l=0; l<n2_in; l++) {
+      lon_out_list[n*MAX_V+l] = x2_in[l];
+      lat_out_list[n*MAX_V+l] = y2_in[l];
+    }    
+  }
+
+nxgrid = 0;
+
+#if defined(_OPENMP)
+#pragma omp parallel for default(none) shared(nblocks,nx1,ny1,nx1p,mask_in,lon_in,lat_in, \
+                                              istart2,iend2,nx2,lat_out_min_list,lat_out_max_list, \
+                                              n2_list,lon_out_list,lat_out_list,lon_out_min_list, \
+                                              lon_out_max_list,lon_out_avg,area_in,area_out, \
+                                              pxgrid_area,pnxgrid,pi_in,pj_in,pi_out,pj_out,pstart,nthreads)
+#endif  
+  for(m=0; m<nblocks; m++) {
+    int i1, j1, ij;
+    for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+      int n0, n1, n2, n3, l,n1_in;
+      double lat_in_min,lat_in_max,lon_in_min,lon_in_max,lon_in_avg;
+      double x1_in[MV], y1_in[MV], x_out[MV], y_out[MV];
+ 
+      n0 = j1*nx1p+i1;       n1 = j1*nx1p+i1+1;
+      n2 = (j1+1)*nx1p+i1+1; n3 = (j1+1)*nx1p+i1;      
+      x1_in[0] = lon_in[n0]; y1_in[0] = lat_in[n0];
+      x1_in[1] = lon_in[n1]; y1_in[1] = lat_in[n1];
+      x1_in[2] = lon_in[n2]; y1_in[2] = lat_in[n2];
+      x1_in[3] = lon_in[n3]; y1_in[3] = lat_in[n3];
+      lat_in_min = minval_double(4, y1_in);
+      lat_in_max = maxval_double(4, y1_in);
+      n1_in = fix_lon(x1_in, y1_in, 4, M_PI);
+      lon_in_min = minval_double(n1_in, x1_in);
+      lon_in_max = maxval_double(n1_in, x1_in);
+      lon_in_avg = avgval_double(n1_in, x1_in);
+      for(ij=istart2[m]; ij<=iend2[m]; ij++) {
+	int n_in, n_out, i2, j2, n2_in;
+	double xarea, dx, lon_out_min, lon_out_max;
+	double x2_in[MAX_V], y2_in[MAX_V];
+	
+	i2 = ij%nx2;
+	j2 = ij/nx2;
+	
+	if(lat_out_min_list[ij] >= lat_in_max || lat_out_max_list[ij] <= lat_in_min ) continue;
+	/* adjust x2_in according to lon_in_avg*/
+	n2_in = n2_list[ij];
+	for(l=0; l<n2_in; l++) {
+	  x2_in[l] = lon_out_list[ij*MAX_V+l];
+	  y2_in[l] = lat_out_list[ij*MAX_V+l];
+	}
+	lon_out_min = lon_out_min_list[ij];
+	lon_out_max = lon_out_max_list[ij];  
+        dx = lon_out_avg[ij] - lon_in_avg;
+	if(dx < -M_PI ) {
+	  lon_out_min += TPI;
+	  lon_out_max += TPI;
+	  for (l=0; l<n2_in; l++) x2_in[l] += TPI;
+	}
+        else if (dx >  M_PI) {
+	  lon_out_min -= TPI;
+	  lon_out_max -= TPI;
+	  for (l=0; l<n2_in; l++) x2_in[l] -= TPI;
+	}
+
+	/* x2_in should in the same range as x1_in after lon_fix, so no need to
+	   consider cyclic condition
+	*/
+	if(lon_out_min >= lon_in_max || lon_out_max <= lon_in_min ) continue;
+	if (  (n_out = clip_2dx2d( x1_in, y1_in, n1_in, x2_in, y2_in, n2_in, x_out, y_out )) > 0) {
+          double min_area;
+	  int    nn;
+	  xarea = poly_area (x_out, y_out, n_out ) * mask_in[j1*nx1+i1];	
+	  min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	  if( xarea/min_area > AREA_RATIO_THRESH ) {
+	    pnxgrid[m]++;
+            if(pnxgrid[m]>= MAXXGRID/nthreads)
+	      error_handler("nxgrid is greater than MAXXGRID/nthreads, increase MAXXGRID, decrease nthreads, or increase number of MPI ranks");
+	    nn = pstart[m] + pnxgrid[m]-1;	    
+
+	    pxgrid_area[nn] = xarea;
+	    pi_in[nn]       = i1;
+	    pj_in[nn]       = j1;
+	    pi_out[nn]      = i2;
+	    pj_out[nn]      = j2;
+	  }
+	  
+	}
+	
+      }
+    }
+  }
+
+  /*copy data if nblocks > 1 */
+  if(nblocks == 1) {
+    nxgrid = pnxgrid[0];
+    pi_in = NULL;
+    pj_in = NULL;
+    pi_out = NULL;
+    pj_out = NULL;
+    pxgrid_area = NULL;
+  }
+  else {
+    int nn, i;
+    nxgrid = 0;
+    for(m=0; m<nblocks; m++) {
+      for(i=0; i<pnxgrid[m]; i++) {
+	nn = pstart[m] + i;
+	i_in[nxgrid] = pi_in[nn];
+	j_in[nxgrid] = pj_in[nn];
+	i_out[nxgrid] = pi_out[nn];
+	j_out[nxgrid] = pj_out[nn];
+	xgrid_area[nxgrid] = pxgrid_area[nn];
+	nxgrid++;
+      }
+    }
+    free(pi_in);
+    free(pj_in);
+    free(pi_out);
+    free(pj_out);
+    free(pxgrid_area);
+  }
+  
+  free(area_in);
+  free(area_out);  
+  free(lon_out_min_list);
+  free(lon_out_max_list);
+  free(lat_out_min_list);
+  free(lat_out_max_list);
+  free(lon_out_avg);
+  free(n2_list);  
+  free(lon_out_list);
+  free(lat_out_list);
+
+  return nxgrid;
+  
+};/* get_xgrid_2Dx2D_order1 */
+
+/********************************************************************************
+  void create_xgrid_2dx1d_order2
+  This routine generate exchange grids between two grids for the second order
+  conservative interpolation. nlon_in,nlat_in,nlon_out,nlat_out are the size of the grid cell
+  and lon_in,lat_in, lon_out,lat_out are geographic grid location of grid cell bounds.
+  mask is on grid lon_in/lat_in. 
+********************************************************************************/
+#ifndef __AIX
+int create_xgrid_2dx2d_order2_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			       const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			       const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			       double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+  int nxgrid;
+  nxgrid = create_xgrid_2dx2d_order2(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out, mask_in, i_in,
+                                     j_in, i_out, j_out, xgrid_area, xgrid_clon, xgrid_clat);
+  return nxgrid;
+
+};
+#endif
+int create_xgrid_2dx2d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+
+#define MAX_V 8  
+  int nx1, nx2, ny1, ny2, nx1p, nx2p, nxgrid;
+  double xctrlon, xctrlat;
+  double *area_in, *area_out;
+  int nblocks =1;
+  int *istart2=NULL, *iend2=NULL;
+  int npts_left, nblks_left, pos, m, npts_my, ij;
+  double *lon_out_min_list,*lon_out_max_list,*lon_out_avg,*lat_out_min_list,*lat_out_max_list;  
+  double *lon_out_list, *lat_out_list;
+  int *pnxgrid=NULL, *pstart;
+  int *pi_in=NULL, *pj_in=NULL, *pi_out=NULL, *pj_out=NULL;
+  double *pxgrid_area=NULL, *pxgrid_clon=NULL, *pxgrid_clat=NULL;
+  int    *n2_list;
+  int nthreads, nxgrid_block_max;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;  
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+
+  area_in  = (double *)malloc(nx1*ny1*sizeof(double));
+  area_out = (double *)malloc(nx2*ny2*sizeof(double));
+  get_grid_area(nlon_in, nlat_in, lon_in, lat_in, area_in);     
+  get_grid_area(nlon_out, nlat_out, lon_out, lat_out, area_out);
+
+  nthreads = 1;
+#if defined(_OPENMP)
+#pragma omp parallel
+  nthreads = omp_get_num_threads();
+#endif  
+
+  nblocks = nthreads;
+
+  istart2 = (int *)malloc(nblocks*sizeof(int));
+  iend2 = (int *)malloc(nblocks*sizeof(int));
+
+  pstart = (int *)malloc(nblocks*sizeof(int));
+  pnxgrid = (int *)malloc(nblocks*sizeof(int));
+
+  nxgrid_block_max = MAXXGRID/nblocks;
+  
+  for(m=0; m<nblocks; m++) {
+    pnxgrid[m] = 0;
+    pstart[m] = m*nxgrid_block_max;
+  }
+
+  if(nblocks == 1) {
+    pi_in = i_in;
+    pj_in = j_in;
+    pi_out = i_out;
+    pj_out = j_out;
+    pxgrid_area = xgrid_area;
+    pxgrid_clon = xgrid_clon;
+    pxgrid_clat = xgrid_clat;
+  }
+  else {
+    pi_in = (int *)malloc(MAXXGRID*sizeof(int));
+    pj_in = (int *)malloc(MAXXGRID*sizeof(int));
+    pi_out = (int *)malloc(MAXXGRID*sizeof(int));
+    pj_out = (int *)malloc(MAXXGRID*sizeof(int));
+    pxgrid_area = (double *)malloc(MAXXGRID*sizeof(double));
+    pxgrid_clon = (double *)malloc(MAXXGRID*sizeof(double));
+    pxgrid_clat = (double *)malloc(MAXXGRID*sizeof(double));    
+  }
+    
+  npts_left = nx2*ny2;
+  nblks_left = nblocks;
+  pos = 0;
+  for(m=0; m<nblocks; m++) {
+    istart2[m] = pos;
+    npts_my = npts_left/nblks_left;
+    iend2[m] = istart2[m] + npts_my - 1;
+    pos = iend2[m] + 1;
+    npts_left -= npts_my;
+    nblks_left--;
+  }
+
+  lon_out_min_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lon_out_max_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lat_out_min_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lat_out_max_list = (double *)malloc(nx2*ny2*sizeof(double));
+  lon_out_avg = (double *)malloc(nx2*ny2*sizeof(double));
+  n2_list     = (int *)malloc(nx2*ny2*sizeof(int));
+  lon_out_list = (double *)malloc(MAX_V*nx2*ny2*sizeof(double));
+  lat_out_list = (double *)malloc(MAX_V*nx2*ny2*sizeof(double));
+#if defined(_OPENMP)
+#pragma omp parallel for default(none) shared(nx2,ny2,nx2p,lon_out,lat_out,lat_out_min_list, \
+                                              lat_out_max_list,lon_out_min_list,lon_out_max_list, \
+                                              lon_out_avg,n2_list,lon_out_list,lat_out_list) 
+#endif                        
+  for(ij=0; ij<nx2*ny2; ij++){
+    int i2, j2, n, n0, n1, n2, n3, n2_in, l;
+    double x2_in[MV], y2_in[MV];
+    i2 = ij%nx2;
+    j2 = ij/nx2;
+    n = j2*nx2+i2;
+    n0 = j2*nx2p+i2; n1 = j2*nx2p+i2+1;
+    n2 = (j2+1)*nx2p+i2+1; n3 = (j2+1)*nx2p+i2;
+    x2_in[0] = lon_out[n0]; y2_in[0] = lat_out[n0];
+    x2_in[1] = lon_out[n1]; y2_in[1] = lat_out[n1];
+    x2_in[2] = lon_out[n2]; y2_in[2] = lat_out[n2];
+    x2_in[3] = lon_out[n3]; y2_in[3] = lat_out[n3];
+    
+    lat_out_min_list[n] = minval_double(4, y2_in);
+    lat_out_max_list[n] = maxval_double(4, y2_in);
+    n2_in = fix_lon(x2_in, y2_in, 4, M_PI);
+    if(n2_in > MAX_V) error_handler("create_xgrid.c: n2_in is greater than MAX_V");
+    lon_out_min_list[n] = minval_double(n2_in, x2_in);
+    lon_out_max_list[n] = maxval_double(n2_in, x2_in);
+    lon_out_avg[n] = avgval_double(n2_in, x2_in);
+    n2_list[n] = n2_in;
+    for(l=0; l<n2_in; l++) {
+      lon_out_list[n*MAX_V+l] = x2_in[l];
+      lat_out_list[n*MAX_V+l] = y2_in[l];
+    }    
+  }
+
+nxgrid = 0;
+
+#if defined(_OPENMP)
+#pragma omp parallel for default(none) shared(nblocks,nx1,ny1,nx1p,mask_in,lon_in,lat_in, \
+                                              istart2,iend2,nx2,lat_out_min_list,lat_out_max_list, \
+                                              n2_list,lon_out_list,lat_out_list,lon_out_min_list, \
+                                              lon_out_max_list,lon_out_avg,area_in,area_out, \
+                                              pxgrid_area,pnxgrid,pxgrid_clon,pxgrid_clat,pi_in, \
+                                              pj_in,pi_out,pj_out,pstart,nthreads)
+#endif  
+  for(m=0; m<nblocks; m++) {
+    int i1, j1, ij;
+    for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+      int n0, n1, n2, n3, l,n1_in;
+      double lat_in_min,lat_in_max,lon_in_min,lon_in_max,lon_in_avg;
+      double x1_in[MV], y1_in[MV], x_out[MV], y_out[MV];
+ 
+      n0 = j1*nx1p+i1;       n1 = j1*nx1p+i1+1;
+      n2 = (j1+1)*nx1p+i1+1; n3 = (j1+1)*nx1p+i1;      
+      x1_in[0] = lon_in[n0]; y1_in[0] = lat_in[n0];
+      x1_in[1] = lon_in[n1]; y1_in[1] = lat_in[n1];
+      x1_in[2] = lon_in[n2]; y1_in[2] = lat_in[n2];
+      x1_in[3] = lon_in[n3]; y1_in[3] = lat_in[n3];
+      lat_in_min = minval_double(4, y1_in);
+      lat_in_max = maxval_double(4, y1_in);
+      n1_in = fix_lon(x1_in, y1_in, 4, M_PI);
+      lon_in_min = minval_double(n1_in, x1_in);
+      lon_in_max = maxval_double(n1_in, x1_in);
+      lon_in_avg = avgval_double(n1_in, x1_in);
+      for(ij=istart2[m]; ij<=iend2[m]; ij++) {
+	int n_in, n_out, i2, j2, n2_in;
+	double xarea, dx, lon_out_min, lon_out_max;
+	double x2_in[MAX_V], y2_in[MAX_V];
+	
+	i2 = ij%nx2;
+	j2 = ij/nx2;
+	
+	if(lat_out_min_list[ij] >= lat_in_max || lat_out_max_list[ij] <= lat_in_min ) continue;
+	/* adjust x2_in according to lon_in_avg*/
+	n2_in = n2_list[ij];
+	for(l=0; l<n2_in; l++) {
+	  x2_in[l] = lon_out_list[ij*MAX_V+l];
+	  y2_in[l] = lat_out_list[ij*MAX_V+l];
+	}
+	lon_out_min = lon_out_min_list[ij];
+	lon_out_max = lon_out_max_list[ij];  
+        dx = lon_out_avg[ij] - lon_in_avg;
+	if(dx < -M_PI ) {
+	  lon_out_min += TPI;
+	  lon_out_max += TPI;
+	  for (l=0; l<n2_in; l++) x2_in[l] += TPI;
+	}
+        else if (dx >  M_PI) {
+	  lon_out_min -= TPI;
+	  lon_out_max -= TPI;
+	  for (l=0; l<n2_in; l++) x2_in[l] -= TPI;
+	}
+
+	/* x2_in should in the same range as x1_in after lon_fix, so no need to
+	   consider cyclic condition
+	*/
+	if(lon_out_min >= lon_in_max || lon_out_max <= lon_in_min ) continue;
+	if (  (n_out = clip_2dx2d( x1_in, y1_in, n1_in, x2_in, y2_in, n2_in, x_out, y_out )) > 0) {
+          double min_area;
+	  int nn;
+	  xarea = poly_area (x_out, y_out, n_out ) * mask_in[j1*nx1+i1];	
+	  min_area = min(area_in[j1*nx1+i1], area_out[j2*nx2+i2]);
+	  if( xarea/min_area > AREA_RATIO_THRESH ) {
+	    pnxgrid[m]++;
+            if(pnxgrid[m]>= MAXXGRID/nthreads)
+	      error_handler("nxgrid is greater than MAXXGRID/nthreads, increase MAXXGRID, decrease nthreads, or increase number of MPI ranks");
+	    nn = pstart[m] + pnxgrid[m]-1;
+	    pxgrid_area[nn] = xarea;
+	    pxgrid_clon[nn] = poly_ctrlon(x_out, y_out, n_out, lon_in_avg);
+	    pxgrid_clat[nn] = poly_ctrlat (x_out, y_out, n_out );
+	    pi_in[nn]       = i1;
+	    pj_in[nn]       = j1;
+	    pi_out[nn]      = i2;
+	    pj_out[nn]      = j2;
+	  }	  
+	}
+      }
+    }
+  }
+
+  /*copy data if nblocks > 1 */
+  if(nblocks == 1) {
+    nxgrid = pnxgrid[0];
+    pi_in = NULL;
+    pj_in = NULL;
+    pi_out = NULL;
+    pj_out = NULL;
+    pxgrid_area = NULL;
+    pxgrid_clon = NULL;
+    pxgrid_clat = NULL;
+  }
+  else {
+    int nn, i;
+    nxgrid = 0;
+    for(m=0; m<nblocks; m++) {
+      for(i=0; i<pnxgrid[m]; i++) {
+	nn = pstart[m] + i;
+	i_in[nxgrid] = pi_in[nn];
+	j_in[nxgrid] = pj_in[nn];
+	i_out[nxgrid] = pi_out[nn];
+	j_out[nxgrid] = pj_out[nn];
+	xgrid_area[nxgrid] = pxgrid_area[nn];
+	xgrid_clon[nxgrid] = pxgrid_clon[nn];
+	xgrid_clat[nxgrid] = pxgrid_clat[nn];
+	nxgrid++;
+      }
+    }
+    free(pi_in);
+    free(pj_in);
+    free(pi_out);
+    free(pj_out);
+    free(pxgrid_area);
+    free(pxgrid_clon);
+    free(pxgrid_clat);
+  }
+
+  free(area_in);
+  free(area_out);  
+  free(lon_out_min_list);
+  free(lon_out_max_list);
+  free(lat_out_min_list);
+  free(lat_out_max_list);
+  free(lon_out_avg);
+  free(n2_list);  
+  free(lon_out_list);
+  free(lat_out_list);
+
+  return nxgrid;
+  
+};/* get_xgrid_2Dx2D_order2 */
+
+
+/*******************************************************************************
+   Sutherland-Hodgeman algorithm sequentially clips parts outside 4 boundaries
+*******************************************************************************/
+
+int clip(const double lon_in[], const double lat_in[], int n_in, double ll_lon, double ll_lat,
+	 double ur_lon, double ur_lat, double lon_out[], double lat_out[])
+{
+  double x_tmp[MV], y_tmp[MV], x_last, y_last;
+  int i_in, i_out, n_out, inside_last, inside;
+
+  /* clip polygon with LEFT boundary - clip V_IN to V_TMP */
+  x_last = lon_in[n_in-1];
+  y_last = lat_in[n_in-1];
+  inside_last = (x_last >= ll_lon);
+  for (i_in=0,i_out=0;i_in<n_in;i_in++) {
+ 
+    /* if crossing LEFT boundary - output intersection */
+    if ((inside=(lon_in[i_in] >= ll_lon))!=inside_last) {
+      x_tmp[i_out] = ll_lon;
+      y_tmp[i_out++] = y_last + (ll_lon - x_last) * (lat_in[i_in] - y_last) / (lon_in[i_in] - x_last);
+    }
+
+    /* if "to" point is right of LEFT boundary, output it */
+    if (inside) {
+      x_tmp[i_out]   = lon_in[i_in];
+      y_tmp[i_out++] = lat_in[i_in];
+    }
+    x_last = lon_in[i_in];
+    y_last = lat_in[i_in];
+    inside_last = inside;
+  }
+  if (!(n_out=i_out)) return(0);
+
+  /* clip polygon with RIGHT boundary - clip V_TMP to V_OUT */
+  x_last = x_tmp[n_out-1];
+  y_last = y_tmp[n_out-1];
+  inside_last = (x_last <= ur_lon);
+  for (i_in=0,i_out=0;i_in<n_out;i_in++) {
+ 
+    /* if crossing RIGHT boundary - output intersection */
+    if ((inside=(x_tmp[i_in] <= ur_lon))!=inside_last) {
+      lon_out[i_out]   = ur_lon;
+      lat_out[i_out++] = y_last + (ur_lon - x_last) * (y_tmp[i_in] - y_last)
+                                                 / (x_tmp[i_in] - x_last);
+    }
+
+    /* if "to" point is left of RIGHT boundary, output it */
+    if (inside) {
+      lon_out[i_out]   = x_tmp[i_in];
+      lat_out[i_out++] = y_tmp[i_in];
+    }
+    
+    x_last = x_tmp[i_in];
+    y_last = y_tmp[i_in];
+    inside_last = inside;
+  }
+  if (!(n_out=i_out)) return(0);
+
+  /* clip polygon with BOTTOM boundary - clip V_OUT to V_TMP */
+  x_last = lon_out[n_out-1];
+  y_last = lat_out[n_out-1];
+  inside_last = (y_last >= ll_lat);
+  for (i_in=0,i_out=0;i_in<n_out;i_in++) {
+ 
+    /* if crossing BOTTOM boundary - output intersection */
+    if ((inside=(lat_out[i_in] >= ll_lat))!=inside_last) {
+      y_tmp[i_out]   = ll_lat;
+      x_tmp[i_out++] = x_last + (ll_lat - y_last) * (lon_out[i_in] - x_last) / (lat_out[i_in] - y_last);
+    }
+
+    /* if "to" point is above BOTTOM boundary, output it */
+    if (inside) {
+      x_tmp[i_out]   = lon_out[i_in];
+      y_tmp[i_out++] = lat_out[i_in];
+    }
+    x_last = lon_out[i_in];
+    y_last = lat_out[i_in];
+    inside_last = inside;
+  }
+  if (!(n_out=i_out)) return(0);
+
+  /* clip polygon with TOP boundary - clip V_TMP to V_OUT */
+  x_last = x_tmp[n_out-1];
+  y_last = y_tmp[n_out-1];
+  inside_last = (y_last <= ur_lat);
+  for (i_in=0,i_out=0;i_in<n_out;i_in++) {
+ 
+    /* if crossing TOP boundary - output intersection */
+    if ((inside=(y_tmp[i_in] <= ur_lat))!=inside_last) {
+      lat_out[i_out]   = ur_lat;
+      lon_out[i_out++] = x_last + (ur_lat - y_last) * (x_tmp[i_in] - x_last) / (y_tmp[i_in] - y_last);
+    }
+
+    /* if "to" point is below TOP boundary, output it */
+    if (inside) {
+      lon_out[i_out]   = x_tmp[i_in];
+      lat_out[i_out++] = y_tmp[i_in];
+    }
+    x_last = x_tmp[i_in];
+    y_last = y_tmp[i_in];
+    inside_last = inside;
+  }
+  return(i_out);
+}; /* clip */  
+
+
+/*******************************************************************************
+   Revise Sutherland-Hodgeman algorithm to find the vertices of the overlapping
+   between any two grid boxes. It return the number of vertices for the exchange grid.
+*******************************************************************************/
+
+int clip_2dx2d(const double lon1_in[], const double lat1_in[], int n1_in, 
+	 const double lon2_in[], const double lat2_in[], int n2_in, 
+	 double lon_out[], double lat_out[])
+{
+  double lon_tmp[MV], lat_tmp[MV];
+  double x1_0, y1_0, x1_1, y1_1, x2_0, y2_0, x2_1, y2_1;
+  double dx1, dy1, dx2, dy2, determ, ds1, ds2;
+  int i_out, n_out, inside_last, inside, i1, i2;
+
+  /* clip polygon with each boundary of the polygon */
+  /* We treat lon1_in/lat1_in as clip polygon and lon2_in/lat2_in as subject polygon */
+  n_out = n1_in;
+  for(i1=0; i1<n1_in; i1++) {
+    lon_tmp[i1] = lon1_in[i1];
+    lat_tmp[i1] = lat1_in[i1];
+  }
+  x2_0 = lon2_in[n2_in-1];
+  y2_0 = lat2_in[n2_in-1];
+  for(i2=0; i2<n2_in; i2++) {
+    x2_1 = lon2_in[i2];
+    y2_1 = lat2_in[i2];
+    x1_0 = lon_tmp[n_out-1];
+    y1_0 = lat_tmp[n_out-1];
+    inside_last = inside_edge( x2_0, y2_0, x2_1, y2_1, x1_0, y1_0);
+    for(i1=0, i_out=0; i1<n_out; i1++) {
+      x1_1 = lon_tmp[i1];
+      y1_1 = lat_tmp[i1];
+      if((inside = inside_edge(x2_0, y2_0, x2_1, y2_1, x1_1, y1_1)) != inside_last ) {
+        /* there is intersection, the line between <x1_0,y1_0> and  <x1_1,y1_1>
+           should not parallel to the line between <x2_0,y2_0> and  <x2_1,y2_1>
+           may need to consider truncation error */
+	dy1 = y1_1-y1_0;
+	dy2 = y2_1-y2_0;
+	dx1 = x1_1-x1_0;
+	dx2 = x2_1-x2_0;
+	ds1 = y1_0*x1_1 - y1_1*x1_0;
+	ds2 = y2_0*x2_1 - y2_1*x2_0;
+	determ = dy2*dx1 - dy1*dx2;
+        if(fabs(determ) < EPSLN30) {
+	  error_handler("the line between <x1_0,y1_0> and  <x1_1,y1_1> should not parallel to "
+				     "the line between <x2_0,y2_0> and  <x2_1,y2_1>");
+	}
+	lon_out[i_out]   = (dx2*ds1 - dx1*ds2)/determ;
+	lat_out[i_out++] = (dy2*ds1 - dy1*ds2)/determ;
+	
+
+      }
+      if(inside) {
+	lon_out[i_out]   = x1_1;
+	lat_out[i_out++] = y1_1;	
+      }
+      x1_0 = x1_1;
+      y1_0 = y1_1;
+      inside_last = inside;
+    }
+    if(!(n_out=i_out)) return 0;
+    for(i1=0; i1<n_out; i1++) {
+      lon_tmp[i1] = lon_out[i1];
+      lat_tmp[i1] = lat_out[i1];
+    }
+    /* shift the starting point */
+    x2_0 = x2_1;
+    y2_0 = y2_1;
+  }
+  return(n_out);
+}; /* clip */
+    
+/*#define debug_test_create_xgrid*/  
+
+#ifndef __AIX
+int create_xgrid_great_circle_(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+  int nxgrid;
+  nxgrid = create_xgrid_great_circle(nlon_in, nlat_in, nlon_out, nlat_out, lon_in, lat_in, lon_out, lat_out,
+			      mask_in, i_in, j_in, i_out, j_out, xgrid_area, xgrid_clon, xgrid_clat);
+
+  return nxgrid;
+};
+#endif
+  
+int create_xgrid_great_circle(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat)
+{
+
+  int nx1, nx2, ny1, ny2, nx1p, nx2p, ny1p, ny2p, nxgrid, n1_in, n2_in;
+  int n0, n1, n2, n3, i1, j1, i2, j2, l, n;
+  double x1_in[MV], y1_in[MV], z1_in[MV];
+  double x2_in[MV], y2_in[MV], z2_in[MV];
+  double x_out[MV], y_out[MV], z_out[MV];
+  double *x1=NULL, *y1=NULL, *z1=NULL;
+  double *x2=NULL, *y2=NULL, *z2=NULL;
+
+  double xctrlon, xctrlat;
+  double *area1, *area2, min_area;
+  
+  nx1 = *nlon_in;
+  ny1 = *nlat_in;
+  nx2 = *nlon_out;
+  ny2 = *nlat_out;  
+  nxgrid = 0;
+  nx1p = nx1 + 1;
+  nx2p = nx2 + 1;
+  ny1p = ny1 + 1;
+  ny2p = ny2 + 1;
+
+  /* first convert lon-lat to cartesian coordinates */
+  x1 = (double *)malloc(nx1p*ny1p*sizeof(double));
+  y1 = (double *)malloc(nx1p*ny1p*sizeof(double));
+  z1 = (double *)malloc(nx1p*ny1p*sizeof(double));
+  x2 = (double *)malloc(nx2p*ny2p*sizeof(double));
+  y2 = (double *)malloc(nx2p*ny2p*sizeof(double));
+  z2 = (double *)malloc(nx2p*ny2p*sizeof(double));
+  
+  latlon2xyz(nx1p*ny1p, lon_in, lat_in, x1, y1, z1);
+  latlon2xyz(nx2p*ny2p, lon_out, lat_out, x2, y2, z2);
+  
+  area1  = (double *)malloc(nx1*ny1*sizeof(double));
+  area2 = (double *)malloc(nx2*ny2*sizeof(double));
+  get_grid_great_circle_area(nlon_in, nlat_in, lon_in, lat_in, area1);     
+  get_grid_great_circle_area(nlon_out, nlat_out, lon_out, lat_out, area2); 
+  n1_in = 4;
+  n2_in = 4;
+  
+  for(j1=0; j1<ny1; j1++) for(i1=0; i1<nx1; i1++) if( mask_in[j1*nx1+i1] > MASK_THRESH ) {
+    /* clockwise */
+    n0 = j1*nx1p+i1;       n1 = (j1+1)*nx1p+i1;
+    n2 = (j1+1)*nx1p+i1+1; n3 = j1*nx1p+i1+1;      
+    x1_in[0] = x1[n0]; y1_in[0] = y1[n0]; z1_in[0] = z1[n0];
+    x1_in[1] = x1[n1]; y1_in[1] = y1[n1]; z1_in[1] = z1[n1];
+    x1_in[2] = x1[n2]; y1_in[2] = y1[n2]; z1_in[2] = z1[n2];
+    x1_in[3] = x1[n3]; y1_in[3] = y1[n3]; z1_in[3] = z1[n3];
+      
+    for(j2=0; j2<ny2; j2++) for(i2=0; i2<nx2; i2++) {
+      int n_in, n_out;
+      double xarea;
+
+      n0 = j2*nx2p+i2;       n1 = (j2+1)*nx2p+i2;
+      n2 = (j2+1)*nx2p+i2+1; n3 = j2*nx2p+i2+1;
+      x2_in[0] = x2[n0]; y2_in[0] = y2[n0]; z2_in[0] = z2[n0];
+      x2_in[1] = x2[n1]; y2_in[1] = y2[n1]; z2_in[1] = z2[n1];
+      x2_in[2] = x2[n2]; y2_in[2] = y2[n2]; z2_in[2] = z2[n2];
+      x2_in[3] = x2[n3]; y2_in[3] = y2[n3]; z2_in[3] = z2[n3];
+
+      if (  (n_out = clip_2dx2d_great_circle( x1_in, y1_in, z1_in, n1_in, x2_in, y2_in, z2_in, n2_in,
+					      x_out, y_out, z_out)) > 0) {
+	xarea = great_circle_area ( n_out, x_out, y_out, z_out ) * mask_in[j1*nx1+i1];
+	min_area = min(area1[j1*nx1+i1], area2[j2*nx2+i2]);
+	if( xarea/min_area > AREA_RATIO_THRESH ) {
+#ifdef debug_test_create_xgrid	  
+	  printf("(i2,j2)=(%d,%d), (i1,j1)=(%d,%d), xarea=%g\n", i2, j2, i1, j1, xarea);
+#endif
+	  xgrid_area[nxgrid] = xarea;
+	  xgrid_clon[nxgrid] = 0; /*z1l: will be developed very soon */
+	  xgrid_clat[nxgrid] = 0; 
+	  i_in[nxgrid]       = i1;
+	  j_in[nxgrid]       = j1;
+	  i_out[nxgrid]      = i2;
+	  j_out[nxgrid]      = j2;
+	  ++nxgrid;
+	  if(nxgrid > MAXXGRID) error_handler("nxgrid is greater than MAXXGRID, increase MAXXGRID");
+	}
+      }
+    }
+  }
+
+  
+  free(area1);
+  free(area2);  
+
+  free(x1);
+  free(y1);
+  free(z1);
+  free(x2);
+  free(y2);
+  free(z2);
+  
+  return nxgrid;
+  
+};/* create_xgrid_great_circle */
+
+/*******************************************************************************
+   Revise Sutherland-Hodgeman algorithm to find the vertices of the overlapping
+   between any two grid boxes. It return the number of vertices for the exchange grid.
+   Each edge of grid box is a part of great circle. All the points are cartesian
+   coordinates. Here we are assuming each polygon is convex.
+   RANGE_CHECK_CRITERIA is used to determine if the two grid boxes are possible to be
+   overlap. The size should be between 0 and 0.5. The larger the range_check_criteria,
+   the more expensive of the computatioin. When the value is close to 0,
+   some small exchange grid might be lost. Suggest to use value 0.05 for C48. 
+*******************************************************************************/
+
+int clip_2dx2d_great_circle(const double x1_in[], const double y1_in[], const double z1_in[], int n1_in, 
+			    const double x2_in[], const double y2_in[], const double z2_in [], int n2_in, 
+			    double x_out[], double y_out[], double z_out[])
+{
+  struct Node *subjList=NULL;
+  struct Node *clipList=NULL;
+  struct Node *grid1List=NULL;
+  struct Node *grid2List=NULL;
+  struct Node *intersectList=NULL;
+  struct Node *polyList=NULL;
+  struct Node *curList=NULL;
+  struct Node *firstIntersect=NULL, *curIntersect=NULL;
+  struct Node *temp1=NULL, *temp2=NULL, *temp=NULL;
+  
+  int    i1, i2, i1p, i2p, i2p2, npts1, npts2;
+  int    nintersect, n_out;
+  int    maxiter1, maxiter2, iter1, iter2;
+  int    found1, found2, curListNum;
+  int    has_inbound, inbound;
+  double pt1[MV][3], pt2[MV][3];
+  double *p1_0=NULL, *p1_1=NULL;
+  double *p2_0=NULL, *p2_1=NULL, *p2_2=NULL;
+  double intersect[3];
+  double u1, u2;
+  double min_x1, max_x1, min_y1, max_y1, min_z1, max_z1;
+  double min_x2, max_x2, min_y2, max_y2, min_z2, max_z2;
+  static int first_call=1;
+
+  
+  /* first check the min and max of (x1_in, y1_in, z1_in) with (x2_in, y2_in, z2_in) */
+  min_x1 = minval_double(n1_in, x1_in);
+  max_x2 = maxval_double(n2_in, x2_in);  
+  if(min_x1 >= max_x2+RANGE_CHECK_CRITERIA) return 0;
+  max_x1 = maxval_double(n1_in, x1_in); 
+  min_x2 = minval_double(n2_in, x2_in);
+  if(min_x2 >= max_x1+RANGE_CHECK_CRITERIA) return 0;
+
+  min_y1 = minval_double(n1_in, y1_in);
+  max_y2 = maxval_double(n2_in, y2_in);  
+  if(min_y1 >= max_y2+RANGE_CHECK_CRITERIA) return 0;
+  max_y1 = maxval_double(n1_in, y1_in); 
+  min_y2 = minval_double(n2_in, y2_in);
+  if(min_y2 >= max_y1+RANGE_CHECK_CRITERIA) return 0;  
+
+  min_z1 = minval_double(n1_in, z1_in);
+  max_z2 = maxval_double(n2_in, z2_in);  
+  if(min_z1 >= max_z2+RANGE_CHECK_CRITERIA) return 0;
+  max_z1 = maxval_double(n1_in, z1_in); 
+  min_z2 = minval_double(n2_in, z2_in);
+  if(min_z2 >= max_z1+RANGE_CHECK_CRITERIA) return 0;    
+
+  rewindList();
+
+  grid1List = getNext();
+  grid2List = getNext();  
+  intersectList = getNext();
+  polyList = getNext();
+    
+  /* insert points into SubjList and ClipList */
+  for(i1=0; i1<n1_in; i1++) addEnd(grid1List, x1_in[i1], y1_in[i1], z1_in[i1], 0, 0, 0, -1);
+  for(i2=0; i2<n2_in; i2++) addEnd(grid2List, x2_in[i2], y2_in[i2], z2_in[i2], 0, 0, 0, -1);
+  npts1 = length(grid1List);
+  npts2 = length(grid2List);
+
+  n_out = 0;
+  /* set the inside value */
+#ifdef debug_test_create_xgrid
+  printf("\nNOTE from clip_2dx2d_great_circle: begin to set inside value grid1List\n"); 
+#endif  
+  /* first check number of points in grid1 is inside grid2 */
+
+  temp = grid1List;
+  while(temp) {    
+    if(insidePolygon(temp, grid2List))
+      temp->isInside = 1;
+    else
+      temp->isInside = 0;
+    temp = getNextNode(temp);
+  }
+
+#ifdef debug_test_create_xgrid
+  printf("\nNOTE from clip_2dx2d_great_circle: begin to set inside value of grid2List\n"); 
+#endif      
+  /* check if grid2List is inside grid1List */
+  temp = grid2List;
+
+  while(temp) {
+    if(insidePolygon(temp, grid1List))
+      temp->isInside = 1;
+    else
+      temp->isInside = 0;
+    temp = getNextNode(temp);
+  }
+      
+  /* make sure the grid box is clockwise */
+  
+  /*make sure each polygon is convex, which is equivalent that the great_circle_area is positive */
+  if( gridArea(grid1List) <= 0 )
+    error_handler("create_xgrid.c(clip_2dx2d_great_circle): grid box 1 is not convex");
+  if( gridArea(grid2List) <= 0 )
+    error_handler("create_xgrid.c(clip_2dx2d_great_circle): grid box 2 is not convex");
+  
+#ifdef debug_test_create_xgrid
+  printNode(grid1List, "grid1List");
+  printNode(grid2List, "grid2List");
+#endif  
+
+  /* get the coordinates from grid1List and grid2List.
+     Please not npts1 might not equal n1_in, npts2 might not equal n2_in because of pole
+  */
+
+  temp = grid1List;
+  for(i1=0; i1<npts1; i1++) {
+    getCoordinates(temp, pt1[i1]);
+    temp = temp->Next;
+  }
+  temp = grid2List;
+  for(i2=0; i2<npts2; i2++) {
+    getCoordinates(temp, pt2[i2]);
+    temp = temp->Next;
+  }  
+  
+  firstIntersect=getNext();
+  curIntersect = getNext();
+
+#ifdef debug_test_create_xgrid  
+  printf("\n\n************************ Start line_intersect_2D_3D ******************************\n");
+#endif
+  /* first find all the intersection points */
+  nintersect = 0;
+  for(i1=0; i1<npts1; i1++) {
+    i1p = (i1+1)%npts1;
+    p1_0 = pt1[i1];
+    p1_1 = pt1[i1p];
+    for(i2=0; i2<npts2; i2++) {
+      i2p = (i2+1)%npts2;
+      i2p2 = (i2+2)%npts2;
+      p2_0 = pt2[i2];
+      p2_1 = pt2[i2p];
+      p2_2 = pt2[i2p2];
+#ifdef debug_test_create_xgrid
+      printf("\n******************************************************************************\n");
+      printf(" i1 = %d, i2 = %d \n", i1, i2);
+      printf("********************************************************************************\n");
+#endif
+      if( line_intersect_2D_3D(p1_0, p1_1, p2_0, p2_1, p2_2, intersect, &u1, &u2, &inbound) ) {
+	int n_prev, n_cur;
+	int is_in_subj, is_in_clip;
+
+	/* from the value of u1, u2 and inbound, we can partially decide if a point is inside or outside of polygon */        
+	
+	/* add the intersection into intersetList, The intersection might already be in
+	   intersectList and will be taken care addIntersect
+	*/
+	if(addIntersect(intersectList, intersect[0], intersect[1], intersect[2], 1, u1, u2, inbound, i1, i1p, i2, i2p)) {
+	  /* add the intersection into the grid1List */
+    
+	  if(u1 == 1) {
+	    insertIntersect(grid1List, intersect[0], intersect[1], intersect[2], 0.0, u2, inbound, p1_1[0], p1_1[1], p1_1[2]);
+	  }
+	  else
+	    insertIntersect(grid1List, intersect[0], intersect[1], intersect[2], u1, u2, inbound, p1_0[0], p1_0[1], p1_0[2]);
+	  /* when u1 == 0 or 1, need to adjust the vertice to intersect value for roundoff error */
+	  if(u1==1) {
+	    p1_1[0] = intersect[0];
+	    p1_1[1] = intersect[1];
+	    p1_1[2] = intersect[2];
+	  }
+	  else if(u1 == 0) {
+	    p1_0[0] = intersect[0];
+	    p1_0[1] = intersect[1];
+	    p1_0[2] = intersect[2];
+	  }
+	  /* add the intersection into the grid2List */
+	  if(u2==1)
+	    insertIntersect(grid2List, intersect[0], intersect[1], intersect[2], 0.0, u1, 0, p2_1[0], p2_1[1], p2_1[2]);
+	  else
+	    insertIntersect(grid2List, intersect[0], intersect[1], intersect[2], u2, u1, 0, p2_0[0], p2_0[1], p2_0[2]);
+	  /* when u2 == 0 or 1, need to adjust the vertice to intersect value for roundoff error */
+	  if(u2==1) {
+	    p2_1[0] = intersect[0];
+	    p2_1[1] = intersect[1];
+	    p2_1[2] = intersect[2];
+	  } 
+	  else if(u2 == 0) {
+	    p2_0[0] = intersect[0];
+	    p2_0[1] = intersect[1];
+	    p2_0[2] = intersect[2];
+	  }
+	}
+      }
+    }
+  }
+  
+  /* set inbound value for the points in intersectList that has inbound == 0,
+     this will also set some inbound value of the points in grid1List
+  */
+
+  /* get the first point in intersectList has inbound = 2, if not, set inbound value */
+  has_inbound = 0;
+  /* loop through intersectList to see if there is any has inbound=1 or 2 */
+  temp = intersectList;
+  nintersect = length(intersectList);
+  if(nintersect > 1) {
+    getFirstInbound(intersectList, firstIntersect);
+    if(firstIntersect->initialized) {
+      has_inbound = 1;
+    }
+  }
+
+  /* when has_inbound == 0, get the grid1List and grid2List */
+  if( !has_inbound && nintersect > 1) {
+    setInbound(intersectList, grid1List);
+    getFirstInbound(intersectList, firstIntersect);
+    if(firstIntersect->initialized) has_inbound = 1;
+  }
+
+  /* if has_inbound = 1, find the overlapping */
+  n_out = 0;
+  
+  if(has_inbound) {
+    maxiter1 = nintersect;
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from clip_2dx2d_great_circle: number of intersect is %d\n", nintersect);
+    printf("\n size of grid2List is %d, size of grid1List is %d\n", length(grid2List), length(grid1List));
+    printNode(intersectList, "beginning intersection list");
+    printNode(grid2List, "beginning clip list");
+    printNode(grid1List, "beginning subj list");
+    printf("\n************************ End line_intersect_2D_3D **********************************\n\n");
+#endif  
+    temp1 = getNode(grid1List, *firstIntersect);
+    if( temp1 == NULL) {
+      double lon[10], lat[10];
+      int i;
+      xyz2latlon(n1_in, x1_in, y1_in, z1_in, lon, lat);
+      for(i=0; i< n1_in; i++) printf("lon1 = %g, lat1 = %g\n", lon[i]*R2D, lat[i]*R2D);
+      printf("\n");
+      xyz2latlon(n2_in, x2_in, y2_in, z2_in, lon, lat);
+      for(i=0; i< n2_in; i++) printf("lon2 = %g, lat2 = %g\n", lon[i]*R2D, lat[i]*R2D);
+      printf("\n");	
+	
+      error_handler("firstIntersect is not in the grid1List");
+    }
+    addNode(polyList, *firstIntersect);
+    nintersect--;
+#ifdef debug_test_create_xgrid    
+    printNode(polyList, "polyList at stage 1");
+#endif      
+	
+    /* Loop over the grid1List and grid2List to find again the firstIntersect */
+    curList = grid1List;
+    curListNum = 0;
+	
+    /* Loop through curList to find the next intersection, the loop will end
+       when come back to firstIntersect
+    */
+    copyNode(curIntersect, *firstIntersect);
+    iter1 = 0;
+    found1 = 0;
+
+    while( iter1 < maxiter1 ) {
+#ifdef debug_test_create_xgrid
+      printf("\n----------- At iteration = %d\n\n", iter1+1 );
+      printNode(curIntersect, "curIntersect at the begining of iter1");      
+#endif
+      /* find the curIntersect in curList and get the next intersection points */
+      temp1 =  getNode(curList, *curIntersect);
+      temp2 = temp1->Next;
+      if( temp2 == NULL ) temp2 = curList;
+
+      maxiter2 = length(curList);
+      found2 = 0;
+      iter2  = 0;
+      /* Loop until find the next intersection */
+      while( iter2 < maxiter2 ) {
+	int temp2IsIntersect;
+
+	temp2IsIntersect = 0;
+	if( isIntersect( *temp2 ) ) { /* copy the point and switch to the grid2List */
+	  struct Node *temp3;
+	  
+	  /* first check if temp2 is the firstIntersect */
+	  if( sameNode( *temp2, *firstIntersect) ) {
+	    found1 = 1; 
+	    break;
+	  }	  
+	  
+	  temp3 = temp2->Next;
+	  if( temp3 == NULL) temp3 = curList;
+	  if( temp3 == NULL) error_handler("creat_xgrid.c: temp3 can not be NULL");
+	  found2 = 1;
+	  /* if next node is inside or an intersection,
+	     need to keep on curList
+	  */
+	  temp2IsIntersect = 1;
+	  if( isIntersect(*temp3) || (temp3->isInside == 1)  ) found2 = 0;
+	}
+	if(found2) {
+	  copyNode(curIntersect, *temp2);
+	  break;
+	}
+	else {
+	  addNode(polyList, *temp2);
+#ifdef debug_test_create_xgrid    
+	  printNode(polyList, "polyList at stage 2");
+#endif      	  
+	  if(temp2IsIntersect) { 
+	    nintersect--;
+	  }
+	}
+	temp2 = temp2->Next;
+	if( temp2 == NULL ) temp2 = curList;
+	iter2 ++;
+      }
+      if(found1) break;
+    
+      if( !found2 ) error_handler(" not found the next intersection ");
+
+      /* if find the first intersection, the poly found */
+      if( sameNode( *curIntersect, *firstIntersect) ) {
+	found1 = 1; 
+	break;
+      }
+
+      /* add curIntersect to polyList and remove it from intersectList and curList */
+      addNode(polyList, *curIntersect);
+#ifdef debug_test_create_xgrid    
+      printNode(polyList, "polyList at stage 3");
+#endif      
+      nintersect--;
+      
+      
+      /* switch curList */
+      if( curListNum == 0) {
+	curList = grid2List;
+	curListNum = 1;
+      }
+      else {
+	curList = grid1List;
+	curListNum = 0;
+      }
+      iter1++;
+    }
+    if(!found1) error_handler("not return back to the first intersection");
+
+    /* currently we are only clipping convex polygon to convex polygon */
+    if( nintersect > 0) error_handler("After clipping, nintersect should be 0");
+
+    /* copy the polygon to x_out, y_out, z_out */
+    temp1 = polyList;
+    while (temp1 != NULL) {
+      getCoordinate(*temp1, x_out+n_out, y_out+n_out, z_out+n_out);
+      temp1 = temp1->Next;
+      n_out++;
+    }
+    
+    /* if(n_out < 3) error_handler(" The clipped region has < 3 vertices"); */
+    if( n_out < 3) n_out = 0;
+#ifdef debug_test_create_xgrid
+    printNode(polyList, "polyList after clipping");
+#endif
+  }
+
+  /* check if grid1 is inside grid2 */
+  if(n_out==0){
+    /* first check number of points in grid1 is inside grid2 */
+    int n, n1in2;
+    /* One possible is that grid1List is inside grid2List */
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from clip_2dx2d_great_circle: check if grid1 is inside grid2\n");
+#endif    
+    n1in2 = 0;
+    temp = grid1List;
+    while(temp) {
+      if(temp->intersect != 1) {
+#ifdef debug_test_create_xgrid	
+	printf("grid1->isInside = %d\n", temp->isInside);
+#endif 
+	if( temp->isInside == 1) n1in2++;
+      }
+      temp = getNextNode(temp);
+    }
+    if(npts1==n1in2) { /* grid1 is inside grid2 */
+      n_out = npts1;
+      n = 0;
+      temp = grid1List;
+      while( temp ) {
+	getCoordinate(*temp, &x_out[n], &y_out[n], &z_out[n]);
+	n++;
+	temp = getNextNode(temp);
+      }
+    }
+    if(n_out>0) return n_out;
+  }
+  
+  /* check if grid2List is inside grid1List */
+  if(n_out ==0){
+    int n, n2in1;
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from clip_2dx2d_great_circle: check if grid2 is inside grid1\n");
+#endif    
+    
+    temp = grid2List;
+    n2in1 = 0;
+    while(temp) {
+      if(temp->intersect != 1) {
+#ifdef debug_test_create_xgrid	
+	printf("grid2->isInside = %d\n", temp->isInside);
+#endif
+	if( temp->isInside == 1) n2in1++;
+      }
+      temp = getNextNode(temp);
+    }
+      
+    if(npts2==n2in1) { /* grid2 is inside grid1 */
+      n_out = npts2;
+      n = 0;
+      temp = grid2List;
+      while( temp ) {
+	getCoordinate(*temp, &x_out[n], &y_out[n], &z_out[n]);
+	n++;
+	temp = getNextNode(temp);
+      }
+      
+    }
+  }  
+
+  
+  return n_out;
+}
+
+
+/* Intersects between the line a and the seqment s
+   where both line and segment are great circle lines on the sphere represented by
+   3D cartesian points.
+   [sin sout] are the ends of a line segment
+   returns true if the lines could be intersected, false otherwise.
+   inbound means the direction of (a1,a2) go inside or outside of (q1,q2,q3)
+*/
+
+int line_intersect_2D_3D(double *a1, double *a2, double *q1, double *q2, double *q3,
+			 double *intersect, double *u_a, double *u_q, int *inbound){
+
+  /* Do this intersection by reprsenting the line a1 to a2 as a plane through the
+     two line points and the origin of the sphere (0,0,0). This is the
+     definition of a great circle arc.
+  */
+  double plane[9];
+  double plane_p[2];
+  double u;
+  double p1[3], v1[3], v2[3];
+  double c1[3], c2[3], c3[3];
+  double coincident, sense, norm;
+  int    i;
+  int is_inter1, is_inter2;
+
+  *inbound = 0;
+  
+  /* first check if any vertices are the same */
+  if(samePoint(a1[0], a1[1], a1[2], q1[0], q1[1], q1[2])) {
+    *u_a = 0;
+    *u_q = 0;
+    intersect[0] = a1[0];
+    intersect[1] = a1[1];
+    intersect[2] = a1[2];
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_a = %19.15f, u_q=%19.15f, inbound=%d\n", *u_a, *u_q, *inbound); 
+#endif      
+    return 1;
+   }
+   else if (samePoint(a1[0], a1[1], a1[2], q2[0], q2[1], q2[2])) {
+    *u_a = 0;
+    *u_q = 1;
+    intersect[0] = a1[0];
+    intersect[1] = a1[1];
+    intersect[2] = a1[2];
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_a = %19.15f, u_q=%19.15f, inbound=%d\n", *u_a, *u_q, *inbound); 
+#endif      
+    return 1;
+  }
+   else if(samePoint(a2[0], a2[1], a2[2], q1[0], q1[1], q1[2])) {
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_a = %19.15f, u_q=%19.15f, inbound=%d\n", *u_a, *u_q, *inbound); 
+#endif           
+    *u_a = 1;
+    *u_q = 0;
+    intersect[0] = a2[0];
+    intersect[1] = a2[1];
+    intersect[2] = a2[2];
+    return 1;
+   }
+   else if (samePoint(a2[0], a2[1], a2[2], q2[0], q2[1], q2[2])) {
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_a = %19.15f, u_q=%19.15f, inbound=%d\n", *u_a, *u_q, *inbound); 
+#endif           
+    *u_a = 1;
+    *u_q = 1;
+    intersect[0] = a2[0];
+    intersect[1] = a2[1];
+    intersect[2] = a2[2];
+    return 1;
+  }
+
+
+  /* Load points defining plane into variable (these are supposed to be in counterclockwise order) */
+  plane[0]=q1[0];
+  plane[1]=q1[1];
+  plane[2]=q1[2];
+  plane[3]=q2[0];
+  plane[4]=q2[1];
+  plane[5]=q2[2];
+  plane[6]=0.0;
+  plane[7]=0.0;
+  plane[8]=0.0;
+
+  /* Intersect the segment with the plane */
+  is_inter1 = intersect_tri_with_line(plane, a1, a2, plane_p, u_a);
+
+  if(!is_inter1)
+     return 0;
+
+  if(fabs(*u_a) < EPSLN8) *u_a = 0;
+  if(fabs(*u_a-1) < EPSLN8) *u_a = 1;
+
+  
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_a = %19.15f\n", *u_a);
+#endif
+
+
+  if( (*u_a < 0) || (*u_a > 1) ) return 0;
+
+  /* Load points defining plane into variable (these are supposed to be in counterclockwise order) */
+  plane[0]=a1[0];
+  plane[1]=a1[1];
+  plane[2]=a1[2];
+  plane[3]=a2[0];
+  plane[4]=a2[1];
+  plane[5]=a2[2];
+  plane[6]=0.0;
+  plane[7]=0.0;
+  plane[8]=0.0;
+
+  /* Intersect the segment with the plane */
+  is_inter2 = intersect_tri_with_line(plane, q1, q2, plane_p, u_q);
+
+  if(!is_inter2)
+     return 0;
+
+  if(fabs(*u_q) < EPSLN8) *u_q = 0;
+  if(fabs(*u_q-1) < EPSLN8) *u_q = 1;
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: u_q = %19.15f\n", *u_q);
+#endif
+  
+
+  if( (*u_q < 0) || (*u_q > 1) ) return 0;
+  
+  u =*u_a;
+  
+  /* The two planes are coincidental */
+  vect_cross(a1, a2, c1);
+  vect_cross(q1, q2, c2);
+  vect_cross(c1, c2, c3);
+  coincident = metric(c3);
+
+  if(fabs(coincident) < EPSLN30) return 0;
+  
+  /* Calculate point of intersection */
+  intersect[0]=a1[0] + u*(a2[0]-a1[0]);
+  intersect[1]=a1[1] + u*(a2[1]-a1[1]);
+  intersect[2]=a1[2] + u*(a2[2]-a1[2]);
+
+  norm = metric( intersect );
+  for(i = 0; i < 3; i ++) intersect[i] /= norm;
+
+  /* when u_q =0 or u_q =1, the following could not decide the inbound value */
+  if(*u_q != 0 && *u_q != 1){
+  
+    p1[0] = a2[0]-a1[0];
+    p1[1] = a2[1]-a1[1];
+    p1[2] = a2[2]-a1[2];
+    v1[0] = q2[0]-q1[0];
+    v1[1] = q2[1]-q1[1];
+    v1[2] = q2[2]-q1[2];
+    v2[0] = q3[0]-q2[0];
+    v2[1] = q3[1]-q2[1];
+    v2[2] = q3[2]-q2[2];
+
+    vect_cross(v1, v2, c1);
+    vect_cross(v1, p1, c2);
+
+    sense = dot(c1, c2);
+    *inbound = 1;
+    if(sense > 0) *inbound = 2; /* v1 going into v2 in CCW sense */
+  }
+#ifdef debug_test_create_xgrid
+    printf("\nNOTE from line_intersect_2D_3D: inbound=%d\n", *inbound); 
+#endif      
+  
+  return 1;
+}
+
+
+/*------------------------------------------------------------------------------
+  double poly_ctrlat(const double x[], const double y[], int n)
+  This routine is used to calculate the latitude of the centroid 
+   ---------------------------------------------------------------------------*/
+
+double poly_ctrlat(const double x[], const double y[], int n)
+{
+  double ctrlat = 0.0;
+  int    i;
+
+  for (i=0;i<n;i++) {
+    int ip = (i+1) % n;
+    double dx = (x[ip]-x[i]);
+    double dy, avg_y, hdy;
+    double lat1, lat2;
+    lat1 = y[ip];
+    lat2 = y[i];
+    dy = lat2 - lat1;
+    hdy = dy*0.5;
+    avg_y = (lat1+lat2)*0.5;
+    if      (dx==0.0) continue;
+    if(dx > M_PI)  dx = dx - 2.0*M_PI;
+    if(dx < -M_PI) dx = dx + 2.0*M_PI;
+
+    if ( fabs(hdy)< SMALL_VALUE ) /* cheap area calculation along latitude */
+      ctrlat -= dx*(2*cos(avg_y) + lat2*sin(avg_y) - cos(lat1) );
+    else 
+      ctrlat -= dx*( (sin(hdy)/hdy)*(2*cos(avg_y) + lat2*sin(avg_y)) - cos(lat1) );
+  }
+  return (ctrlat*RADIUS*RADIUS);
+}; /* poly_ctrlat */        
+
+/*------------------------------------------------------------------------------
+  double poly_ctrlon(const double x[], const double y[], int n, double clon)
+  This routine is used to calculate the lontitude of the centroid.
+   ---------------------------------------------------------------------------*/
+double poly_ctrlon(const double x[], const double y[], int n, double clon)
+{
+  double ctrlon = 0.0;
+  int    i;
+
+  clon = clon;
+  for (i=0;i<n;i++) {
+    int ip = (i+1) % n;
+    double phi1, phi2, dphi, lat1, lat2, dphi1, dphi2;
+    double f1, f2, fac, fint;
+    phi1   = x[ip];
+    phi2   = x[i];
+    lat1 = y[ip];
+    lat2 = y[i];    
+    dphi   = phi1 - phi2;
+    
+    if      (dphi==0.0) continue;
+
+    f1 = 0.5*(cos(lat1)*sin(lat1)+lat1);
+    f2 = 0.5*(cos(lat2)*sin(lat2)+lat2);
+
+     /* this will make sure longitude of centroid is at 
+        the same interval as the center of any grid */  
+    if(dphi > M_PI)  dphi = dphi - 2.0*M_PI;
+    if(dphi < -M_PI) dphi = dphi + 2.0*M_PI;
+    dphi1 = phi1 - clon;
+    if( dphi1 > M_PI) dphi1 -= 2.0*M_PI;
+    if( dphi1 <-M_PI) dphi1 += 2.0*M_PI;
+    dphi2 = phi2 -clon;
+    if( dphi2 > M_PI) dphi2 -= 2.0*M_PI;
+    if( dphi2 <-M_PI) dphi2 += 2.0*M_PI;    
+
+    if(abs(dphi2 -dphi1) < M_PI) {
+      ctrlon -= dphi * (dphi1*f1+dphi2*f2)/2.0;
+    }
+    else {
+      if(dphi1 > 0.0)
+	fac = M_PI;
+      else
+	fac = -M_PI;
+      fint = f1 + (f2-f1)*(fac-dphi1)/abs(dphi);
+      ctrlon -= 0.5*dphi1*(dphi1-fac)*f1 - 0.5*dphi2*(dphi2+fac)*f2
+	+ 0.5*fac*(dphi1+dphi2)*fint;
+	}
+    
+  }
+  return (ctrlon*RADIUS*RADIUS);
+};   /* poly_ctrlon */
+
+/* -----------------------------------------------------------------------------
+   double box_ctrlat(double ll_lon, double ll_lat, double ur_lon, double ur_lat)
+   This routine is used to calculate the latitude of the centroid.
+   ---------------------------------------------------------------------------*/
+double box_ctrlat(double ll_lon, double ll_lat, double ur_lon, double ur_lat)
+{
+  double dphi = ur_lon-ll_lon;
+  double ctrlat;
+  
+  if(dphi > M_PI)  dphi = dphi - 2.0*M_PI;
+  if(dphi < -M_PI) dphi = dphi + 2.0*M_PI;
+  ctrlat = dphi*(cos(ur_lat) + ur_lat*sin(ur_lat)-(cos(ll_lat) + ll_lat*sin(ll_lat)));
+  return (ctrlat*RADIUS*RADIUS); 
+}; /* box_ctrlat */
+
+/*------------------------------------------------------------------------------
+  double box_ctrlon(double ll_lon, double ll_lat, double ur_lon, double ur_lat, double clon)
+  This routine is used to calculate the lontitude of the centroid 
+   ----------------------------------------------------------------------------*/
+double box_ctrlon(double ll_lon, double ll_lat, double ur_lon, double ur_lat, double clon)
+{
+  double phi1, phi2, dphi, lat1, lat2, dphi1, dphi2;
+  double f1, f2, fac, fint;  
+  double ctrlon  = 0.0;
+  int i;
+  clon = clon;  
+  for( i =0; i<2; i++) {
+    if(i == 0) {
+      phi1 = ur_lon;
+      phi2 = ll_lon;
+      lat1 = lat2 = ll_lat;
+    }
+    else {
+      phi1 = ll_lon;
+      phi2 = ur_lon;
+      lat1 = lat2 = ur_lat;
+    }
+    dphi   = phi1 - phi2;
+    f1 = 0.5*(cos(lat1)*sin(lat1)+lat1);
+    f2 = 0.5*(cos(lat2)*sin(lat2)+lat2);
+
+    if(dphi > M_PI)  dphi = dphi - 2.0*M_PI;
+    if(dphi < -M_PI) dphi = dphi + 2.0*M_PI;
+    /* make sure the center is in the same grid box. */
+    dphi1 = phi1 - clon;
+    if( dphi1 > M_PI) dphi1 -= 2.0*M_PI;
+    if( dphi1 <-M_PI) dphi1 += 2.0*M_PI;
+    dphi2 = phi2 -clon;
+    if( dphi2 > M_PI) dphi2 -= 2.0*M_PI;
+    if( dphi2 <-M_PI) dphi2 += 2.0*M_PI;    
+
+    if(abs(dphi2 -dphi1) < M_PI) {
+      ctrlon -= dphi * (dphi1*f1+dphi2*f2)/2.0;
+    }
+    else {
+      if(dphi1 > 0.0)
+	fac = M_PI;
+      else
+	fac = -M_PI;
+      fint = f1 + (f2-f1)*(fac-dphi1)/abs(dphi);
+      ctrlon -= 0.5*dphi1*(dphi1-fac)*f1 - 0.5*dphi2*(dphi2+fac)*f2
+	+ 0.5*fac*(dphi1+dphi2)*fint;
+    }
+  }
+  return (ctrlon*RADIUS*RADIUS);    
+} /* box_ctrlon */
+
+/*******************************************************************************
+  double grid_box_radius(double *x, double *y, double *z, int n);
+  Find the radius of the grid box, the radius is defined the
+  maximum distance between any two vertices
+*******************************************************************************/ 
+double grid_box_radius(const double *x, const double *y, const double *z, int n)
+{
+  double radius;
+  int i, j;
+  
+  radius = 0;
+  for(i=0; i<n-1; i++) {
+    for(j=i+1; j<n; j++) {
+      radius = max(radius, pow(x[i]-x[j],2.)+pow(y[i]-y[j],2.)+pow(z[i]-z[j],2.));
+    }
+  }
+  
+  radius = sqrt(radius);
+
+  return (radius);
+  
+}; /* grid_box_radius */
+
+/*******************************************************************************
+  double dist_between_boxes(const double *x1, const double *y1, const double *z1, int n1,
+			    const double *x2, const double *y2, const double *z2, int n2);
+  Find the distance between any two grid boxes. The distance is defined by the maximum
+  distance between any vertices of these two box
+*******************************************************************************/
+double dist_between_boxes(const double *x1, const double *y1, const double *z1, int n1,
+			  const double *x2, const double *y2, const double *z2, int n2)
+{
+  double dist;
+  int i, j;
+
+  dist = 0.0;
+  for(i=0; i<n1; i++) {
+    for(j=0; j<n2; j++) {   
+      dist = max(dist, pow(x1[i]-x2[j],2.)+pow(y1[i]-y2[j],2.)+pow(z1[i]-z2[j],2.));
+    }
+  }
+
+  dist = sqrt(dist);
+  return (dist);
+
+}; /* dist_between_boxes */
+
+/*******************************************************************************
+ int inside_edge(double x0, double y0, double x1, double y1, double x, double y)
+ determine a point(x,y) is inside or outside a given edge with vertex,
+ (x0,y0) and (x1,y1). return 1 if inside and 0 if outside. <y1-y0, -(x1-x0)> is
+ the outward edge normal from vertex <x0,y0> to <x1,y1>. <x-x0,y-y0> is the vector
+ from <x0,y0> to <x,y>. 
+ if Inner produce <x-x0,y-y0>*<y1-y0, -(x1-x0)> > 0, outside, otherwise inside.
+ inner product value = 0 also treate as inside.
+*******************************************************************************/
+int inside_edge(double x0, double y0, double x1, double y1, double x, double y)
+{
+   const double SMALL = 1.e-12;
+   double product;
+   
+   product = ( x-x0 )*(y1-y0) + (x0-x1)*(y-y0);
+   return (product<=SMALL) ? 1:0;
+   
+ }; /* inside_edge */
+
+
+/* The following is a test program to test subroutines in create_xgrid.c */
+
+#ifdef test_create_xgrid
+
+#include "create_xgrid.h"
+#include <math.h>
+
+#define D2R (M_PI/180)
+#define R2D (180/M_PI)
+#define MAXPOINT 1000
+
+int main(int argc, char* argv[])
+{
+
+  double lon1_in[MAXPOINT], lat1_in[MAXPOINT];
+  double lon2_in[MAXPOINT], lat2_in[MAXPOINT];
+  double x1_in[MAXPOINT], y1_in[MAXPOINT], z1_in[MAXPOINT];
+  double x2_in[MAXPOINT], y2_in[MAXPOINT], z2_in[MAXPOINT];
+  double lon_out[20], lat_out[20];
+  double x_out[20], y_out[20], z_out[20];
+  int    n1_in, n2_in, n_out, i, j;
+  int    nlon1=0, nlat1=0, nlon2=0, nlat2=0;
+  int    n;
+  int    ntest = 11;
+  
+
+  for(n=11; n<=ntest; n++) {
+    
+    switch (n) {
+    case 1:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 1:
+       box 1: (20,10), (20,12), (22,12), (22,10)
+       box 2: (21,11), (21,14), (24,14), (24,11)
+       out  : (21, 12.0018), (22, 12), (22, 11.0033), (21, 11) 
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+      lon1_in[0] = 20; lat1_in[0] = 10;
+      lon1_in[1] = 20; lat1_in[1] = 12;
+      lon1_in[2] = 22; lat1_in[2] = 12;
+      lon1_in[3] = 22; lat1_in[3] = 10;
+      lon2_in[0] = 21; lat2_in[0] = 11;
+      lon2_in[1] = 21; lat2_in[1] = 14;
+      lon2_in[2] = 24; lat2_in[2] = 14;
+      lon2_in[3] = 24; lat2_in[3] = 11;
+      break;
+      
+    case 2:
+      /****************************************************************
+
+        test clip_2dx2d_great_cirle case 2: two identical box
+        box 1: (20,10), (20,12), (22,12), (22,10)
+        box 2: (20,10), (20,12), (22,12), (22,10)
+        out  : (20,10), (20,12), (22,12), (22,10)
+
+      ****************************************************************/      
+      lon1_in[0] = 20; lat1_in[0] = 10;
+      lon1_in[1] = 20; lat1_in[1] = 12;
+      lon1_in[2] = 22; lat1_in[2] = 12;
+      lon1_in[3] = 22; lat1_in[3] = 10;  
+
+      for(i=0; i<n2_in; i++) {
+	lon2_in[i] = lon1_in[i];
+	lat2_in[i] = lat1_in[i];
+      }
+      break;
+
+    case 3:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 3: one cubic sphere grid close to the pole with lat-lon grid.
+       box 1: (251.7, 88.98), (148.3, 88.98), (57.81, 88.72), (342.2, 88.72) 
+       box 2: (150, 88), (150, 90), (152.5, 90), (152.5, 88)
+       out  : (152.5, 89.0642), (150, 89.0165), (0, 90) 
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+      lon1_in[0] = 251.7; lat1_in[0] = 88.98;
+      lon1_in[1] = 148.3; lat1_in[1] = 88.98;
+      lon1_in[2] = 57.81; lat1_in[2] = 88.72;
+      lon1_in[3] = 342.2; lat1_in[3] = 88.72;
+
+      lon2_in[0] = 150; lat2_in[0] = 88;
+      lon2_in[1] = 150; lat2_in[1] = 90;
+      lon2_in[2] = 152.5; lat2_in[2] = 90;
+      lon2_in[3] = 152.5; lat2_in[3] = 88;
+      /*
+      for(i=0; i<4; i++) {
+	lon2_in[i] = lon1_in[i];
+	lat2_in[i] = lat1_in[i];
+      }
+      */
+      break;
+
+    case 4:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 4: One box contains the pole
+       box 1: (-160, 88.5354), (152.011, 87.8123) , (102.985, 88.4008), (20, 89.8047) 
+       box 2: (145,88), (145,90), (150,90), (150,88)
+       out  : (145.916, 88.0011), (145, 88.0249), (0, 90), (150, 88) 
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+
+      lon1_in[0] = -160;  lat1_in[0] = 88.5354;
+      lon1_in[1] = 152.011; lat1_in[1] = 87.8123;
+      lon1_in[2] = 102.985; lat1_in[2] = 88.4008;
+      lon1_in[3] = 20; lat1_in[3] = 89.8047;  
+
+      lon2_in[0] = 145; lat2_in[0] = 88;
+      lon2_in[1] = 145; lat2_in[1] = 90;
+      lon2_in[2] = 150; lat2_in[2] = 90;
+      lon2_in[3] = 150; lat2_in[3] = 88;
+      break;
+
+    case 5:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 5: One tripolar grid around the pole with lat-lon grid.
+       box 1: (-202.6, 87.95), (-280, 89.56), (-100, 90), (-190, 88)
+       box 2: (21,11), (21,14), (24,14), (24,11)
+       out  : (150, 88.7006), (145,  88.9507), (0, 90) 
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+
+      lon1_in[0] = -202.6;  lat1_in[0] = 87.95;
+      lon1_in[1] = -280.;   lat1_in[1] = 89.56;
+      lon1_in[2] = -100.0; lat1_in[2] = 90;
+      lon1_in[3] = -190.; lat1_in[3] = 88;  
+
+      lon2_in[0] = 145; lat2_in[0] = 88;
+      lon2_in[1] = 145; lat2_in[1] = 90;
+      lon2_in[2] = 150; lat2_in[2] = 90;
+      lon2_in[3] = 150; lat2_in[3] = 88;
+      break; 
+
+    case 6:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 6: One cubic sphere grid arounc the pole with one tripolar grid box
+                                       around the pole.
+       box 1: (-160, 88.5354), (152.011, 87.8123) , (102.985, 88.4008), (20, 89.8047) 
+       box 2: (-202.6, 87.95), (-280, 89.56), (-100, 90), (-190, 88)
+       out  : (170, 88.309), (157.082, 88.0005), (83.714, 89.559), (80, 89.6094), (0, 90), (200, 88.5354) 
+
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+
+      lon1_in[0] = -160;  lat1_in[0] = 88.5354;
+      lon1_in[1] = 152.011; lat1_in[1] = 87.8123;
+      lon1_in[2] = 102.985; lat1_in[2] = 88.4008;
+      lon1_in[3] = 20; lat1_in[3] = 89.8047;  
+
+      lon2_in[0] = -202.6;  lat2_in[0] = 87.95;
+      lon2_in[1] = -280.;   lat2_in[1] = 89.56;
+      lon2_in[2] = -100.0;  lat2_in[2] = 90;
+      lon2_in[3] = -190.;   lat2_in[3] = 88;
+      break;
+
+    case 7:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 7: One small grid box inside a big grid box.
+       box 1: (20,10), (20,12), (22,12), (22,10)
+       box 2: (18,8), (18,14), (24,14), (24,8)
+       out  : (20,10), (20,12), (22,12), (22,10)
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+      lon1_in[0] = 20; lat1_in[0] = 10;
+      lon1_in[1] = 20; lat1_in[1] = 12;
+      lon1_in[2] = 22; lat1_in[2] = 12;
+      lon1_in[3] = 22; lat1_in[3] = 10;
+      lon2_in[0] = 18; lat2_in[0] = 8;
+      lon2_in[1] = 18; lat2_in[1] = 14;
+      lon2_in[2] = 24; lat2_in[2] = 14;
+      lon2_in[3] = 24; lat2_in[3] = 8;
+      break;
+
+    case 8:
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 8: Cubic sphere grid at tile = 1, point (i=25,j=1)
+          with N45 at (i=141,j=23)
+       box 1: 
+       box 2: 
+       out  : None
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+      /* first a simple lat-lo
+	 n grid box to clip another lat-lon grid box */
+      lon1_in[0] = 350.0; lat1_in[0] = -45;
+      lon1_in[1] = 350.0; lat1_in[1] = -43.43;
+      lon1_in[2] = 352.1; lat1_in[2] = -43.41;
+      lon1_in[3] = 352.1; lat1_in[3] = -44.98;
+      lon2_in[0] = 350.0;   lat2_in[0] = -46;
+      lon2_in[1] = 350.0;   lat2_in[1] = -44;
+      lon2_in[2] = 352.5; lat2_in[2] = -44;
+      lon2_in[3] = 352.5; lat2_in[3] = -46;
+      break;      
+
+    case 9:      
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 9: Cubic sphere grid at tile = 1, point (i=1,j=1)
+          with N45 at (i=51,j=61)
+       box 1: 
+       box 2: 
+       out  : None
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+
+      lon1_in[0] = 305.0; lat1_in[0] = -35.26;
+      lon1_in[1] = 305.0; lat1_in[1] = -33.80;
+      lon1_in[2] = 306.6; lat1_in[2] = -34.51;
+      lon1_in[3] = 306.6; lat1_in[3] = -35.99;
+      lon2_in[0] = 125;   lat2_in[0] = 32;
+      lon2_in[1] = 125;   lat2_in[1] = 34;
+      lon2_in[2] = 127.5; lat2_in[2] = 34;
+      lon2_in[3] = 127.5; lat2_in[3] = 32;
+      break;      
+
+    case 10:      
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 10: Cubic sphere grid at tile = 3, point (i=24,j=1)
+          with N45 at (i=51,j=46)
+       box 1: 
+       box 2: 
+       out  : None
+
+      ****************************************************************/
+      n1_in = 4; n2_in = 4;  
+
+      lon1_in[0] = 125.0; lat1_in[0] = 1.46935;
+      lon1_in[1] = 126.573; lat1_in[1] = 1.5091;
+      lon1_in[2] = 126.573; lat1_in[2] = 0;
+      lon1_in[3] = 125.0; lat1_in[3] = 0;
+      lon2_in[0] = 125;   lat2_in[0] = 0;
+      lon2_in[1] = 125;   lat2_in[1] = 2;
+      lon2_in[2] = 127.5; lat2_in[2] = 2;
+      lon2_in[3] = 127.5; lat2_in[3] = 0;
+      break;      
+
+    case 11:      
+      /****************************************************************
+
+       test clip_2dx2d_great_cirle case 10: Cubic sphere grid at tile = 3, point (i=24,j=1)
+          with N45 at (i=51,j=46)
+       box 1: 
+       box 2: 
+       out  : 
+
+      ****************************************************************/
+      nlon1 = 1;
+      nlat1 = 1;
+      nlon2 = 1;
+      nlat2 = 1;
+      n1_in = (nlon1+1)*(nlat1+1);
+      n2_in = (nlon2+1)*(nlat2+1);
+
+      lon1_in[0] = 350.0; lat1_in[0] = 90.00;
+      lon1_in[1] = 170.0; lat1_in[1] = 87.92;
+      lon1_in[2] = 260.0; lat1_in[2] = 87.92;
+      lon1_in[3] = 215.0;  lat1_in[3] = 87.06;
+      
+/*       lon1_in[0] = 35.0; lat1_in[0] = 87.06; */
+/*       lon1_in[1] = 80.0; lat1_in[1] = 87.92; */
+/*       lon1_in[2] = 125.0; lat1_in[2] = 87.06; */
+/*       lon1_in[3] = 350.0; lat1_in[3] = 87.92; */
+/*       lon1_in[4] = 350.0; lat1_in[4] = 90.00; */
+/*       lon1_in[5] = 170.0; lat1_in[5] = 87.92; */
+/*       lon1_in[6] = 305.0; lat1_in[6] = 87.06; */
+/*       lon1_in[7] = 260.0; lat1_in[7] = 87.92; */
+/*       lon1_in[8] = 215.0;  lat1_in[8] = 87.06; */
+
+      lon2_in[0] = 167.5; lat2_in[0] = 88;
+      lon2_in[1] = 170;   lat2_in[1] = 88;
+      lon2_in[2] = 167.5; lat2_in[2] = 90;
+      lon2_in[3] = 170;   lat2_in[3] = 90;
+      
+/*       nlon1 = 3; */
+/*       nlat1 = 2; */
+/*       nlon2 = 1; */
+/*       nlat2 = 1; */
+/*       n1_in = (nlon1+1)*(nlat1+1); */
+/*       n2_in = (nlon2+1)*(nlat2+1); */
+
+/*       lon1_in[0] = 35.00;     lat1_in[0] = -59.90; */
+/*       lon1_in[1] = 37.64;     lat1_in[1] = -58.69; */
+/*       lon1_in[2] = 40.07;     lat1_in[2] = -57.44; */
+/*       lon1_in[3] = 42.32;     lat1_in[3] = -56.15; */
+/*       lon1_in[4] = 32.36;     lat1_in[4] = -58.69; */
+/*       lon1_in[5] = 35.00;     lat1_in[5] = -57.56; */
+/*       lon1_in[6] = 37.45;     lat1_in[6] = -56.39; */
+/*       lon1_in[7] = 39.74;     lat1_in[7] = -55.18; */
+/*       lon1_in[8] = 29.93;     lat1_in[8] = -57.44; */
+/*       lon1_in[9] = 32.55;     lat1_in[9] = -56.39; */
+/*       lon1_in[10] = 35.00;     lat1_in[10] = -55.29; */
+/*       lon1_in[11] = 37.30;     lat1_in[11] = -54.16; */
+/*       lon2_in[0] = 35;   lat2_in[0] = -58; */
+/*       lon2_in[1] = 37.5; lat2_in[1] = -58; */
+/*       lon2_in[2] = 35;   lat2_in[2] = -56; */
+/*       lon2_in[3] = 37.5; lat2_in[3] = -56; */
+
+/*       nlon1 = 1; */
+/*       nlat1 = 1; */
+/*       nlon2 = 1; */
+/*       nlat2 = 1; */
+/*       n1_in = (nlon1+1)*(nlat1+1); */
+/*       n2_in = (nlon2+1)*(nlat2+1); */
+
+/*       lon1_in[0] = 305;     lat1_in[0] = -35.26; */
+/*       lon1_in[1] = 306;     lat1_in[1] = -35.99; */
+/*       lon1_in[2] = 305;     lat1_in[2] = -33.80; */
+/*       lon1_in[3] = 306;     lat1_in[3] = -34.51; */
+/*       lon2_in[0] = 305;   lat2_in[0] = -34; */
+/*       lon2_in[1] = 307.5; lat2_in[1] = -34; */
+/*       lon2_in[2] = 305;   lat2_in[2] = -32; */
+/*       lon2_in[3] = 307.5; lat2_in[3] = -32; */
+
+       nlon1 = 2; 
+       nlat1 = 2; 
+       nlon2 = 1; 
+       nlat2 = 1;
+      n1_in = (nlon1+1)*(nlat1+1);
+      n2_in = (nlon2+1)*(nlat2+1);
+       
+      lon1_in[0] = 111.3; lat1_in[0] = 1.591;
+      lon1_in[1] = 109.7; lat1_in[1] = 2.926;
+      lon1_in[2] = 108.2; lat1_in[2] = 4.256;
+      lon1_in[3] = 110.0; lat1_in[3] = 0.000;
+      lon1_in[4] = 108.4; lat1_in[4] = 1.335;
+      lon1_in[5] = 106.8; lat1_in[5] = 2.668;
+      lon1_in[6] = 108.7; lat1_in[6] = -1.591;
+      lon1_in[7] = 107.1; lat1_in[7] = -0.256;
+      lon1_in[8] = 105.5;  lat1_in[8] = 1.078;
+
+      lon2_in[0] = 107.5; lat2_in[0] = 0;
+      lon2_in[1] = 110;   lat2_in[1] = 0;
+      lon2_in[2] = 107.5; lat2_in[2] = 2;
+      lon2_in[3] = 110;   lat2_in[3] = 2;
+      
+      break;      
+      
+    case 12:
+      /****************************************************************
+
+       test : create_xgrid_great_circle
+       box 1: (20,10), (20,12), (22,12), (22,10)
+       box 2: (21,11), (21,14), (24,14), (24,11)
+       out  : (21, 12.0018), (22, 12), (22, 11.0033), (21, 11) 
+
+      ****************************************************************/
+      nlon1 = 2;
+      nlat1 = 2;
+      nlon2 = 3;
+      nlat2 = 3;
+      n1_in = (nlon1+1)*(nlat1+1);
+      n2_in = (nlon2+1)*(nlat2+1);
+      
+      /* first a simple lat-lon grid box to clip another lat-lon grid box */
+      for(j=0; j<=nlat1; j++) for(i=0; i<=nlon1; i++){
+	lon1_in[j*(nlon1+1)+i] = 20.0 + (i-1)*2.0;
+	lat1_in[j*(nlon1+1)+i] = 10.0 + (j-1)*2.0;
+      }
+       for(j=0; j<=nlat2; j++) for(i=0; i<=nlon2; i++){
+	lon2_in[j*(nlon2+1)+i] = 19.0 + (i-1)*2.0;
+	lat2_in[j*(nlon2+1)+i] = 9.0 + (j-1)*2.0;
+      }
+	
+      break;
+
+    case 13:
+
+      nlon1 = 1;
+      nlat1 = 1;
+      nlon2 = 1;
+      nlat2 = 1;
+      n1_in = (nlon1+1)*(nlat1+1);
+      n2_in = (nlon2+1)*(nlat2+1);
+
+/*       lon1_in[0] = ; lat1_in[0] = ; */
+/*       lon1_in[1] = ; lat1_in[1] = ; */
+/*       lon1_in[2] = ; lat1_in[2] = ; */
+/*       lon1_in[3] = ; lat1_in[3] = ; */
+/*       lon2_in[0] = ; lat2_in[0] = ; */
+/*       lon2_in[1] = ; lat2_in[1] = ; */
+/*       lon2_in[2] = ; lat2_in[2] = ; */
+/*       lon2_in[3] = ; lat2_in[3] = ;     */
+      
+/*       lon1_in[0] = 1.35536; lat1_in[0] = 1.16251; */
+/*       lon1_in[1] = 1.36805; lat1_in[1] = 1.15369; */
+/*       lon1_in[2] = 1.37843; lat1_in[2] = 1.16729; */
+/*       lon1_in[3] = 1.39048; lat1_in[3] = 1.15826; */
+/*       lon2_in[0] = 1.34611; lat2_in[0] = 1.16372; */
+/*       lon2_in[1] = 1.35616; lat2_in[1] = 1.15802;    */
+/*       lon2_in[2] = 1.35143; lat2_in[2] = 1.16509; */
+/*       lon2_in[3] = 1.36042; lat2_in[3] = 1.15913; */
+
+/*       lon1_in[0] = 12.508065121288551; lat1_in[0] = -87.445883646793547; */
+/*       lon1_in[1] = 325.425637772; lat1_in[1] = -86.481216821859505; */
+/*       lon1_in[2] = 97.5; lat1_in[2] = -89.802136057677174; */
+/*       lon1_in[3] = 277.5; lat1_in[3] = -87.615232005344637; */
+
+/*       for(j=0; j<=nlat2; j++) for(i=0; i<=nlon2; i++) { */
+/* 	lon2_in[j*(nlon2+1)+i] = -280.0 + i*1.0; */
+/* 	lat2_in[j*(nlon2+1)+i] = -90.0 + j*8.0; */
+/*       } */
+      lon1_in[0] = 120.369397984526174; lat1_in[0] = 16.751543427495864;
+      lon1_in[1] = 119.999999999999986; lat1_in[1] = 16.751871929590038;
+      lon1_in[2] = 120.369397846883501; lat1_in[2] = 16.397797979598028;
+      lon1_in[3] = 119.999999999999986; lat1_in[3] = 16.398120477217255;
+      lon2_in[0] = 120.369415056522087; lat2_in[0] = 16.752176828509153;
+      lon2_in[1] = 119.999999999999986; lat2_in[1] = 16.752505523196167;
+      lon2_in[2] = 120.369415056522087; lat2_in[2] = 16.397797949548146;
+      lon2_in[3] = 119.999999999999986; lat2_in[3] = 16.398120477217255;      
+      
+      break;
+
+      
+    default:
+      error_handler("test_create_xgrid: incorrect case number");
+    }
+
+    /* convert to radian */
+
+    for(i=0; i<n1_in; i++) {
+      lon1_in[i] *= D2R; lat1_in[i] *=D2R;
+    }
+    for(i=0; i<n2_in; i++) {
+      lon2_in[i] *= D2R; lat2_in[i] *=D2R;
+    }
+    
+  
+    printf("\n*********************************************************\n");
+    printf("\n               Case %d                                    \n", n);
+    printf("\n*********************************************************\n");
+
+
+    if( n > 10 ) {
+      int nxgrid;
+      int *i1, *j1, *i2, *j2;
+      double *xarea, *xclon, *xclat, *mask1;
+
+      mask1 = (double *)malloc(nlon1*nlat1*sizeof(double));
+      i1    = (int    *)malloc(MAXXGRID*sizeof(int));
+      j1    = (int    *)malloc(MAXXGRID*sizeof(int));
+      i2    = (int    *)malloc(MAXXGRID*sizeof(int));
+      j2    = (int    *)malloc(MAXXGRID*sizeof(int));
+      xarea = (double *)malloc(MAXXGRID*sizeof(double));
+      xclon = (double *)malloc(MAXXGRID*sizeof(double));
+      xclat = (double *)malloc(MAXXGRID*sizeof(double));
+
+      for(i=0; i<nlon1*nlat1; i++) mask1[i] = 1.0;
+      
+      nxgrid = create_xgrid_great_circle(&nlon1, &nlat1, &nlon2, &nlat2, lon1_in, lat1_in,
+					 lon2_in, lat2_in, mask1, i1, j1, i2, j2,
+					 xarea, xclon, xclat);
+      printf("\n*********************************************************\n");
+      printf("\n     First input grid box longitude, latitude   \n \n");
+      for(i=0; i<n1_in; i++) printf(" %g,  %g \n", lon1_in[i]*R2D, lat1_in[i]*R2D);
+  
+      printf("\n     Second input grid box longitude, latitude \n \n");
+      for(i=0; i<n2_in; i++) printf(" %g,  %g \n", lon2_in[i]*R2D, lat2_in[i]*R2D);
+
+      printf("\n  Number of exchange grid is %d\n", nxgrid);
+      for(i=0; i<nxgrid; i++) {
+	printf("(i1,j1)=(%d,%d), (i2,j2)=(%d, %d), xgrid_area=%g, xgrid_clon=%g, xgrid_clat=%g\n",
+	       i1[i], j1[i], i2[i], j2[i], xarea[i], xclon[i], xclat[i]);
+      }
+
+      /* comparing the area sum of exchange grid and grid1 area */
+      {
+	double *x1, *y1, *z1, *area1;
+	double area_sum;
+	int    i;
+	area_sum = 0.0;
+	
+	for(i=0; i<nxgrid; i++) {
+	  area_sum+= xarea[i];
+	}
+
+	area1 = (double *)malloc((nlon1)*(nlat1)*sizeof(double));
+	get_grid_great_circle_area_(&nlon1, &nlat1, lon1_in, lat1_in, area1);      
+
+	printf("xgrid area sum is %g, grid 1 area is %g\n", area_sum, area1[0]);
+      }
+	
+      printf("\n");
+      free(i1);
+      free(i2);
+      free(j1);
+      free(j2);
+      free(xarea);
+      free(xclon);
+      free(xclat);
+      free(mask1);      
+    }
+    else {
+      latlon2xyz(n1_in, lon1_in, lat1_in, x1_in, y1_in, z1_in);
+      latlon2xyz(n2_in, lon2_in, lat2_in, x2_in, y2_in, z2_in);
+    
+      n_out = clip_2dx2d_great_circle(x1_in, y1_in, z1_in, 4, x2_in, y2_in, z2_in, n2_in,
+				      x_out, y_out,  z_out);
+      xyz2latlon(n_out, x_out, y_out, z_out, lon_out, lat_out);
+
+      printf("\n*********************************************************\n");
+      printf("\n     First input grid box longitude, latitude   \n \n");
+      for(i=0; i<n1_in; i++) printf(" %g,  %g \n", lon1_in[i]*R2D, lat1_in[i]*R2D);
+  
+      printf("\n     Second input grid box longitude, latitude \n \n");
+      for(i=0; i<n2_in; i++) printf(" %g,  %g \n", lon2_in[i]*R2D, lat2_in[i]*R2D);
+  
+      printf("\n     output clip grid box longitude, latitude for case 1 \n \n");
+      for(i=0; i<n_out; i++) printf(" %g,  %g \n", lon_out[i]*R2D, lat_out[i]*R2D);
+      printf("\n");
+    }
+  }
+}
+
+
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/create_xgrid.h b/sorc/fre-nctools.fd/shared_lib/create_xgrid.h
new file mode 100644
index 0000000..d72958e
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/create_xgrid.h
@@ -0,0 +1,56 @@
+#ifndef CREATE_XGRID_H_
+#define CREATE_XGRID_H_
+#ifndef MAXXGRID
+#define MAXXGRID 1e6
+#endif
+
+#define MV 50
+/* this value is small compare to earth area */
+
+double poly_ctrlon(const double lon[], const double lat[], int n, double clon);
+double poly_ctrlat(const double lon[], const double lat[], int n);
+double box_ctrlon(double ll_lon, double ll_lat, double ur_lon, double ur_lat, double clon);
+double box_ctrlat(double ll_lon, double ll_lat, double ur_lon, double ur_lat);
+int get_maxxgrid(void);
+void get_grid_area(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area);
+void get_grid_great_circle_area(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area);
+void get_grid_area_dimensionless(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area);
+void get_grid_area_no_adjust(const int *nlon, const int *nlat, const double *lon, const double *lat, double *area);
+int clip(const double lon_in[], const double lat_in[], int n_in, double ll_lon, double ll_lat,
+	 double ur_lon, double ur_lat, double lon_out[], double lat_out[]);
+int clip_2dx2d(const double lon1_in[], const double lat1_in[], int n1_in, 
+	       const double lon2_in[], const double lat2_in[], int n2_in, 
+	       double lon_out[], double lat_out[]);
+int create_xgrid_1dx2d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out, const double *lon_in,
+			      const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area);
+int create_xgrid_1dx2d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat);
+int create_xgrid_2dx1d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out, const double *lon_in,
+			      const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area);
+int create_xgrid_2dx1d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat);
+int create_xgrid_2dx2d_order1(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out,
+			      int *j_out, double *xgrid_area);
+int create_xgrid_2dx2d_order2(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat);
+int clip_2dx2d_great_circle(const double x1_in[], const double y1_in[], const double z1_in[], int n1_in, 
+			    const double x2_in[], const double y2_in[], const double z2_in [], int n2_in, 
+			    double x_out[], double y_out[], double z_out[]);
+int create_xgrid_great_circle(const int *nlon_in, const int *nlat_in, const int *nlon_out, const int *nlat_out,
+			      const double *lon_in, const double *lat_in, const double *lon_out, const double *lat_out,
+			      const double *mask_in, int *i_in, int *j_in, int *i_out, int *j_out,
+			      double *xgrid_area, double *xgrid_clon, double *xgrid_clat);
+
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/gradient.F90 b/sorc/fre-nctools.fd/shared_lib/gradient.F90
new file mode 100644
index 0000000..d41af30
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/gradient.F90
@@ -0,0 +1,134 @@
+module gradient_mod
+! <CONTACT EMAIL="Zhi.Liang@noaa.gov">
+!   Zhi Liang
+! </CONTACT>
+
+! <HISTORY SRC="http://www.gfdl.noaa.gov/fms-cgi-bin/cvsweb.cgi/FMS/"/>
+
+! <OVERVIEW>
+!    <TT>gradient_mod</TT> implements some utility routines to calculate gradient.
+! </OVERVIEW>
+
+! <DESCRIPTION>
+!    <TT>gradient_mod</TT> implements some utility routines to calculate gradient.
+!    Currently only gradient on cubic grid is implemented. Also a public interface 
+!    is provided to calculate grid information needed to calculate gradient.
+
+use mpp_mod,       only : mpp_error, FATAL
+use constants_mod, only : RADIUS
+
+implicit none
+private
+
+
+public :: gradient_cubic
+public :: calc_cubic_grid_info
+
+character(len=128) :: version = '$Id$'
+character(len=128) :: tagname = '$Name$'
+
+contains
+
+
+!#####################################################################
+!  NOTe: pin has halo size = 1.
+!  the size of pin    will be (nx+2,ny+2), T-cell center, with halo = 1
+!  the size of dx     will be (nx, ny+1),  N-cell center
+!  the size of dy     will be (nx+1, ny),  E-cell center
+!  the size of area   will be (nx, ny),    T-cell center.
+!  The size of edge_w will be (ny+1),      C-cell center
+!  The size of edge_e will be (ny+1),      C-cell center
+!  The size of edge_s will be (nx+1),      C-cell center
+!  The size of edge_n will be (nx+1),      C-cell center
+!  The size of en_n   will be (3,nx,ny+1), N-cell center
+!  The size of en_e   will be (3,nx+1,ny), E-cell center
+!  The size of vlon   will be (3,nx, ny)   T-cell center
+!  The size of vlat   will be (3,nx, ny),  T-cell center
+
+subroutine gradient_cubic(pin, dx, dy, area, edge_w, edge_e, edge_s, edge_n,    &
+                          en_n, en_e, vlon, vlat, grad_x, grad_y, on_west_edge, &
+                          on_east_edge, on_south_edge, on_north_edge)
+
+  real,    dimension(:,:  ), intent(in ) :: pin, dx, dy, area
+  real,    dimension(:    ), intent(in ) :: edge_w, edge_e, edge_s, edge_n
+  real,    dimension(:,:,:), intent(in ) :: en_n, en_e
+  real,    dimension(:,:,:), intent(in ) :: vlon, vlat
+  real,    dimension(:,:  ), intent(out) :: grad_x, grad_y
+  logical,                   intent(in ) :: on_west_edge, on_east_edge, on_south_edge, on_north_edge
+  integer :: nx, ny
+
+
+  nx = size(grad_x,1)
+  ny = size(grad_x,2)
+
+  if(size(pin,1) .NE. nx+2 .OR. size(pin,2) .NE. ny+2)call mpp_error(FATAL, "gradient_mod:size of pin should be (nx+2, ny+2)")
+  if(size(dx,1) .NE. nx .OR. size(dx,2) .NE. ny+1 ) call mpp_error(FATAL, "gradient_mod: size of dx should be (nx,ny+1)")
+  if(size(dy,1) .NE. nx+1 .OR. size(dy,2) .NE. ny ) call mpp_error(FATAL, "gradient_mod: size of dy should be (nx+1,ny)")
+  if(size(area,1) .NE. nx .OR. size(area,2) .NE. ny ) call mpp_error(FATAL, "gradient_mod: size of area should be (nx,ny)")
+  if(size(vlon,1) .NE. 3 .OR. size(vlon,2) .NE. nx .OR. size(vlon,3) .NE. ny) &
+          call mpp_error(FATAL, "gradient_mod: size of vlon should be (3,nx,ny)")
+  if(size(vlat,1) .NE. 3 .OR. size(vlat,2) .NE. nx .OR. size(vlat,3) .NE. ny) &
+          call mpp_error(FATAL, "gradient_mod: size of vlat should be (3,nx,ny)")
+  if(size(edge_w) .NE. ny+1) call mpp_error(FATAL, "gradient_mod: size of edge_w should be (ny+1)")
+  if(size(edge_e) .NE. ny+1) call mpp_error(FATAL, "gradient_mod: size of edge_e should be (ny+1)")
+  if(size(edge_s) .NE. nx+1) call mpp_error(FATAL, "gradient_mod: size of edge_s should be (nx+1)")
+  if(size(edge_n) .NE. nx+1) call mpp_error(FATAL, "gradient_mod: size of edge_n should be (nx+1)")
+  if(size(en_n,1) .NE. 3 .OR. size(en_n,2) .NE. nx .OR.  size(en_n,3) .NE. ny+1 ) &
+       call mpp_error(FATAL, "gradient_mod:size of en_n should be (3, nx, ny+1)")
+  if(size(en_e,1) .NE. 3 .OR. size(en_e,2) .NE. nx+1 .OR.  size(en_e,3) .NE. ny ) &
+       call mpp_error(FATAL, "gradient_mod:size of en_e should be (3, nx+1, ny)")
+
+  call grad_c2l(nx, ny, pin, dx, dy, area, edge_w, edge_e, edge_s, edge_n, en_n, en_e, vlon, vlat, &
+                grad_x, grad_y, on_west_edge, on_east_edge, on_south_edge, on_north_edge)
+
+  return
+
+end subroutine gradient_cubic
+
+
+subroutine calc_cubic_grid_info(xt, yt, xc, yc, dx, dy, area, edge_w, edge_e, edge_s, edge_n, &
+                           en_n, en_e, vlon, vlat, on_west_edge, on_east_edge, on_south_edge, on_north_edge )
+  real,    dimension(:,:  ), intent(in ) :: xt, yt, xc, yc
+  real,    dimension(:,:  ), intent(out) :: dx, dy, area
+  real,    dimension(:    ), intent(out) :: edge_w, edge_e, edge_s, edge_n
+  real,    dimension(:,:,:), intent(out) :: en_n, en_e
+  real,    dimension(:,:,:), intent(out) :: vlon, vlat
+  logical,                   intent(in ) :: on_west_edge, on_east_edge, on_south_edge, on_north_edge
+  integer :: nx, ny, nxp, nyp
+
+
+  nx  = size(area,1)
+  ny  = size(area,2)
+  nxp = nx+1
+  nyp = ny+1
+
+  if(size(xt,1) .NE. nx+2 .OR. size(xt,2) .NE. ny+2 ) call mpp_error(FATAL, "gradient_mod: size of xt should be (nx+2,ny+2)")
+  if(size(yt,1) .NE. nx+2 .OR. size(yt,2) .NE. ny+2 ) call mpp_error(FATAL, "gradient_mod: size of yt should be (nx+2,ny+2)")
+  if(size(xc,1) .NE. nxp .OR. size(xc,2) .NE. nyp ) call mpp_error(FATAL, "gradient_mod: size of xc should be (nx+1,ny+1)")
+  if(size(yc,1) .NE. nxp .OR. size(yc,2) .NE. nyp ) call mpp_error(FATAL, "gradient_mod: size of yc should be (nx+1,ny+1)")
+  if(size(dx,1) .NE. nx .OR. size(dx,2) .NE. nyp ) call mpp_error(FATAL, "gradient_mod: size of dx should be (nx,ny+1)")
+  if(size(dy,1) .NE. nxp .OR. size(dy,2) .NE. ny ) call mpp_error(FATAL, "gradient_mod: size of dy should be (nx+1,ny)")
+  if(size(area,1) .NE. nx .OR. size(area,2) .NE. ny ) call mpp_error(FATAL, "gradient_mod: size of area should be (nx,ny)")
+  if(size(vlon,1) .NE. 3 .OR. size(vlon,2) .NE. nx .OR. size(vlon,3) .NE. ny) &
+          call mpp_error(FATAL, "gradient_mod: size of vlon should be (3,nx,ny)")
+  if(size(vlat,1) .NE. 3 .OR. size(vlat,2) .NE. nx .OR. size(vlat,3) .NE. ny) &
+          call mpp_error(FATAL, "gradient_mod: size of vlat should be (3,nx,ny)")
+  if(size(edge_w) .NE. ny+1) call mpp_error(FATAL, "gradient_mod: size of edge_w should be (ny-1)")
+  if(size(edge_e) .NE. ny+1) call mpp_error(FATAL, "gradient_mod: size of edge_e should be (ny-1)")
+  if(size(edge_s) .NE. nx+1) call mpp_error(FATAL, "gradient_mod: size of edge_s should be (nx-1)")
+  if(size(edge_n) .NE. nx+1) call mpp_error(FATAL, "gradient_mod: size of edge_n should be (nx-1)")
+  if(size(en_n,1) .NE. 3 .OR. size(en_n,2) .NE. nx .OR.  size(en_n,3) .NE. nyp ) &
+       call mpp_error(FATAL, "gradient_mod:size of en_n should be (3, nx, ny+1)")
+  if(size(en_e,1) .NE. 3 .OR. size(en_e,2) .NE. nxp .OR.  size(en_e,3) .NE. ny ) &
+       call mpp_error(FATAL, "gradient_mod:size of en_e should be (3, nx+1, ny)")
+
+
+  call calc_c2l_grid_info(nx, ny, xt, yt, xc, yc, dx, dy, area, edge_w, edge_e, edge_s, edge_n, &
+                          en_n, en_e, vlon, vlat, on_west_edge, on_east_edge, on_south_edge, on_north_edge )
+
+
+  return
+
+end subroutine calc_cubic_grid_info
+
+end module gradient_mod
diff --git a/sorc/fre-nctools.fd/shared_lib/gradient_c2l.c b/sorc/fre-nctools.fd/shared_lib/gradient_c2l.c
new file mode 100644
index 0000000..f218bae
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/gradient_c2l.c
@@ -0,0 +1,438 @@
+#include <math.h>
+#include <stdlib.h>
+#include "constant.h"
+#include "mosaic_util.h"
+#include "gradient_c2l.h"
+#include <stdio.h>
+void a2b_ord2(int nx, int ny, const double *qin, const double *edge_w, const double *edge_e,
+	      const double *edge_s, const double *edge_n, double *qout,
+	      int on_west_edge, int on_east_edge, int on_south_edge, int on_north_edge);
+
+
+/*------------------------------------------------------------------------------
+  Routine to compute gradient terms for SCRIP:
+  SJL: Oct 5, 2007
+  NOTe: pin has halo size = 1.
+  the size of pin    will be (nx+2,ny+2), T-cell center, with halo = 1
+  the size of dx     will be (nx, ny+1),  N-cell center
+  the size of dy     will be (nx+1, ny),  E-cell center
+  the size of area   will be (nx, ny),    T-cell center.
+  The size of edge_w will be (ny+1),      C-cell center
+  The size of edge_e will be (ny+1),      C-cell center
+  The size of edge_s will be (nx+1),      C-cell center
+  The size of edge_n will be (nx+1),      C-cell center
+  The size of en_n   will be (nx, ny+1,3),N-cell center
+  The size of en_e   will be (nx+1,ny,3), E-cell center
+  The size of vlon   will be (nx, ny, 3)  T-cell center
+  The size of vlat   will be (nx, ny, 3), T-cell center
+  ----------------------------------------------------------------------------*/
+void grad_c2l_(const int *nlon, const int *nlat, const double *pin, const double *dx, const double *dy, const double *area,
+	       const double *edge_w, const double *edge_e, const double *edge_s, const double *edge_n,
+	       const double *en_n, const double *en_e, const double *vlon, const double *vlat,
+	       double *grad_x, double *grad_y, const int *on_west_edge, const int *on_east_edge,
+	       const int *on_south_edge, const int *on_north_edge)
+{
+  grad_c2l(nlon, nlat, pin, dx, dy, area, edge_w, edge_e, edge_s, edge_n, en_n, en_e, vlon, vlat, grad_x, grad_y,
+	   on_west_edge, on_east_edge, on_south_edge, on_north_edge);
+}
+  
+void grad_c2l(const int *nlon, const int *nlat, const double *pin, const double *dx, const double *dy, const double *area,
+	      const double *edge_w, const double *edge_e, const double *edge_s, const double *edge_n,
+	      const double *en_n, const double *en_e, const double *vlon, const double *vlat,
+	      double *grad_x, double *grad_y, const int *on_west_edge, const int *on_east_edge,
+	      const int *on_south_edge, const int *on_north_edge)
+{
+
+  double *pb, *pdx, *pdy, *grad3;
+  int nx, ny, nxp, nyp, i, j, m0, m1, m2, n;
+
+  nx    = *nlon;
+  ny    = *nlat;
+  nxp   = nx+1;
+  nyp   = ny+1;
+  pb    = (double *)malloc(nxp*nyp*sizeof(double));
+  pdx   = (double *)malloc(3*nx*(ny+1)*sizeof(double));
+  pdy   = (double *)malloc(3*(nx+1)*ny*sizeof(double));
+  grad3 = (double *)malloc(3*nx*ny*sizeof(double));
+  a2b_ord2(nx, ny, pin, edge_w, edge_e, edge_s, edge_n, pb, *on_west_edge, *on_east_edge,*on_south_edge, *on_north_edge);
+  
+  for(j=0; j<nyp; j++) for(i=0; i<nx; i++) {
+    m0 = j*nx+i;
+    m1 = j*nxp+i;
+    for(n=0; n<3; n++) {
+      pdx[3*m0+n] = 0.5*(pb[m1]+pb[m1+1])*dx[m0]*en_n[3*m0+n];
+    }
+  }
+
+  for(j=0; j<ny; j++) for(i=0; i<nxp; i++) {
+    m0 = j*nxp+i;
+    for(n=0; n<3; n++) {
+      pdy[3*m0+n] = 0.5*(pb[m0]+pb[m0+nxp])*dy[m0]*en_e[3*m0+n];
+    }
+  }
+
+  /* Compute 3D grad of the input scalar field  by Green's theorem */
+  for(j=0; j<ny; j++) for(i=0; i<nx; i++) {
+    m0 = 3*(j*nx+i);
+    for(n=0; n<3; n++) {
+      grad3[m0+n] = pdx[3*((j+1)*nx+i)+n]-pdx[m0+n]-pdy[3*(j*nxp+i)+n]+pdy[3*(j*nxp+i+1)+n];
+    }
+  }
+
+  /* Compute inner product: V3 * grad (pe) */
+  for(j=0; j<ny; j++) for(i=0; i<nx; i++) {
+    m0 = j*nx+i;
+    m1 = 3*m0;
+    /* dq / d(Lamda)*/
+    grad_x[m0] = (vlon[m1]*grad3[m1] + vlon[m1+1]*grad3[m1+1] + vlon[m1+2]*grad3[m1+2])/area[m0];
+    grad_x[m0] *= RADIUS;
+    /* dq / d(theta) */
+    grad_y[m0] = (vlat[m1]*grad3[m1] + vlat[m1+1]*grad3[m1+1] + vlat[m1+2]*grad3[m1+2] )/area[m0];
+    grad_y[m0] *= RADIUS;
+  }
+
+  free(pb);
+  free(pdx);
+  free(pdy);
+  free(grad3);
+  
+}; /* grad_c2l */
+
+/*------------------------------------------------------------------------------
+  qin:  A-grid field, size (nx+2, ny+2)
+  qout: B-grid field, size (nx+1, ny+1)
+  ----------------------------------------------------------------------------*/
+void a2b_ord2(int nx, int ny, const double *qin, const double *edge_w, const double *edge_e,
+	      const double *edge_s, const double *edge_n, double *qout,
+	      int on_west_edge, int on_east_edge, int on_south_edge, int on_north_edge)
+{
+  int    nxp, nyp, i, j;
+  int    istart, iend, jstart, jend;
+  double *q1, *q2;
+  const double r3 = 1./3.;
+
+  nxp = nx+1;
+  nyp = ny+1;
+  q1 = (double *)malloc((nx+2)*sizeof(double));
+  q2 = (double *)malloc((ny+2)*sizeof(double));
+
+  
+  if(on_west_edge)
+    istart = 1;
+  else
+    istart = 0;
+  if(on_east_edge)
+    iend = nx;
+  else
+    iend = nxp;
+  if(on_south_edge)
+    jstart = 1;
+  else
+    jstart = 0;
+  if(on_north_edge)
+    jend = ny;
+  else
+    jend = nyp;
+  
+  /* internal region ( 1: nx-1, 1:ny-1) */
+  for(j=jstart; j<jend; j++) for(i=istart; i<iend; i++) {
+    qout[j*nxp+i] = 0.25*(qin[j*(nx+2)+i] + qin[j*(nx+2)+i+1] +
+			  qin[(j+1)*(nx+2)+i] + qin[(j+1)*(nx+2)+i+1] );
+  }
+
+  /* Fix the 4 Corners */
+  if(on_west_edge && on_south_edge)qout[        0] = r3*(qin[1* (nx+2)+1 ]+qin[1* (nx+2)    ]+qin[             1]); /* sw_corner */
+  if(on_east_edge && on_south_edge)qout[       nx] = r3*(qin[1* (nx+2)+nx]+qin[          nx ]+qin[1*  (nx+2)+nxp]); /* se_corner */
+  if(on_east_edge && on_north_edge)qout[ny*nxp+nx] = r3*(qin[ny*(nx+2)+nx]+qin[ny*(nx+2)+nxp]+qin[nyp*(nx+2)+nx ]); /* ne_corner */
+  if(on_west_edge && on_north_edge)qout[ny*nxp   ] = r3*(qin[ny*(nx+2)+1 ]+qin[ny*(nx+2)    ]+qin[nyp*(nx+2)+1  ]); /* nw_corner */
+  
+  /* West Edges */
+  if(on_west_edge) {
+    for(j=jstart; j<=jend; j++) q2[j] = 0.5*(qin[j*(nx+2)] + qin[j*(nx+2)+1]);
+    for(j=jstart; j<jend; j++) qout[j*nxp] = edge_w[j]*q2[j] + (1-edge_w[j])*q2[j+1];
+  }
+  
+  /* East Edges */
+  if(on_east_edge) {  
+    for(j=jstart; j<=jend; j++)q2[j] = 0.5*(qin[j*(nx+2)+nx] + qin[j*(nx+2)+nxp]);
+    for(j=jstart; j<jend; j++) qout[j*nxp+nx] = edge_e[j]*q2[j] + (1-edge_e[j])*q2[j+1];
+  }
+  
+  /* south edge */
+  if(on_south_edge) {  
+    for(i=istart; i<=iend; i++) q1[i] = 0.5*(qin[i] + qin[(nx+2)+i]);
+    for(i=istart; i<iend; i++) qout[i] = edge_s[i]*q1[i] + (1 - edge_s[i])*q1[i+1];
+  }
+  
+  /* north edge */
+  if(on_north_edge) {  
+     for(i=istart; i<=iend; i++) q1[i] = 0.5*(qin[ny*(nx+2)+i] + qin[nyp*(nx+2)+i]);
+     for(i=istart; i<iend; i++) qout[ny*nxp+i] = edge_n[i]*q1[i] + (1 - edge_n[i])*q1[i+1];  
+  }
+  
+  free(q1);
+  free(q2);
+
+}; /* a2b_ord2 */
+
+
+void get_edge(int nx, int ny, const double *lont, const double *latt,
+	      const double *lonc, const double *latc, double *edge_w, double *edge_e, double *edge_s, double *edge_n,
+	      int on_west_edge, int on_east_edge, int on_south_edge, int on_north_edge)
+{
+  int i, j, nxp, nyp;
+  int istart, iend, jstart, jend;
+  double p1[2], p2[2];
+  double *py, *px;
+  double d1, d2;
+  
+  nxp = nx + 1;
+  nyp = ny + 1;
+
+  for(i=0; i<nxp; i++) {
+    edge_s[i] = 0.5; /* dummy value */
+    edge_n[i] = 0.5; /* dummy value */
+  }
+  for(j=0; j<nyp; j++) {
+    edge_w[j] = 0.5; /* dummy value */
+    edge_e[j] = 0.5; /* dummy value */
+  }  
+    
+  px = (double *)malloc(2*(nx+2)*sizeof(double));
+  py = (double *)malloc(2*(ny+2)*sizeof(double));
+
+  if(on_west_edge)
+    istart = 1;
+  else
+    istart = 0;
+  if(on_east_edge)
+    iend = nx;
+  else
+    iend = nxp;
+  if(on_south_edge)
+    jstart = 1;
+  else
+    jstart = 0;
+  if(on_north_edge)
+    jend = ny;
+  else
+    jend = nyp;  
+  /* west edge */
+
+  if(on_west_edge) {
+    i=0;
+    for(j=jstart; j<=jend; j++) {
+      /* get mid point sphere */
+      p1[0] = lont[j*(nx+2)+i  ]; p1[1] = latt[j*(nx+2)+i  ];
+      p2[0] = lont[j*(nx+2)+i+1]; p2[1] = latt[j*(nx+2)+i+1];
+      mid_pt_sphere(p1, p2, &(py[2*j]));
+    }    
+    
+    for(j=jstart; j<jend; j++) {
+      p1[0] = lonc[j*nxp+i];
+      p1[1] = latc[j*nxp+i];
+      d1 = great_circle_distance(py+2*j, p1);
+      d2 = great_circle_distance(py+2*(j+1), p1);
+      edge_w[j] = d2/(d1+d2);
+    }
+  }
+  /* east edge */
+  if(on_east_edge) {  
+    i=nx;
+    for(j=jstart; j<=jend; j++) {
+      /* get mid point sphere */
+      p1[0] = lont[j*(nx+2)+i  ]; p1[1] = latt[j*(nx+2)+i  ];
+      p2[0] = lont[j*(nx+2)+i+1]; p2[1] = latt[j*(nx+2)+i+1];
+      mid_pt_sphere(p1, p2, &(py[2*j]));
+    }    
+    
+    for(j=jstart; j<jend; j++) {
+      p1[0] = lonc[j*nxp+i];
+      p1[1] = latc[j*nxp+i];
+      d1 = great_circle_distance(&(py[2*j]), p1);
+      d2 = great_circle_distance(&(py[2*(j+1)]), p1);
+      edge_e[j] = d2/(d1+d2);
+    }  
+  }
+  
+  /* south edge */
+  if(on_south_edge) {
+    j=0;
+    for(i=istart; i<=iend; i++) {
+      p1[0] = lont[j    *(nx+2)+i]; p1[1] = latt[j    *(nx+2)+i];
+      p2[0] = lont[(j+1)*(nx+2)+i]; p2[1] = latt[(j+1)*(nx+2)+i];
+      mid_pt_sphere(p1, p2, &(px[2*i]));
+    }
+    for(i=istart; i<iend; i++) {
+      p1[0] = lonc[j*nxp+i];
+      p1[1] = latc[j*nxp+i];
+      d1 = great_circle_distance(&(px[2*i]), p1);
+      d2 = great_circle_distance(&(px[2*(i+1)]), p1);
+      edge_s[i] = d2/(d1+d2);
+    }
+  }
+  /* north edge */
+  if(on_north_edge) {
+    j=ny;
+    for(i=istart; i<=iend; i++) {
+      p1[0] = lont[j    *(nx+2)+i]; p1[1] = latt[j    *(nx+2)+i];
+      p2[0] = lont[(j+1)*(nx+2)+i]; p2[1] = latt[(j+1)*(nx+2)+i];
+      mid_pt_sphere(p1, p2, &(px[2*i]));
+    }
+    for(i=istart; i<iend; i++) {
+      p1[0] = lonc[j*nxp+i];
+      p1[1] = latc[j*nxp+i];
+      d1 = great_circle_distance(&(px[2*i]), p1);
+      d2 = great_circle_distance(&(px[2*(i+1)]), p1);
+      edge_n[i] = d2/(d1+d2);
+    }  
+  }
+  
+  free(px);
+  free(py);
+  
+}; /* get_edge */
+
+void mid_pt_sphere(const double *p1, const double *p2, double *pm)
+{
+  double e1[3], e2[3], e3[3];
+
+  latlon2xyz(1, p1, p1+1, e1, e1+1, e1+2);
+  latlon2xyz(1, p2, p2+1, e2, e2+1, e2+2);
+  mid_pt3_cart(e1, e2, e3);
+  xyz2latlon(1, e3, e3+1, e3+2, pm, pm+1);
+
+}
+
+void mid_pt3_cart(const double *p1, const double *p2, double *e)
+{
+  double dd;
+
+  e[0] = p1[0] + p2[0];
+  e[1] = p1[1] + p2[1];
+  e[2] = p1[2] + p2[2];
+  dd = sqrt( e[0]*e[0] + e[1]*e[1] + e[2]*e[2] );
+  e[0] /= dd;
+  e[1] /= dd;
+  e[2] /= dd;
+}
+
+/**********************************************************************************************
+  This routine is used to calculate grid information for second order conservative interpolation
+  from cubic grid to other grid
+  the size of xt     will be (nx+2,ny+2), T-cell center, with halo = 1
+  the size of yt     will be (nx+2,ny+2), T-cell center, with halo = 1
+  the size of xc     will be (nx+1,ny+1), C-cell center
+  the size of yc     will be (nx+1,ny+1), C-cell center
+  the size of dx     will be (nx, ny+1),  N-cell center
+  the size of dy     will be (nx+1, ny),  E-cell center
+  the size of area   will be (nx, ny),    T-cell center.
+  The size of edge_w will be (ny-1),      C-cell center, without two end point
+  The size of edge_e will be (ny-1),      C-cell center, without two end point
+  The size of edge_s will be (nx-1),      C-cell center, without two end point
+  The size of edge_n will be (nx-1),      C-cell center, without two end point
+  The size of en_n   will be (nx, ny+1,3),N-cell center
+  The size of en_e   will be (nx+1,ny,3), E-cell center
+  The size of vlon   will be (nx, ny)     T-cell center
+  The size of vlat   will be (nx, ny),    T-cell center
+**********************************************************************************************/
+void calc_c2l_grid_info_(int *nx_pt, int *ny_pt, const double *xt, const double *yt, const double *xc, const double *yc,
+		         double *dx, double *dy, double *area, double *edge_w, double *edge_e, double *edge_s,
+		         double *edge_n, double *en_n, double *en_e, double *vlon, double *vlat,
+			int *on_west_edge, int *on_east_edge, int *on_south_edge, int *on_north_edge)
+{
+    calc_c2l_grid_info(nx_pt, ny_pt, xt, yt, xc, yc, dx, dy, area, edge_w, edge_e, edge_s, edge_n,
+		       en_n, en_e, vlon, vlat, on_west_edge, on_east_edge, on_south_edge, on_north_edge);
+
+}
+
+void calc_c2l_grid_info(int *nx_pt, int *ny_pt, const double *xt, const double *yt, const double *xc, const double *yc,
+		        double *dx, double *dy, double *area, double *edge_w, double *edge_e, double *edge_s,
+		        double *edge_n, double *en_n, double *en_e, double *vlon, double *vlat,
+			int *on_west_edge, int *on_east_edge, int *on_south_edge, int *on_north_edge)
+{
+  double *x, *y, *z, *xt_tmp, *yt_tmp;
+  int    nx, ny, nxp, nyp, i, j;
+  double p1[3], p2[3], p3[3], p4[3];
+
+
+  nx  = *nx_pt;
+  ny  = *ny_pt;
+  nxp = nx+1;
+  nyp = ny+1;
+
+  for(j=0; j<nyp; j++) for(i=0; i<nx; i++) {
+    p1[0] = xc[j*nxp+i];
+    p1[1] = yc[j*nxp+i];
+    p2[0] = xc[j*nxp+i+1];
+    p2[1] = yc[j*nxp+i+1];
+    dx[j*nx+i] = great_circle_distance(p1, p2);
+  }
+
+  for(j=0; j<ny; j++) for(i=0; i<nxp; i++) {
+    p1[0] = xc[j*nxp+i];
+    p1[1] = yc[j*nxp+i];
+    p2[0] = xc[(j+1)*nxp+i];
+    p2[1] = yc[(j+1)*nxp+i];
+    dy[j*nxp+i] = great_circle_distance(p1, p2);
+  }
+  
+  for(j=0; j<ny; j++) for(i=0; i<nx; i++) {
+    p1[0] = xc[j*nxp+i];       /* ll lon */
+    p1[1] = yc[j*nxp+i];       /* ll lat */
+    p2[0] = xc[(j+1)*nxp+i];   /* ul lon */
+    p2[1] = yc[(j+1)*nxp+i];   /* ul lat */
+    p3[0] = xc[j*nxp+i+1];     /* lr lon */
+    p3[1] = yc[j*nxp+i+1];     /* lr lat */
+    p4[0] = xc[(j+1)*nxp+i+1]; /* ur lon */
+    p4[1] = yc[(j+1)*nxp+i+1]; /* ur lat */	
+    area[j*nx+i] = spherical_excess_area(p1, p2, p3, p4, RADIUS);
+  }
+
+  x = (double *)malloc(nxp*nyp*sizeof(double));
+  y = (double *)malloc(nxp*nyp*sizeof(double));
+  z = (double *)malloc(nxp*nyp*sizeof(double));
+  
+  latlon2xyz(nxp*nyp, xc, yc, x, y, z);
+  for(j=0; j<nyp; j++) for(i=0; i<nx; i++) {
+    p1[0] = x[j*nxp+i];
+    p1[1] = y[j*nxp+i];
+    p1[2] = z[j*nxp+i];
+    p2[0] = x[j*nxp+i+1];
+    p2[1] = y[j*nxp+i+1];
+    p2[2] = z[j*nxp+i+1];
+    vect_cross(p1, p2, en_n+3*(j*nx+i) );
+    normalize_vect(en_n+3*(j*nx+i));
+  }
+
+  for(j=0; j<ny; j++) for(i=0; i<nxp; i++) {
+    p2[0] = x[j*nxp+i];
+    p2[1] = y[j*nxp+i];
+    p2[2] = z[j*nxp+i];
+    p1[0] = x[(j+1)*nxp+i];
+    p1[1] = y[(j+1)*nxp+i];
+    p1[2] = z[(j+1)*nxp+i];
+    vect_cross(p1, p2, en_e+3*(j*nxp+i) );
+    normalize_vect(en_e+3*(j*nxp+i));
+  }  
+  
+  xt_tmp = (double *)malloc(nx*ny*sizeof(double));
+  yt_tmp = (double *)malloc(nx*ny*sizeof(double));
+  for(j=0; j<ny; j++)for(i=0; i<nx; i++) {
+    xt_tmp[j*nx+i] = xt[(j+1)*(nx+2)+i+1];
+    yt_tmp[j*nx+i] = yt[(j+1)*(nx+2)+i+1];
+  }  
+  unit_vect_latlon(nx*ny, xt_tmp, yt_tmp, vlon, vlat);
+  get_edge(nx, ny, xt, yt, xc, yc, edge_w, edge_e, edge_s, edge_n, *on_west_edge, *on_east_edge,
+	   *on_south_edge, *on_north_edge);
+
+  free(x);
+  free(y);
+  free(z);
+  free(xt_tmp);
+  free(yt_tmp);
+  
+}
+
+
+
diff --git a/sorc/fre-nctools.fd/shared_lib/gradient_c2l.h b/sorc/fre-nctools.fd/shared_lib/gradient_c2l.h
new file mode 100644
index 0000000..e68440a
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/gradient_c2l.h
@@ -0,0 +1,17 @@
+#ifndef GRADIENT_H_
+#define GRADIENT_H_
+void grad_c2l(const int *nlon, const int *nlat, const double *pin, const double *dx, const double *dy, const double *area,
+	      const double *edge_w, const double *edge_e, const double *edge_s, const double *edge_n,
+	      const double *en_n, const double *en_e, const double *vlon, const double *vlat,
+	      double *grad_x, double *grad_y, const int *on_west_edge, const int *on_east_edge,
+	      const int *on_south_edge, const int *on_north_edge);
+void calc_c2l_grid_info(int *nx_pt, int *ny_pt, const double *xt, const double *yt, const double *xc, const double *yc,
+		        double *dx, double *dy, double *area, double *edge_w, double *edge_e, double *edge_s,
+		        double *edge_n, double *en_n, double *en_e, double *vlon, double *vlat,
+                        int *on_west_edge, int *on_east_edge, int *on_south_edge, int *on_north_edge);
+void get_edge(int nx, int ny, const double *lont, const double *latt,
+	      const double *lonc, const double *latc, double *edge_w, double *edge_e, double *edge_s, double *edge_n,
+              int on_west_edge, int on_east_edge, int on_south_edge, int on_north_edge );
+void mid_pt_sphere(const double *p1, const double *p2, double *pm);
+void mid_pt3_cart(const double *p1, const double *p2, double *e);
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/grid.F90 b/sorc/fre-nctools.fd/shared_lib/grid.F90
new file mode 100644
index 0000000..262efd1
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/grid.F90
@@ -0,0 +1,913 @@
+module grid_mod
+
+use mpp_mod, only : mpp_root_pe
+use constants_mod, only : PI, radius
+use fms_mod, only : uppercase, lowercase, field_exist, field_size, read_data, &
+     error_mesg, string, FATAL, NOTE
+use fms_io_mod, only : get_great_circle_algorithm, get_global_att_value
+use mosaic_mod, only : get_mosaic_ntiles, get_mosaic_xgrid_size, get_mosaic_grid_sizes, &
+     get_mosaic_xgrid, calc_mosaic_grid_area, calc_mosaic_grid_great_circle_area
+
+! the following two use statement are only needed for define_cube_mosaic
+use mpp_domains_mod, only : domain2d, mpp_define_mosaic, mpp_get_compute_domain, &
+                            mpp_get_global_domain
+use mosaic_mod, only : get_mosaic_ncontacts, get_mosaic_contact
+
+implicit none;private
+
+! ==== public interfaces =====================================================
+! grid dimension inquiry subroutines
+public :: get_grid_ntiles ! returns number of tiles
+public :: get_grid_size   ! returns horizontal sizes of the grid
+! grid geometry inquiry subroutines
+public :: get_grid_cell_centers 
+public :: get_grid_cell_vertices
+! grid area inquiry subroutines
+public :: get_grid_cell_area
+public :: get_grid_comp_area
+! decompose cubed sphere domains -- probably does not belong here, but it should 
+! be in some place available for component models
+public :: define_cube_mosaic
+! ==== end of public interfaces ==============================================
+
+interface get_grid_size
+   module procedure get_grid_size_for_all_tiles
+   module procedure get_grid_size_for_one_tile
+end interface
+
+interface get_grid_cell_vertices
+   module procedure get_grid_cell_vertices_1D
+   module procedure get_grid_cell_vertices_2D
+end interface
+
+interface get_grid_cell_centers
+   module procedure get_grid_cell_centers_1D
+   module procedure get_grid_cell_centers_2D
+end interface
+
+! ==== module constants ======================================================
+character(len=*), parameter :: &
+     module_name = 'grid_mod', &
+     version     = '$Id$', &
+     tagname     = '$Name$'
+
+character(len=*), parameter :: &
+     grid_dir  = 'INPUT/',     &      ! root directory for all grid files
+     grid_file = 'INPUT/grid_spec.nc' ! name of the grid spec file
+
+integer, parameter :: &
+     MAX_NAME = 256,  & ! max length of the variable names
+     MAX_FILE = 1024, & ! max length of the file names
+     VERSION_0 = 0,   &
+     VERSION_1 = 1,   &
+     VERSION_2 = 2
+
+integer, parameter :: BUFSIZE = 1048576  ! This is used to control memory usage in get_grid_comp_area
+                                         ! We may change this to a namelist variable is needed.
+
+! ==== module variables ======================================================
+integer :: grid_version = -1
+logical :: great_circle_algorithm = .FALSE.
+logical :: first_call = .TRUE.
+
+
+contains 
+
+function get_grid_version()
+  integer :: get_grid_version
+
+  if(first_call) then
+     great_circle_algorithm = get_great_circle_algorithm()
+     first_call = .FALSE.
+  endif
+
+  if(grid_version<0) then
+    if(field_exist(grid_file, 'geolon_t')) then
+       grid_version = VERSION_0 
+    else if(field_exist(grid_file, 'x_T')) then
+       grid_version = VERSION_1
+    else if(field_exist(grid_file, 'ocn_mosaic_file') ) then
+       grid_version = VERSION_2
+    else
+       call error_mesg(module_name//'/get_grid_version',&
+            'Can''t determine the version of the grid spec: none of "x_T", "geolon_t", or "ocn_mosaic_file" exist in file "'//trim(grid_file)//'"', &
+            FATAL )
+    endif
+  endif
+  get_grid_version = grid_version
+end function get_grid_version
+
+
+! ============================================================================
+! returns number of tiles for a given component
+! ============================================================================
+subroutine get_grid_ntiles(component,ntiles)
+  character(len=*)     :: component
+  integer, intent(out) :: ntiles
+
+  ! local vars
+  character(len=MAX_FILE) :: component_mosaic
+
+  select case (get_grid_version())
+  case(VERSION_0,VERSION_1)
+     ntiles = 1
+  case(VERSION_2)
+     call read_data(grid_file,trim(lowercase(component))//'_mosaic_file',component_mosaic)
+     ntiles = get_mosaic_ntiles(grid_dir//trim(component_mosaic))
+  end select
+end subroutine get_grid_ntiles
+
+
+! ============================================================================
+! returns size of the grid for each of the tiles
+! ============================================================================
+subroutine get_grid_size_for_all_tiles(component,nx,ny)
+  character(len=*)     :: component
+  integer, intent(inout) :: nx(:),ny(:)
+
+  ! local vars
+  integer :: siz(4) ! for the size of external fields
+  character(len=MAX_NAME) :: varname1, varname2
+  character(len=MAX_FILE) :: component_mosaic
+  
+  varname1 = 'AREA_'//trim(uppercase(component))
+  varname2 = trim(lowercase(component))//'_mosaic_file'
+
+  select case (get_grid_version())
+  case(VERSION_0,VERSION_1)
+     call field_size(grid_file, varname1, siz)
+     nx(1) = siz(1); ny(1)=siz(2)
+  case(VERSION_2) ! mosaic file
+     call read_data(grid_file,varname2, component_mosaic)
+     call get_mosaic_grid_sizes(grid_dir//trim(component_mosaic),nx,ny)
+  end select
+end subroutine get_grid_size_for_all_tiles
+
+
+! ============================================================================
+! returns size of the grid for one of the tiles
+! ============================================================================
+subroutine get_grid_size_for_one_tile(component,tile,nx,ny)
+  character(len=*)       :: component
+  integer, intent(in)    :: tile
+  integer, intent(inout) :: nx,ny
+  
+  ! local vars
+  integer, allocatable :: nnx(:), nny(:)
+  integer :: ntiles
+
+  call get_grid_ntiles(component, ntiles)
+  if(tile>0.and.tile<=ntiles) then
+     allocate(nnx(ntiles),nny(ntiles))
+     call get_grid_size_for_all_tiles(component,nnx,nny)
+     nx = nnx(tile); ny = nny(tile)
+     deallocate(nnx,nny)
+  else
+     call error_mesg('get_grid_size',&
+          'requested tile index '//trim(string(tile))//' is out of bounds (1:'//trim(string(ntiles))//')',&
+          FATAL)
+  endif
+end subroutine get_grid_size_for_one_tile
+
+! ============================================================================
+! return grid cell area for the specified model component and tile
+! ============================================================================
+subroutine get_grid_cell_area(component, tile, cellarea, domain)
+  character(len=*), intent(in)    :: component
+  integer         , intent(in)    :: tile
+  real            , intent(inout) :: cellarea(:,:)
+  type(domain2d)  , intent(in), optional :: domain
+
+  ! local vars
+  integer :: nlon, nlat
+  real, allocatable :: glonb(:,:), glatb(:,:)
+
+  select case(get_grid_version())
+  case(VERSION_0,VERSION_1)
+     select case(trim(component))
+     case('LND')
+        call read_data(grid_file, 'AREA_LND_CELL', cellarea, &
+            no_domain=.not.present(domain), domain=domain)
+     case('ATM','OCN')
+        call read_data(grid_file, 'AREA_'//trim(uppercase(component)),cellarea,&
+            no_domain=.not.present(domain),domain=domain)
+     case default
+        call error_mesg(module_name//'/get_grid_cell_area',&
+             'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+             FATAL)
+     end select
+     ! convert area to m2
+     cellarea = cellarea*4.*PI*radius**2
+  case(VERSION_2)
+     if (present(domain)) then
+        call mpp_get_compute_domain(domain,xsize=nlon,ysize=nlat)
+     else
+        call get_grid_size(component,tile,nlon,nlat)
+     endif
+     allocate(glonb(nlon+1,nlat+1),glatb(nlon+1,nlat+1))
+     call get_grid_cell_vertices(component, tile, glonb, glatb, domain)
+     if (great_circle_algorithm) then
+        call calc_mosaic_grid_great_circle_area(glonb*pi/180.0, glatb*pi/180.0, cellarea)
+     else
+        call calc_mosaic_grid_area(glonb*pi/180.0, glatb*pi/180.0, cellarea)
+     end if
+     deallocate(glonb,glatb)
+  end select
+
+end subroutine get_grid_cell_area
+
+
+! ============================================================================
+! get the area of the component per grid cell
+! ============================================================================
+subroutine get_grid_comp_area(component,tile,area,domain)
+  character(len=*) :: component
+  integer, intent(in) :: tile
+  real, intent(inout) :: area(:,:)
+  type(domain2d), intent(in), optional :: domain
+  ! local vars
+  integer :: n_xgrid_files ! number of exchange grid files in the mosaic
+  integer :: siz(4), nxgrid
+  integer :: i,j,m,n
+  integer, allocatable :: i1(:), j1(:), i2(:), j2(:)
+  real, allocatable :: xgrid_area(:)
+  real, allocatable :: rmask(:,:)
+  character(len=MAX_NAME) :: &
+     xgrid_name, & ! name of the variable holding xgrid names
+     tile_name,  & ! name of the tile
+     xgrid_file, & ! name of the current xgrid file
+     mosaic_name,& ! name of the mosaic
+     mosaic_file,&
+     tilefile 
+  character(len=4096)     :: attvalue
+  character(len=MAX_NAME), allocatable :: nest_tile_name(:)
+  character(len=MAX_NAME) :: varname1, varname2
+  integer :: is,ie,js,je ! boundaries of our domain
+  integer :: i0, j0 ! offsets for x and y, respectively
+  integer :: num_nest_tile, ntiles
+  logical :: is_nest
+  integer :: found_xgrid_files ! how many xgrid files we actually found in the grid spec
+  integer :: ibegin, iend, bsize, l
+
+  select case (get_grid_version())
+  case(VERSION_0,VERSION_1)
+     select case(component)
+     case('ATM')
+        call read_data(grid_file,'AREA_ATM',area, no_domain=.not.present(domain),domain=domain)
+     case('OCN')
+        allocate(rmask(size(area,1),size(area,2)))
+        call read_data(grid_file,'AREA_OCN',area, no_domain=.not.present(domain),domain=domain)
+        call read_data(grid_file,'wet',     rmask,no_domain=.not.present(domain),domain=domain)
+        area = area*rmask
+        deallocate(rmask)
+     case('LND')
+        call read_data(grid_file,'AREA_LND',area,no_domain=.not.present(domain),domain=domain)
+     case default
+        call error_mesg(module_name//'/get_grid_comp_area',&
+             'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+             FATAL)
+     end select
+  case(VERSION_2) ! mosaic gridspec
+     select case (component)
+     case ('ATM')
+        ! just read the grid cell area and return
+        call get_grid_cell_area(component,tile,area)
+        return
+     case ('LND')
+        xgrid_name = 'aXl_file'
+        call read_data(grid_file, 'lnd_mosaic', mosaic_name)
+        tile_name  = trim(mosaic_name)//'_tile'//char(tile+ichar('0'))
+     case ('OCN')
+        xgrid_name = 'aXo_file'
+        call read_data(grid_file, 'ocn_mosaic', mosaic_name)
+        tile_name  = trim(mosaic_name)//'_tile'//char(tile+ichar('0'))
+     case default
+        call error_mesg(module_name//'/get_grid_comp_area',&
+             'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+             FATAL)
+     end select
+     ! get the boundaries of the requested domain
+     if(present(domain)) then
+        call mpp_get_compute_domain(domain,is,ie,js,je)
+        i0 = 1-is ; j0=1-js
+     else
+        call get_grid_size(component,tile,ie,je)
+        is = 1 ; i0 = 0
+        js = 1 ; j0 = 0
+     endif
+     if (size(area,1)/=ie-is+1.or.size(area,2)/=je-js+1) &
+        call error_mesg(module_name//'/get_grid_comp_area',&
+        'size of the output argument "area" is not consistent with the domain',FATAL) 
+
+     ! find the nest tile 
+     call read_data(grid_file, 'atm_mosaic', mosaic_name)
+     call read_data(grid_file,'atm_mosaic_file',mosaic_file)
+     mosaic_file = grid_dir//trim(mosaic_file)
+     ntiles = get_mosaic_ntiles(trim(mosaic_file))   
+     allocate(nest_tile_name(ntiles))  
+     num_nest_tile = 0
+     do n = 1, ntiles
+        call read_data(mosaic_file, 'gridfiles', tilefile, level=n)        
+        tilefile = grid_dir//trim(tilefile)
+        if( get_global_att_value(tilefile, "nest_grid", attvalue) ) then
+           if(trim(attvalue) == "TRUE") then
+              num_nest_tile = num_nest_tile + 1
+              nest_tile_name(num_nest_tile) = trim(mosaic_name)//'_tile'//char(n+ichar('0'))
+           else if(trim(attvalue) .NE. "FALSE") then
+              call error_mesg(module_name//'/get_grid_comp_area', 'value of global attribute nest_grid in file'// &
+                   trim(tilefile)//' should be TRUE of FALSE', FATAL)
+           endif
+        end if
+     end do
+     area(:,:) = 0.
+     if(field_exist(grid_file,xgrid_name)) then
+        ! get the number of the exchange-grid files
+        call field_size(grid_file,xgrid_name,siz)
+        n_xgrid_files = siz(2)
+        found_xgrid_files = 0
+        ! loop through all exchange grid files
+        do n = 1, n_xgrid_files
+           ! get the name of the current exchange grid file
+           call read_data(grid_file,xgrid_name,xgrid_file,level=n)
+           ! skip the rest of the loop if the name of the current tile isn't found 
+           ! in the file name, but check this only if there is more than 1 tile
+           if(n_xgrid_files>1) then
+              if(index(xgrid_file,trim(tile_name))==0) cycle
+           endif
+           found_xgrid_files = found_xgrid_files + 1
+           !---make sure the atmosphere grid is not a nested grid
+           is_nest = .false. 
+           do m = 1, num_nest_tile
+              if(index(xgrid_file, trim(nest_tile_name(m))) .NE. 0) then
+                 is_nest = .true.
+                 exit
+              end if
+           end do
+           if(is_nest) cycle 
+
+           ! finally read the exchange grid
+           nxgrid = get_mosaic_xgrid_size(grid_dir//xgrid_file)
+           if(nxgrid < BUFSIZE) then
+              allocate(i1(nxgrid), j1(nxgrid), i2(nxgrid), j2(nxgrid), xgrid_area(nxgrid))
+           else
+              allocate(i1(BUFSIZE), j1(BUFSIZE), i2(BUFSIZE), j2(BUFSIZE), xgrid_area(BUFSIZE))
+           endif
+           ibegin = 1
+           do l = 1,nxgrid,BUFSIZE
+              bsize = min(BUFSIZE, nxgrid-l+1)
+              iend = ibegin + bsize - 1
+              call get_mosaic_xgrid(grid_dir//xgrid_file, i1(1:bsize), j1(1:bsize), i2(1:bsize), j2(1:bsize), &
+                                    xgrid_area(1:bsize), ibegin, iend)
+              ! and sum the exchange grid areas
+              do m = 1, bsize
+                 i = i2(m); j = j2(m)
+                 if (i<is.or.i>ie) cycle
+                 if (j<js.or.j>je) cycle
+                 area(i+i0,j+j0) = area(i+i0,j+j0) + xgrid_area(m)
+              end do
+              ibegin = iend + 1
+           enddo
+           deallocate(i1, j1, i2, j2, xgrid_area)
+        enddo
+        if (found_xgrid_files == 0) &
+           call error_mesg('get_grid_comp_area', 'no xgrid files were found for component '& 
+                 //trim(component)//' (mosaic name is '//trim(mosaic_name)//')', FATAL)
+
+     endif
+     deallocate(nest_tile_name)
+  end select ! version
+  ! convert area to m2
+  area = area*4.*PI*radius**2
+end subroutine
+
+! ============================================================================
+! returns arrays of global grid cell boundaries for given model component and 
+! mosaic tile number.
+! NOTE that in case of non-lat-lon grid the returned coordinates may have be not so 
+! meaningful, by the very nature of such grids. But presumably these 1D coordinate 
+! arrays are good enough for diag axis and such.
+! ============================================================================
+subroutine get_grid_cell_vertices_1D(component, tile, glonb, glatb)
+  character(len=*), intent(in) :: component
+  integer,          intent(in) :: tile
+  real,          intent(inout) :: glonb(:),glatb(:)
+
+  integer                      :: nlon, nlat
+  integer                      :: start(4), nread(4)
+  real, allocatable            :: tmp(:,:), x_vert_t(:,:,:), y_vert_t(:,:,:)
+  character(len=MAX_FILE)      :: filename1, filename2
+
+  call get_grid_size_for_one_tile(component, tile, nlon, nlat)
+  if (size(glonb(:))/=nlon+1) &
+       call error_mesg ( module_name//'/get_grid_cell_vertices_1D',&
+       'Size of argument "glonb" is not consistent with the grid size',FATAL)
+  if (size(glatb(:))/=nlat+1) &
+       call error_mesg ( module_name//'/get_grid_cell_vertices_1D',&
+       'Size of argument "glatb" is not consistent with the grid size',FATAL)
+  if(trim(component) .NE. 'ATM' .AND. component .NE. 'LND' .AND. component .NE. 'OCN') then
+     call error_mesg(module_name//'/get_grid_cell_vertices_1D',&
+          'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+          FATAL)     
+  endif
+
+  select case(get_grid_version())
+  case(VERSION_0)
+     select case(trim(component))
+     case('ATM','LND')
+        call read_data(grid_file, 'xb'//lowercase(component(1:1)), glonb, no_domain=.true.)
+        call read_data(grid_file, 'yb'//lowercase(component(1:1)), glatb, no_domain=.true.)
+     case('OCN')
+        call read_data(grid_file, "gridlon_vert_t", glonb, no_domain=.true.) 
+        call read_data(grid_file, "gridlat_vert_t", glatb, no_domain=.true.) 
+     end select
+  case(VERSION_1)
+     select case(trim(component))
+     case('ATM','LND')
+        call read_data(grid_file, 'xb'//lowercase(component(1:1)), glonb, no_domain=.true.)
+        call read_data(grid_file, 'yb'//lowercase(component(1:1)), glatb, no_domain=.true.)
+     case('OCN')
+        allocate (x_vert_t(nlon,1,2), y_vert_t(1,nlat,2) ) 
+        start = 1; nread = 1
+        nread(1) = nlon; nread(2) = 1; start(3) = 1
+        call read_data(grid_file, "x_vert_T", x_vert_t(:,:,1), start, nread, no_domain=.TRUE.)
+        nread(1) = nlon; nread(2) = 1; start(3) = 2
+        call read_data(grid_file, "x_vert_T", x_vert_t(:,:,2), start, nread, no_domain=.TRUE.)
+
+        nread(1) = 1; nread(2) = nlat; start(3) = 1
+        call read_data(grid_file, "y_vert_T", y_vert_t(:,:,1), start, nread, no_domain=.TRUE.)
+        nread(1) = 1; nread(2) = nlat; start(3) = 4
+        call read_data(grid_file, "y_vert_T", y_vert_t(:,:,2), start, nread, no_domain=.TRUE.)
+        glonb(1:nlon) = x_vert_t(1:nlon,1,1)
+        glonb(nlon+1) = x_vert_t(nlon,1,2)
+        glatb(1:nlat) = y_vert_t(1,1:nlat,1)
+        glatb(nlat+1) = y_vert_t(1,nlat,2)
+        deallocate(x_vert_t, y_vert_t)
+     end select
+  case(VERSION_2)
+     ! get the name of the mosaic file for the component
+     call read_data(grid_file, trim(lowercase(component))//'_mosaic_file', filename1)
+     filename1=grid_dir//trim(filename1)
+     ! get the name of the grid file for the component and tile
+     call read_data(filename1, 'gridfiles', filename2, level=tile)
+     filename2 = grid_dir//trim(filename2)
+
+     start = 1; nread = 1
+     nread(1) = 2*nlon+1
+     allocate( tmp(2*nlon+1,1) )
+     call read_data(filename2, "x", tmp, start, nread, no_domain=.TRUE.)
+     glonb(1:nlon+1) = tmp(1:2*nlon+1:2,1)
+     deallocate(tmp)
+     allocate(tmp(1,2*nlat+1))
+
+     start = 1; nread = 1
+     nread(2) = 2*nlat+1
+     call read_data(filename2, "y", tmp, start, nread, no_domain=.TRUE.)
+     glatb(1:nlat+1) = tmp(1,1:2*nlat+1:2)
+     deallocate(tmp)
+  end select
+
+end subroutine get_grid_cell_vertices_1D
+
+! ============================================================================
+! returns cell vertices for the specified model component and mosaic tile number
+! ============================================================================
+subroutine get_grid_cell_vertices_2D(component, tile, lonb, latb, domain)
+  character(len=*),         intent(in) :: component
+  integer,                  intent(in) :: tile
+  real,                  intent(inout) :: lonb(:,:),latb(:,:)
+  type(domain2d), optional, intent(in) :: domain
+
+  ! local vars
+  character(len=MAX_FILE) :: filename1, filename2
+  integer :: nlon, nlat
+  integer :: i,j
+  real, allocatable :: buffer(:), tmp(:,:), x_vert_t(:,:,:), y_vert_t(:,:,:)
+  integer :: is,ie,js,je ! boundaries of our domain
+  integer :: i0,j0 ! offsets for coordinates
+  integer :: isg, jsg
+  integer :: start(4), nread(4)
+
+  call get_grid_size_for_one_tile(component, tile, nlon, nlat)
+  if (present(domain)) then
+    call mpp_get_compute_domain(domain,is,ie,js,je)
+  else
+    is = 1 ; ie = nlon
+    js = 1 ; je = nlat
+    !--- domain normally should be present
+    call error_mesg ( module_name//'/get_grid_cell_vertices',&
+       'domain is not present, global data will be read', NOTE)
+  endif
+  i0 = -is+1; j0 = -js+1
+  
+  ! verify that lonb and latb sizes are consistent with the size of domain
+  if (size(lonb,1)/=ie-is+2.or.size(lonb,2)/=je-js+2) &
+       call error_mesg ( module_name//'/get_grid_cell_vertices',&
+       'Size of argument "lonb" is not consistent with the domain size',FATAL)
+  if (size(latb,1)/=ie-is+2.or.size(latb,2)/=je-js+2) &
+       call error_mesg ( module_name//'/get_grid_cell_vertices',&
+       'Size of argument "latb" is not consistent with the domain size',FATAL)
+  if(trim(component) .NE. 'ATM' .AND. component .NE. 'LND' .AND. component .NE. 'OCN') then
+     call error_mesg(module_name//'/get_grid_cell_vertices',&
+          'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+          FATAL)  
+  endif
+
+  select case(get_grid_version())
+  case(VERSION_0)
+     select case(component)
+     case('ATM','LND')
+        allocate(buffer(max(nlon,nlat)+1))
+        ! read coordinates of grid cell vertices
+        call read_data(grid_file, 'xb'//lowercase(component(1:1)), buffer(1:nlon+1), no_domain=.true.)
+        do j = js, je+1
+           do i = is, ie+1
+              lonb(i+i0,j+j0) = buffer(i)
+           enddo
+        enddo
+        call read_data(grid_file, 'yb'//lowercase(component(1:1)), buffer(1:nlat+1), no_domain=.true.)
+        do j = js, je+1
+           do i = is, ie+1
+              latb(i+i0,j+j0) = buffer(j)
+           enddo
+        enddo
+        deallocate(buffer)
+     case('OCN')
+        if (present(domain)) then
+           start = 1; nread = 1
+           start(1) = is; start(2) = js
+           nread(1) = ie-is+2; nread(2) = je-js+2
+           call read_data(grid_file, 'geolon_vert_t', lonb, start, nread, no_domain=.true. )
+           call read_data(grid_file, 'geolat_vert_t', latb, start, nread, no_domain=.true. )
+         else
+           call read_data(grid_file, 'geolon_vert_t', lonb, no_domain=.TRUE. )
+           call read_data(grid_file, 'geolat_vert_t', latb, no_domain=.TRUE. )
+         endif
+     end select
+  case(VERSION_1)
+     select case(component)
+     case('ATM','LND')
+        allocate(buffer(max(nlon,nlat)+1))
+        ! read coordinates of grid cell vertices
+        call read_data(grid_file, 'xb'//lowercase(component(1:1)), buffer(1:nlon+1), no_domain=.true.)
+        do j = js, je+1
+           do i = is, ie+1
+              lonb(i+i0,j+j0) = buffer(i)
+           enddo
+        enddo
+        call read_data(grid_file, 'yb'//lowercase(component(1:1)), buffer(1:nlat+1), no_domain=.true.)
+        do j = js, je+1
+           do i = is, ie+1
+              latb(i+i0,j+j0) = buffer(j)
+           enddo
+        enddo
+        deallocate(buffer)
+     case('OCN')
+        nlon=ie-is+1; nlat=je-js+1
+        allocate (x_vert_t(nlon,nlat,4), y_vert_t(nlon,nlat,4) ) 
+        call read_data(grid_file, 'x_vert_T', x_vert_t, no_domain=.not.present(domain), domain=domain )
+        call read_data(grid_file, 'y_vert_T', y_vert_t, no_domain=.not.present(domain), domain=domain )
+        lonb(1:nlon,1:nlat) = x_vert_t(1:nlon,1:nlat,1)
+        lonb(nlon+1,1:nlat) = x_vert_t(nlon,1:nlat,2)
+        lonb(1:nlon,nlat+1) = x_vert_t(1:nlon,nlat,4)
+        lonb(nlon+1,nlat+1) = x_vert_t(nlon,nlat,3)
+        latb(1:nlon,1:nlat) = y_vert_t(1:nlon,1:nlat,1)
+        latb(nlon+1,1:nlat) = y_vert_t(nlon,1:nlat,2)
+        latb(1:nlon,nlat+1) = y_vert_t(1:nlon,nlat,4)
+        latb(nlon+1,nlat+1) = y_vert_t(nlon,nlat,3)
+        deallocate(x_vert_t, y_vert_t)
+     end select
+  case(VERSION_2)
+     ! get the name of the mosaic file for the component
+     call read_data(grid_file, trim(lowercase(component))//'_mosaic_file', filename1)
+     filename1=grid_dir//trim(filename1)
+     ! get the name of the grid file for the component and tile
+     call read_data(filename1, 'gridfiles', filename2, level=tile)
+     filename2 = grid_dir//trim(filename2)
+     if(PRESENT(domain)) then
+        call mpp_get_global_domain(domain, xbegin=isg, ybegin=jsg)
+        start = 1; nread = 1
+        start(1) = 2*(is-isg+1) - 1; nread(1) = 2*(ie-is)+3
+        start(2) = 2*(js-jsg+1) - 1; nread(2) = 2*(je-js)+3
+        allocate(tmp(nread(1), nread(2)) )
+        call read_data(filename2, 'x', tmp, start, nread, no_domain=.TRUE.)
+        do j = 1, je-js+2
+           do i = 1, ie-is+2
+              lonb(i,j) = tmp(2*i-1,2*j-1)
+           enddo
+        enddo
+        call read_data(filename2, 'y', tmp, start, nread, no_domain=.TRUE.)
+        do j = 1, je-js+2
+           do i = 1, ie-is+2
+              latb(i,j) = tmp(2*i-1,2*j-1)
+           enddo
+        enddo        
+     else
+        allocate(tmp(2*nlon+1,2*nlat+1))
+        call read_data(filename2, 'x', tmp, no_domain=.TRUE.)
+        do j = js, je+1
+           do i = is, ie+1
+              lonb(i+i0,j+j0) = tmp(2*i-1,2*j-1)
+           end do
+        end do
+        call read_data(filename2, 'y', tmp, no_domain=.TRUE.)
+        do j = js, je+1
+           do i = is, ie+1
+              latb(i+i0,j+j0) = tmp(2*i-1,2*j-1)
+           end do
+        end do
+     endif
+     deallocate(tmp)
+  end select
+
+end subroutine get_grid_cell_vertices_2D
+
+! ============================================================================
+! returns global coordinate arrays fro given model component and mosaic tile number
+! NOTE that in case of non-lat-lon grid those coordinates may have be not so 
+! meaningful, by the very nature of such grids. But presumably these 1D coordinate 
+! arrays are good enough for diag axis and such.
+! ============================================================================
+subroutine get_grid_cell_centers_1D(component, tile, glon, glat)
+  character(len=*), intent(in) :: component
+  integer, intent(in) :: tile
+  real, intent(inout) :: glon(:),glat(:)
+  integer                      :: nlon, nlat
+  integer                      :: start(4), nread(4)
+  real, allocatable            :: tmp(:,:)
+  character(len=MAX_FILE)      :: filename1, filename2
+
+  call get_grid_size_for_one_tile(component, tile, nlon, nlat)
+  if (size(glon(:))/=nlon) &
+       call error_mesg ( module_name//'/get_grid_cell_centers_1D',&
+       'Size of argument "glon" is not consistent with the grid size',FATAL)
+  if (size(glat(:))/=nlat) &
+       call error_mesg ( module_name//'/get_grid_cell_centers_1D',&
+       'Size of argument "glat" is not consistent with the grid size',FATAL)
+  if(trim(component) .NE. 'ATM' .AND. component .NE. 'LND' .AND. component .NE. 'OCN') then
+     call error_mesg(module_name//'/get_grid_cell_centers_1D',&
+          'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+          FATAL)     
+  endif
+
+  select case(get_grid_version())
+  case(VERSION_0)
+     select case(trim(component))
+     case('ATM','LND')
+        call read_data(grid_file, 'xt'//lowercase(component(1:1)), glon, no_domain=.true.)
+        call read_data(grid_file, 'yt'//lowercase(component(1:1)), glat, no_domain=.true.)
+     case('OCN')
+        call read_data(grid_file, "gridlon_t", glon, no_domain=.true.) 
+        call read_data(grid_file, "gridlat_t", glat, no_domain=.true.)
+     end select 
+  case(VERSION_1)
+     select case(trim(component))
+     case('ATM','LND')
+        call read_data(grid_file, 'xt'//lowercase(component(1:1)), glon, no_domain=.true.)
+        call read_data(grid_file, 'yt'//lowercase(component(1:1)), glat, no_domain=.true.)
+     case('OCN')
+        call read_data(grid_file, "grid_x_T", glon, no_domain=.true.) 
+        call read_data(grid_file, "grid_y_T", glat, no_domain=.true.) 
+     end select
+  case(VERSION_2)
+     ! get the name of the mosaic file for the component
+     call read_data(grid_file, trim(lowercase(component))//'_mosaic_file', filename1)
+     filename1=grid_dir//trim(filename1)
+     ! get the name of the grid file for the component and tile
+     call read_data(filename1, 'gridfiles', filename2, level=tile)
+     filename2 = grid_dir//trim(filename2)
+
+     start = 1; nread = 1
+     nread(1) = 2*nlon+1; start(2) = 2
+     allocate( tmp(2*nlon+1,1) )
+     call read_data(filename2, "x", tmp, start, nread, no_domain=.TRUE.)
+     glon(1:nlon) = tmp(2:2*nlon:2,1)
+     deallocate(tmp)
+     allocate(tmp(1, 2*nlat+1))
+
+     start = 1; nread = 1
+     nread(2) = 2*nlat+1; start(1) = 2
+     call read_data(filename2, "y", tmp, start, nread, no_domain=.TRUE.)
+     glat(1:nlat) = tmp(1,2:2*nlat:2)
+     deallocate(tmp)
+  end select
+
+  
+end subroutine get_grid_cell_centers_1D
+
+! ============================================================================
+! returns grid cell centers for specified model component and mosaic tile number
+! ============================================================================
+subroutine get_grid_cell_centers_2D(component, tile, lon, lat, domain)
+  character(len=*), intent(in) :: component
+  integer, intent(in) :: tile
+  real, intent(inout) :: lon(:,:),lat(:,:)
+  type(domain2d), intent(in), optional :: domain
+  ! local vars
+  character(len=MAX_NAME) :: varname
+  character(len=MAX_FILE) :: filename1, filename2
+  integer :: nlon, nlat
+  integer :: i,j
+  real, allocatable :: buffer(:),tmp(:,:)
+  integer :: is,ie,js,je ! boundaries of our domain
+  integer :: i0,j0 ! offsets for coordinates
+  integer :: isg, jsg
+  integer :: start(4), nread(4) 
+
+  call get_grid_size_for_one_tile(component, tile, nlon, nlat)
+  if (present(domain)) then
+    call mpp_get_compute_domain(domain,is,ie,js,je)
+  else
+    is = 1 ; ie = nlon
+    js = 1 ; je = nlat
+    !--- domain normally should be present
+    call error_mesg ( module_name//'/get_grid_cell_centers',&
+       'domain is not present, global data will be read', NOTE)
+  endif
+  i0 = -is+1; j0 = -js+1
+
+  ! verify that lon and lat sizes are consistent with the size of domain
+  if (size(lon,1)/=ie-is+1.or.size(lon,2)/=je-js+1) &
+       call error_mesg ( module_name//'/get_grid_cell_centers',&
+       'Size of array "lon" is not consistent with the domain size',&
+       FATAL )
+  if (size(lat,1)/=ie-is+1.or.size(lat,2)/=je-js+1) &
+       call error_mesg ( module_name//'/get_grid_cell_centers',&
+       'Size of array "lat" is not consistent with the domain size',&
+       FATAL )
+  if(trim(component) .NE. 'ATM' .AND. component .NE. 'LND' .AND. component .NE. 'OCN') then
+     call error_mesg(module_name//'/get_grid_cell_vertices',&
+          'Illegal component name "'//trim(component)//'": must be one of ATM, LND, or OCN',&
+          FATAL)  
+  endif
+
+  select case(get_grid_version())
+  case(VERSION_0)
+     select case (trim(component))
+     case('ATM','LND')
+        allocate(buffer(max(nlon,nlat)))
+        ! read coordinates of grid cell vertices
+        call read_data(grid_file, 'xt'//lowercase(component(1:1)), buffer(1:nlon), no_domain=.true.)
+        do j = js,je
+        do i = is,ie
+           lon(i+i0,j+j0) = buffer(i)
+        enddo
+        enddo
+        call read_data(grid_file, 'yt'//lowercase(component(1:1)), buffer(1:nlat), no_domain=.true.)
+        do j = js,je
+        do i = is,ie
+           lat(i+i0,j+j0) = buffer(j)
+        enddo
+        enddo
+        deallocate(buffer)
+     case('OCN')
+        call read_data(grid_file, 'geolon_t', lon, no_domain=.not.present(domain), domain=domain )
+        call read_data(grid_file, 'geolat_t', lat, no_domain=.not.present(domain), domain=domain )
+     end select
+  case(VERSION_1)
+     select case(trim(component))
+     case('ATM','LND')
+        allocate(buffer(max(nlon,nlat)))
+        ! read coordinates of grid cell vertices
+        call read_data(grid_file, 'xt'//lowercase(component(1:1)), buffer(1:nlon), no_domain=.true.)
+        do j = js,je
+        do i = is,ie
+           lon(i+i0,j+j0) = buffer(i)
+        enddo
+        enddo
+        call read_data(grid_file, 'yt'//lowercase(component(1:1)), buffer(1:nlat), no_domain=.true.)
+        do j = js,je
+        do i = is,ie
+           lat(i+i0,j+j0) = buffer(j)
+        enddo
+        enddo
+        deallocate(buffer)
+     case('OCN')
+        call read_data(grid_file, 'x_T', lon, no_domain=.not.present(domain), domain=domain )
+        call read_data(grid_file, 'y_T', lat, no_domain=.not.present(domain), domain=domain )
+     end select
+  case(VERSION_2) ! mosaic grid file
+     ! get the name of the mosaic file for the component
+     call read_data(grid_file, trim(lowercase(component))//'_mosaic_file', filename1)
+     filename1=grid_dir//trim(filename1)
+     ! get the name of the grid file for the component and tile
+     call read_data(filename1, 'gridfiles', filename2, level=tile)
+     filename2 = grid_dir//trim(filename2)
+     if(PRESENT(domain)) then
+        call mpp_get_global_domain(domain, xbegin=isg, ybegin=jsg)
+        start = 1; nread = 1
+        start(1) = 2*(is-isg+1) - 1; nread(1) = 2*(ie-is)+3
+        start(2) = 2*(js-jsg+1) - 1; nread(2) = 2*(je-js)+3
+        allocate(tmp(nread(1), nread(2)))
+        call read_data(filename2, 'x', tmp, start, nread, no_domain=.TRUE.)
+        do j = 1, je-js+1
+           do i = 1, ie-is+1
+              lon(i,j) = tmp(2*i,2*j)
+           enddo
+        enddo
+        call read_data(filename2, 'y', tmp, start, nread, no_domain=.TRUE.)
+        do j = 1, je-js+1
+           do i = 1, ie-is+1
+              lat(i,j) = tmp(2*i,2*j)
+           enddo
+        enddo        
+     else
+        allocate(tmp(2*nlon+1,2*nlat+1))
+        call read_data(filename2, 'x', tmp, no_domain=.TRUE.)
+        do j = js,je
+           do i = is,ie
+              lon(i+i0,j+j0) = tmp(2*i,2*j)
+           end do
+        end do
+        call read_data(filename2, 'y', tmp, no_domain=.TRUE.)
+        do j = js,je
+           do i = is,ie
+              lat(i+i0,j+j0) = tmp(2*i,2*j)
+           end do
+        end do
+        deallocate(tmp)
+     endif
+  end select
+
+end subroutine get_grid_cell_centers_2D
+
+
+! ============================================================================
+! given a model component, a layout, and (optionally) a halo size, returns a 
+! domain for current processor
+! ============================================================================
+! this subroutine probably does not belong in the grid_mod 
+subroutine define_cube_mosaic ( component, domain, layout, halo, maskmap )
+  character(len=*) , intent(in)    :: component
+  type(domain2d)   , intent(inout) :: domain
+  integer          , intent(in)    :: layout(2)
+  integer, optional, intent(in)    :: halo 
+  logical, optional, intent(in)    :: maskmap(:,:,:)
+
+  ! ---- local constants
+  
+  ! ---- local vars
+  character(len=MAX_NAME) :: varname
+  character(len=MAX_FILE) :: mosaic_file
+  integer :: ntiles     ! number of tiles
+  integer :: ncontacts  ! number of contacts between mosaic tiles
+  integer :: n
+  integer :: ng, pe_pos, npes         ! halo size
+  integer, allocatable :: nlon(:), nlat(:), global_indices(:,:)
+  integer, allocatable :: pe_start(:), pe_end(:), layout_2d(:,:)
+  integer, allocatable :: tile1(:),tile2(:)
+  integer, allocatable :: is1(:),ie1(:),js1(:),je1(:)
+  integer, allocatable :: is2(:),ie2(:),js2(:),je2(:)
+
+  call get_grid_ntiles(component,ntiles)
+  allocate(nlon(ntiles), nlat(ntiles))
+  allocate(global_indices(4,ntiles))
+  allocate(pe_start(ntiles),pe_end(ntiles))
+  allocate(layout_2d(2,ntiles))
+  call get_grid_size(component,nlon,nlat)
+
+  pe_pos = mpp_root_pe()
+  do n = 1, ntiles
+     global_indices(:,n) = (/ 1, nlon(n), 1, nlat(n) /)
+     layout_2d     (:,n) = layout
+     if(present(maskmap)) then
+        npes = count(maskmap(:,:,n))
+     else
+        npes = layout(1)*layout(2)
+     endif
+     pe_start(n) = pe_pos
+     pe_end  (n) = pe_pos + npes - 1
+     pe_pos      = pe_end(n) + 1
+  enddo
+
+  varname=trim(lowercase(component))//'_mosaic_file'
+  call read_data(grid_file,varname,mosaic_file)
+  mosaic_file = grid_dir//mosaic_file
+
+  ! get the contact information from mosaic file
+  ncontacts = get_mosaic_ncontacts(mosaic_file)
+  allocate(tile1(ncontacts),tile2(ncontacts))
+  allocate(is1(ncontacts),ie1(ncontacts),js1(ncontacts),je1(ncontacts))
+  allocate(is2(ncontacts),ie2(ncontacts),js2(ncontacts),je2(ncontacts))
+  call get_mosaic_contact(mosaic_file, tile1, tile2, &
+       is1, ie1, js1, je1, is2, ie2, js2, je2)
+
+  ng = 0
+  if(present(halo)) ng = halo
+  ! create the domain2d variable
+  call mpp_define_mosaic ( global_indices, layout_2d, domain, &
+       ntiles, ncontacts, tile1, tile2,                  &
+       is1, ie1, js1, je1, &
+       is2, ie2, js2, je2, &
+       pe_start=pe_start, pe_end=pe_end, symmetry=.true.,  &
+       shalo = ng, nhalo = ng, whalo = ng, ehalo = ng,     &
+       maskmap = maskmap,                                  &
+       name = trim(component)//'Cubic-Sphere Grid' )
+
+  deallocate(nlon,nlat,global_indices,pe_start,pe_end,layout_2d)
+  deallocate(tile1,tile2)
+  deallocate(is1,ie1,js1,je1)
+  deallocate(is2,ie2,js2,je2)
+
+end subroutine define_cube_mosaic
+
+end module grid_mod
diff --git a/sorc/fre-nctools.fd/shared_lib/grid.html b/sorc/fre-nctools.fd/shared_lib/grid.html
new file mode 100644
index 0000000..1b61d16
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/grid.html
@@ -0,0 +1,278 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
+<html>
+<head>
+  <title>Module grid_mod</title>
+  <link type="text/css" href="http://www.gfdl.noaa.gov/~fms/style/doc.css" rel="stylesheet">
+</head>
+
+<body>
+<a name="TOP"></a><font class="header" size="1"><a href="#PUBLIC INTERFACE">PUBLIC INTERFACE </a>~
+          <a href="#PUBLIC DATA">PUBLIC DATA </a>~
+          <a href="#PUBLIC ROUTINES">PUBLIC ROUTINES </a>~
+          <a href="#NAMELIST">NAMELIST </a>~
+          <a href="#DIAGNOSTIC FIELDS">DIAGNOSTIC FIELDS </a>~
+          <a href="#ERROR MESSAGES">ERROR MESSAGES </a>~
+          <a href="#REFERENCES">REFERENCES </a>~ 
+          <a href="#NOTES">NOTES</a></font>
+
+<hr>
+<h2>Module grid_mod</h2>
+
+<a name="HEADER"></a>
+<div>
+  <b>Contact:&nbsp;</b> <br>
+  <b>Reviewers:&nbsp;</b> <br>
+  <b>Change History:&nbsp;</b> <br>
+  <br>
+</div>
+
+<a name="OVERVIEW"></a>
+<hr>
+<h4>OVERVIEW</h4>
+<!-- BEGIN OVERVIEW -->
+<p class="text">Provides a set of subroutines for reading grid spec files</p>
+
+<a name="DESCRIPTION"></a>
+<div>
+Historically, there are several different formats of the grid specification
+files.  Though all  of them are NetCDF files, they differ in the information
+they contain, and in the way this information is stored. For example, the
+geographical coordinates of ocean grid cells can be stored in differently named variables in
+grid_spec.nc, or the can be in a separate component mosaic file, referred to from grid_spec.nc.
+<p>
+This module aims to isolate a casual user from the complexity of grid spec
+file parsing and to provide a unified interface for access to the grid data.
+
+At the same time, it allows the developers of the grid specifications to keep enhancing the
+internal structure transparently for the users of this module, as long as the
+interfaces of the module subroutines are preserved. 
+</div>
+
+<h4>OTHER MODULES USED</h4>
+<div>
+<pre>  constants_mod 
+        fms_mod
+     mosaic_mod
+mpp_domains_mod </pre>
+</div>
+
+<a name="PUBLIC INTERFACE"></a>
+<hr>
+<h4>PUBLIC INTERFACE</h4>
+<dl>
+<dt><a href="#get_grid_ntiles">get_grid_ntiles</a><dt><dd>returns number of mosaic tiles</dd>
+<dt><a href="#get_grid_size">get_grid_size</a></dt> <dd>returns horizontal size of the grid, or sizes of the mosaic tiles</dd>
+<dt><a href="#get_grid_cell_centers">get_grid_cell_centers</a></dt> <dd>reads arrays of grid cell center point coordinates</dd>
+<dt><a href="#get_grid_cell_vertices">get_grid_cell_vertices</a></dt> <dd>reads arrays of grid cell verices coordinates</dd>
+<dt><a href="#get_grid_cell_area">get_grid_cell_area</a></dt> <dd>reads an array of grid cell areas</dd>
+<dt><a href="#get_grid_comp_area">get_grid_comp_area</a></dt> <dd>reads an array of the areas for a component model</dd>
+</dl>
+
+
+
+<a name="PUBLIC ROUTINES"></a>
+<hr>
+<h4>PUBLIC ROUTINES</h4>
+<!-- BEGIN PUBLIC ROUTINES -->
+<ol type="a">
+
+
+<li> <a name="get_grid_ntiles"></a>
+   <h4>get_grid_ntiles</h4>
+         <pre>subroutine get_grid_ntiles(component,ntiles)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+         Given a component name, returns the number of mosaic tiles for the component. For
+         pre-mosaic grid spec files returns 1.
+         </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td>
+      <td>A name of the component, 'ATM', 'OCN', or 'LND'<br>
+      <span class="type">[character(len=*)]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>ntiles</tt></td><td>number of mosaic tiles for the component<br>
+      <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+
+<li> <a name="get_grid_size"></a>
+   <h4>get_grid_size</h4>
+   <pre>
+subroutine get_grid_size(component,nx,ny)
+subroutine get_grid_size(component,tile,nx,ny)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+         Given a component name, returns the size of the grid for all mosaic tiles, or for the
+	 specified tile. 
+         </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td><td>A name of the component: 'ATM', 'OCN', or 'LND'<br>
+         <span class="type">[character(len=*)]</span></td>
+   </tr> <tr>
+      <td valign="top"><tt>tile</tt></td><td>Number of mosaic tile<br>
+          <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>nx, ny</tt></td>
+      <td>number of grid cell along respective axis, either for all mosaic tiles, 
+          or for a specified mosaic tile<br>
+          <span class="type">[integer]</span><br>
+          <span class="type">[integer, dimension(:)]</span>
+      </td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+
+<li> <a name="get_grid_cell_centers"></a>
+   <h4>get_grid_cell_centers</h4>
+         <pre>subroutine get_grid_cell_centers(component,tile,glon,glat)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+         Given a component name and a mosaic tile number, returns longitudes and latitudes of grid ceneters
+         for the specified mosaic tile.
+      </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td>
+      <td>A name of the component, 'ATM', 'OCN', or 'LND'<br><span class="type">[character(len=*)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>tile</tt></td><td>Number of mosaic tile<br>
+          <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>glon</tt></td>
+      <td>longitudes of grid cell centers, degree<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>glat</tt></td>
+      <td>latatitdes of grid cell centers, degree<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+
+<li> <a name="get_grid_cell_vertices"></a>
+   <h4>get_grid_cell_vertices</h4>
+         <pre>subroutine get_grid_cell_vertices(component,tile,glonb,glatb)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+         Given a component name and a mosaic tile number, returns longitudes and latitudes of grid vertices
+         for the specified mosaic tile.
+      </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td>
+      <td>A name of the component, 'ATM', 'OCN', or 'LND'<br><span class="type">[character(len=*)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>tile</tt></td><td>Number of mosaic tile<br>
+          <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>glonb</tt></td>
+      <td>longitudes of grid cell vertices, degree<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>glatb</tt></td>
+      <td>latatitdes of grid cell vertices, degree<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+
+<li> <a name="get_grid_cell_area"></a>
+   <h4>get_grid_cell_area</h4>
+         <pre>subroutine get_grid_cell_area(component,tile,cellarea)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+         Given a component name and a mosaic tile number, returns an array of areas
+	 for the specified tile. Note that the returnd values are <emph>full</emph>
+	 grid cell areas, so for example for land it will not depend on the fraction of
+	 land actually present in the grid cell.
+      </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td>
+      <td>A name of the component, 'ATM', 'OCN', or 'LND'<br><span class="type">[character(len=*)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>tile</tt></td><td>Number of mosaic tile<br>
+          <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>cellarea</tt></td>
+      <td>array of grid cell areas, m2<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+
+<li> <a name="get_grid_comp_area"></a>
+   <h4>get_grid_cell_area</h4>
+         <pre>subroutine get_grid_comp_area(component,tile,area)</pre>
+   <dl>
+      <dt><b>DESCRIPTION</b></dt><dd>
+	 Given a component name and a mosaic tile number, returns an array of component
+	 model areas for the specified tile. Note that the returnd values are the areas
+	 for each grid cell that belong to the specified component, so for example for
+	 land it will depend on the fraction of land actually present in the grid cell.
+	 For atmosphere the area returned by this routine is the same as the cell area
+	 area returned by <tt>get_grid_cell_area</tt>
+      </dd>
+      <dt><b>INPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>component</tt></td>
+      <td>A name of the component, 'ATM', 'OCN', or 'LND'<br><span class="type">[character(len=*)]</span></td>
+   </tr><tr>
+      <td valign="top"><tt>tile</tt></td><td>Number of mosaic tile<br>
+          <span class="type">[integer]</span></td>
+   </tr>
+</table>
+         </dd>
+      <dt><b>OUTPUT</b></dt><dd>
+<table border="0"> 
+   <tr>
+      <td valign="top"><tt>area</tt></td>
+      <td>array of grid cell areas, m2<br><span class="type">[real, dimension(:,:)]</span></td>
+   </tr>
+</table>
+         </dd>
+   </dl>
+
+</ol>
+<hr>
+</body>
+</html>
diff --git a/sorc/fre-nctools.fd/shared_lib/interp.c b/sorc/fre-nctools.fd/shared_lib/interp.c
new file mode 100644
index 0000000..4c8ee80
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/interp.c
@@ -0,0 +1,379 @@
+/*
+  Copyright 2011 NOAA Geophysical Fluid Dynamics Lab, Princeton, NJ
+  This program is distributed under the terms of the GNU General Public
+  License. See the file COPYING contained in this directory
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include "mosaic_util.h"
+#include "interp.h"
+#include "create_xgrid.h"
+
+/*********************************************************************
+   void cublic_spline_sp(size1, size2, grid1, grid2, data1, data2)
+
+   Calculate a shape preserving cubic spline. Monotonicity is ensured over each subinterval
+   unlike classic cubic spline interpolation.
+   It will be used to interpolation data in 1-D space.
+
+   INPUT Arguments:
+    grid1:    grid for input data grid.          
+    grid2:    grid for output data grid.         
+    size1:    size of input grid.                
+    size2:    size of output grid.               
+    data1:    input data associated with grid1.
+
+   OUTPUT ARGUMENTS:
+    data2:    output data associated with grid2. (OUTPUT)
+
+*********************************************************************/
+
+void cubic_spline_sp(int size1, int size2, const double *grid1, const double *grid2, const double *data1,
+                  double *data2 )
+{
+  double *delta=NULL, *d=NULL, *dh=NULL, *b=NULL, *c = NULL;
+  double h, h2, s, w1, w2, p;
+  int i, k, n, klo, khi, kmax;
+
+  for(i=1; i<size1; i++) {
+    if( grid1[i] <= grid1[i-1] ) error_handler("cubic_spline_sp: grid1 is not monotonic increasing");
+  }
+
+  for(i=0; i<size2; i++) {
+    if( grid2[i] < grid1[0] || grid2[i] > grid1[size1-1]) error_handler("cubic_spline_sp: grid2 lies outside grid1");
+  }
+
+  if(size1 < 2) error_handler("cubic_spline_sp: the size of input grid should be at least 2");
+  if(size1 == 2) {  /* when size1 is 2, it just reduced to a linear interpolation */
+    p = (data1[1]-data1[0])/(grid1[1]-grid1[0]);
+    for(i=0; i< size2; i++) data2[i] = p*(grid2[i] - grid1[0]) + data1[0];
+    return;
+  }
+  delta = (double *)malloc((size1-1)*sizeof(double));
+  dh = (double *)malloc((size1-1)*sizeof(double));
+  d = (double *)malloc(size1*sizeof(double));
+  for(k=0;k<size1-1;k++) {
+    dh[k] = grid1[k+1]-grid1[k];
+    delta[k] = (data1[k+1]-data1[k])/(dh[k]);
+  }
+/*
+  Interior slopes
+*/
+  for(k=1;k<size1-1;k++) {
+     if( delta[k]*delta[k-1] > 0.0 ) {
+         w1 = 2.0*dh[k] + dh[k-1];
+         w2 = dh[k] + 2.0*dh[k-1];
+         d[k] = (w1+w2)/(w1/delta[k-1]+w2/delta[k]);
+     }
+     else {
+         d[k] = 0.0;
+     }
+  }
+/* 
+End slopes
+*/
+  kmax = size1-1;
+  d[0] = ((2.0*dh[0] + dh[1])*delta[0] - dh[0]*delta[1])/(dh[0]+dh[1]);
+
+  if ( d[0]*delta[0] < 0.0 ) {
+     d[0] = 0.0;
+  }
+  else {
+     if ( delta[0]*delta[1] < 0.0 && abs(d[0]) > abs(3.0*delta[0])) {
+        d[0]=3.0*delta[0];
+     }
+  }
+
+  d[kmax] = ((2.0*dh[kmax-1] + dh[kmax-2])*delta[kmax-1] - dh[kmax-1]*delta[kmax-2])/(dh[kmax-1]+dh[kmax-2]);
+  if ( d[kmax]*delta[kmax-1] < 0.0 ) {
+     d[kmax] = 0.0;
+  }
+  else {
+     if ( delta[kmax-1]*delta[kmax-2] < 0.0 && abs(d[kmax]) > abs(3.0*delta[kmax-1])) {
+        d[kmax]=3.0*delta[kmax-1];
+     }
+  }
+  
+/* Precalculate coefficients */
+  b = (double *)malloc((size1-1)*sizeof(double));
+  c = (double *)malloc((size1-1)*sizeof(double));
+  for (k=0; k<size1-1; k++) {
+    h   = dh[k];
+    h2  = h*h;
+    c[k]   = (3.0*delta[k]-2.0*d[k]-d[k+1])/dh[k];
+    b[k]   = (d[k]-2.0*delta[k]+d[k+1])/(dh[k]*dh[k]);
+  }
+  /* interpolate data onto grid2 */
+  for(k=0; k<size2; k++) {
+    n = nearest_index(grid2[k],grid1, size1);
+    if (grid1[n] < grid2[k]) {
+	 klo = n;
+    }
+    else {
+      if(n==0) {
+	klo = n;
+      }
+      else {
+	klo = n -1;
+      }
+    }
+    khi = klo+1;
+    s   = grid2[k] - grid1[klo];
+    data2[k] = data1[klo]+s*(d[klo]+s*(c[klo]+s*b[klo]));
+  }
+
+  free(c);
+  free(b);
+  free(d);
+  free(dh);
+  free(delta);
+
+};/* cubic spline sp */
+
+
+/*********************************************************************
+   void cublic_spline(size1, size2, grid1, grid2, data1, data2, yp1, ypn  )
+
+   This alborithm is to get an interpolation formula that is smooth in the first
+   derivative, and continuous in the second derivative, both within an interval
+   and its boundaries. It will be used to interpolation data in 1-D space.
+
+   INPUT Arguments:
+    grid1:    grid for input data grid.          
+    grid2:    grid for output data grid.         
+    size1:    size of input grid.                
+    size2:    size of output grid.               
+    data1:    input data associated with grid1.
+    yp1:      first derivative of starting point.
+              Set to 0 to be "natural"           (INPUT)
+    ypn:      first derivative of ending point.
+              Set to 0 to be "natural"           (INPUT)
+
+   OUTPUT ARGUMENTS:
+    data2:    output data associated with grid2. (OUTPUT)
+
+*********************************************************************/
+
+                                     
+void cubic_spline(int size1, int size2, const double *grid1, const double *grid2, const double *data1,
+		  double *data2, double yp1, double ypn  )
+{
+  double *y2=NULL, *u=NULL;
+  double p, sig, qn, un, h, a, b;
+  int i, k, n, klo, khi;
+  
+  for(i=1; i<size1; i++) {
+    if( grid1[i] <= grid1[i-1] ) error_handler("cubic_spline: grid1 is not monotonic increasing");
+  }
+
+  for(i=0; i<size2; i++) {
+    if( grid2[i] < grid1[0] || grid2[i] > grid1[size1-1]) error_handler("cubic_spline: grid2 lies outside grid1");
+  }  
+
+  if(size1 < 2) error_handler("cubic_spline: the size of input grid should be at least 2");
+  if(size1 == 2) {  /* when size1 is 2, it just reduced to a linear interpolation */
+    p = (data1[1]-data1[0])/(grid1[1]-grid1[0]);
+    for(i=0; i< size2; i++) data2[i] = p*(grid2[i] - grid1[0]) + data1[0];
+    return;
+  }
+  y2 = (double *)malloc(size1*sizeof(double));
+  u = (double *)malloc(size1*sizeof(double));
+  if (yp1 >.99e30) {
+    y2[0]=0.;
+    u[0]=0.;
+  }
+  else {
+    y2[0]=-0.5;
+    u[0]=(3./(grid1[1]-grid1[0]))*((data1[1]-data1[0])/(grid1[1]-grid1[0])-yp1);
+  }
+
+  for(i=1; i<size1-1; i++) {
+    sig=(grid1[i]-grid1[i-1])/(grid1[i+1]-grid1[i-1]);
+    p=sig*y2[i-1]+2.;
+    y2[i]=(sig-1.)/p;
+    u[i]=(6.*((data1[i+1]-data1[i])/(grid1[i+1]-grid1[i])-(data1[i]-data1[i-1])
+	      /(grid1[i]-grid1[i-1]))/(grid1[i+1]-grid1[i-1])-sig*u[i-1])/p;
+
+  }
+  
+  if (ypn > .99e30) {
+    qn=0.;
+    un=0.;
+  }
+  else {
+    qn=0.5;
+    un=(3./(grid1[size1-1]-grid1[size1-2]))*(ypn-(data1[size1-1]-data1[size1-2])/(grid1[size1-1]-grid1[size1-2]));
+  }
+
+  y2[size1-1]=(un-qn*u[size1-2])/(qn*y2[size1-2]+1.);
+
+  for(k=size1-2; k>=0; k--) y2[k] = y2[k]*y2[k+1]+u[k];
+
+  /* interpolate data onto grid2 */
+  for(k=0; k<size2; k++) {
+    n = nearest_index(grid2[k],grid1, size1);
+    if (grid1[n] < grid2[k]) {
+	 klo = n;
+    }
+    else {
+      if(n==0) {
+	klo = n;
+      }
+      else {
+	klo = n -1;
+      }
+    }
+    khi = klo+1;
+    h   = grid1[khi]-grid1[klo];
+    a   = (grid1[khi] - grid2[k])/h;
+    b   = (grid2[k] - grid1[klo])/h;
+    data2[k] = a*data1[klo] + b*data1[khi]+ ((pow(a,3.0)-a)*y2[klo] + (pow(b,3.0)-b)*y2[khi])*(pow(h,2.0))/6;
+  }
+
+  free(y2);
+  free(u);
+  
+};/* cubic spline */
+
+
+/*------------------------------------------------------------------------------
+  void conserve_interp()
+  conservative interpolation through exchange grid.
+  Currently only first order interpolation are implemented here.
+  ----------------------------------------------------------------------------*/
+void conserve_interp(int nx_src, int ny_src, int nx_dst, int ny_dst, const double *x_src,
+		     const double *y_src, const double *x_dst, const double *y_dst,
+		     const double *mask_src, const double *data_src, double *data_dst )
+{
+  int n, nxgrid;
+  int *xgrid_i1, *xgrid_j1, *xgrid_i2, *xgrid_j2;
+  double *xgrid_area, *dst_area, *area_frac; 
+  
+  /* get the exchange grid between source and destination grid. */
+  xgrid_i1   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_j1   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_i2   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_j2   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_area = (double *)malloc(MAXXGRID*sizeof(double));
+  dst_area   = (double *)malloc(nx_dst*ny_dst*sizeof(double));
+  nxgrid = create_xgrid_2dx2d_order1(&nx_src, &ny_src, &nx_dst, &ny_dst, x_src, y_src, x_dst, y_dst, mask_src,
+	                       xgrid_i1, xgrid_j1, xgrid_i2, xgrid_j2, xgrid_area );
+  /* The source grid may not cover the destination grid
+     so need to sum of exchange grid area to get dst_area
+     get_grid_area(&nx_dst, &ny_dst, x_dst, y_dst, dst_area);
+  */
+  for(n=0; n<nx_dst*ny_dst; n++) dst_area[n] = 0;
+  for(n=0; n<nxgrid; n++) dst_area[xgrid_j2[n]*nx_dst+xgrid_i2[n]] += xgrid_area[n];
+  
+  area_frac = (double *)malloc(nxgrid*sizeof(double));
+  for(n=0; n<nxgrid; n++) area_frac[n] = xgrid_area[n]/dst_area[xgrid_j2[n]*nx_dst+xgrid_i2[n]];
+  
+  for(n=0; n<nx_dst*ny_dst; n++) {
+    data_dst[n] = 0;
+  }
+  for(n=0; n<nxgrid; n++) {
+    data_dst[xgrid_j2[n]*nx_dst+xgrid_i2[n]] += data_src[xgrid_j1[n]*nx_src+xgrid_i1[n]]*area_frac[n];
+  }
+
+  free(xgrid_i1);
+  free(xgrid_j1);
+  free(xgrid_i2);
+  free(xgrid_j2);
+  free(xgrid_area);
+  free(dst_area);
+  free(area_frac);
+  
+}; /* conserve_interp */
+
+/*------------------------------------------------------------------------------
+  void conserve_interp_great_circle()
+  conservative interpolation through exchange grid.
+  Currently only first order interpolation are implemented here.
+  great_circle algorithm is used for clipping and interpolation.
+  ----------------------------------------------------------------------------*/
+void conserve_interp_great_circle(int nx_src, int ny_src, int nx_dst, int ny_dst, const double *x_src,
+		     const double *y_src, const double *x_dst, const double *y_dst,
+		     const double *mask_src, const double *data_src, double *data_dst )
+{
+  int n, nxgrid;
+  int *xgrid_i1, *xgrid_j1, *xgrid_i2, *xgrid_j2;
+  double *xgrid_area, *dst_area, *area_frac, *xgrid_di, *xgrid_dj; 
+  
+  /* get the exchange grid between source and destination grid. */
+  xgrid_i1   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_j1   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_i2   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_j2   = (int    *)malloc(MAXXGRID*sizeof(int));
+  xgrid_area = (double *)malloc(MAXXGRID*sizeof(double));
+  xgrid_di   = (double *)malloc(MAXXGRID*sizeof(double));
+  xgrid_dj   = (double *)malloc(MAXXGRID*sizeof(double));
+  dst_area   = (double *)malloc(nx_dst*ny_dst*sizeof(double));
+  nxgrid = create_xgrid_great_circle(&nx_src, &ny_src, &nx_dst, &ny_dst, x_src, y_src, x_dst, y_dst, mask_src,
+				     xgrid_i1, xgrid_j1, xgrid_i2, xgrid_j2, xgrid_area, xgrid_di, xgrid_dj );
+  /* The source grid may not cover the destination grid
+     so need to sum of exchange grid area to get dst_area
+     get_grid_area(&nx_dst, &ny_dst, x_dst, y_dst, dst_area);
+  */
+  for(n=0; n<nx_dst*ny_dst; n++) dst_area[n] = 0;
+  for(n=0; n<nxgrid; n++) dst_area[xgrid_j2[n]*nx_dst+xgrid_i2[n]] += xgrid_area[n];
+  
+  area_frac = (double *)malloc(nxgrid*sizeof(double));
+  for(n=0; n<nxgrid; n++) area_frac[n] = xgrid_area[n]/dst_area[xgrid_j2[n]*nx_dst+xgrid_i2[n]];
+  
+  for(n=0; n<nx_dst*ny_dst; n++) {
+    data_dst[n] = 0;
+  }
+  for(n=0; n<nxgrid; n++) {
+    data_dst[xgrid_j2[n]*nx_dst+xgrid_i2[n]] += data_src[xgrid_j1[n]*nx_src+xgrid_i1[n]]*area_frac[n];
+  }
+
+  free(xgrid_i1);
+  free(xgrid_j1);
+  free(xgrid_i2);
+  free(xgrid_j2);
+  free(xgrid_area);
+  free(dst_area);
+  free(area_frac);
+  
+}; /* conserve_interp_great_circle */
+
+
+
+void linear_vertical_interp(int nx, int ny, int nk1, int nk2, const double *grid1, const double *grid2,
+			    double *data1, double *data2) 
+{
+  int n1, n2, i, n, k, l;
+  double w;
+
+  for(k=1; k<nk1; k++) {
+    if(grid1[k] <= grid1[k-1]) error_handler("interp.c: grid1 not monotonic");
+  }
+  for(k=1; k<nk2; k++) {
+    if(grid2[k] <= grid2[k-1]) error_handler("interp.c: grid2 not monotonic");
+  }
+  
+  if (grid1[0] > grid2[0] ) error_handler("interp.c: grid2 lies outside grid1");
+  if (grid1[nk1-1] < grid2[nk2-1] ) error_handler("interp.c: grid2 lies outside grid1");
+
+  for(k=0; k<nk2; k++) {    
+    n = nearest_index(grid2[k],grid1,nk1);
+    if (grid1[n] < grid2[k]) {
+      w = (grid2[k]-grid1[n])/(grid1[n+1]-grid1[n]);
+      for(l=0; l<nx*ny; l++) {
+	data2[k*nx*ny+l] = (1.-w)*data1[n*nx*ny+l] + w*data1[(n+1)*nx*ny+l];
+      }
+    }
+    else {
+      if(n==0)
+	for(l=0;l<nx*ny;l++) data2[k*nx*ny+l] = data1[n*nx*ny+l];
+      else {
+	w = (grid2[k]-grid1[n-1])/(grid1[n]-grid1[n-1]);
+	for(l=0; l<nx*ny; l++) {
+	  data2[k*nx*ny+l] = (1.-w)*data1[(n-1)*nx*ny+l] + w*data1[n*nx*ny+l];
+	}
+      }
+    }
+  }
+
+}
diff --git a/sorc/fre-nctools.fd/shared_lib/interp.h b/sorc/fre-nctools.fd/shared_lib/interp.h
new file mode 100644
index 0000000..d704bee
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/interp.h
@@ -0,0 +1,25 @@
+/*
+  Copyright 2011 NOAA Geophysical Fluid Dynamics Lab, Princeton, NJ
+  This program is distributed under the terms of the GNU General Public
+  License. See the file COPYING contained in this directory
+*/
+#ifndef INTERP_H_
+#define INTERP_H_
+/*********************************************************************
+                     interp.h
+   This header files contains defition of some interpolation routine  (1-D or 2-D).
+   contact: Zhi.Liang@noaa.gov
+*********************************************************************/
+void cubic_spline_sp(int size1, int size2, const double *grid1, const double *grid2, const double *data1,
+                  double *data2 );
+void cubic_spline(int size1, int size2, const double *grid1, const double *grid2, const double *data1,
+		  double *data2, double yp1, double ypn  );
+void conserve_interp(int nx_src, int ny_src, int nx_dst, int ny_dst, const double *x_src,
+		     const double *y_src, const double *x_dst, const double *y_dst,
+		     const double *mask_src, const double *data_src, double *data_dst );
+void conserve_interp_great_circle(int nx_src, int ny_src, int nx_dst, int ny_dst, const double *x_src,
+		     const double *y_src, const double *x_dst, const double *y_dst,
+		     const double *mask_src, const double *data_src, double *data_dst );
+void linear_vertical_interp(int nx, int ny, int nk1, int nk2, const double *grid1, const double *grid2,
+			    double *data1, double *data2);
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/mosaic.F90 b/sorc/fre-nctools.fd/shared_lib/mosaic.F90
new file mode 100644
index 0000000..794c821
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mosaic.F90
@@ -0,0 +1,674 @@
+module mosaic_mod
+
+! <CONTACT EMAIL="Zhi.Liang@noaa.gov">
+!   Zhi Liang
+! </CONTACT>
+
+! <HISTORY SRC="http://www.gfdl.noaa.gov/fms-cgi-bin/cvsweb.cgi/FMS/"/>
+
+! <OVERVIEW>
+!    <TT>mosaic_mod</TT> implements some utility routines to read mosaic information.
+! </OVERVIEW>
+
+! <DESCRIPTION>
+!    <TT>mosaic_mod</TT> implements some utility routines to read mosaic information.
+!    The information includes number of tiles and contacts in the mosaic, 
+!    mosaic grid resolution of each tile, mosaic contact information, mosaic exchange
+!    grid information. Each routine will call a C-version routine to get these information.
+! </DESCRIPTION>
+
+use mpp_mod,    only : mpp_error, FATAL, mpp_pe, mpp_root_pe
+use mpp_io_mod, only : MPP_MULTI
+use fms_io_mod, only : dimension_size, field_exist, read_data, read_compressed
+use constants_mod, only : PI, RADIUS
+
+implicit none
+private
+
+character(len=*), parameter :: &
+     grid_dir  = 'INPUT/'      ! root directory for all grid files
+
+integer, parameter :: &
+     MAX_NAME = 256,  & ! max length of the variable names
+     MAX_FILE = 1024, & ! max length of the file names
+     X_REFINE = 2,    & ! supergrid size/model grid size in x-direction
+     Y_REFINE = 2       ! supergrid size/model grid size in y-direction
+
+! --- public interface
+
+
+public :: get_mosaic_ntiles
+public :: get_mosaic_ncontacts
+public :: get_mosaic_grid_sizes
+public :: get_mosaic_contact
+public :: get_mosaic_xgrid_size
+public :: get_mosaic_xgrid
+public :: calc_mosaic_grid_area
+public :: calc_mosaic_grid_great_circle_area
+public :: is_inside_polygon
+
+logical :: module_is_initialized = .true.
+! version information varaible
+ character(len=128) :: version = '$Id$'
+ character(len=128) :: tagname = '$Name$'
+
+contains
+
+!#######################################################################
+
+! <SUBROUTINE NAME="mosaic_init">
+!   <OVERVIEW>
+!     Initialize the mosaic_mod. 
+!   </OVERVIEW>
+!   <DESCRIPTION>
+!     Initialization routine for the mosaic module. It writes the 
+!     version information to the log file.
+!   </DESCRIPTION>
+!   <TEMPLATE>
+!     call mosaic_init ( )
+!   </TEMPLATE>
+subroutine mosaic_init() 
+
+  if (module_is_initialized) return
+  module_is_initialized = .TRUE.
+
+!--------- write version number and namelist ------------------
+!  call write_version_number (version, tagname)
+
+end subroutine mosaic_init
+! </SUBROUTINE>
+
+!#######################################################################
+! <FUNCTION NAME="get_mosaic_xgrid_size">
+!   <OVERVIEW>
+!     return exchange grid size of mosaic xgrid file.
+!   </OVERVIEW>
+!   <DESCRIPTION>
+!     return exchange grid size of mosaic xgrid file.
+!   </DESCRIPTION>
+!   <TEMPLATE>
+!    nxgrid = get_mosaic_xgrid_size(xgrid_file)
+!   </TEMPLATE>
+!   <IN NAME="xgrid_file" TYPE="character(len=*)">
+!     The file that contains exchange grid information.
+!   </IN>
+  function get_mosaic_xgrid_size(xgrid_file)
+    character(len=*), intent(in)          :: xgrid_file
+    integer                               :: get_mosaic_xgrid_size
+
+    get_mosaic_xgrid_size = dimension_size(xgrid_file, "ncells", no_domain=.TRUE.)
+
+    return   
+
+  end function get_mosaic_xgrid_size
+! </FUNCTION>
+!#######################################################################
+! <SUBROUTINE NAME="get_mosaic_xgrid">
+!   <OVERVIEW>
+!     get exchange grid information from mosaic xgrid file.
+!   </OVERVIEW>
+!   <DESCRIPTION>
+!     get exchange grid information from mosaic xgrid file.
+!   </DESCRIPTION>
+!   <TEMPLATE>
+!     call get_mosaic_xgrid(xgrid_file, nxgrid, i1, j1, i2, j2, area)
+!   </TEMPLATE>
+!   <IN NAME="xgrid_file" TYPE="character(len=*)">
+!     The file that contains exchange grid information.
+!   </IN>
+!   <INOUT NAME="nxgrid" TYPE="integer">
+!     number of exchange grid in xgrid_file
+!   </INOUT>
+!   <INOUT NAME="i1, j1" TYPE="integer, dimension(:)">
+!     i and j-index in grid 1 of exchange grid.
+!   </INOUT>
+!   <INOUT NAME="i2, j2" TYPE="integer, dimension(:)">
+!     i and j-index in grid 2 of exchange grid.
+!   </INOUT>
+!   <INOUT NAME="area" TYPE="real, dimension(:)">
+!     area of the exchange grid. The area is scaled to represent unit earth area.
+!   </INOUT>
+  subroutine get_mosaic_xgrid(xgrid_file, i1, j1, i2, j2, area, ibegin, iend)
+    character(len=*), intent(in) :: xgrid_file
+    integer,       intent(inout) :: i1(:), j1(:), i2(:), j2(:)
+    real,          intent(inout) :: area(:)
+    integer, optional, intent(in) :: ibegin, iend
+
+    integer                            :: start(4), nread(4), istart
+    real,    dimension(2, size(i1(:))) :: tile1_cell, tile2_cell
+    integer                            :: nxgrid, n
+    real                               :: garea
+    real                               :: get_global_area;
+
+    garea = get_global_area();
+
+    ! When start and nread present, make sure nread(1) is the same as the size of the data
+    if(present(ibegin) .and. present(iend)) then
+       istart = ibegin
+       nxgrid = iend - ibegin + 1
+       if(nxgrid .NE. size(i1(:))) call mpp_error(FATAL, "get_mosaic_xgrid: nxgrid .NE. size(i1(:))")
+       if(nxgrid .NE. size(j1(:))) call mpp_error(FATAL, "get_mosaic_xgrid: nxgrid .NE. size(j1(:))")
+       if(nxgrid .NE. size(i2(:))) call mpp_error(FATAL, "get_mosaic_xgrid: nxgrid .NE. size(i2(:))")
+       if(nxgrid .NE. size(j2(:))) call mpp_error(FATAL, "get_mosaic_xgrid: nxgrid .NE. size(j2(:))")
+       if(nxgrid .NE. size(area(:))) call mpp_error(FATAL, "get_mosaic_xgrid: nxgrid .NE. size(area(:))")
+    else
+       istart = 1
+       nxgrid = size(i1(:))
+    endif
+
+    start  = 1; nread = 1
+    start(1) = istart; nread(1) = nxgrid
+    call read_compressed(xgrid_file, 'xgrid_area', area, start=start, nread=nread, threading=MPP_MULTI)
+    start = 1; nread = 1
+    nread(1) = 2
+    start(2) = istart; nread(2) = nxgrid
+    call read_compressed(xgrid_file, 'tile1_cell', tile1_cell, start=start, nread=nread, threading=MPP_MULTI)
+    call read_compressed(xgrid_file, 'tile2_cell', tile2_cell, start=start, nread=nread, threading=MPP_MULTI)
+
+     do n = 1, nxgrid
+       i1(n) = tile1_cell(1,n) 
+       j1(n) = tile1_cell(2,n)
+       i2(n) = tile2_cell(1,n) 
+       j2(n) = tile2_cell(2,n)
+       area(n) = area(n)/garea
+    end do
+    
+    return
+
+  end subroutine get_mosaic_xgrid
+! </SUBROUTINE>
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="get_mosaic_ntiles">
+  !   <OVERVIEW>
+  !     get number of tiles in the mosaic_file.
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     get number of tiles in the mosaic_file.
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     ntiles = get_mosaic_ntiles( mosaic_file)
+  !   </TEMPLATE>
+  !   <IN NAME="mosaic_file" TYPE="character(len=*)">
+  !     The file that contains mosaic information.
+  !   </IN>
+  function get_mosaic_ntiles(mosaic_file)
+    character(len=*), intent(in) :: mosaic_file
+    integer                      :: get_mosaic_ntiles 
+
+    get_mosaic_ntiles = dimension_size(mosaic_file, "ntiles")
+
+    return
+
+  end function get_mosaic_ntiles
+! </SUBROUTINE>
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="get_mosaic_ncontacts">
+  !   <OVERVIEW>
+  !     get number of contacts in the mosaic_file.
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     get number of contacts in the mosaic_file.
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     ntiles = get_mosaic_ncontacts( mosaic_file)
+  !   </TEMPLATE>
+  !   <IN NAME="mosaic_file" TYPE="character(len=*)">
+  !     The file that contains mosaic information.
+  !   </IN>
+  function get_mosaic_ncontacts( mosaic_file)
+    character(len=*), intent(in) :: mosaic_file
+    integer                      :: get_mosaic_ncontacts 
+
+    character(len=len_trim(mosaic_file)+1) :: mfile    
+    integer                                :: strlen
+    integer                                :: read_mosaic_ncontacts
+
+    if(field_exist(mosaic_file, "contacts") ) then
+      get_mosaic_ncontacts = dimension_size(mosaic_file, "ncontact", no_domain=.TRUE.)
+    else
+      get_mosaic_ncontacts = 0
+    endif
+
+    return
+
+  end function get_mosaic_ncontacts
+! </SUBROUTINE>
+
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="get_mosaic_grid_sizes">
+  !   <OVERVIEW>
+  !     get grid size of each tile from mosaic_file
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     get grid size of each tile from mosaic_file
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     call get_mosaic_grid_sizes(mosaic_file, nx, ny)
+  !   </TEMPLATE>
+  !   <IN NAME="mosaic_file" TYPE="character(len=*)">
+  !     The file that contains mosaic information.
+  !   </IN>
+  !   <INOUT NAME="nx" TYPE="integer, dimension(:)">
+  !     List of grid size in x-direction of each tile.
+  !   </INOUT>
+  !   <INOUT NAME="ny" TYPE="integer, dimension(:)">
+  !     List of grid size in y-direction of each tile.
+  !   </INOUT>
+  subroutine get_mosaic_grid_sizes( mosaic_file, nx, ny)
+    character(len=*),         intent(in) :: mosaic_file
+    integer, dimension(:), intent(inout) :: nx, ny
+
+    character(len=MAX_FILE) :: gridfile
+    integer                 :: ntiles, n    
+
+    ntiles = get_mosaic_ntiles(mosaic_file)
+    if(ntiles .NE. size(nx(:)) .OR. ntiles .NE. size(ny(:)) ) then
+      call mpp_error(FATAL, "get_mosaic_grid_sizes: size of nx/ny does not equal to ntiles")
+    endif
+    do n = 1, ntiles
+      call read_data(mosaic_file, 'gridfiles', gridfile, level=n)
+      gridfile = grid_dir//trim(gridfile)
+      nx(n) = dimension_size(gridfile, "nx")
+      ny(n) = dimension_size(gridfile, "ny")
+      if(mod(nx(n),x_refine) .NE. 0) call mpp_error(FATAL, "get_mosaic_grid_sizes: nx is not divided by x_refine");
+      if(mod(ny(n),y_refine) .NE. 0) call mpp_error(FATAL, "get_mosaic_grid_sizes: ny is not divided by y_refine");
+      nx(n) = nx(n)/x_refine;
+      ny(n) = ny(n)/y_refine;
+    enddo
+
+    return
+
+  end subroutine get_mosaic_grid_sizes
+! </SUBROUTINE>
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="get_mosaic_contact">
+  !   <OVERVIEW>
+  !     get contact information from mosaic_file
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     get contact information from mosaic_file
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     call get_mosaic_contact(mosaic_file, tile1, tile2, istart1, iend1, jstart1, jend1,
+  !                             istart2, iend2, jstart2, jend2)
+  !   </TEMPLATE>
+  !   <IN NAME="mosaic_file" TYPE="character(len=*)">
+  !     The file that contains mosaic information.
+  !   </IN>
+  !   <INOUT NAME="tile1" TYPE="integer, dimension(:)">
+  !     list tile number in tile 1 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="tile1" TYPE="integer, dimension(:)">
+  !     list tile number in tile 2 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="istart1" TYPE="integer, dimension(:)">
+  !     list starting i-index in tile 1 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="iend1" TYPE="integer, dimension(:)">
+  !     list ending i-index in tile 1 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="jstart1" TYPE="integer, dimension(:)">
+  !     list starting j-index in tile 1 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="jend1" TYPE="integer, dimension(:)">
+  !     list ending j-index in tile 1 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="istart2" TYPE="integer, dimension(:)">
+  !     list starting i-index in tile 2 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="iend2" TYPE="integer, dimension(:)">
+  !     list ending i-index in tile 2 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="jstart2" TYPE="integer, dimension(:)">
+  !     list starting j-index in tile 2 of each contact.
+  !   </INOUT>
+  !   <INOUT NAME="jend2" TYPE="integer, dimension(:)">
+  !     list ending j-index in tile 2 of each contact.
+  !   </INOUT>
+  subroutine get_mosaic_contact( mosaic_file, tile1, tile2, istart1, iend1, jstart1, jend1, &
+                                   istart2, iend2, jstart2, jend2)
+    character(len=*),         intent(in) :: mosaic_file
+    integer, dimension(:), intent(inout) :: tile1, tile2
+    integer, dimension(:), intent(inout) :: istart1, iend1, jstart1, jend1
+    integer, dimension(:), intent(inout) :: istart2, iend2, jstart2, jend2
+    character(len=MAX_NAME), allocatable :: gridtiles(:)
+    character(len=MAX_NAME)              :: contacts
+    character(len=MAX_NAME)              :: strlist(8)
+    integer :: ntiles, n, m, ncontacts, nstr, ios
+    integer :: i1_type, j1_type, i2_type, j2_type
+    logical :: found
+
+    ntiles = get_mosaic_ntiles(mosaic_file)
+    allocate(gridtiles(ntiles))    
+    do n = 1, ntiles
+      call read_data(mosaic_file, 'gridtiles', gridtiles(n), level=n)
+    enddo
+
+    ncontacts = get_mosaic_ncontacts(mosaic_file)
+
+    do n = 1, ncontacts
+      call read_data(mosaic_file, "contacts", contacts, level=n)
+      nstr = parse_string(contacts, ":", strlist)      
+      if(nstr .NE. 4) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): number of elements in contact seperated by :/:: should be 4")
+      found = .false.
+      do m = 1, ntiles
+        if(trim(gridtiles(m)) == trim(strlist(2)) ) then !found the tile name 
+          found = .true.
+          tile1(n) = m
+          exit
+        endif
+      enddo
+    
+      if(.not.found) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact):the first tile name specified in contact is not found in tile list")
+
+      found = .false.
+      do m = 1, ntiles
+        if(trim(gridtiles(m)) == trim(strlist(4)) ) then !found the tile name 
+          found = .true.
+          tile2(n) = m
+          exit
+        endif
+      enddo
+    
+      if(.not.found) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact):the second tile name specified in contact is not found in tile list")
+
+      call read_data(mosaic_file, "contact_index", contacts, level=n)
+      nstr = parse_string(contacts, ":,", strlist)
+      if(nstr .NE. 8) then
+        if(mpp_pe()==mpp_root_pe()) then 
+          print*, "nstr is ", nstr
+          print*, "contacts is ", contacts
+          do m = 1, nstr
+            print*, "strlist is ", trim(strlist(m))
+          enddo
+        endif
+        call mpp_error(FATAL, &
+               "mosaic_mod(get_mosaic_contact): number of elements in contact_index seperated by :/, should be 8")
+      endif
+      read(strlist(1), *, iostat=ios) istart1(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading istart1")
+      read(strlist(2), *, iostat=ios) iend1(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading iend1")
+      read(strlist(3), *, iostat=ios) jstart1(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading jstart1")
+      read(strlist(4), *, iostat=ios) jend1(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading jend1")
+      read(strlist(5), *, iostat=ios) istart2(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading istart2")
+      read(strlist(6), *, iostat=ios) iend2(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading iend2")
+      read(strlist(7), *, iostat=ios) jstart2(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading jstart2")
+      read(strlist(8), *, iostat=ios) jend2(n)
+      if(ios .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): Error in reading jend2")
+
+      i1_type = transfer_to_model_index(istart1(n), iend1(n), x_refine)
+      j1_type = transfer_to_model_index(jstart1(n), jend1(n), y_refine)
+      i2_type = transfer_to_model_index(istart2(n), iend2(n), x_refine)
+      j2_type = transfer_to_model_index(jstart2(n), jend2(n), y_refine)
+
+      if( i1_type == 0 .AND. j1_type == 0 ) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): istart1==iend1 and jstart1==jend1")
+      if( i2_type == 0 .AND. j2_type == 0 ) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): istart2==iend2 and jstart2==jend2")
+      if( i1_type + j1_type .NE. i2_type + j2_type ) call mpp_error(FATAL, &
+         "mosaic_mod(get_mosaic_contact): It is not a line or overlap contact")
+
+   enddo
+
+      deallocate(gridtiles)
+
+  end subroutine get_mosaic_contact
+! </SUBROUTINE>
+
+
+function transfer_to_model_index(istart, iend, refine_ratio)
+   integer, intent(inout) :: istart, iend
+   integer                :: refine_ratio
+   integer                :: transfer_to_model_index
+   integer                :: istart_in, iend_in
+
+   istart_in = istart
+   iend_in = iend
+
+   if( istart_in == iend_in ) then
+      transfer_to_model_index = 0
+      istart = (istart_in + 1)/refine_ratio
+      iend   = istart
+   else 
+      transfer_to_model_index = 1
+      if( iend_in > istart_in ) then
+        istart = istart_in + 1
+        iend   = iend_in
+      else 
+        istart = istart_in
+        iend   = iend_in + 1
+      endif
+      if( mod(istart, refine_ratio) .NE. 0 .OR. mod(iend,refine_ratio) .NE. 0) call mpp_error(FATAL, &
+         "mosaic_mod(transfer_to_model_index): mismatch between refine_ratio and istart/iend")
+      istart = istart/refine_ratio
+      iend = iend/refine_ratio
+
+   endif
+
+   return
+
+end function transfer_to_model_index
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="calc_mosaic_grid_area">
+  !   <OVERVIEW>
+  !     calculate grid cell area.
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     calculate the grid cell area. The purpose of this routine is to make 
+  !     sure the consistency between model grid area and exchange grid area.
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     call calc_mosaic_grid_area(lon, lat, area)
+  !   </TEMPLATE>
+  !   <IN NAME="lon" TYPE="real, dimension(:,:)">
+  !     geographical longitude of grid cell vertices.
+  !   </IN>
+  !   <IN NAME="lat" TYPE="real, dimension(:,:)">
+  !     geographical latitude of grid cell vertices.
+  !   </IN>
+  !   <INOUT NAME="area" TYPE="real, dimension(:,:)">
+  !     grid cell area.
+  !   </INOUT>
+  subroutine calc_mosaic_grid_area(lon, lat, area)
+     real, dimension(:,:), intent(in)    :: lon
+     real, dimension(:,:), intent(in)    :: lat
+     real, dimension(:,:), intent(inout) :: area
+     integer                             :: nlon, nlat
+
+     nlon = size(area,1)
+     nlat = size(area,2)
+     ! make sure size of lon, lat and area are consitency
+     if( size(lon,1) .NE. nlon+1 .OR. size(lat,1) .NE. nlon+1 ) &
+        call mpp_error(FATAL, "mosaic_mod: size(lon,1) and size(lat,1) should equal to size(area,1)+1")
+     if( size(lon,2) .NE. nlat+1 .OR. size(lat,2) .NE. nlat+1 ) &
+        call mpp_error(FATAL, "mosaic_mod: size(lon,2) and size(lat,2) should equal to size(area,2)+1")
+
+     call get_grid_area( nlon, nlat, lon, lat, area)
+
+  end subroutine calc_mosaic_grid_area
+  ! </SUBROUTINE>
+
+  !###############################################################################
+  ! <SUBROUTINE NAME="calc_mosaic_grid_great_circle_area">
+  !   <OVERVIEW>
+  !     calculate grid cell area using great cirlce algorithm
+  !   </OVERVIEW>
+  !   <DESCRIPTION>
+  !     calculate the grid cell area. The purpose of this routine is to make 
+  !     sure the consistency between model grid area and exchange grid area.
+  !   </DESCRIPTION>
+  !   <TEMPLATE>
+  !     call calc_mosaic_grid_great_circle_area(lon, lat, area)
+  !   </TEMPLATE>
+  !   <IN NAME="lon" TYPE="real, dimension(:,:)">
+  !     geographical longitude of grid cell vertices.
+  !   </IN>
+  !   <IN NAME="lat" TYPE="real, dimension(:,:)">
+  !     geographical latitude of grid cell vertices.
+  !   </IN>
+  !   <INOUT NAME="area" TYPE="real, dimension(:,:)">
+  !     grid cell area.
+  !   </INOUT>
+  subroutine calc_mosaic_grid_great_circle_area(lon, lat, area)
+     real, dimension(:,:), intent(in)    :: lon
+     real, dimension(:,:), intent(in)    :: lat
+     real, dimension(:,:), intent(inout) :: area
+     integer                             :: nlon, nlat
+     
+
+     nlon = size(area,1)
+     nlat = size(area,2)
+     ! make sure size of lon, lat and area are consitency
+     if( size(lon,1) .NE. nlon+1 .OR. size(lat,1) .NE. nlon+1 ) &
+        call mpp_error(FATAL, "mosaic_mod: size(lon,1) and size(lat,1) should equal to size(area,1)+1")
+     if( size(lon,2) .NE. nlat+1 .OR. size(lat,2) .NE. nlat+1 ) &
+        call mpp_error(FATAL, "mosaic_mod: size(lon,2) and size(lat,2) should equal to size(area,2)+1")
+
+     call get_grid_great_circle_area( nlon, nlat, lon, lat, area)
+
+  end subroutine calc_mosaic_grid_great_circle_area
+  ! </SUBROUTINE>
+
+  !#####################################################################
+  ! This function check if a point (lon1,lat1) is inside a polygon (lon2(:), lat2(:))
+  ! lon1, lat1, lon2, lat2 are in radians.
+  function is_inside_polygon(lon1, lat1, lon2, lat2 )
+     real, intent(in) :: lon1, lat1
+     real, intent(in) :: lon2(:), lat2(:)
+     logical          :: is_inside_polygon
+     real, dimension(size(lon2(:))) :: x2, y2, z2
+     integer                        :: npts, isinside
+     integer                        :: inside_a_polygon
+
+     npts = size(lon2(:))
+
+     isinside = inside_a_polygon(lon1, lat1, npts, lon2, lat2)
+     if(isinside == 1) then
+        is_inside_polygon = .TRUE.
+     else
+        is_inside_polygon = .FALSE.
+     endif
+
+     return
+
+  end function is_inside_polygon
+
+  function parse_string(string, set, value)
+  character(len=*),  intent(in) :: string
+  character(len=*),  intent(in) :: set
+  character(len=*), intent(out) :: value(:)
+  integer                       :: parse_string
+  integer :: nelem, length, first, last
+
+     nelem = size(value(:))
+     length = len_trim(string)
+
+     first = 1; last = 0
+     parse_string = 0
+
+     do while(first .LE. length)
+       parse_string = parse_string + 1
+       if(parse_string>nelem) then
+         call mpp_error(FATAL, "mosaic_mod(parse_string) : number of element is greater than size(value(:))")
+       endif
+       last = first - 1 + scan(string(first:length), set)
+       if(last == first-1 ) then  ! not found, end of string
+         value(parse_string) = string(first:length)
+         exit
+       else
+         if(last <= first) then
+           call mpp_error(FATAL, "mosaic_mod(parse_string) : last <= first")
+         endif
+         value(parse_string) = string(first:(last-1))
+         first = last + 1
+         ! scan to make sure the next is not the character in the set
+         do while (first == last+1)
+           last = first - 1 + scan(string(first:length), set)
+           if(last == first) then
+             first = first+1
+           else
+             exit
+           endif
+         end do
+       endif
+     enddo
+
+     return
+
+  end function parse_string
+
+
+     
+end module mosaic_mod
+
+
+#ifdef TEST_MOSAIC
+program test_mosaic
+
+use mosaic_mod, only : get_mosaic_ntiles, get_mosaic_ncontacts
+use mosaic_mod, only : get_mosaic_grid_sizes, get_mosaic_contact
+
+implicit none
+
+integer              :: ntiles, ncontacts, n
+integer, allocatable :: tile1(:), tile2(:), nx(:), ny(:)
+integer, allocatable :: istart1(:), iend1(:), jstart1(:), jend1(:)
+integer, allocatable :: istart2(:), iend2(:), jstart2(:), jend2(:)
+character(len=128)   :: mosaic_file = "INPUT/mosaic.nc"
+
+ntiles = get_mosaic_ntiles(mosaic_file)
+ncontacts = get_mosaic_ncontacts(mosaic_file)
+allocate(nx(ntiles), ny(ntiles))
+allocate(tile1(ncontacts), tile2(ncontacts) )
+allocate(istart1(ncontacts), iend1(ncontacts), jstart1(ncontacts), jend1(ncontacts) )
+allocate(istart2(ncontacts), iend2(ncontacts), jstart2(ncontacts), jend2(ncontacts) )
+
+call get_mosaic_grid_sizes(mosaic_file, nx, ny )
+call get_mosaic_contact(mosaic_file, tile1, tile2, istart1, iend1, jstart1, jend1, istart2, iend2, jstart2, jend2)
+
+! print out information
+
+print '(a,i3,a,a)', "****** There is ", ntiles, " tiles in ", trim(mosaic_file)
+do n = 1, ntiles
+   print '(a,i3,a,i3,a,i3)', " tile = ", n, ", nx = ", nx(n), ", ny = ", ny(n)
+end do
+
+print '(a,i3,a,a)', "****** There is ", ncontacts, " contacts in ", trim(mosaic_file)
+do n = 1, ncontacts
+   print '(a,i3,a,i3,a,i3,a,i4,a,i4,a,i4,a,i4,a,i4,a,i4,a,i4,a,i4)', &
+           "contact=", n, ": tile1=", tile1(n), " tile2=", tile2(n),   &
+           " is1=", istart1(n), " ie1=", iend1(n),                   &
+           " js1=", jstart1(n), " je1=", jend1(n),                   &
+           " is2=", istart2(n), " ie2=", iend2(n),                   &
+           " js2=", jstart2(n), " je2=", jend2(n)
+end do
+
+deallocate(tile1, tile2, nx, ny)
+deallocate(istart1, iend1, jstart1, jend1)
+deallocate(istart2, iend2, jstart2, jend2)
+
+
+end program test_mosaic
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/mosaic_util.c b/sorc/fre-nctools.fd/shared_lib/mosaic_util.c
new file mode 100644
index 0000000..995fad7
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mosaic_util.c
@@ -0,0 +1,1351 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#ifdef use_libMPI 
+#include <mpi.h>
+#endif
+#include "mosaic_util.h"
+#include "constant.h"
+
+#define HPI (0.5*M_PI)
+#define TPI (2.0*M_PI)
+#define TOLORENCE (1.e-6)
+#define EPSLN8 (1.e-8)
+#define EPSLN10 (1.e-10)
+#define EPSLN15 (1.e-15)
+#define EPSLN30 (1.e-30)
+/***********************************************************
+    void error_handler(char *str)
+    error handler: will print out error message and then abort
+***********************************************************/
+int reproduce_siena = 0;
+
+void set_reproduce_siena_true(void)
+{
+  reproduce_siena = 1;
+}
+
+#ifndef __AIX
+void set_reproduce_siena_true_(void)
+{
+  reproduce_siena = 1;
+}
+#endif
+
+  
+void error_handler(const char *msg)
+{
+  fprintf(stderr, "FATAL Error: %s\n", msg );
+#ifdef use_libMPI      
+  MPI_Abort(MPI_COMM_WORLD, -1);
+#else
+  exit(1);
+#endif  
+}; /* error_handler */
+
+/*********************************************************************
+
+   int nearest_index(double value, const double *array, int ia)
+
+   return index of nearest data point within "array" corresponding to "value".
+   if "value" is outside the domain of "array" then nearest_index = 0
+   or = size(array)-1 depending on whether array(0) or array(ia-1) is
+   closest to "value"
+
+   Arguments:
+     value:  arbitrary data...same units as elements in "array"
+     array:  array of data points  (must be monotonically increasing)
+     ia   :  size of array.
+
+ ********************************************************************/
+int nearest_index(double value, const double *array, int ia)
+{
+  int index, i;
+  int keep_going;
+
+  for(i=1; i<ia; i++){
+    if (array[i] < array[i-1]) 
+      error_handler("nearest_index: array must be monotonically increasing"); 
+  }
+  if (value < array[0] )
+    index = 0;
+  else if ( value > array[ia-1]) 
+    index = ia-1;
+  else
+    {
+      i=0;
+      keep_going = 1;
+      while (i < ia && keep_going) {
+	i = i+1;
+	if (value <= array[i]) {
+	  index = i;
+	  if (array[i]-value > value-array[i-1]) index = i-1;
+	  keep_going = 0;
+	}
+      }
+    }
+  return index;
+
+};
+
+/******************************************************************/
+
+void tokenize(const char * const string, const char *tokens, unsigned int varlen,
+	      unsigned int maxvar, char * pstring, unsigned int * const nstr)
+{
+  size_t i, j, nvar, len, ntoken;
+  int found, n;
+  
+  nvar = 0; j = 0;
+  len = strlen(string);
+  ntoken = strlen(tokens);
+  /* here we use the fact that C array [][] is contiguous in memory */
+  if(string[0] == 0)error_handler("Error from tokenize: to-be-parsed string is empty");
+  
+  for(i = 0; i < len; i ++){
+    if(string[i] != ' ' && string[i] != '\t'){
+      found = 0;
+      for(n=0; n<ntoken; n++) {
+	if(string[i] == tokens[n] ) {
+	  found = 1;
+	  break;
+	}
+      }
+      if(found) {
+	if( j != 0) { /* remove :: */
+	  *(pstring + (nvar++)*varlen + j) = 0;
+	  j = 0;
+	  if(nvar >= maxvar) error_handler("Error from tokenize: number of variables exceeds limit");
+	}
+      }
+      else {
+        *(pstring + nvar*varlen + j++) = string[i];
+        if(j >= varlen ) error_handler("error from tokenize: variable name length exceeds limit during tokenization");
+      }
+    }
+  }
+  *(pstring + nvar*varlen + j) = 0;
+  
+  *nstr = ++nvar;
+
+}
+
+/*******************************************************************************
+  double maxval_double(int size, double *data)
+  get the maximum value of double array
+*******************************************************************************/
+double maxval_double(int size, const double *data)
+{
+  int n;
+  double maxval;
+
+  maxval = data[0];
+  for(n=1; n<size; n++){
+    if( data[n] > maxval ) maxval = data[n];
+  }
+
+  return maxval;
+  
+}; /* maxval_double */
+
+
+/*******************************************************************************
+  double minval_double(int size, double *data)
+  get the minimum value of double array
+*******************************************************************************/
+double minval_double(int size, const double *data)
+{
+  int n;
+  double minval;
+
+  minval = data[0];
+  for(n=1; n<size; n++){
+    if( data[n] < minval ) minval = data[n];
+  }
+
+  return minval;
+  
+}; /* minval_double */
+
+/*******************************************************************************
+  double avgval_double(int size, double *data)
+  get the average value of double array
+*******************************************************************************/
+double avgval_double(int size, const double *data)
+{
+  int n;
+  double avgval;
+
+  avgval = 0;
+  for(n=0; n<size; n++) avgval += data[n];
+  avgval /= size;
+  
+  return avgval;
+  
+}; /* avgval_double */
+
+
+/*******************************************************************************
+  void latlon2xyz
+  Routine to map (lon, lat) to (x,y,z)
+******************************************************************************/
+void latlon2xyz(int size, const double *lon, const double *lat, double *x, double *y, double *z)
+{
+  int n;
+  
+  for(n=0; n<size; n++) {
+    x[n] = cos(lat[n])*cos(lon[n]);
+    y[n] = cos(lat[n])*sin(lon[n]);
+    z[n] = sin(lat[n]);
+  }
+
+} /* latlon2xyz */
+
+/*------------------------------------------------------------
+       void xyz2laton(np, p, xs, ys)
+   Transfer cartesian coordinates to spherical coordinates
+   ----------------------------------------------------------*/
+void xyz2latlon( int np, const double *x, const double *y, const double *z, double *lon, double *lat)
+{
+
+  double xx, yy, zz;
+  double dist, sinp;
+  int i;
+
+  for(i=0; i<np; i++) {
+    xx = x[i];
+    yy = y[i];
+    zz = z[i];
+    dist = sqrt(xx*xx+yy*yy+zz*zz);
+    xx /= dist;
+    yy /= dist;
+    zz /= dist;
+    
+    if ( fabs(xx)+fabs(yy)  < EPSLN10 ) 
+       lon[i] = 0;
+     else
+       lon[i] = atan2(yy, xx);
+     lat[i] = asin(zz);
+    
+     if ( lon[i] < 0.) lon[i] = 2.*M_PI + lon[i];
+  }
+
+} /* xyz2latlon */
+
+/*------------------------------------------------------------------------------
+  double box_area(double ll_lon, double ll_lat, double ur_lon, double ur_lat)
+  return the area of a lat-lon grid box. grid is in radians.
+  ----------------------------------------------------------------------------*/
+double box_area(double ll_lon, double ll_lat, double ur_lon, double ur_lat)
+{
+  double dx = ur_lon-ll_lon;
+  double area;
+  
+  if(dx > M_PI)  dx = dx - 2.0*M_PI;
+  if(dx < -M_PI) dx = dx + 2.0*M_PI;
+
+  return (dx*(sin(ur_lat)-sin(ll_lat))*RADIUS*RADIUS ) ;
+  
+}; /* box_area */
+
+
+/*------------------------------------------------------------------------------
+  double poly_area(const x[], const y[], int n)
+  obtains area of input polygon by line integrating -sin(lat)d(lon)
+  Vertex coordinates must be in degrees.
+  Vertices must be listed counter-clockwise around polygon.
+  grid is in radians.
+  ----------------------------------------------------------------------------*/
+double poly_area_dimensionless(const double x[], const double y[], int n)
+{
+  double area = 0.0;
+  int    i;
+
+  for (i=0;i<n;i++) {
+    int ip = (i+1) % n;
+    double dx = (x[ip]-x[i]);
+    double lat1, lat2;
+    double dy, dat;
+    
+    lat1 = y[ip];
+    lat2 = y[i];
+    if(dx > M_PI)  dx = dx - 2.0*M_PI;
+    if(dx < -M_PI) dx = dx + 2.0*M_PI;
+    if (dx==0.0) continue;
+    
+    if ( fabs(lat1-lat2) < SMALL_VALUE) /* cheap area calculation along latitude */
+      area -= dx*sin(0.5*(lat1+lat2));
+    else {
+      if(reproduce_siena) {
+	area += dx*(cos(lat1)-cos(lat2))/(lat1-lat2);
+      }
+      else {
+	dy = 0.5*(lat1-lat2);
+	dat = sin(dy)/dy;
+	area -= dx*sin(0.5*(lat1+lat2))*dat;
+      }
+    }
+  }
+  if(area < 0)
+    return (-area/(4*M_PI));
+  else
+    return (area/(4*M_PI));
+
+}; /* poly_area */
+
+double poly_area(const double x[], const double y[], int n)
+{
+  double area = 0.0;
+  int    i;
+
+  for (i=0;i<n;i++) {
+    int ip = (i+1) % n;
+    double dx = (x[ip]-x[i]);
+    double lat1, lat2;
+    double dy, dat;
+    
+    lat1 = y[ip];
+    lat2 = y[i];
+    if(dx > M_PI)  dx = dx - 2.0*M_PI;
+    if(dx < -M_PI) dx = dx + 2.0*M_PI;
+    if (dx==0.0) continue;
+    
+    if ( fabs(lat1-lat2) < SMALL_VALUE) /* cheap area calculation along latitude */
+      area -= dx*sin(0.5*(lat1+lat2));
+    else {
+      if(reproduce_siena) {
+	area += dx*(cos(lat1)-cos(lat2))/(lat1-lat2);
+      }
+      else {
+	dy = 0.5*(lat1-lat2);
+	dat = sin(dy)/dy;
+	area -= dx*sin(0.5*(lat1+lat2))*dat;
+      }
+    }
+  }
+  if(area < 0)
+     return -area*RADIUS*RADIUS;
+  else  
+     return area*RADIUS*RADIUS;
+
+}; /* poly_area */
+
+double poly_area_no_adjust(const double x[], const double y[], int n)
+{
+  double area = 0.0;
+  int    i;
+
+  for (i=0;i<n;i++) {
+    int ip = (i+1) % n;
+    double dx = (x[ip]-x[i]);
+    double lat1, lat2;
+
+    lat1 = y[ip];
+    lat2 = y[i];
+    if (dx==0.0) continue;
+    
+    if ( fabs(lat1-lat2) < SMALL_VALUE) /* cheap area calculation along latitude */
+      area -= dx*sin(0.5*(lat1+lat2));
+    else
+      area += dx*(cos(lat1)-cos(lat2))/(lat1-lat2);
+  }
+  if(area < 0)
+     return area*RADIUS*RADIUS;
+  else
+     return area*RADIUS*RADIUS;
+}; /* poly_area_no_adjust */
+
+int delete_vtx(double x[], double y[], int n, int n_del)
+{
+  for (;n_del<n-1;n_del++) {
+    x[n_del] = x[n_del+1];
+    y[n_del] = y[n_del+1];
+  }
+  
+  return (n-1);
+} /* delete_vtx */
+
+int insert_vtx(double x[], double y[], int n, int n_ins, double lon_in, double lat_in)
+{
+  int i;
+
+  for (i=n-1;i>=n_ins;i--) {
+    x[i+1] = x[i];
+    y[i+1] = y[i];
+  }
+  
+  x[n_ins] = lon_in;
+  y[n_ins] = lat_in;
+  return (n+1);
+} /* insert_vtx */
+
+void v_print(double x[], double y[], int n)
+{
+  int i;
+
+  for (i=0;i<n;i++) printf(" %20g   %20g\n", x[i], y[i]);
+} /* v_print */
+
+int fix_lon(double x[], double y[], int n, double tlon)
+{
+  double x_sum, dx;
+  int i, nn = n, pole = 0;
+
+  for (i=0;i<nn;i++) if (fabs(y[i])>=HPI-TOLORENCE) pole = 1;
+  if (0&&pole) {
+    printf("fixing pole cell\n");
+    v_print(x, y, nn);
+    printf("---------");
+  }
+
+  /* all pole points must be paired */
+  for (i=0;i<nn;i++) if (fabs(y[i])>=HPI-TOLORENCE) {
+    int im=(i+nn-1)%nn, ip=(i+1)%nn;
+
+    if (y[im]==y[i] && y[ip]==y[i]) {
+      nn = delete_vtx(x, y, nn, i);
+      i--;
+    } else if (y[im]!=y[i] && y[ip]!=y[i]) {
+      nn = insert_vtx(x, y, nn, i, x[i], y[i]);
+      i++;
+    }
+  }
+  /* first of pole pair has longitude of previous vertex */
+  /* second of pole pair has longitude of subsequent vertex */
+  for (i=0;i<nn;i++) if (fabs(y[i])>=HPI-TOLORENCE) {
+    int im=(i+nn-1)%nn, ip=(i+1)%nn;
+
+    if (y[im]!=y[i]) x[i] = x[im];
+    if (y[ip]!=y[i]) x[i] = x[ip];
+  }
+
+  if (nn) x_sum = x[0]; else return(0);
+  for (i=1;i<nn;i++) {
+    double dx = x[i]-x[i-1];
+
+    if      (dx < -M_PI) dx = dx + TPI;
+    else if (dx >  M_PI) dx = dx - TPI;
+    x_sum += (x[i] = x[i-1] + dx);
+  }
+
+  dx = (x_sum/nn)-tlon;
+  if      (dx < -M_PI) for (i=0;i<nn;i++) x[i] += TPI;
+  else if (dx >  M_PI) for (i=0;i<nn;i++) x[i] -= TPI;
+
+  if (0&&pole) {
+    printf("area=%g\n", poly_area(x, y,nn));
+    v_print(x, y, nn);
+    printf("---------");
+  }
+
+  return (nn);
+} /* fix_lon */
+
+
+/*------------------------------------------------------------------------------
+  double great_circle_distance()
+  computes distance between two points along a great circle
+  (the shortest distance between 2 points on a sphere)
+  returned in units of meter
+  ----------------------------------------------------------------------------*/
+double great_circle_distance(double *p1, double *p2)
+{
+  double dist, beta;
+  
+  /* This algorithm is not accurate for small distance 
+  dist = RADIUS*ACOS(SIN(p1[1])*SIN(p2[1]) + COS(p1[1])*COS(p2[1])*COS(p1[0]-p2[0]));
+  */
+  beta = 2.*asin( sqrt( sin((p1[1]-p2[1])/2.)*sin((p1[1]-p2[1])/2.) + 
+                               cos(p1[1])*cos(p2[1])*(sin((p1[0]-p2[0])/2.)*sin((p1[0]-p2[0])/2.)) ) );
+  dist = RADIUS*beta;
+  return dist;
+
+}; /* great_circle_distance */
+
+
+/* Compute the great circle area of a polygon on a sphere */
+double great_circle_area(int n, const double *x, const double *y, const double *z) {
+  int i;
+  double pnt0[3], pnt1[3], pnt2[3];
+  double sum, area;
+  
+  /* sum angles around polygon */
+  sum=0.0;
+  for ( i=0; i<n; i++) {
+    /* points that make up a side of polygon */
+    pnt0[0] = x[i];
+    pnt0[1] = y[i];
+    pnt0[2] = z[i];
+    pnt1[0] = x[(i+1)%n];
+    pnt1[1] = y[(i+1)%n];
+    pnt1[2] = z[(i+1)%n];
+    pnt2[0] = x[(i+2)%n];
+    pnt2[1] = y[(i+2)%n];
+    pnt2[2] = z[(i+2)%n];    
+
+    /* compute angle for pnt1 */
+    sum += spherical_angle(pnt1, pnt2, pnt0);
+
+  }
+  area = (sum - (n-2.)*M_PI) * RADIUS* RADIUS;
+  return area;
+}
+
+/*------------------------------------------------------------------------------
+  double spherical_angle(const double *p1, const double *p2, const double *p3)
+           p3
+         /
+        /
+       p1 ---> angle
+         \
+          \
+           p2
+ -----------------------------------------------------------------------------*/
+double spherical_angle(const double *v1, const double *v2, const double *v3)
+{
+  double angle;
+#ifdef NO_QUAD_PRECISION  
+  double px, py, pz, qx, qy, qz, ddd;
+#else
+  long double px, py, pz, qx, qy, qz, ddd;
+#endif
+  
+  /* vector product between v1 and v2 */
+  px = v1[1]*v2[2] - v1[2]*v2[1];
+  py = v1[2]*v2[0] - v1[0]*v2[2];
+  pz = v1[0]*v2[1] - v1[1]*v2[0];
+  /* vector product between v1 and v3 */
+  qx = v1[1]*v3[2] - v1[2]*v3[1];
+  qy = v1[2]*v3[0] - v1[0]*v3[2];
+  qz = v1[0]*v3[1] - v1[1]*v3[0];
+
+  ddd = (px*px+py*py+pz*pz)*(qx*qx+qy*qy+qz*qz);
+  if ( ddd <= 0.0 ) 
+    angle = 0. ;
+  else {
+    ddd = (px*qx+py*qy+pz*qz) / sqrt(ddd);
+    if( fabs(ddd-1) < EPSLN30 ) ddd = 1;
+    if( fabs(ddd+1) < EPSLN30 ) ddd = -1;
+    if ( ddd>1. || ddd<-1. ) {
+      /*FIX (lmh) to correctly handle co-linear points (angle near pi or 0) */
+      if (ddd < 0.)
+	angle = M_PI;
+      else
+	angle = 0.;
+    }
+    else
+      angle = acosl( ddd );
+  }
+  
+  return angle;
+}; /* spherical_angle */
+
+/*------------------------------------------------------------------------------
+  double spherical_excess_area(p_lL, p_uL, p_lR, p_uR) 
+  get the surface area of a cell defined as a quadrilateral 
+  on the sphere. Area is computed as the spherical excess
+  [area units are m^2]
+  ----------------------------------------------------------------------------*/
+double spherical_excess_area(const double* p_ll, const double* p_ul,
+			     const double* p_lr, const double* p_ur, double radius)
+{
+  double area, ang1, ang2, ang3, ang4;
+  double v1[3], v2[3], v3[3];
+
+  /*   S-W: 1   */  
+  latlon2xyz(1, p_ll, p_ll+1, v1, v1+1, v1+2);
+  latlon2xyz(1, p_lr, p_lr+1, v2, v2+1, v2+2);
+  latlon2xyz(1, p_ul, p_ul+1, v3, v3+1, v3+2);
+  ang1 = spherical_angle(v1, v2, v3);
+
+  /*   S-E: 2   */  
+  latlon2xyz(1, p_lr, p_lr+1, v1, v1+1, v1+2);
+  latlon2xyz(1, p_ur, p_ur+1, v2, v2+1, v2+2);
+  latlon2xyz(1, p_ll, p_ll+1, v3, v3+1, v3+2);
+  ang2 = spherical_angle(v1, v2, v3);
+
+  /*   N-E: 3   */  
+  latlon2xyz(1, p_ur, p_ur+1, v1, v1+1, v1+2);
+  latlon2xyz(1, p_ul, p_ul+1, v2, v2+1, v2+2);
+  latlon2xyz(1, p_lr, p_lr+1, v3, v3+1, v3+2);
+  ang3 = spherical_angle(v1, v2, v3);
+  
+  /*   N-W: 4   */  
+  latlon2xyz(1, p_ul, p_ul+1, v1, v1+1, v1+2);
+  latlon2xyz(1, p_ur, p_ur+1, v2, v2+1, v2+2);
+  latlon2xyz(1, p_ll, p_ll+1, v3, v3+1, v3+2);
+  ang4 = spherical_angle(v1, v2, v3);
+
+  area = (ang1 + ang2 + ang3 + ang4 - 2.*M_PI) * radius* radius;
+
+  return area;
+  
+}; /* spherical_excess_area */
+
+
+/*----------------------------------------------------------------------
+    void vect_cross(e, p1, p2)
+    Perform cross products of 3D vectors: e = P1 X P2
+    -------------------------------------------------------------------*/
+    
+void vect_cross(const double *p1, const double *p2, double *e )
+{
+  
+  e[0] = p1[1]*p2[2] - p1[2]*p2[1];
+  e[1] = p1[2]*p2[0] - p1[0]*p2[2];
+  e[2] = p1[0]*p2[1] - p1[1]*p2[0];
+
+}; /* vect_cross */
+
+
+/*----------------------------------------------------------------------
+    double* vect_cross(p1, p2)
+    return cross products of 3D vectors: = P1 X P2
+    -------------------------------------------------------------------*/
+    
+double dot(const double *p1, const double *p2)
+{
+
+  return( p1[0]*p2[0] + p1[1]*p2[1] + p1[2]*p2[2] );
+
+}
+
+
+double metric(const double *p) {
+  return (sqrt(p[0]*p[0] + p[1]*p[1]+p[2]*p[2]) );
+}
+
+
+/* ----------------------------------------------------------------
+   make a unit vector
+   --------------------------------------------------------------*/
+void normalize_vect(double *e)
+{
+  double pdot;
+  int k;
+
+  pdot = e[0]*e[0] + e[1] * e[1] + e[2] * e[2];
+  pdot = sqrt( pdot ); 
+
+  for(k=0; k<3; k++) e[k] /= pdot;
+};
+
+
+/*------------------------------------------------------------------
+  void unit_vect_latlon(int size, lon, lat, vlon, vlat)
+
+  calculate unit vector for latlon in cartesian coordinates
+
+  ---------------------------------------------------------------------*/
+void unit_vect_latlon(int size, const double *lon, const double *lat, double *vlon, double *vlat)
+{
+  double sin_lon, cos_lon, sin_lat, cos_lat;
+  int n;
+  
+  for(n=0; n<size; n++) {
+    sin_lon = sin(lon[n]);
+    cos_lon = cos(lon[n]);
+    sin_lat = sin(lat[n]);
+    cos_lat = cos(lat[n]);
+    
+    vlon[3*n] = -sin_lon;
+    vlon[3*n+1] =  cos_lon;
+    vlon[3*n+2] =  0.;
+    
+    vlat[3*n]   = -sin_lat*cos_lon;
+    vlat[3*n+1] = -sin_lat*sin_lon;
+    vlat[3*n+2] =  cos_lat;
+  }
+}; /* unit_vect_latlon */
+
+
+/* Intersect a line and a plane
+   Intersects between the plane ( three points ) (entries in counterclockwise order)
+   and the line determined by the endpoints l1 and l2 (t=0.0 at l1 and t=1.0 at l2)
+   returns true if the two intersect and the output variables are valid
+   outputs p containing the coordinates in the tri and t the coordinate in the line
+   of the intersection.
+   NOTE: the intersection doesn't have to be inside the tri or line for this to return true
+*/
+int intersect_tri_with_line(const double *plane, const double *l1, const double *l2, double *p,
+			    double *t) {
+
+  long double M[3*3], inv_M[3*3];
+  long double V[3];
+  long double X[3];
+  int is_invert=0;
+  
+  const double *pnt0=plane;
+  const double *pnt1=plane+3;
+  const double *pnt2=plane+6;
+
+  /* To do intersection just solve the set of linear equations for both
+     Setup M
+  */
+  M[0]=l1[0]-l2[0]; M[1]=pnt1[0]-pnt0[0]; M[2]=pnt2[0]-pnt0[0];
+  M[3]=l1[1]-l2[1]; M[4]=pnt1[1]-pnt0[1]; M[5]=pnt2[1]-pnt0[1];
+  M[6]=l1[2]-l2[2]; M[7]=pnt1[2]-pnt0[2]; M[8]=pnt2[2]-pnt0[2];
+
+
+  /* Invert M */
+  is_invert = invert_matrix_3x3(M,inv_M);
+  if (!is_invert) return 0;
+
+  /* Set variable holding vector */
+  V[0]=l1[0]-pnt0[0];
+  V[1]=l1[1]-pnt0[1];
+  V[2]=l1[2]-pnt0[2];
+
+  /* Calculate solution */
+  mult(inv_M, V, X);
+
+  /* Get answer out */
+  *t=X[0];
+  p[0]=X[1];
+  p[1]=X[2];
+
+  return 1;
+}
+
+
+void mult(long double m[], long double v[], long double out_v[]) {
+
+  out_v[0]=m[0]*v[0]+m[1]*v[1]+m[2]*v[2];
+  out_v[1]=m[3]*v[0]+m[4]*v[1]+m[5]*v[2];
+  out_v[2]=m[6]*v[0]+m[7]*v[1]+m[8]*v[2];
+
+}
+
+
+/* returns 1 if matrix is inverted, 0 otherwise */
+int invert_matrix_3x3(long double m[], long double m_inv[]) {
+
+  
+  const long double det =  m[0] * (m[4]*m[8] - m[5]*m[7])
+                     -m[1] * (m[3]*m[8] - m[5]*m[6])
+                     +m[2] * (m[3]*m[7] - m[4]*m[6]);
+#ifdef test_invert_matrix_3x3
+  printf("det = %Lf\n", det);
+#endif  
+  if (fabs(det) < EPSLN15 ) return 0;
+
+  const long double deti = 1.0/det;
+
+  m_inv[0] = (m[4]*m[8] - m[5]*m[7]) * deti;
+  m_inv[1] = (m[2]*m[7] - m[1]*m[8]) * deti;
+  m_inv[2] = (m[1]*m[5] - m[2]*m[4]) * deti;
+
+  m_inv[3] = (m[5]*m[6] - m[3]*m[8]) * deti;
+  m_inv[4] = (m[0]*m[8] - m[2]*m[6]) * deti;
+  m_inv[5] = (m[2]*m[3] - m[0]*m[5]) * deti;
+
+  m_inv[6] = (m[3]*m[7] - m[4]*m[6]) * deti;
+  m_inv[7] = (m[1]*m[6] - m[0]*m[7]) * deti;
+  m_inv[8] = (m[0]*m[4] - m[1]*m[3]) * deti;
+
+  return 1;
+}
+
+#ifndef MAXNODELIST
+#define MAXNODELIST 100
+#endif
+
+struct Node *nodeList=NULL;
+int curListPos=0;
+
+void rewindList(void)
+{
+  int n;
+
+  curListPos = 0;
+  if(!nodeList) nodeList = (struct Node *)malloc(MAXNODELIST*sizeof(struct Node));
+  for(n=0; n<MAXNODELIST; n++) initNode(nodeList+n);
+  
+}
+
+struct Node *getNext()
+{
+  struct Node *temp=NULL;
+  int n;
+  
+  if(!nodeList) {
+    nodeList = (struct Node *)malloc(MAXNODELIST*sizeof(struct Node));
+    for(n=0; n<MAXNODELIST; n++) initNode(nodeList+n);
+  }
+  
+  temp = nodeList+curListPos;
+  curListPos++;
+  if(curListPos > MAXNODELIST) error_handler("getNext: curListPos >= MAXNODELIST");
+  
+  return (temp);
+}
+
+
+void initNode(struct Node *node)
+{
+    node->x = 0;
+    node->y = 0;
+    node->z = 0;
+    node->u = 0;  
+    node->intersect = 0;
+    node->inbound = 0;
+    node->isInside = 0;
+    node->Next = NULL;
+    node->initialized=0;
+    
+}
+  
+void addEnd(struct Node *list, double x, double y, double z, int intersect, double u, int inbound, int inside)
+{
+
+  struct Node *temp=NULL;
+
+  if(list == NULL) error_handler("addEnd: list is NULL");
+  
+  if(list->initialized) {
+
+    /* (x,y,z) might already in the list when intersect is true and u=0 or 1 */
+      temp = list;
+      while (temp) {
+        if(samePoint(temp->x, temp->y, temp->z, x, y, z)) return;
+        temp=temp->Next;
+      }
+    temp = list;
+    while(temp->Next)  
+      temp=temp->Next;  
+  
+    /* Append at the end of the list.  */
+    temp->Next = getNext();
+    temp = temp->Next;
+  }
+  else {
+    temp = list;
+  }
+
+  temp->x = x;
+  temp->y = y;
+  temp->z = z;
+  temp->u = u;
+  temp->intersect = intersect;
+  temp->inbound = inbound;
+  temp->initialized=1;
+  temp->isInside = inside;
+}
+
+/* return 1 if the point (x,y,z) is added in the list, return 0 if it is already in the list */
+
+int addIntersect(struct Node *list, double x, double y, double z, int intersect, double u1, double u2, int inbound,
+		 int is1, int ie1, int is2, int ie2)
+{
+
+  double u1_cur, u2_cur;
+  int    i1_cur, i2_cur;
+  struct Node *temp=NULL;
+
+  if(list == NULL) error_handler("addEnd: list is NULL");
+
+  /* first check to make sure this point is not in the list */
+  u1_cur = u1;
+  i1_cur = is1;
+  u2_cur = u2;
+  i2_cur = is2;
+  if(u1_cur == 1) {
+    u1_cur = 0;
+    i1_cur = ie1;
+  }
+  if(u2_cur == 1) {
+    u2_cur = 0;
+    i2_cur = ie2;
+  }
+  
+  if(list->initialized) {
+    temp = list;
+    while(temp) {
+      if( temp->u == u1_cur && temp->subj_index == i1_cur) return 0;
+      if( temp->u_clip == u2_cur && temp->clip_index == i2_cur) return 0;
+      if( !temp->Next ) break;
+      temp=temp->Next;
+    }
+    
+    /* Append at the end of the list.  */
+    temp->Next = getNext();
+    temp = temp->Next;
+  }
+  else {
+    temp = list;
+  }
+
+  temp->x = x;
+  temp->y = y;
+  temp->z = z;
+  temp->intersect = intersect;
+  temp->inbound = inbound;
+  temp->initialized=1;
+  temp->isInside = 0;
+  temp->u = u1_cur;
+  temp->subj_index = i1_cur;
+  temp->u_clip = u2_cur;
+  temp->clip_index = i2_cur;
+  
+  return 1;
+}
+
+
+int length(struct Node *list)  
+{  
+   struct Node *cur_ptr=NULL;  
+   int count=0;  
+  
+   cur_ptr=list;  
+  
+   while(cur_ptr)  
+   {
+     if(cur_ptr->initialized ==0) break;
+      cur_ptr=cur_ptr->Next;
+      count++;  
+   }  
+   return(count);  
+}  
+
+/* two points are the same if there are close enough */
+int samePoint(double x1, double y1, double z1, double x2, double y2, double z2)
+{
+    if( fabs(x1-x2) > EPSLN10 || fabs(y1-y2) > EPSLN10 || fabs(z1-z2) > EPSLN10 )
+      return 0;
+    else
+      return 1;
+}
+
+  
+
+int sameNode(struct Node node1, struct Node node2)
+{
+  if( node1.x == node2.x && node1.y == node2.y && node1.z==node2.z )
+    return 1;
+  else
+    return 0;
+}
+      
+
+void addNode(struct Node *list, struct Node inNode)
+{
+
+  addEnd(list, inNode.x, inNode.y, inNode.z, inNode.intersect, inNode.u, inNode.inbound, inNode.isInside);
+  
+}
+
+struct Node *getNode(struct Node *list, struct Node inNode)
+{
+  struct Node *thisNode=NULL;
+  struct Node *temp=NULL;
+
+  temp = list;
+  while( temp ) {
+    if( sameNode( *temp, inNode ) ) {
+      thisNode = temp;
+      temp = NULL;
+      break;
+    }
+    temp = temp->Next;
+  }
+
+  return thisNode;
+}
+
+struct Node *getNextNode(struct Node *list)
+{
+  return list->Next;
+}
+
+void copyNode(struct Node *node_out, struct Node node_in)
+{
+
+  node_out->x = node_in.x;
+  node_out->y = node_in.y;
+  node_out->z = node_in.z;
+  node_out->u = node_in.u;
+  node_out->intersect = node_in.intersect;
+  node_out->inbound   = node_in.inbound;
+  node_out->Next = NULL;
+  node_out->initialized = node_in.initialized;
+  node_out->isInside = node_in.isInside;
+}
+
+void printNode(struct Node *list, char *str)
+{
+  struct Node *temp;
+
+  if(list == NULL) error_handler("printNode: list is NULL");
+  if(str) printf("  %s \n", str);
+  temp = list;
+  while(temp) {
+    if(temp->initialized ==0) break;
+    printf(" (x, y, z, interset, inbound, isInside) = (%19.15f,%19.15f,%19.15f,%d,%d,%d)\n",
+	   temp->x, temp->y, temp->z, temp->intersect, temp->inbound, temp->isInside);
+    temp = temp->Next;
+  }
+  printf("\n");
+}
+
+int intersectInList(struct Node *list, double x, double y, double z) 
+{
+  struct Node *temp;
+  int found=0;
+  
+  temp = list;
+  found = 0;
+  while ( temp ) {
+    if( temp->x == x && temp->y == y && temp->z == z ) {
+      found = 1;
+      break;
+    }
+    temp=temp->Next;
+  }
+  if (!found) error_handler("intersectInList: point (x,y,z) is not found in the list");
+  if( temp->intersect == 2 )
+    return 1;
+  else
+    return 0;
+
+}
+  
+
+/* The following insert a intersection after non-intersect point (x2,y2,z2), if the point
+   after (x2,y2,z2) is an intersection, if u is greater than the u value of the intersection,
+   insert after, otherwise insert before
+*/
+void insertIntersect(struct Node *list, double x, double y, double z, double u1, double u2, int inbound,
+		 double x2, double y2, double z2)
+{
+  struct Node *temp1=NULL, *temp2=NULL;
+  struct Node *temp;
+  double u_cur;
+  int found=0;
+    
+  temp1 = list;
+  found = 0;
+  while ( temp1 ) {
+    if( temp1->x == x2 && temp1->y == y2 && temp1->z == z2 ) {
+      found = 1;
+      break;
+    }
+    temp1=temp1->Next;
+  }
+  if (!found) error_handler("inserAfter: point (x,y,z) is not found in the list");
+
+  /* when u = 0 or u = 1, set the grid point to be the intersection point to solve truncation error isuse */
+  u_cur = u1;
+  if(u1 == 1) {
+    u_cur = 0;
+    temp1 = temp1->Next;
+    if(!temp1) temp1 = list;
+  }
+  if(u_cur==0) {
+    temp1->intersect = 2; 
+    temp1->isInside = 1;
+    temp1->u = u_cur;
+    temp1->x = x;
+    temp1->y = y;
+    temp1->z = z;
+    return;
+  }
+
+  /* when u2 != 0 and u2 !=1, can decide if one end of the point is outside depending on inbound value */
+  if(u2 != 0 && u2 != 1) {
+    if(inbound == 1) { /* goes outside, then temp1->Next is an outside point */
+      /* find the next non-intersect point */
+      temp2 = temp1->Next;
+      if(!temp2) temp2 = list;
+      while(temp2->intersect) {
+         temp2=temp2->Next;
+         if(!temp2) temp2 = list;
+      }
+
+      temp2->isInside = 0;
+    }
+    else if(inbound ==2) { /* goes inside, then temp1 is an outside point */
+      temp1->isInside = 0;
+    }
+  }
+      
+  temp2 = temp1->Next;
+  while ( temp2 ) {
+    if( temp2->intersect == 1 ) {
+      if( temp2->u > u_cur ) {
+	break;
+      }
+    }
+    else
+      break;
+    temp1 = temp2;
+    temp2 = temp2->Next;
+  }
+
+  /* assign value */
+  temp = getNext();
+  temp->x = x;
+  temp->y = y;
+  temp->z = z;
+  temp->u = u_cur;
+  temp->intersect = 1;
+  temp->inbound = inbound;
+  temp->isInside = 1;
+  temp->initialized = 1;
+  temp1->Next = temp;
+  temp->Next = temp2;
+  
+}
+
+double gridArea(struct Node *grid) {
+  double x[20], y[20], z[20];
+  struct Node *temp=NULL;
+  double area;
+  int n;
+  
+  temp = grid;
+  n = 0;
+  while( temp ) {
+    x[n] = temp->x;
+    y[n] = temp->y;
+    z[n] = temp->z;
+    n++;
+    temp = temp->Next;
+  }
+
+  area = great_circle_area(n, x, y, z);
+
+  return area;
+  
+}
+
+int isIntersect(struct Node node) {
+
+  return node.intersect;
+
+}
+
+
+int getInbound( struct Node node )
+{
+  return node.inbound;
+}
+
+struct Node *getLast(struct Node *list)
+{
+  struct Node *temp1;
+
+  temp1 = list;
+  if( temp1 ) {
+    while( temp1->Next ) {
+      temp1 = temp1->Next;
+    }
+  }
+
+  return temp1;
+}
+
+
+int getFirstInbound( struct Node *list, struct Node *nodeOut)
+{
+  struct Node *temp=NULL;
+
+  temp=list;
+
+  while(temp) {
+    if( temp->inbound == 2 ) {
+      copyNode(nodeOut, *temp);
+      return 1;
+    }
+    temp=temp->Next;
+  }
+
+  return 0;
+}
+
+void getCoordinate(struct Node node, double *x, double *y, double *z)
+{
+
+
+  *x = node.x;
+  *y = node.y;
+  *z = node.z;
+
+}
+
+void getCoordinates(struct Node *node, double *p)
+{
+
+
+  p[0] = node->x;
+  p[1] = node->y;
+  p[2] = node->z;
+
+}
+
+void setCoordinate(struct Node *node, double x, double y, double z)
+{
+
+
+  node->x = x;
+  node->y = y;
+  node->z = z;
+
+}
+
+/* set inbound value for the points in interList that has inbound =0,
+   this will also set some inbound value of the points in list1
+*/
+
+void setInbound(struct Node *interList, struct Node *list)
+{
+
+  struct Node *temp1=NULL, *temp=NULL;
+  struct Node *temp1_prev=NULL, *temp1_next=NULL;
+  int prev_is_inside, next_is_inside;
+
+  /* for each point in interList, search through list to decide the inbound value the interList point */
+  /* For each inbound point, the prev node should be outside and the next is inside. */
+  if(length(interList) == 0) return;
+  
+  temp = interList;
+
+  while(temp) {
+    if( !temp->inbound) {
+      /* search in grid1 to find the prev and next point of temp, when prev point is outside and next point is inside
+	 inbound = 2, else inbound = 1*/
+      temp1 = list;
+      temp1_prev = NULL;
+      temp1_next = NULL; 
+      while(temp1) {
+	if(sameNode(*temp1, *temp)) {
+	  if(!temp1_prev) temp1_prev = getLast(list);
+	  temp1_next = temp1->Next; 
+	  if(!temp1_next) temp1_next = list;
+	  break;
+	}
+	temp1_prev = temp1;
+	temp1 = temp1->Next;
+      }
+      if(!temp1_next) error_handler("Error from create_xgrid.c: temp is not in list1");
+      if( temp1_prev->isInside == 0 && temp1_next->isInside == 1)
+	temp->inbound = 2;   /* go inside */
+      else
+	temp->inbound = 1;
+    }
+    temp=temp->Next;
+  }
+}
+
+int isInside(struct Node *node) {
+
+  if(node->isInside == -1) error_handler("Error from mosaic_util.c: node->isInside is not set");
+  return(node->isInside);
+  
+}
+
+/*  #define debug_test_create_xgrid */ 
+
+/* check if node is inside polygon list or not */
+ int insidePolygon( struct Node *node, struct Node *list)
+{
+  int i, ip, is_inside;
+  double pnt0[3], pnt1[3], pnt2[3];
+  double anglesum;
+  struct Node *p1=NULL, *p2=NULL;  
+
+  anglesum = 0;
+
+  pnt0[0] = node->x;
+  pnt0[1] = node->y;
+  pnt0[2] = node->z;
+
+  p1 = list;
+  p2 = list->Next;
+  is_inside = 0;
+
+  
+  while(p1) {
+    pnt1[0] = p1->x;
+    pnt1[1] = p1->y;
+    pnt1[2] = p1->z;
+    pnt2[0] = p2->x;
+    pnt2[1] = p2->y;
+    pnt2[2] = p2->z;
+    if(samePoint(pnt0[0], pnt0[1], pnt0[2], pnt1[0], pnt1[1], pnt1[2])) return 1;     
+    anglesum += spherical_angle(pnt0, pnt2, pnt1);
+    p1 = p1->Next;
+    p2 = p2->Next;
+    if(p2==NULL)p2 = list;
+  }
+
+  if( fabs(anglesum - 2*M_PI) < EPSLN8 )
+    is_inside = 1;
+  else
+    is_inside = 0;
+
+#ifdef debug_test_create_xgrid 
+  printf("anglesum-2PI is %19.15f, is_inside = %d\n", anglesum- 2*M_PI, is_inside);
+#endif
+  
+  return is_inside;
+  
+}
+
+int inside_a_polygon(double *lon1, double *lat1, int *npts, double *lon2, double *lat2)
+{
+
+  double x2[20], y2[20], z2[20];
+  double x1, y1, z1;
+  double min_x2, max_x2, min_y2, max_y2, min_z2, max_z2;
+  int isinside, i;
+
+  struct Node *grid1=NULL, *grid2=NULL;
+
+  /* first convert to cartesian grid */
+  latlon2xyz(*npts, lon2, lat2, x2, y2, z2);
+  latlon2xyz(1, lon1, lat1, &x1, &y1, &z1);
+
+  max_x2 = maxval_double(*npts, x2);
+  if(x1 >= max_x2+RANGE_CHECK_CRITERIA) return 0;
+  min_x2 = minval_double(*npts, x2);
+  if(min_x2 >= x1+RANGE_CHECK_CRITERIA) return 0;
+
+  max_y2 = maxval_double(*npts, y2);
+  if(y1 >= max_y2+RANGE_CHECK_CRITERIA) return 0;
+  min_y2 = minval_double(*npts, y2);
+  if(min_y2 >= y1+RANGE_CHECK_CRITERIA) return 0;
+
+  max_z2 = maxval_double(*npts, z2);
+  if(z1 >= max_z2+RANGE_CHECK_CRITERIA) return 0;
+  min_z2 = minval_double(*npts, z2);
+  if(min_z2 >= z1+RANGE_CHECK_CRITERIA) return 0;
+
+
+  /* add x2,y2,z2 to a Node */
+  rewindList();
+  grid1 = getNext();
+  grid2 = getNext();
+
+  addEnd(grid1, x1, y1, z1, 0, 0, 0, -1);
+  for(i=0; i<*npts; i++) addEnd(grid2, x2[i], y2[i], z2[i], 0, 0, 0, -1);
+
+  isinside = insidePolygon(grid1, grid2);
+
+  return isinside;
+
+}
+
+#ifndef __AIX
+int inside_a_polygon_(double *lon1, double *lat1, int *npts, double *lon2, double *lat2)
+{
+
+  int isinside;
+
+  isinside = inside_a_polygon(lon1, lat1, npts, lon2, lat2);
+
+  return isinside;
+
+}
+#endif
+
diff --git a/sorc/fre-nctools.fd/shared_lib/mosaic_util.h b/sorc/fre-nctools.fd/shared_lib/mosaic_util.h
new file mode 100644
index 0000000..c7c0cef
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mosaic_util.h
@@ -0,0 +1,92 @@
+/***********************************************************************
+                      mosaic_util.h
+    This header file provide some utilities routine that will be used in many tools.
+    
+    contact: Zhi.Liang@noaa.gov
+***********************************************************************/
+#ifndef MOSAIC_UTIL_H_
+#define MOSAIC_UTIL_H_
+
+#ifndef RANGE_CHECK_CRITERIA
+#define RANGE_CHECK_CRITERIA 0.05
+#endif
+
+#define min(a,b) (a<b ? a:b)
+#define max(a,b) (a>b ? a:b)
+#define SMALL_VALUE ( 1.e-10 )
+struct Node{
+  double x, y, z, u, u_clip;
+  int intersect; /* indicate if this point is an intersection, 0 = no, 1= yes, 2=both intersect and vertices */ 
+  int inbound;      /* -1 uninitialized, 0 coincident, 1 outbound, 2 inbound */
+  int initialized; /* = 0 means empty list */
+  int isInside;   /* = 1 means one point is inside the other polygon, 0 is not, -1 undecided. */
+  int subj_index; /* the index of subject point that an intersection follow. */
+  int clip_index; /* the index of clip point that an intersection follow */
+  struct Node *Next;
+};
+
+
+void error_handler(const char *msg);
+int nearest_index(double value, const double *array, int ia);
+int lon_fix(double *x, double *y, int n_in, double tlon);
+double minval_double(int size, const double *data);
+double maxval_double(int size, const double *data);
+double avgval_double(int size, const double *data);
+void latlon2xyz(int size, const double *lon, const double *lat, double *x, double *y, double *z); 
+void xyz2latlon(int size, const double *x, const double *y, const double *z, double *lon, double *lat);
+double box_area(double ll_lon, double ll_lat, double ur_lon, double ur_lat);
+double poly_area(const double lon[], const double lat[], int n);
+double poly_area_dimensionless(const double lon[], const double lat[], int n);
+double poly_area_no_adjust(const double x[], const double y[], int n);
+int fix_lon(double lon[], double lat[], int n, double tlon);
+void tokenize(const char * const string, const char *tokens, unsigned int varlen,
+	      unsigned int maxvar, char * pstring, unsigned int * const nstr);
+double great_circle_distance(double *p1, double *p2);
+double spherical_excess_area(const double* p_ll, const double* p_ul,
+			     const double* p_lr, const double* p_ur, double radius);
+void vect_cross(const double *p1, const double *p2, double *e );
+double spherical_angle(const double *v1, const double *v2, const double *v3);
+void normalize_vect(double *e);
+void unit_vect_latlon(int size, const double *lon, const double *lat, double *vlon, double *vlat);
+double great_circle_area(int n, const double *x, const double *y, const double *z);
+double * cross(const double *p1, const double *p2);
+double dot(const double *p1, const double *p2);
+int intersect_tri_with_line(const double *plane, const double *l1, const double *l2, double *p,
+			     double *t);
+int invert_matrix_3x3(long double m[], long double m_inv[]);
+void mult(long double m[], long double v[], long double out_v[]);
+double metric(const double *p);
+int insidePolygon(struct Node *node, struct Node *list );
+int inside_a_polygon( double *lon1, double *lat1, int *npts, double *lon2, double *lat2);
+
+void rewindList(void);
+struct Node *getNext();
+void initNode(struct Node *node);
+void addEnd(struct Node *list, double x, double y, double z, int intersect, double u, int inbound, int inside);
+int addIntersect(struct Node *list, double x, double y, double z, int intersect, double u1, double u2, 
+                int inbound, int is1, int ie1, int is2, int ie2);
+int length(struct Node *list);
+int samePoint(double x1, double y1, double z1, double x2, double y2, double z2);
+int sameNode(struct Node node1, struct Node node2);
+void addNode(struct Node *list, struct Node nodeIn);
+struct Node *getNode(struct Node *list, struct Node inNode);
+struct Node *getNextNode(struct Node *list);
+void copyNode(struct Node *node_out, struct Node node_in);
+void printNode(struct Node *list, char *str);
+int intersectInList(struct Node *list, double x, double y, double z);
+void insertAfter(struct Node *list, double x, double y, double z, int intersect, double u, int inbound,
+		 double x2, double y2, double z2);
+double gridArea(struct Node *grid);
+int isIntersect(struct Node node);
+int getInbound( struct Node node );
+struct Node *getLast(struct Node *list);
+int getFirstInbound( struct Node *list, struct Node *nodeOut);
+void getCoordinate(struct Node node, double *x, double *y, double *z);
+void getCoordinates(struct Node *node, double *p);
+void setCoordinate(struct Node *node, double x, double y, double z);
+void setInbound(struct Node *interList, struct Node *list);
+int isInside(struct Node *node);
+void set_reproduce_siena_true(void);
+
+
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp.c b/sorc/fre-nctools.fd/shared_lib/mpp.c
new file mode 100644
index 0000000..3207c6e
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp.c
@@ -0,0 +1,353 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#ifdef use_libMPI
+#include <mpi.h>
+#endif
+#include "mpp.h"
+
+
+/****************************************************
+         global variables
+*****************************************************/
+int npes, root_pe, pe;
+int *pelist=NULL;
+const int tag = 1;
+#ifdef use_libMPI  
+MPI_Request *request;
+#endif
+
+/**************************************************************
+                     void mpp_init()
+     this routine will create communicator.
+***************************************************************/
+
+void mpp_init(int *argc, char ***argv)
+{
+  int n;
+  
+#ifdef use_libMPI
+  MPI_Init(argc, argv); 
+  MPI_Comm_rank(MPI_COMM_WORLD,&pe);
+  MPI_Comm_size(MPI_COMM_WORLD,&npes);
+  request = (MPI_Request *)malloc(npes*sizeof(MPI_Request));
+  for(n=0; n<npes; n++) request[n] = MPI_REQUEST_NULL;
+#else
+  pe = 0;
+  npes = 1;
+#endif
+  pelist = (int *)malloc(npes*sizeof(int));
+  for(n=0; n<npes; n++) pelist[n] = n;
+  root_pe = 0;
+}; /* mpp_init */
+
+/***********************************************************
+               void mpp_end()
+     This routine will terminate the parallel.
+************************************************************/
+
+void mpp_end()
+{
+#ifdef use_libMPI   
+  MPI_Finalize();
+#endif  
+} /* mpp_end */
+
+/*****************************************************************
+           int mpp_pe()
+      Returns processor ID.
+******************************************************************/
+
+int mpp_pe()
+{
+  return pe;
+}; /* mpp_pe */
+
+
+/**************************************************************
+                 int mpp_npes()
+      Returns processor count for current pelist.
+**************************************************************/
+
+int mpp_npes()
+{
+  return npes;
+}; /* mpp_npes */
+
+/*************************************************************
+               int mpp_root_pe()
+    return root processor of current pelist
+*************************************************************/
+
+int mpp_root_pe()
+{
+  return root_pe;
+}; /* mpp_root_pe */
+
+/*************************************************************
+               int* mpp_get_pelist()
+    return current pelist
+*************************************************************/
+
+int* mpp_get_pelist()
+{
+  return pelist;
+}; /* mpp_get_pelist */
+
+/************************************************************
+    void mpp_sync_self()
+ this is to check if current PE's outstanding puts are complete
+*************************************************************/
+void mpp_sync_self() {
+  int n;
+#ifdef use_libMPI     
+  MPI_Status status;
+  
+  for(n=0; n<npes; n++) {
+    if(request[n] != MPI_REQUEST_NULL) MPI_Wait( request+n, &status );
+  }
+#endif
+  
+}
+
+/************************************************************
+  void mpp_sync()
+************************************************************/
+void mpp_sync()
+{
+#ifdef use_libMPI
+  MPI_Barrier(MPI_COMM_WORLD);
+#endif
+
+}
+
+/*************************************************************
+    void mpp_send_double(const double* data, int size, int to_pe)
+      send data to "to_pe"
+*************************************************************/
+
+void mpp_send_double(const double* data, int size, int to_pe)
+{
+#ifdef use_libMPI    
+  MPI_Status status;
+  /* make sure only one message from pe->to_pe in queue */
+  if(request[to_pe] != MPI_REQUEST_NULL) {
+    MPI_Wait( request+to_pe, &status );
+  }
+    
+  MPI_Isend(data, size, MPI_DOUBLE, to_pe, tag, MPI_COMM_WORLD, request+to_pe);
+#endif
+  
+}; /* mpp_send_double */
+
+
+/*************************************************************
+    void mpp_send_int(const int* data, int size, int to_pe)
+      send data to "to_pe"
+*************************************************************/
+
+void mpp_send_int(const int* data, int size, int to_pe)
+{
+#ifdef use_libMPI    
+  MPI_Status status;
+  if(request[to_pe] != MPI_REQUEST_NULL) {
+    MPI_Wait( request+to_pe, &status );
+  }  
+
+  MPI_Isend(data, size, MPI_INT, to_pe, tag, MPI_COMM_WORLD, request+to_pe);
+#endif
+  
+}; /* mpp_send_int */
+
+/***********************************************************
+    void mpp_recv_double(double* data, int size, int from_pe)
+     receive data from "from_pe"
+***********************************************************/
+
+void mpp_recv_double(double* data, int size, int from_pe)
+{
+#ifdef use_libMPI      
+  MPI_Status status;
+  MPI_Recv(data, size, MPI_DOUBLE, from_pe, MPI_ANY_TAG, MPI_COMM_WORLD,&status);
+#endif  
+}; /* mpp_recv_double */
+
+/***********************************************************
+    void mpp_recv_int(int* data, int size, int from_pe)
+     receive data from "from_pe"
+***********************************************************/
+
+void mpp_recv_int(int* data, int size, int from_pe)
+{
+#ifdef use_libMPI      
+  MPI_Status status;
+  MPI_Recv(data, size, MPI_INT, from_pe, MPI_ANY_TAG, MPI_COMM_WORLD,&status);
+#endif  
+}; /* mpp_recv_int */
+
+
+/*******************************************************************************
+  int mpp_sum_int(int count, int *data)
+  sum integer over all the pes.
+*******************************************************************************/
+void mpp_sum_int(int count, int *data)
+{
+
+#ifdef use_libMPI
+  int i;
+  int *sum;
+  sum = (int *)malloc(count*sizeof(int));
+  MPI_Allreduce(data, sum, count, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+  for(i=0; i<count; i++)data[i] = sum[i];
+  free(sum);
+#endif
+
+
+}; /* mpp_sum_int */
+
+/*******************************************************************************
+  void mpp_sum_double(int count, double *data)
+  sum double over all the pes.
+*******************************************************************************/
+void mpp_sum_double(int count, double *data)
+{
+
+#ifdef use_libMPI
+  int i;
+  double *sum;
+  sum = (double *)malloc(count*sizeof(double));
+  MPI_Allreduce(data, sum, count, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
+  for(i=0; i<count; i++)data[i] = sum[i];
+  free(sum);  
+#endif
+
+
+}; /* mpp_sum_double */
+
+void mpp_min_double(int count, double *data)
+{
+
+#ifdef use_libMPI
+  int i;
+  double *minval;
+  minval = (double *)malloc(count*sizeof(double));
+  MPI_Allreduce(data, minval, count, MPI_DOUBLE, MPI_MIN, MPI_COMM_WORLD);
+  for(i=0; i<count; i++) data[i] = minval[i];
+  free(minval);
+#endif
+
+}; /* mpp_min_double */
+
+
+void mpp_max_double(int count, double *data)
+{
+
+#ifdef use_libMPI
+  int i;
+  double *maxval;
+  maxval = (double *)malloc(count*sizeof(double));
+  MPI_Allreduce(data, maxval, count, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
+  for(i=0; i<count; i++) data[i] = maxval[i];
+  free(maxval);
+#endif
+
+}; /* mpp_max_double */
+
+/***********************************************************
+    void mpp_error(char *str)
+    error handler: will print out error message and then abort
+***********************************************************/
+
+void mpp_error(char *str)
+{
+  fprintf(stderr, "Error from pe %d: %s\n", pe, str );
+#ifdef use_libMPI      
+  MPI_Abort(MPI_COMM_WORLD, -1);
+#else
+  exit(1);
+#endif  
+}; /* mpp_error */
+
+double get_mem_usage(void)
+
+{
+  double mem;
+  
+#if defined(__sgi) || defined(__aix) || defined(__SX)
+#define RUSAGE_SELF      0         /* calling process */
+#define RUSAGE_CHILDREN  -1        /* terminated child processes */
+ struct rusage my_rusage;
+ int iret;
+
+ my_rusage.ru_maxrss = 0;
+ iret = getrusage(RUSAGE_SELF,&my_rusage);
+ mem = my_rusage.ru_maxrss;
+ mem /= 1000;
+
+#else
+ char filename[]="/proc/self/status";
+ char mesg[256];
+ FILE *fp;
+ char line[80], units[32];
+
+ fp = fopen(filename, "r");
+ if(!fp) {
+   strcpy(mesg, "tool_util.c: Can not open ascii file ");
+   strcat(mesg,filename);
+   mpp_error(mesg);
+ }
+
+ mem = 0;
+ while(fgets(line, 80, fp) != NULL)  /* get a line, up to 80 chars from fp.  done if NULL */
+   {
+     if( strncmp(line, "VmHWM:", 6) == 0) {
+       sscanf(line+6, "%lf %s", &mem, units);
+       if( strcmp(units, "kB") == 0) mem = mem/1024;
+       break;
+     }
+   }
+ fclose(fp); 
+#endif
+
+ return mem;
+ 
+}
+
+void print_time(const char* text, double t)
+{
+  double tmin, tmax, tavg;
+  
+  tmin=t;
+  tmax=t;
+  tavg=t;
+  mpp_min_double(1, &tmin);
+  mpp_max_double(1, &tmax);
+  mpp_sum_double(1, &tavg);
+  tavg /= mpp_npes();
+  if( mpp_pe() == mpp_root_pe() ) {
+    printf("Running time for %s, min=%g, max=%g, avg=%g\n", text, tmin, tmax, tavg); 
+  }
+
+}
+
+
+void print_mem_usage(const char* text)
+{
+  double m, mmin, mmax, mavg;
+
+
+    m = get_mem_usage();
+    mmin = m;
+    mmax = m;
+    mavg = m;
+    mpp_min_double(1, &mmin);
+    mpp_max_double(1, &mmax);
+    mpp_sum_double(1, &mavg);
+    mavg /= mpp_npes();
+    if( mpp_pe() == mpp_root_pe() ) {
+      printf("Memuse(MB) at %s, min=%g, max=%g, avg=%g\n", text, mmin, mmax, mavg); 
+    }
+}
+      
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp.h b/sorc/fre-nctools.fd/shared_lib/mpp.h
new file mode 100644
index 0000000..0ad54d7
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp.h
@@ -0,0 +1,30 @@
+
+/*********************************************************************
+                    mpp.h
+  This header contains subroutine for parallel programming.
+  only MPI parallel is implemented. 
+  Contact: Zhi.Liang@noaa.gov
+ ********************************************************************/
+#ifndef MPP_H_
+#define MPP_H_
+
+void mpp_init(int *argc, char ***argv);          /* start parallel programming, create communicator */
+void mpp_end();           /* end of parallel programming, abort the program */
+int mpp_pe();      /* return processor ID */
+int mpp_root_pe(); /* return root pe of current pelist */
+int mpp_npes();    /* return number of processor used */
+int* mpp_get_pelist();
+void mpp_send_double(const double* data, int size, int to_pe); /* send data */
+void mpp_send_int(const int* data, int size, int to_pe); /* send data */
+void mpp_recv_double(double* data, int size, int from_pe); /* recv data */
+void mpp_recv_int(int* data, int size, int from_pe); /* recv data */
+void mpp_error(char *str);
+void mpp_sum_int(int count, int *data);
+void mpp_sum_double(int count, double *data);
+void mpp_min_double(int count, double *data);
+void mpp_max_double(int count, double *data);
+void print_mem_usage(const char* text);
+void print_time(const char* text, double t);
+void mpp_sync_self();
+void mpp_sync();
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp_domain.c b/sorc/fre-nctools.fd/shared_lib/mpp_domain.c
new file mode 100644
index 0000000..3c8b6b1
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp_domain.c
@@ -0,0 +1,901 @@
+/*
+      **** MppDomain.cpp ****
+      MppDomain package
+      NOTE: only mpi is implemented here. if needed, shmem version
+      will be added on in the future.
+      Contact: Zhi.Liang@noaa.gov
+*/
+#include <stdlib.h>
+#include <math.h>
+#include "mpp.h"
+#include "mpp_domain.h"
+
+/***********************************************************
+   global variables
+***********************************************************/
+int pe, npes, root_pe;
+#define MAX_BUFFER_SIZE 10000000
+double rBuffer[MAX_BUFFER_SIZE];
+double sBuffer[MAX_BUFFER_SIZE];
+
+/************************************************************
+         void mpp_domain_init()
+   initialization routine. get the processor information.
+   memory allocation.
+************************************************************/
+void mpp_domain_init( )
+{
+  pe      = mpp_pe();
+  npes    = mpp_npes();
+  root_pe = mpp_root_pe();  
+
+}; /* mpp_domain_init */
+
+/*********************************************************** 
+         void mpp_domain_end()
+         release memory.
+***********************************************************/
+void mpp_domain_end ()
+{
+  /* will add something here if needed */
+};
+
+/************************************************************
+    void mpp_define_layout()
+    define domain layout based on given grid resolution and
+    number of processors
+***********************************************************/
+
+void mpp_define_layout(int ni, int nj, int ndivs, int layout[])
+{
+  int idiv, jdiv;
+  float fdiv;
+
+  /*first try to divide ndivs in the domain aspect ratio:
+    if imperfect aspect, reduce idiv till it divides ndivs */
+  fdiv = sqrt((1.0*ndivs*ni)/nj); 
+  idiv = floor(fdiv);
+  if(fdiv-idiv > 0.5) idiv = idiv + 1;
+  idiv = (idiv>1) ? idiv : 1;  /*for isz=1 line above can give 0*/
+  while( ndivs%idiv != 0 ) {
+    idiv = idiv - 1;
+  }                 /*will terminate at idiv=1 if not before*/
+  jdiv = ndivs/idiv;
+  layout[0] = idiv;
+  layout[1] = jdiv;
+};
+
+/***************************************************************
+ void mpp_compute_extent(int npts, int ndivs, int *ibegin, int *iend)
+
+ Compute extent of 1-D decomposition
+
+ problem of dividing nx points into n domains maintaining symmetry
+ i.e nx=18 n=4 4554 and 5445 are solutions but 4455 is not.
+ this will always work for nx even n even or odd
+ this will always work for nx odd, n odd
+ this will never  work for nx odd, n even: for this case we supersede the mirror calculation
+ symmetrize = .NOT. ( mod(ndivs,2).EQ.0 .AND. mod(ieg-isg+1,2).EQ.1 )
+ nx even n odd fails if n>nx/2
+
+***************************************************************/
+void mpp_compute_extent(int npts, int ndivs, int *ibegin, int *iend)
+{
+  int ndivs_is_odd, npts_is_odd, symmetrize;
+  int isg, ieg, is, ie;
+  int imax, ndmax, ndmirror;
+  int ndiv;
+  
+  if(ndivs > npts ) {
+     mpp_error("mpp_compute_extent: more divisions requested than rows available. " );
+  }
+
+  ndivs_is_odd = ndivs%2;
+  npts_is_odd = npts%2;
+  symmetrize = 0;
+  if( ndivs_is_odd && npts_is_odd ) symmetrize = 1; 
+  if( ndivs_is_odd == 0 && npts_is_odd == 0 ) symmetrize = 1;
+  if( ndivs_is_odd && npts_is_odd == 0 && ndivs < npts/2 ) symmetrize = 1;
+
+  isg = 0;
+  ieg = npts-1;
+  is = isg;
+  for(ndiv=0; ndiv<ndivs; ndiv++){
+    /*mirror domains are stored in the list and retrieved if required. */
+    if( ndiv == 0 ) { /* initialize max points and max domains */
+      imax = ieg;
+      ndmax = ndivs;
+    }
+    /* do bottom half of decomposition, going over the midpoint for odd ndivs */
+    if( ndiv < (ndivs-1)/2+1 ) {
+      /*domain is sized by dividing remaining points by remaining domains */
+      ie = is + ceil((imax-is+1.0)/(ndmax-ndiv) ) - 1;
+      ndmirror = (ndivs-1) - ndiv; /* mirror domain */
+      if( ndmirror > ndiv && symmetrize ) { /* only for domains over the midpoint */
+	/*mirror extents, the max(,) is to eliminate overlaps */
+	ibegin[ndmirror] = max( isg+ieg-ie, ie+1 );
+	iend[ndmirror]   = max( isg+ieg-is, ie+1 );
+	imax = ibegin[ndmirror] - 1;
+	ndmax --;
+      }
+    }
+    else {
+      if( symmetrize ){
+	/*do top half of decomposition by retrieving saved values */
+	is = ibegin[ndiv];
+	ie = iend[ndiv];
+      }
+      else {
+	ie = is + ceil((imax-is+1.0)/(ndmax-ndiv)) - 1;
+      }
+    }
+ 
+    ibegin[ndiv] = is;
+    iend[ndiv] = ie;
+    if( ie < is )mpp_error("mpp_domains(mpp_compute_extent): domain extents must be positive definite." );
+    if( ndiv == ndivs-1 && iend[ndiv] != ieg )
+      mpp_error( "mpp_domains(mpp_compute_extent): domain extents do not span space completely." );
+    is = ie + 1;
+  }
+
+}; /* mpp_compute_extent */
+
+
+/***********************************************************
+    void mpp_define_domain_1d(int size, domain1D *domain )
+    define 1-D domain decomposition.
+**********************************************************/
+void mpp_define_domain_1d(int npts, int ndivs, domain1D *domain )
+{
+  int n, npts_left, pos, size;
+
+  domain->beglist = (int *)malloc(ndivs*sizeof(int));
+  domain->endlist = (int *)malloc(ndivs*sizeof(int));
+
+  mpp_compute_extent(npts, ndivs, domain->beglist, domain->endlist);
+  
+  if(npes == ndivs) {
+    domain->start = domain->beglist[pe];
+    domain->end   = domain->endlist[pe];
+    domain->size  = domain->end - domain->start + 1;
+    domain->sizeg = npts;
+  }
+  
+}; /* mpp_define_domain_1d */
+
+
+/************************************************************
+  void define_domain(int ni, int nj, int layout[], int xhalo, int yhalo, domain2D *domain  )
+   define 2D domain decomposition
+************************************************************/
+
+void mpp_define_domain2d(int ni, int nj, int layout[], int xhalo, int yhalo, domain2D *domain )
+{
+  domain1D domx, domy;
+  int i, j, posx, posy, n; 
+
+  domain->isclist = (int *)malloc(layout[0]*layout[1]*sizeof(int));
+  domain->ieclist = (int *)malloc(layout[0]*layout[1]*sizeof(int));
+  domain->jsclist = (int *)malloc(layout[0]*layout[1]*sizeof(int));
+  domain->jeclist = (int *)malloc(layout[0]*layout[1]*sizeof(int));  
+
+  mpp_define_domain_1d(ni, layout[0], &domx);
+  mpp_define_domain_1d(nj, layout[1], &domy); 
+
+  n = 0;
+  for(j=0; j<layout[1]; j++) {
+    for(i=0; i<layout[0]; i++) {
+      domain->isclist[n] = domx.beglist[i]+xhalo;
+      domain->ieclist[n] = domx.endlist[i]+xhalo;
+      domain->jsclist[n] = domy.beglist[j]+yhalo;
+      domain->jeclist[n] = domy.endlist[j]+yhalo;
+      n++;
+    }
+  }
+
+  domain->xhalo = xhalo;
+  domain->yhalo = yhalo;
+  domain->isc   = domain->isclist[pe];
+  domain->iec   = domain->ieclist[pe];
+  domain->jsc   = domain->jsclist[pe];
+  domain->jec   = domain->jeclist[pe];
+  domain->isd   = domain->isc - xhalo;
+  domain->ied   = domain->iec + xhalo;
+  domain->jsd   = domain->jsc - yhalo;
+  domain->jed   = domain->jec + yhalo;  
+  domain->nxc   = domain->iec - domain->isc + 1;
+  domain->nyc   = domain->jec - domain->jsc + 1;
+  domain->nxd   = domain->ied - domain->isd + 1;
+  domain->nyd   = domain->jed - domain->jsd + 1;
+  domain->nxg   = ni;
+  domain->nyg   = nj;
+
+  mpp_delete_domain1d(&domx);
+  mpp_delete_domain1d(&domy);
+  
+}; /* mpp_define_domain2d */
+
+/****************************************************************************
+  void mpp_delete_domain1d(domain1D *domain);
+  release the memory assigned to 1-D domain
+*****************************************************************************/
+void mpp_delete_domain1d(domain1D *domain)
+{
+
+  free(domain->beglist);
+  free(domain->endlist);
+  
+}; /* mpp_delete_domain1d */
+
+/****************************************************************************
+  void mpp_delete_domain2d(domain2D *domain);
+  release the memory assigned to 2-D domain
+*****************************************************************************/
+void mpp_delete_domain2d(domain2D *domain)
+{
+
+  free(domain->isclist);
+  free(domain->ieclist);
+  free(domain->jsclist);
+  free(domain->jeclist);
+  
+}; /* mpp_delete_domain2d */
+
+
+
+/***********************************************************
+     void get_get_compute_domain(omain2D domain, int *is, int *ie, int *js, int *je)
+    get the compute domain decomposition
+***********************************************************/
+
+void mpp_get_compute_domain2d(domain2D domain, int *is, int *ie, int *js, int *je)
+{
+  *is = domain.isc;
+  *ie = domain.iec;
+  *js = domain.jsc;
+  *je = domain.jec;
+}; /* mpp_get_compute_domain */
+
+/***********************************************************
+     void get_get_compute_domain( int *is, int *ie, int *js, int *je)
+    get the compute domain decomposition of current pe list.
+***********************************************************/
+
+void mpp_get_compute_domains2d(domain2D domain, int *is, int *ie, int *js, int *je)
+{
+  int n;
+  
+  for(n=0; n<npes;n++) {
+    is[n] = domain.isclist[n];
+    ie[n] = domain.ieclist[n];
+    js[n] = domain.jsclist[n];
+    je[n] = domain.jeclist[n];
+  }
+
+}/* mpp_get_compute_domains */
+
+/**********************************************************
+    void mpp_get_data_domain(int *is, int *ie, int *js, int *je)
+   get the data domain decomposition
+***********************************************************/
+
+void mpp_get_data_domain2d(domain2D domain, int *is, int *ie, int *js, int *je)
+{
+  *is = domain.isd;
+  *ie = domain.ied;
+  *js = domain.jsd;
+  *je = domain.jed;
+}; /* mpp_get_data_domain */ 
+
+/**********************************************************
+    void mpp_get_global_domain(int *nx, int *ny )
+   get the global domain size
+***********************************************************/
+
+void mpp_get_global_domain2d(domain2D domain, int *nx, int *ny )
+{
+  *nx = domain.nxg;
+  *ny = domain.nyg;
+}; /* mpp_get_global_domain */ 
+
+/****************************************************************
+   void mpp_get_shift(int sizex, int sizey, int *ishift, int *jshift)
+   Return the shift value. For non-symmetry domain, ishift will be always 0.
+   For symmetric domain, shift value can be 0 or 1 depending on position.
+
+****************************************************************/
+void mpp_get_shift(domain2D domain, int sizex, int sizey, int *ishift, int *jshift)
+{
+  int nxc, nyc, nxd, nyd;
+  
+  nxc = domain.nxc; nyc = domain.nyc;
+  nxd = domain.nxd; nyd = domain.nyd;
+
+  if( (sizex == nxc && sizey == nyc) || (sizex == nxd && sizey == nyd) ) { 
+    *ishift = 0;
+    *jshift = 0;
+  }
+  else if ( (sizex == nxc+1 && sizey == nyc) || (sizex == nxd+1 && sizey == nyd)) { 
+    *ishift = 1;
+    *jshift = 0;
+  }
+  else if ( (sizex == nxc && sizey == nyc+1) || (sizex == nxd && sizey == nyd+1) ) { 
+    *ishift = 0;
+    *jshift = 1;
+  }
+  else if ( (sizex == nxc+1 && sizey == nyc+1) || (sizex == nxd+1 && sizey == nyd+1) ) { 
+    *ishift = 1;
+    *jshift = 1;
+  }
+  else
+    mpp_error("mpp_domain: data should be on either compute or data domain.");
+
+}; /* mpp_get_shift */
+
+/*************************************************************
+    mpp_global_field_all_double(domain2D domain, int sizex, int sizey, const double *ldata, double *gdata)
+    get the global data on all the pe.
+    ldata is on compute domain and gdata is on global domain
+************************************************************/
+void mpp_global_field_all_double(domain2D domain, int sizex, int sizey, const double* ldata, double* gdata)
+{
+  double *send_buffer=NULL, *recv_buffer=NULL;
+  int i, j, n, ni, nj, ii, jj, l, p, recv_size;
+  int ishift, jshift, nxc, nyc, nxd, nyd, nxg;
+  int is, ie, js, je, isd, jsd;
+  int send_buffer_is_allocated;
+
+  mpp_get_shift( domain, sizex, sizey, &ishift, &jshift);
+  is = domain.isc;
+  ie = domain.iec + ishift;
+  js = domain.jsc;
+  je = domain.jec + jshift;
+  
+  nxc = ie-is+1;
+  nyc = je-js+1;
+  isd = domain.isd;
+  jsd = domain.jsd;
+  nxd = domain.nxd + ishift;
+  nyd = domain.nyd + jshift;
+  nxg = domain.nxg + ishift;
+
+  /* first fill the send buffer */
+  send_buffer = (double *)malloc(nxc*nyc*sizeof(double));
+  if( sizex == nxc && sizey == nyc ){ /* data is on compute domain */
+    /* for one pe case, just simply copy ldata to gdata */
+    if(npes == 1) {
+      for(i=0; i<nxc*nyc; i++) gdata[i]=ldata[i];
+      return;
+    }
+    else {
+      for(i=0; i<nxc*nyc; i++) send_buffer[i] = ldata[i];
+    }
+  }
+  else if( sizex == nxd && sizey == nyd  ){ /* data is on data domain */
+    n = 0;
+    /* for one pe case, just simply copy ldata to gdata */
+    if(npes == 1) {
+      for(j=js;j<=je;j++) for(i=is;i<=ie;i++) {
+	gdata[n++] = ldata[(j-jsd)*nxd+(i-isd)];
+      }
+      return;
+    }
+    else {
+      for(j=js;j<=je;j++) for(i=is;i<=ie;i++) {
+	send_buffer[n++] = ldata[(j-jsd)*nxd+(i-isd)];
+      }
+    }
+  }
+  else
+    mpp_error("mpp_domain(mpp_global_field_all_double: data should be on compute/data domain");
+  
+  /* send the data */
+  for(p=0;p<npes;p++) {
+    mpp_send_double(send_buffer, nxc*nyc, p);
+  }
+
+  /* received the data */
+  for(p=0;p<npes;p++) {
+    recv_size = (domain.ieclist[p]-domain.isclist[p]+1+ishift)*(domain.jeclist[p]-domain.jsclist[p]+1+jshift);
+    recv_buffer = ( double *) malloc(recv_size*sizeof(double));
+    mpp_recv_double(recv_buffer, recv_size, p );
+    n = 0;
+    for(j=domain.jsclist[p]; j<=domain.jeclist[p]+jshift; j++){
+      for(i=domain.isclist[p]; i<=domain.ieclist[p]+ishift; i++){
+	gdata[j*nxg+i] = recv_buffer[n++];
+      }
+    }
+    free(recv_buffer);
+  }
+
+  mpp_sync_self();
+  
+  free(send_buffer);
+}; /* mpp_global_field_all_double */
+
+
+/*************************************************************
+    mpp_global_field_double(domain2D domain, int sizex, int sizey, const double *ldata, double *gdata)
+    get the global data on root pe.
+    ldata is on compute domain and gdata is on global domain
+************************************************************/
+void mpp_global_field_double(domain2D domain, int sizex, int sizey, const double* ldata, double* gdata)
+{
+  double *send_buffer=NULL, *recv_buffer=NULL;
+  int i, j, n, ni, nj, ii, jj, l, p, recv_size;
+  int ishift, jshift, nxc, nyc, nxd, nyd, nxg;
+  int is, ie, js, je, isd, jsd;
+  
+  mpp_get_shift( domain, sizex, sizey, &ishift, &jshift);
+  is = domain.isc;
+  ie = domain.iec + ishift;
+  js = domain.jsc;
+  je = domain.jec + jshift;
+  
+  nxc = ie-is+1;
+  nyc = je-js+1;
+  isd = domain.isd;
+  jsd = domain.jsd;
+  nxd = domain.nxd + ishift;
+  nyd = domain.nyd + jshift;
+  nxg = domain.nxg + ishift;
+  
+  /* all other pe except root pe will send data to root pe */
+  if( pe != root_pe) {
+    if( sizex == nxc && sizey == nyc ){ /* data is on compute domain */
+      mpp_send_double(ldata, sizex*sizey, root_pe);
+    }
+    else if( sizex == nxd && sizey == nyd  ){ /* data is on data domain */
+      send_buffer = (double *)malloc(nxc*nyc*sizeof(double));
+      n = 0;
+      for(j=js;j<=je;j++) {
+	for(i=is;i<=ie;i++) send_buffer[n++] = ldata[(j-jsd)*nxd+(i-isd)];
+      }
+      mpp_send_double(send_buffer, nxc*nyc, root_pe);
+    }
+    else
+      mpp_error("mpp_domain: data should be on compute/data domain");
+  }
+
+  /* receive from other pe on root pe   */
+  if( pe == root_pe ) {
+    for(p=0;p<npes;p++) {
+      if( p == root_pe) {
+	if( sizex == nxc && sizey == nyc  ){ /* data is on compute domain */
+	  n = 0;
+	  for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[j*nxg+i] = ldata[n++];
+	  }
+	}
+	else {
+	  for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[j*nxg+i] = ldata[(j-jsd)*nxd+(i-isd)];
+	  }
+	}
+      }
+      else {
+	recv_size = (domain.ieclist[p]-domain.isclist[p]+1+ishift)*(domain.jeclist[p]-domain.jsclist[p]+1+jshift);
+	recv_buffer = ( double *) malloc(recv_size*sizeof(double));
+	mpp_recv_double(recv_buffer, recv_size, p );
+	n = 0;
+	for(j=domain.jsclist[p]; j<=domain.jeclist[p]+jshift; j++){
+	  for(i=domain.isclist[p]; i<=domain.ieclist[p]+ishift; i++){
+	    gdata[j*nxg+i] = recv_buffer[n++];
+	  }
+	}
+	free(recv_buffer);
+      }
+    }
+  }
+
+  mpp_sync_self();
+  
+  if(send_buffer != NULL) free(send_buffer);
+}; /* mpp_global_field_double */
+
+/*************************************************************
+    mpp_global_field_int(domain2D domain, int sizex, int sizey, const int *ldata, int *gdata)
+    get the global data on root pe.
+    ldata is on compute domain and gdata is on global domain
+************************************************************/
+void mpp_global_field_int(domain2D domain, int sizex, int sizey, const int* ldata, int* gdata)
+{
+  int *send_buffer=NULL, *recv_buffer=NULL;
+  int i, j, n, ni, nj, ii, jj, l, p, recv_size;
+  int ishift, jshift, nxc, nyc, nxd, nyd, nxg;
+  int is, ie, js, je, isd, jsd;
+  
+  mpp_get_shift( domain, sizex, sizey, &ishift, &jshift);
+  is = domain.isc;
+  ie = domain.iec + ishift;
+  js = domain.jsc;
+  je = domain.jec + jshift;
+  
+  nxc = ie-is+1;
+  nyc = je-js+1;
+  isd = domain.isd;
+  jsd = domain.jsd;
+  nxd = domain.nxd + ishift;
+  nyd = domain.nyd + jshift;
+  nxg = domain.nxg + ishift;
+  
+  /* all other pe except root pe will send data to root pe */
+  if( pe != root_pe) {
+    if( sizex == nxc && sizey == nyc ){ /* data is on compute domain */
+      mpp_send_int(ldata, sizex*sizey, root_pe);
+    }
+    else if( sizex == nxd && sizey == nyd  ){ /* data is on data domain */
+      send_buffer = (int *)malloc(nxc*nyc*sizeof(int));
+      n = 0;
+      for(j=js;j<=je;j++) {
+	for(i=is;i<=ie;i++) send_buffer[n++] = ldata[(j-jsd)*nxd+(i-isd)];
+      }
+      mpp_send_int(send_buffer, nxc*nyc, root_pe);
+    }
+    else
+      mpp_error("mpp_domain: data should be on compute/data domain");
+  }
+
+  /* receive from other pe on root pe   */
+  if( pe == root_pe ) {
+    for(p=0;p<npes;p++) {
+      if( p == root_pe) {
+	if( sizex == nxc && sizey == nyc  ){ /* data is on compute domain */
+	  n = 0;
+	  for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[j*nxg+i] = ldata[n++];
+	  }
+	}
+	else {
+	  for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[j*nxg+i] = ldata[(j-jsd)*nxd+(i-isd)];
+	  }
+	}
+      }
+      else {
+	recv_size = (domain.ieclist[p]-domain.isclist[p]+1+ishift)*(domain.jeclist[p]-domain.jsclist[p]+1+jshift);
+	recv_buffer = ( int *) malloc(recv_size*sizeof(int));
+	mpp_recv_int(recv_buffer, recv_size, p );
+	n = 0;
+	for(j=domain.jsclist[p]; j<=domain.jeclist[p]+jshift; j++){
+	  for(i=domain.isclist[p]; i<=domain.ieclist[p]+ishift; i++){
+	    gdata[j*nxg+i] = recv_buffer[n++];
+	  }
+	}
+	free(recv_buffer);
+      }
+    }
+  }
+
+  mpp_sync_self();
+  
+  if(send_buffer != NULL) free(send_buffer);
+}; /* mpp_global_field_int */
+
+/*************************************************************
+    mpp_global_field_double_3D(domain2D domain, int sizex, int sizey, int sizez,
+                               const double *ldata, double *gdata)
+    get the global data on root pe.
+    ldata is on compute domain and gdata is on global domain
+************************************************************/
+void mpp_global_field_double_3D(domain2D domain, int sizex, int sizey, int sizez,
+				const double* ldata, double* gdata)
+{
+  double *send_buffer=NULL, *recv_buffer=NULL;
+  int i, j, k, n, ni, nj, ii, jj, l, p, recv_size;
+  int ishift, jshift, nxc, nyc, nxd, nyd, nxg, nyg;
+  int is, ie, js, je, isd, jsd;
+  int send_size;  
+
+  mpp_get_shift( domain, sizex, sizey, &ishift, &jshift);
+  is = domain.isc;
+  ie = domain.iec + ishift;
+  js = domain.jsc;
+  je = domain.jec + jshift;
+  
+  nxc = ie-is+1;
+  nyc = je-js+1;
+  isd = domain.isd;
+  jsd = domain.jsd;
+  nxd = domain.nxd + ishift;
+  nyd = domain.nyd + jshift;
+  nxg = domain.nxg + ishift;
+  nyg = domain.nyg + ishift;
+
+  /* all other pe except root pe will send data to root pe */
+  send_size = nxc*nyc*sizez;
+  if( pe != root_pe) {
+    if( sizex == nxc && sizey == nyc ){ /* data is on compute domain */
+      mpp_send_double(ldata, sizex*sizey*sizez, root_pe);
+    }
+    else if( sizex == nxd && sizey == nyd  ){ /* data is on data domain */
+      if( send_size > MAX_BUFFER_SIZE) {
+         send_buffer = (double *)malloc(send_size*sizeof(double));
+      }
+      else {
+         send_buffer = sBuffer;
+      }
+      n = 0;
+      for(k=0; k<sizez; k++) for(j=js;j<=je;j++) {
+	for(i=is;i<=ie;i++) send_buffer[n++] = ldata[k*nxd*nyd+(j-jsd)*nxd+(i-isd)];
+      }
+      mpp_send_double(send_buffer, send_size, root_pe);
+    }
+    else
+      mpp_error("mpp_domain: data should be on compute/data domain");
+  }
+  /* receive from other pe on root pe   */
+  if( pe == root_pe ) {
+    for(p=0;p<npes;p++) {
+      if( p == root_pe) {
+	if( sizex == nxc && sizey == nyc  ){ /* data is on compute domain */
+	  n = 0;
+	  for(k=0;k<sizez;k++) for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[k*nxg*nyg+j*nxg+i] = ldata[n++];
+	  }
+	}
+	else {
+	  for(k=0;k<sizez;k++) for(j=js;j<=je;j++) {
+	    for(i=is;i<=ie;i++) gdata[k*nxg*nyg+j*nxg+i] = ldata[k*nxd*nyd+(j-jsd)*nxd+(i-isd)];
+	  }
+	}
+      }
+      else {
+	recv_size = (domain.ieclist[p]-domain.isclist[p]+1+ishift)
+	  *(domain.jeclist[p]-domain.jsclist[p]+1+jshift)*sizez;
+        if(recv_size>MAX_BUFFER_SIZE){
+	   recv_buffer = ( double *) malloc(recv_size*sizeof(double));
+        }
+        else {
+           recv_buffer = rBuffer;
+        }
+	mpp_recv_double(recv_buffer, recv_size, p );
+	n = 0;
+	for(k=0;k<sizez;k++) {
+	  for(j=domain.jsclist[p]; j<=domain.jeclist[p]+jshift; j++){
+	    for(i=domain.isclist[p]; i<=domain.ieclist[p]+ishift; i++){
+	      gdata[k*nxg*nyg+j*nxg+i] = recv_buffer[n++];
+	    }
+	  }
+	}
+        if(recv_size>MAX_BUFFER_SIZE)
+	   free(recv_buffer);
+        else
+           recv_buffer=NULL;
+      }
+    }
+  }
+  mpp_sync_self();
+/*z1l: mpp_sync is needed when running on multiple processor job. Otherwisde the memory
+usage will increase. For example, remap_land will fail when running on 270 processors */
+  mpp_sync();
+
+  if(send_buffer != NULL) {
+     if(send_size>MAX_BUFFER_SIZE)
+        free(send_buffer);
+     else
+        send_buffer = NULL;
+  }
+}; /* mpp_global_field_double */
+
+/*******************************************************************************
+  void mpp_gather_field_int(int lsize, int *ldata, int *gdata)
+  gather integer data onto every processor
+*******************************************************************************/
+void mpp_gather_field_int(int lsize, int *ldata, int *gdata)
+{
+  int n, p, i;
+  int *rbuffer=NULL;
+  int *rsize=NULL;
+
+  rsize = (int *)malloc(npes*sizeof(int));
+
+  
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* send to other pe. */
+      mpp_send_int(&lsize, 1, p);
+    }
+  }
+
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* recv from other pe. */
+      mpp_recv_int(rsize+p, 1, p);
+    }
+  }
+
+  mpp_sync_self();
+
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* send to other pe. */
+      if(lsize>0) mpp_send_int(ldata, lsize, p);
+    }
+  }  
+  n = 0;
+  /* receive from other pe and fill the gdata */
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* recv from other pe. */
+      if(rsize[p]>0) {
+	rbuffer = ( int *) malloc(rsize[p]*sizeof(int));
+	mpp_recv_int(rbuffer, rsize[p], p );
+	for(i=0; i<rsize[p]; i++) gdata[n++] = rbuffer[i];
+	free(rbuffer);
+      }
+    }
+    else {
+      for(i=0; i<lsize; i++) gdata[n++] = ldata[i];
+    }
+  }
+
+  mpp_sync_self();
+  free(rsize);
+  
+}; /* mpp_gather_field_int */
+
+/*******************************************************************************
+  void mpp_gather_field_int_root(int lsize, int *ldata, int *gdata)
+  gather integer data onto root processor
+*******************************************************************************/
+void mpp_gather_field_int_root(int lsize, int *ldata, int *gdata)
+{
+  int n, p, i;
+  int *rbuffer=NULL;
+  int *rsize=NULL;
+
+  rsize = (int *)malloc(npes*sizeof(int));
+  
+  /* all other pe except root pe will send data to root pe */
+  if( pe != root_pe) {
+      mpp_send_int(&lsize, 1, root_pe);
+  }
+
+  else {
+    for(p = 0; p<npes; p++) {
+       if(root_pe != p) mpp_recv_int(rsize+p, 1, p);
+    }
+  }
+
+  mpp_sync_self();
+
+  if( pe != root_pe) {
+      if(lsize>0) mpp_send_int(ldata, lsize, root_pe);
+  }  
+  else {
+    int cur_size;
+    n = 0;
+    cur_size = 0;
+    /* receive from other pe and fill the gdata */
+    for(p = 0; p<npes; p++) {
+      if(root_pe != p) { /* recv from other pe. */
+	if(rsize[p]>0) {
+	  if( rsize[p] > cur_size ) {
+	    if( rbuffer ) free(rbuffer);
+	    rbuffer = ( int *) malloc(rsize[p]*sizeof(int));
+	    cur_size = rsize[p];
+	  }
+	  mpp_recv_int(rbuffer, rsize[p], p );
+	  for(i=0; i<rsize[p]; i++) gdata[n++] = rbuffer[i];
+	}
+      }
+      else {
+	for(i=0; i<lsize; i++) gdata[n++] = ldata[i];
+      }
+    }
+    if(rbuffer) free(rbuffer);
+  }
+
+  mpp_sync_self();
+  free(rsize);
+  
+}; /* mpp_gather_field_int_root */
+
+
+/*******************************************************************************
+  void mpp_gather_field_double_root(int lsize, double *ldata, double *gdata)
+  gather double data onto root processor
+*******************************************************************************/
+void mpp_gather_field_double_root(int lsize, double *ldata, double *gdata)
+{
+  int n, p, i;
+  double *rbuffer=NULL;
+  int *rsize=NULL;
+
+  rsize = (int *)malloc(npes*sizeof(int));
+  
+  /* all other pe except root pe will send data to root pe */
+  if( pe != root_pe) {
+      mpp_send_int(&lsize, 1, root_pe);
+  }
+
+  else {
+    for(p = 0; p<npes; p++) {
+       if(root_pe != p) mpp_recv_int(rsize+p, 1, p);
+    }
+  }
+
+  mpp_sync_self();
+
+  if( pe != root_pe) {
+      if(lsize>0) mpp_send_double(ldata, lsize, root_pe);
+  }  
+  else {
+    int cur_size;
+    n = 0;
+    cur_size = 0;
+    /* receive from other pe and fill the gdata */
+    for(p = 0; p<npes; p++) {
+      if(root_pe != p) { /* recv from other pe. */
+	if(rsize[p]>0) {
+	  if( rsize[p] > cur_size ) {
+	    if( rbuffer ) free(rbuffer);
+	    rbuffer = ( double *) malloc(rsize[p]*sizeof(double));
+	    cur_size = rsize[p];
+	  }
+	  mpp_recv_double(rbuffer, rsize[p], p );
+	  for(i=0; i<rsize[p]; i++) gdata[n++] = rbuffer[i];
+	}
+      }
+      else {
+	for(i=0; i<lsize; i++) gdata[n++] = ldata[i];
+      }
+    }
+    if(rbuffer) free(rbuffer);
+  }
+
+  mpp_sync_self();
+  free(rsize);
+  
+}; /* mpp_gather_field_double_root */
+
+
+/*******************************************************************************
+  void mpp_gather_field_double(int lsize, double *ldata, double *gdata)
+  gather doubleeger data onto every processor
+*******************************************************************************/
+void mpp_gather_field_double(int lsize, double *ldata, double *gdata)
+{
+  int n, p, i;
+  double*rbuffer=NULL;
+  int *rsize=NULL;
+
+  rsize = (int *)malloc(npes*sizeof(int));
+  
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* send to other pe. */
+      mpp_send_int(&lsize, 1, p);
+    }
+  }
+
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* recv from other pe. */
+      mpp_recv_int(rsize+p, 1, p);
+    }
+  }
+
+  mpp_sync_self();
+
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* send to other pe. */
+      if(lsize>0) mpp_send_double(ldata, lsize, p);
+    }
+  }  
+  n = 0;
+  /* receive from other pe and fill the gdata */
+  for(p = 0; p<npes; p++) {
+    if(pe != p) { /* recv from other pe. */
+      if(rsize[p]>0) {
+	rbuffer = (double *) malloc(rsize[p]*sizeof(double));
+	mpp_recv_double(rbuffer, rsize[p], p );
+	for(i=0; i<rsize[p]; i++) gdata[n++] = rbuffer[i];
+	free(rbuffer);
+      }
+    }
+    else {
+      for(i=0; i<lsize; i++) gdata[n++] = ldata[i];
+    }
+  }
+
+  mpp_sync_self();
+  free(rsize);
+  
+}; /* mpp_gather_field_double*/
+
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp_domain.h b/sorc/fre-nctools.fd/shared_lib/mpp_domain.h
new file mode 100644
index 0000000..7255408
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp_domain.h
@@ -0,0 +1,54 @@
+/****************************************************************
+                        mpp_domain.h 
+   This headers define interface to define domain layout, 
+   define domain decomposition and global field to root pe, 
+   some utilities routine to return domain decomposition.
+   Currently it only used in tools and assume only one domain is created. 
+   If more domains are needed, we may define a struct to hold domain informaiton.
+   contact: Zhi.Liang@noaa.gov
+
+****************************************************************/
+#ifndef MPP_DOMAIN_H_
+#define MPP_DOMAIN_H_
+#define max(a,b) (a>b ? a:b)
+typedef struct{
+  int start, end;           /* starting and ending index of compute domain */
+  int size;                 /* compute domain size */
+  int sizeg;                /* global domain size */
+  int *beglist, *endlist; /* list of starting and ending index of compute domain */
+} domain1D;
+
+typedef struct {
+  int isc, iec, jsc, jec;   /* compute domain decomposition */
+  int isd, ied, jsd, jed;   /* data    domain decomposition */
+  int nxc, nyc;             /* compute domain size */
+  int nxd, nyd;             /* data    domain size */
+  int nxg, nyg;             /* global  domain size */
+  int *isclist, *ieclist;   /* list of i-index of compute domain */
+  int *jsclist, *jeclist;   /* list of j-index of compute domain */
+  int xhalo, yhalo;         /* halo size */
+} domain2D;
+
+void mpp_domain_init();
+void mpp_domain_end();
+void mpp_define_layout(int ni, int nj, int ndivs, int layout[]);
+void mpp_compute_extent(int npts, int ndivs, int *ibegin, int *iend);
+void mpp_define_domain1d(int npts, int ndvis, domain1D *domain );
+void mpp_define_domain2d(int ni, int nj, int layout[], int xhalo, int yhalo, domain2D *domain );
+void mpp_delete_domain1d(domain1D *domain);
+void mpp_delete_domain2d(domain2D *domain);
+void mpp_get_compute_domain2d(domain2D domain, int *is, int *ie, int *js, int *je);
+void mpp_get_data_domain2d(domain2D domain, int *is, int *ie, int *js, int *je);
+void mpp_get_global_domain2d(domain2D domain,  int *nx, int *ny);
+void mpp_get_compute_domains2d(domain2D domain, int *is, int *ie, int *js, int *je);
+void mpp_get_shift(domain2D domain, int sizex, int sizey, int *ishift, int *jshift);
+void mpp_global_field_double(domain2D domain, int sizex, int sizey, const double* ldata, double* gdata);
+void mpp_global_field_int(domain2D domain, int sizex, int sizey, const int* ldata, int* gdata);
+void mpp_global_field_double_3D(domain2D domain, int sizex, int sizey, int sizez,
+				const double* ldata, double* gdata);
+void mpp_global_field_all_double(domain2D domain, int sizex, int sizey, const double* ldata, double* gdata);
+void mpp_gather_field_int(int lsize, int *ldata, int *gdata);
+void mpp_gather_field_double(int lsize, double *ldata, double *gdata);
+void mpp_gather_field_double_root(int lsize, double *ldata, double *gdata);
+void mpp_gather_field_int_root(int lsize, int *ldata, int *gdata);
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp_io.c b/sorc/fre-nctools.fd/shared_lib/mpp_io.c
new file mode 100644
index 0000000..5e6307e
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp_io.c
@@ -0,0 +1,1316 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <netcdf.h>
+#include "mpp.h"
+#include "mpp_domain.h"
+#include "mpp_io.h"
+
+#define  MAXFILE 200
+#define  MAXVAR  1024
+#define  STRING 255
+
+typedef struct {
+  int fldid;
+  char name[128];
+  nc_type type;
+} VarType;
+
+typedef struct {
+  int  ncid;
+  char name[512];
+  int  action;  /* indicate the action, MPP_WRITE or MPP_READ */
+  int  status;  /* indicate if the file is opened or closed */
+  int  nvar;
+  VarType *var;
+} FileType;
+
+FileType files[MAXFILE];
+int      nfiles = 0;
+
+int      in_format = NC_FORMAT_NETCDF4_CLASSIC;
+
+/*********************************************************************
+    void netcdf_error( int status )
+    status is the returning value of netcdf call. this routine will
+    handle the error when status is not NC_NOERR.
+********************************************************************/
+void netcdf_error(const char *msg, int status )
+{
+  char errmsg[512];
+
+  sprintf( errmsg, "%s: %s", msg, nc_strerror(status) );
+  mpp_error(errmsg);
+
+}; /* netcdf_error */
+
+
+/*************************************************************
+ int mpp_open(char *filename, int action)
+ open netcdf file to read or write. return the id for the file opened.
+ Here the id is not the netcdf ncid of the file opened, it is the index
+ in the mpp_io data files. If the file is already opened, will exit with
+ an error message. For the write action, mpp_open can only be called once.
+ For the read action, the file could be open and then close and then open
+ again. The action should be MPP_READ, MPP_WRITE, a constant defined in
+ mpp_io.h. When action is MPP_WRITE, file will be created on root pe.
+************************************************************/
+
+int mpp_open(const char *file, int action) {
+  char curfile[STRING];
+  char errmsg[512];  
+  int ncid, status, istat, n, fid;
+/* size_t blksz=65536; */
+  size_t blksz=1048576;
+  
+  /* write only from root pe. */
+  if(action != MPP_READ && mpp_pe() != mpp_root_pe() ) return -1;
+  /*if file is not ended with .nc add .nc at the end. */
+  strcpy(curfile, file);
+  if(strstr(curfile, ".nc") == NULL) strcat(curfile,".nc");
+
+  /* look through currently files to make sure the file is not in the list*/
+  fid = -1;
+  for(n=0; n<nfiles; n++) {
+    if(!strcmp(files[n].name, file) && files[n].action == action) {
+      fid = n;
+      break;
+    }
+  }
+  if(fid > -1) {
+    if(files[n].action == MPP_WRITE) {
+      sprintf( errmsg, "mpp_io(mpp_open): %s is already created for write", file);
+      mpp_error(errmsg);
+    }
+    if(files[n].status) {
+      sprintf( errmsg, "mpp_io(mpp_open): %s is already opened", file);
+      mpp_error(errmsg);
+    }
+  }
+  else {
+    fid = nfiles;
+    nfiles++;
+    if(nfiles > MAXFILE) mpp_error("mpp_io(mpp_open): nfiles is larger than MAXFILE, increase MAXFILE");
+    strcpy(files[fid].name, file);
+    files[fid].nvar = 0;
+    files[fid].var = (VarType *)malloc(MAXVAR*sizeof(VarType));
+  }
+  switch (action) {
+  case MPP_WRITE:
+#ifdef use_netCDF3
+#ifdef NC_64BIT_OFFSET
+    status = nc_create(curfile, NC_64BIT_OFFSET, &ncid);
+#else
+    status = nc_create(curfile, NC_WRITE, &ncid);
+#endif
+#elif use_netCDF4
+       status = nc__create(curfile, NC_NETCDF4, 0, &blksz, &ncid);
+#else
+    switch (in_format) {
+      case NC_FORMAT_NETCDF4:
+        status = nc__create(curfile, NC_NETCDF4, 0, &blksz, &ncid);
+        break;
+      case NC_FORMAT_NETCDF4_CLASSIC:
+        status = nc__create(curfile, NC_NETCDF4 | NC_CLASSIC_MODEL, 0, &blksz, &ncid);
+        break;
+      case NC_FORMAT_64BIT:
+        status = nc__create(curfile, NC_CLOBBER | NC_64BIT_OFFSET, 0, &blksz, &ncid);
+        break;
+      case NC_FORMAT_CLASSIC:
+        status = nc__create(curfile, NC_CLOBBER | NC_CLASSIC_MODEL, 0, &blksz, &ncid);
+        break;
+      default:
+        sprintf(errmsg, "mpp_io(mpp_open): Unknown netCDF format");
+        mpp_error(errmsg);
+    }
+#endif
+    break;
+  case MPP_APPEND:
+    status = nc_open(curfile, NC_WRITE, &ncid);
+    break;
+  case MPP_READ:
+    status = nc_open(curfile,NC_NOWRITE, &ncid);
+#ifndef use_netCDF3
+    istat = nc_inq_format(ncid,&in_format);
+#endif
+    break;
+  default:
+    sprintf(errmsg, "mpp_io(mpp_open): the action should be MPP_WRITE or MPP_READ when opening file %s", file);
+    mpp_error(errmsg);
+  }
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_open): error in opening file %s", file);
+    netcdf_error(errmsg, status);
+  }
+
+  files[fid].ncid   = ncid;
+  files[fid].status = 1;
+  files[fid].action = action;
+  
+  return fid;
+}
+
+/* close the file */
+void mpp_close(int fid)
+{
+  int status;
+  char errmsg[512];
+
+  if(fid == -1 && mpp_pe() != mpp_root_pe() ) return;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_close): invalid id number, id should be "
+				    "a nonnegative integer that less than nfiles");
+  
+  status = nc_close(files[fid].ncid);
+  if(status != NC_NOERR) {
+    sprintf( errmsg, "mpp_io(mpp_close): error in closing files %s ", files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+  files[fid].ncid = 0;
+  files[fid].status = 0;
+  
+}
+
+
+int mpp_get_nvars(int fid)
+{
+  int nvars, status;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_nvars): invalid id number, id should be "
+				    "a nonnegative integer that less than nfiles"); 
+  status = nc_inq_nvars(files[fid].ncid, &nvars);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_nvars): error in get nvars from file %s", files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+
+  return nvars;
+}
+
+void mpp_get_varname(int fid, int varid, char *name)
+{
+
+  int  status;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_varname): invalid id number, id should be "
+				    "a nonnegative integer that less than nfiles"); 
+  status = nc_inq_varname(files[fid].ncid, varid, name);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_varname): error in get varname from file %s", files[fid].name);
+    netcdf_error(errmsg, status);
+  }  
+ 
+}
+  
+/*******************************************************************************/
+/*                                                                             */
+/*           The following are routines that retrieve information              */
+/*                                                                             */
+/*******************************************************************************/
+
+/*********************************************************************
+  int mpp_get_dimid(int fid, const char *dimname)
+  get the id of the dimname from file with fid, 
+*********************************************************************/
+int mpp_get_dimid(int fid, const char *dimname)
+{
+  int status, dimid;
+  char errmsg[512];
+  
+  /* First look through existing variables to see
+     if the fldid of varname is already retrieved. */
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_dimid): invalid id number, id should be "
+				    "a nonnegative integer that less than nfiles");
+  
+  status =  nc_inq_dimid(files[fid].ncid, dimname, &dimid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_dimid): error in get dimension id of %s from file %s", dimname, files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+
+  return dimid;
+
+};/* mpp_get_dimid */
+
+
+/*********************************************************************
+  int mpp_get_varid(int fid, const char *varname)
+  get the id of the varname from file with fid, the id will be the index
+  in files[fid].var.
+*********************************************************************/
+int mpp_get_varid(int fid, const char *varname)
+{
+  int status, fldid, vid, n;
+  char errmsg[512];
+  
+  /* First look through existing variables to see
+     if the fldid of varname is already retrieved. */
+  if(files[fid].action != MPP_READ  && mpp_pe() != mpp_root_pe() ) return -1;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_varid): invalid id number, id should be "
+				    "a nonnegative integer that less than nfiles");
+  
+  for(n=0; n<files[fid].nvar; n++) {
+    if( !strcmp(files[fid].var[n].name, varname) ) return n;
+  }
+
+  vid = files[fid].nvar;
+  files[fid].nvar++;
+  if(files[fid].nvar > MAXVAR ) mpp_error("mpp_io(mpp_get_varid): nvar is larger than MAXVAR, increase MAXVAR");
+  
+  status =  nc_inq_varid(files[fid].ncid, varname, &fldid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_varid): error in get field_id of variable %s from file %s", varname, files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+
+  status = nc_inq_vartype(files[fid].ncid, fldid, &(files[fid].var[vid].type));
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_varid): Error in getting type of of field %s in file %s ",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+  files[fid].var[vid].fldid = fldid;
+  strcpy(files[fid].var[vid].name, varname);
+  return vid;
+
+};/* mpp_get_varid */
+
+/********************************************************************
+  int mpp_get_dimlen(char* file, char *name)
+  Get the dimension.
+ *******************************************************************/
+int mpp_get_dimlen(int fid, const char *name)
+{
+  int ncid, dimid, status, len;
+  size_t size;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_dimlen): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  ncid = files[fid].ncid;
+  status = nc_inq_dimid(ncid, name, &dimid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_dimlen): error in inquiring dimid of %s from file %s", name, files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+  status = nc_inq_dimlen(ncid, dimid, &size);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_dimlen): error in inquiring dimlen of %s from file %s", name, files[fid].name);
+    netcdf_error(errmsg, status);
+  }
+  len = size;
+  return len;
+  
+}; /* mpp_get_dimlen */
+
+/*********************************************************************
+  void mpp_get_var_value(int fid, int vid, void *data)
+  read part of var data, the part is defined by start and nread.
+*********************************************************************/
+void mpp_get_var_value(int fid, int vid, void *data)
+{
+  int status;
+  int *data_i4;
+  short *data_i2;
+  float *data_r4;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_value_block): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_value_block): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  switch(files[fid].var[vid].type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_get_var_double(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;
+  case NC_INT:
+    status = nc_get_var_int(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;
+  case NC_SHORT:
+    status = nc_get_var_short(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;    
+  case NC_CHAR:
+    status = nc_get_var_text(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break; 
+  default:
+    sprintf(errmsg, "mpp_io(mpp_get_var_value): field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }    
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_value): Error in getting value of variable %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_get_var_value */
+
+/*********************************************************************
+  void mpp_get_var_value_block(int fid, int vid, const size_t *start, const size_t *nread, void *data)
+  read part of var data, the part is defined by start and nread.
+*********************************************************************/
+void mpp_get_var_value_block(int fid, int vid, const size_t *start, const size_t *nread, void *data)
+{
+  int status;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_value_block): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_value_block): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  switch(files[fid].var[vid].type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_get_vara_double(files[fid].ncid, files[fid].var[vid].fldid, start, nread, data);
+    break;
+  case NC_INT:
+    status = nc_get_vara_int(files[fid].ncid, files[fid].var[vid].fldid, start, nread, data);
+    break;
+  case NC_SHORT:
+    status = nc_get_vara_short(files[fid].ncid, files[fid].var[vid].fldid, start, nread, data);
+    break;  
+  case NC_CHAR:
+    status = nc_get_vara_text(files[fid].ncid, files[fid].var[vid].fldid, start, nread, data);
+    break; 
+  default:
+    sprintf(errmsg, "mpp_io(mpp_get_var_value_block): field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }    
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_value_block): Error in getting value of variable %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_get_var_value_block */
+
+/*******************************************************************
+ void mpp_get_var_att(int fid, int vid, const char *name, void *val)
+ get the attribute value of vid from file fid.
+ ******************************************************************/
+void mpp_get_var_att(int fid, int vid, const char *name, void *val)
+{
+  int status;
+  char errmsg[512];
+  nc_type type;
+
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_att): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_att): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  status = nc_inq_atttype(files[fid].ncid, files[fid].var[vid].fldid, name, &type);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): Error in getting type of attribute %s of field %s in file %s ",
+	    name, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+  switch(type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_get_att_double(files[fid].ncid, files[fid].var[vid].fldid, name, val);
+    break;
+  case NC_INT:
+    status = nc_get_att_int(files[fid].ncid, files[fid].var[vid].fldid, name, val);
+    break;      
+  case NC_SHORT:
+    status = nc_get_att_short(files[fid].ncid, files[fid].var[vid].fldid, name, val);
+    break;
+  case NC_CHAR:
+    status = nc_get_att_text(files[fid].ncid, files[fid].var[vid].fldid, name, val);
+    break;    
+  default:
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): attribute %s of field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    name, files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): Error in getting value of attribute %s of variable %s from file %s",
+	    name, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+}
+
+/*******************************************************************
+ void mpp_get_var_att_double(int fid, int vid, const char *name, double *val)
+ get the attribute value of vid from file fid.
+ ******************************************************************/
+void mpp_get_var_att_double(int fid, int vid, const char *name, double *val)
+{
+  int status;
+  char errmsg[512];
+  nc_type type;
+  short sval;
+  int   ival;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_att): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_att): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  status = nc_inq_atttype(files[fid].ncid, files[fid].var[vid].fldid, name, &type);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): Error in getting type of attribute %s of field %s in file %s ",
+	    name, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+  switch(type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_get_att_double(files[fid].ncid, files[fid].var[vid].fldid, name, val);
+    break;
+  case NC_INT:
+    status = nc_get_att_int(files[fid].ncid, files[fid].var[vid].fldid, name, &ival);
+    *val = ival;
+    break;      
+  case NC_SHORT:
+    status = nc_get_att_short(files[fid].ncid, files[fid].var[vid].fldid, name, &sval);
+    *val = sval;
+    break;
+  default:
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): attribute %s of field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    name, files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_att): Error in getting value of attribute %s of variable %s from file %s",
+	    name, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+}
+
+/*******************************************************************
+ void mpp_get_global_att(int fid, const char *name, void *val)
+ get the global attribute from file fid.
+ ******************************************************************/
+void mpp_get_global_att(int fid, const char *name, void *val)
+{
+  int status;
+  char errmsg[512], attval[4096];
+  nc_type type;
+  size_t attlen;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_global_att): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  status = nc_inq_atttype(files[fid].ncid, NC_GLOBAL, name, &type);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_global_att): Error in getting type of global attribute %s in file %s ",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+  
+  switch(type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_get_att_double(files[fid].ncid, NC_GLOBAL, name, val);
+    break;
+  case NC_INT:
+    status = nc_get_att_int(files[fid].ncid, NC_GLOBAL, name, val);
+    break;
+  case NC_SHORT:
+    status = nc_get_att_short(files[fid].ncid, NC_GLOBAL, name, val);
+    break;  
+  case NC_CHAR:
+    status = nc_inq_attlen(files[fid].ncid, NC_GLOBAL, name, &attlen);
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_get_global_att): Error in getting length of global attribute %s from file %s",
+	      name, files[fid].name );
+      netcdf_error(errmsg, status);
+    }
+    status = nc_get_att_text(files[fid].ncid, NC_GLOBAL, name, attval);
+    attval[attlen] = '\0';
+    strncpy(val, attval, attlen+1);
+    break;  
+  default:
+    sprintf(errmsg, "mpp_io(mpp_get_global_att): global attribute %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR", name, files[fid].name );
+    mpp_error(errmsg);
+  }
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_global_att): Error in getting value of global attribute %s from file %s",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+}
+
+/********************************************************************
+  int mpp_get_var_ndim(int fid, int vid)
+********************************************************************/
+int mpp_get_var_ndim(int fid, int vid)
+{
+  int status, ndim;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_ndim): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_ndim): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  
+  status = nc_inq_varndims(files[fid].ncid, files[fid].var[vid].fldid, &ndim);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_ndim): Error in getting ndims of var %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+  return ndim;
+}
+
+/********************************************************************
+  nc_type mpp_get_var_type(int fid, int vid)
+  get var type
+********************************************************************/
+nc_type mpp_get_var_type(int fid, int vid)
+{
+  char errmsg[512];
+  
+  nc_type vartype;
+  int status;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_ndim): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_ndim): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  
+  status = nc_inq_vartype(files[fid].ncid, files[fid].var[vid].fldid, &vartype);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_type): Error in getting type of var %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+  return vartype;
+}
+
+
+/*********************************************************************
+void mpp_get_var_dimname(int fid, int vid, int i, char *name)
+For each dimension we are assuming there is a 1-d field have the same name as the dimension.
+*********************************************************************/
+void mpp_get_var_dimname(int fid, int vid, int ind, char *name)
+{
+  int status, ncid, fldid, ndims, dims[4];
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_dimname): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_dimname): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  ncid = files[fid].ncid;
+  fldid = files[fid].var[vid].fldid;
+  
+  status = nc_inq_varndims(ncid, fldid, &ndims);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var2D_dimname): Error in getting ndims of var %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+  if(ind < 0 || ind >= ndims) mpp_error("mpp_io(mpp_get_var_dimname): invalid ind value, ind should be between 0 and ndim-1");
+  
+  status = nc_inq_vardimid(ncid,fldid,dims);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var2D_dimname): Error in getting dimid of var %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  status = nc_inq_dimname(ncid, dims[ind], name);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var2D_dimname): Error in getting %d dimension name of var %s from file %s",
+	    ind, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+}; /* mpp_get_var_dimname */
+
+
+/***************************************************************************
+  char mpp_get_var_cart(int fid, int vid)
+  get the cart of the dimension variable
+  *************************************************************************/
+char mpp_get_var_cart(int fid, int vid)
+{
+  char cart;
+  int ncid, fldid, status;
+  char errmsg[512];
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_cart): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles"); 
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_cart): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  cart = 'N';
+
+  ncid = files[fid].ncid;
+  fldid = files[fid].var[vid].fldid;
+  status = nc_get_att_text(ncid, fldid, "cartesian_axis", &cart);
+  if(status != NC_NOERR)status = nc_get_att_text(ncid, fldid, "axis", &cart);
+  if(status != NC_NOERR){
+    sprintf(errmsg, "mpp_io(mpp_get_var_cart): Error in getting attribute cartesian_axis/axis of "
+	    "dimension variable %s from file %s", files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+    
+  return cart;
+}
+
+/***************************************************************************
+ void mpp_get_var_bndname(int fid, int vid, char *bndname)
+ Get the bound name of dimension variable if it exist, otherwise the value will be 'none'
+ for time axis, the bounds may be 'climatology' 
+ **************************************************************************/
+void mpp_get_var_bndname(int fid, int vid, char *bndname)
+{
+  int ncid, fldid, status;
+  char errmsg[512], name[32];
+  size_t siz;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_cart): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles"); 
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_get_var_cart): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  ncid = files[fid].ncid;
+  fldid = files[fid].var[vid].fldid;  
+  strcpy(name, "climatology");
+  status = nc_inq_attlen(ncid, fldid, name, &siz);
+  if(status != NC_NOERR){
+    strcpy(name, "bounds");
+    status = nc_inq_attlen(ncid, fldid, name, &siz);
+  }
+  if(status != NC_NOERR){
+    strcpy(name, "edges");
+    status = nc_inq_attlen(ncid, fldid, name, &siz);
+  }
+  if(status != NC_NOERR) {
+    strcpy(bndname, "none");
+  }
+  else {
+    status = nc_get_att_text(ncid, fldid, name, bndname);
+    bndname[siz] = '\0';
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_get_var_bndname): Error in getting attribute %s of "
+	      "dimension variable %s from file %s", name, files[fid].var[vid].name, files[fid].name );
+      netcdf_error(errmsg, status);
+    }
+  }  
+}
+
+/***************************************************************************
+  int mpp_var_att_exist(int fid, int vid, const char *att)
+  check the field var has the attribute "att" or not.
+***************************************************************************/
+int mpp_var_att_exist(int fid, int vid, const char *att)
+{
+  int    status;
+  size_t attlen;
+  nc_type atttype;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_var_att_exist): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_var_att_exist): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+  
+  status = nc_inq_att(files[fid].ncid, files[fid].var[vid].fldid, att, &atttype, &attlen);
+  if(status == NC_NOERR) 
+    return 1;
+  else
+    return 0;
+  
+}; /* mpp_att_exist */
+
+/***************************************************************************
+  int mpp_global_att_exist(int fid, const char *att)
+  check  has the global attribute "att" or not.
+***************************************************************************/
+int mpp_global_att_exist(int fid, const char *att)
+{
+  int    status;
+  size_t attlen;
+  nc_type atttype;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_global_att_exist): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  
+  status = nc_inq_att(files[fid].ncid, NC_GLOBAL, att, &atttype, &attlen);
+  if(status == NC_NOERR) 
+    return 1;
+  else
+    return 0;
+  
+}; /* mpp_att_exist */
+
+
+/*******************************************************************************/
+/*                                                                             */
+/*     The following are routines to write out data                            */
+/*                                                                             */
+/*******************************************************************************/
+
+/********************************************************************
+ int mpp_def_dim(int fid, char* name, int size)
+ define dimension. 
+********************************************************************/
+int mpp_def_dim(int fid, const char* name, int size) {
+  int dimid, status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return 0;
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_dim): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  
+  status = nc_def_dim(files[fid].ncid, name, size, &dimid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_def_dim): Error in defining dimension %s of file %s",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  return dimid;
+} /* mpp_def_dim */
+
+/********************************************************************
+ int mpp_def_var(nt fid, const char* name, int type, int ndim, int *dims, int natts ... )
+ define metadata of field.
+********************************************************************/
+int mpp_def_var(int fid, const char* name, nc_type type, int ndim, const int *dims, int natts, ...) {
+  int fldid, status, i, vid, ncid;
+  va_list ap;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return 0;
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_var): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+
+  ncid = files[fid].ncid;
+  status = nc_def_var(ncid, name, type, ndim, dims, &fldid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_def_var): Error in defining var %s of file %s",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  vid = files[fid].nvar;
+  files[fid].nvar++;
+  if(files[fid].nvar > MAXVAR ) mpp_error("mpp_io(mpp_def_var): nvar is larger than MAXVAR, increase MAXVAR");  
+  files[fid].var[vid].fldid = fldid;
+  files[fid].var[vid].type = type;
+  strcpy(files[fid].var[vid].name, name);
+  
+  va_start(ap, natts);
+  for( i=0; i<natts; i++) {
+    char* attname = va_arg(ap, char*);
+    char* attval = va_arg(ap, char*);
+    if( attname == NULL || attval == NULL) {
+      mpp_error("mpp_io: attribute name and attribute value not defined suitably, check the arguments list.");
+    }
+    status = nc_put_att_text(ncid,fldid,attname,strlen(attval),attval);
+    if(status != NC_NOERR ) {
+      sprintf(errmsg, "mpp_io(mpp_def_var): Error in put attribute %s of var %s of file %s",
+	      attname, name, files[fid].name );
+      netcdf_error(errmsg, status);
+    }
+  }
+  va_end(ap);
+  return vid;
+} /* mpp_define_var */
+
+
+
+
+/*********************************************************************
+  void mpp_def_global_att(int fid, const char *name, const char *val)
+  write out global attribute
+ ********************************************************************/
+void mpp_def_global_att(int fid, const char *name, const char *val)
+{
+  size_t status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_global_att): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  status = nc_put_att_text(files[fid].ncid, NC_GLOBAL, name, strlen(val), val);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_def_global_att): Error in put glboal attribute %s of file %s",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_def_global_att */
+
+
+/*********************************************************************
+  void mpp_def_global_att_double(int fid, const char *name, const char *val)
+  write out double global attribute
+ ********************************************************************/
+void mpp_def_global_att_double(int fid, const char *name, size_t len, const double *val)
+{
+  size_t status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_global_att_double): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  status = nc_put_att_double(files[fid].ncid, NC_GLOBAL, name, NC_DOUBLE, len, val);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_def_global_att_double): Error in put glboal attribute %s of file %s",
+	    name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_def_global_att_double */
+
+
+/**********************************************************************
+void mpp_def_var_att(int fid, int vid, const char *attname, const char *attval)
+ define one field attribute
+*********************************************************************/
+void mpp_def_var_att(int fid, int vid, const char *attname, const char *attval)
+{
+  int ncid, fldid, status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_var_att): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_def_var_att): invalid vid number, vid should be "
+					       "a nonnegative integer that less than nvar");
+  ncid  = files[fid].ncid;
+  fldid = files[fid].var[vid].fldid;
+  status = nc_put_att_text(ncid,fldid,attname,strlen(attval),attval);
+  if(status != NC_NOERR ) {
+    sprintf(errmsg, "mpp_io(mpp_def_var_att): Error in put attribute %s of var %s of file %s",
+	    attname, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+} /* mpp_def_var_att */
+
+
+
+/**********************************************************************
+void mpp_def_var_att_double(int fid, int vid, const char *attname, double attval)
+ define one field double attribute
+*********************************************************************/
+void mpp_def_var_att_double(int fid, int vid, const char *attname, double attval)
+{
+  int ncid, fldid, status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_def_var_att): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_def_var_att): invalid vid number, vid should be "
+					       "a nonnegative integer that less than nvar");
+  ncid  = files[fid].ncid;
+  fldid = files[fid].var[vid].fldid;
+  status = nc_put_att_double(ncid,fldid,attname,NC_DOUBLE,1,&attval);
+  if(status != NC_NOERR ) {
+    sprintf(errmsg, "mpp_io(mpp_def_var_att_double): Error in put attribute %s of var %s of file %s",
+	    attname, files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+} /* mpp_def_var_att_double */
+
+
+
+/**********************************************************************
+  void mpp_copy_var_att(fid_in, fid_out)
+  copy all the field attribute from infile to outfile
+**********************************************************************/
+void mpp_copy_var_att(int fid_in, int vid_in, int fid_out, int vid_out)
+{
+  int natt, status, i, ncid_in, ncid_out, fldid_in, fldid_out;
+  char name[256];
+  char errmsg[512];
+
+  if( mpp_pe() != mpp_root_pe() ) return;
+  
+  if(fid_in<0 || fid_in >=nfiles) mpp_error("mpp_io(mpp_copy_var_att): invalid fid_in number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(fid_out<0 || fid_out >=nfiles) mpp_error("mpp_io(mpp_copy_var_att): invalid fid_out number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+        
+  ncid_in   = files[fid_in].ncid;
+  ncid_out  = files[fid_out].ncid;  
+  fldid_in  = files[fid_in].var[vid_in].fldid;
+  fldid_out = files[fid_out].var[vid_out].fldid;
+  
+  status = nc_inq_varnatts(ncid_in, fldid_in, &natt);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_copy_var_att): Error in inquiring natts of var %s of file %s",
+	    files[fid_in].var[vid_in].name, files[fid_in].name );
+    netcdf_error(errmsg, status);
+  }
+  
+  for(i=0; i<natt; i++) {
+    status = nc_inq_attname(ncid_in, fldid_in, i, name);
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_copy_var_att): Error in inquiring %d attname of var %s of file %s", i, 
+	      files[fid_in].var[vid_in].name, files[fid_in].name );
+      netcdf_error(errmsg, status);
+    }
+    status = nc_copy_att(ncid_in, fldid_in, name, ncid_out, fldid_out);
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_copy_var_att): Error in copying att %s of var %s of file %s", name,  
+	      files[fid_in].var[vid_in].name, files[fid_in].name );
+      netcdf_error(errmsg, status);
+    }
+  }
+
+}; /* mpp_copy_field_att */
+
+
+int mpp_get_var_natts(int fid, int vid)
+{
+  int natts, ncid, fldid, status;
+  char errmsg[512];
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_natts): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+        
+  ncid   = files[fid].ncid;
+  fldid  = files[fid].var[vid].fldid;
+  status = nc_inq_varnatts(ncid, fldid, &natts);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_natts): Error in inquiring natts of var %s of file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+   return natts;
+
+}
+
+void mpp_get_var_attname(int fid, int vid, int i, char *name)
+{
+  int ncid, fldid, status;
+  char errmsg[512];
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_get_var_attname): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  ncid   = files[fid].ncid;
+  fldid  = files[fid].var[vid].fldid;
+
+  status = nc_inq_attname(ncid, fldid, i, name);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_get_var_attname): Error in inquiring %d attname of var %s of file %s", i,
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+
+}
+
+void mpp_copy_att_by_name(int fid_in, int vid_in, int fid_out, int vid_out, const char *name)
+{
+
+  int status, ncid_in, ncid_out, fldid_in, fldid_out;
+  char errmsg[512];
+
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid_in<0 || fid_in >=nfiles) mpp_error("mpp_io(mpp_copy_var_att): invalid fid_in number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(fid_out<0 || fid_out >=nfiles) mpp_error("mpp_io(mpp_copy_var_att): invalid fid_out number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  
+  ncid_in   = files[fid_in].ncid;
+  ncid_out  = files[fid_out].ncid;  
+  fldid_in  = files[fid_in].var[vid_in].fldid;
+  fldid_out = files[fid_out].var[vid_out].fldid;
+
+  status = nc_copy_att(ncid_in, fldid_in, name, ncid_out, fldid_out);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_copy_att_by_name): Error in copying att %s of var %s of file %s", name,
+	    files[fid_in].var[vid_in].name, files[fid_in].name );
+    netcdf_error(errmsg, status);
+  }
+
+}
+  
+
+/**********************************************************************
+  void mpp_copy_global_att(fid_in, fid_out)
+  copy all the global attribute from infile to outfile
+**********************************************************************/
+void mpp_copy_global_att(int fid_in, int fid_out)
+{
+  int natt, status, i, ncid_in, ncid_out;
+  char name[256], errmsg[512];
+
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid_in<0 || fid_in >=nfiles) mpp_error("mpp_io(mpp_copy_global_att): invalid fid_in number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(fid_out<0 || fid_out >=nfiles) mpp_error("mpp_io(mpp_copy_global_att): invalid fid_out number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  ncid_in = files[fid_in].ncid;
+  ncid_out = files[fid_out].ncid;
+  
+  status = nc_inq_varnatts(ncid_in, NC_GLOBAL, &natt);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_copy_global_att): Error in inquiring natts(global) of file %s",
+	    files[fid_in].name );
+    netcdf_error(errmsg, status);
+  }
+
+  for(i=0; i<natt; i++) {
+    status = nc_inq_attname(ncid_in, NC_GLOBAL, i, name);
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_copy_global_att): Error in inquiring %d global attname of file %s", i, 
+	      files[fid_in].name );
+      netcdf_error(errmsg, status);
+    }    
+
+    status = nc_copy_att(ncid_in, NC_GLOBAL, name, ncid_out, NC_GLOBAL);
+    if(status != NC_NOERR) {
+      sprintf(errmsg, "mpp_io(mpp_copy_global_att): Error in copying %d global att %s of file %s", i,  name,  
+	      files[fid_in].name );
+      netcdf_error(errmsg, status);
+    }
+  }
+
+}; /* mpp_copy_global_att */
+
+/*********************************************************************
+  void mpp_put_var_value(int fid, int vid, const void* data)
+  write out string-type data
+
+ ********************************************************************/
+void mpp_put_var_value(int fid, int vid, const void* data)
+{
+  size_t status;
+  char errmsg[600];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_put_var_value): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_put_var_value): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  switch(files[fid].var[vid].type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_put_var_double(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;
+  case NC_INT:
+    status = nc_put_var_int(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;
+  case NC_SHORT:
+    status = nc_put_var_short(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;
+  case NC_CHAR:
+    status = nc_put_var_text(files[fid].ncid, files[fid].var[vid].fldid, data);
+    break;    
+  default:
+    sprintf(errmsg, "mpp_io(mpp_put_var_value): field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_put_var_value): Error in putting value of variable %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_put_var_value*/
+
+/*********************************************************************
+  void mpp_put_var_value_block(int fid, int vid, const size_t *start, const size_t *nread, void *data)
+  read part of var data, the part is defined by start and nread.
+*********************************************************************/
+void mpp_put_var_value_block(int fid, int vid, const size_t *start, const size_t *nwrite, const void *data)
+{
+  int status;
+  char errmsg[512];
+
+  if( mpp_pe() != mpp_root_pe() ) return;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_put_var_value_block): invalid fid number, fid should be "
+				    "a nonnegative integer that less than nfiles");
+  if(vid<0 || vid >=files[fid].nvar) mpp_error("mpp_io(mpp_put_var_value_block): invalid vid number, vid should be "
+				    "a nonnegative integer that less than nvar");
+
+  switch(files[fid].var[vid].type) {
+  case NC_DOUBLE:case NC_FLOAT:
+    status = nc_put_vara_double(files[fid].ncid, files[fid].var[vid].fldid, start, nwrite, data);
+    break;
+  case NC_INT:
+    status = nc_put_vara_int(files[fid].ncid, files[fid].var[vid].fldid, start, nwrite, data);
+    break;
+  case NC_SHORT:
+    status = nc_put_vara_short(files[fid].ncid, files[fid].var[vid].fldid, start, nwrite, data);
+    break;    
+  case NC_CHAR:
+    status = nc_put_vara_text(files[fid].ncid, files[fid].var[vid].fldid, start, nwrite, data);
+    break;
+  default:
+    sprintf(errmsg, "mpp_io(mpp_put_var_value_block): field %s in file %s has an invalid type, "
+	    "the type should be NC_DOUBLE, NC_FLOAT, NC_INT, NC_SHORT or NC_CHAR",
+	    files[fid].var[vid].name, files[fid].name );
+    mpp_error(errmsg);
+  }    
+  
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_put_var_value_block): Error in putting value of variable %s from file %s",
+	    files[fid].var[vid].name, files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+  
+}; /* mpp_put_var_value_block */
+
+/*********************************************************************
+   void mpp_redef(int fid) 
+   redef the meta data of netcdf file with fid.
+ *******************************************************************/
+void mpp_redef(int fid) {
+  int status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_redef): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  
+  status = nc_redef(files[fid].ncid);
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_redef): Error in redef the meta data of file %s", files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+} /* mpp_redef */
+
+/*********************************************************************
+   void mpp_end_def(int ncid) 
+   end the definition of netcdf file with ncid.
+ *******************************************************************/
+void mpp_end_def(int fid) {
+  int status;
+  char errmsg[512];
+  
+  if( mpp_pe() != mpp_root_pe() ) return;
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_end_def): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  if(HEADER_BUFFER_VALUE>0)
+    status = nc__enddef(files[fid].ncid, HEADER_BUFFER_VALUE, 4, 0, 4);
+  else
+    status = nc_enddef(files[fid].ncid);
+    
+  if(status != NC_NOERR) {
+    sprintf(errmsg, "mpp_io(mpp_end_def): Error in end definition of file %s", files[fid].name );
+    netcdf_error(errmsg, status);
+  }
+} /* mpp_end_def */
+
+/*******************************************************************************
+  int mpp_file_exist(const char *file)
+  check to see if file exist or not.
+*******************************************************************************/
+int mpp_file_exist(const char *file)
+{
+  int status, ncid;
+  
+  status = nc_open(file,NC_NOWRITE, &ncid);
+  if(status == NC_NOERR) {
+    status = nc_close(ncid);
+    if(status != NC_NOERR) netcdf_error("mpp_file_exist(mpp_io):in closing file", status);
+    return 1;
+  }
+  else
+    return 0;
+};
+
+int mpp_field_exist(const char *file, const char *field)
+{
+  int fid, status, varid;
+
+  fid = mpp_open(file, MPP_READ);
+  status = nc_inq_varid(files[fid].ncid, field, &varid);
+  mpp_close(fid);
+
+  if(status == NC_NOERR)
+    return 1;
+  else
+    return 0;
+
+}
+
+int mpp_dim_exist(int fid, const char *dimname)
+{
+  int status, dimid;
+  
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_dim_exist): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+
+  status = nc_inq_dimid( files[fid].ncid, dimname, &dimid);
+
+  if(status == NC_NOERR)
+    return 1;
+  else
+    return 0;  
+
+}
+
+
+int mpp_var_exist(int fid, const char *field)
+{
+  int status, varid;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(mpp_var_exist): invalid fid number, fid should be "
+				      "a nonnegative integer that less than nfiles");
+  
+  status = nc_inq_varid(files[fid].ncid, field, &varid);
+
+  if(status == NC_NOERR)
+    return 1;
+  else
+    return 0;
+
+} 
+
+
+int get_great_circle_algorithm(int fid)
+{
+  char attval[256];
+  char errmsg[512];
+  int great_circle_algorithm = 0;
+
+  if(fid<0 || fid >=nfiles) mpp_error("mpp_io(get_great_circle_algorithm): invalid fid number, fid should be "
+                                        "a nonnegative integer that less than nfiles");
+
+  if(mpp_global_att_exist(fid, "great_circle_algorithm")) {
+    mpp_get_global_att(fid, "great_circle_algorithm", attval);
+
+    if(!strcmp(attval, "TRUE"))
+      great_circle_algorithm = 1;
+    else if(!strcmp(attval, "FALSE"))
+      great_circle_algorithm = 0;
+    else {
+      sprintf(errmsg, "mpp_io: global atribute 'great_circle_algorithm' "
+	      "in file %s should have value 'TRUE' or 'FALSE'", files[fid].name);
+      mpp_error(errmsg);
+    }
+  }
+
+  return  great_circle_algorithm;
+}
+
diff --git a/sorc/fre-nctools.fd/shared_lib/mpp_io.h b/sorc/fre-nctools.fd/shared_lib/mpp_io.h
new file mode 100644
index 0000000..b163abb
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/mpp_io.h
@@ -0,0 +1,63 @@
+/****************************************************************
+                    mpp_io.h
+   This headers defines interface to read and write netcdf file. All the data
+will be written out from root pe. 
+
+   contact: Zhi.Liang@noaa.gov
+
+****************************************************************/
+#ifndef MPP_IO_H_
+#define MPP_IO_H_
+#include <netcdf.h>
+
+#define MPP_WRITE 100
+#define MPP_READ  200
+#define MPP_APPEND  300
+#define MPP_INT NC_INT
+#define MPP_DOUBLE NC_DOUBLE
+#define MPP_CHAR NC_CHAR
+#define HEADER_BUFFER_VALUE (16384)
+#define MPP_FILL_INT NC_FILL_INT
+#define MPP_FILL_DOUBLE NC_FILL_DOUBLE
+
+int mpp_open(const char *file, int action);
+void mpp_close(int ncid);
+int mpp_get_nvars(int fid);
+void mpp_get_varname(int fid, int varid, char *name);
+int mpp_get_varid(int fid, const char *varname);
+int mpp_get_dimid(int fid, const char *dimname);
+int mpp_get_dimlen(int fid, const char *name);
+int mpp_get_var_natts(int fid, int vid);
+void mpp_get_var_attname(int fid, int vid, int i, char *name);
+void mpp_copy_att_by_name(int fid_in, int vid_in, int fid_out, int vid_out, const char *name);
+void mpp_get_var_value(int fid, int vid, void *data);
+void mpp_get_var_value_block(int fid, int vid, const size_t *start, const size_t *nread, void *data);
+void mpp_get_var_att(int fid, int vid, const char *name, void *val);
+void mpp_get_var_att_double(int fid, int vid, const char *name, double *val);
+void mpp_get_global_att(int fid, const char *name, void *val);
+int mpp_get_var_ndim(int fid, int vid);
+nc_type mpp_get_var_type(int fid, int vid);
+char mpp_get_var_cart(int fid, int vid);
+void mpp_get_var_dimname(int fid, int vid, int ind, char *name);
+char mpp_get_dim_cart(int fid, const char *name);
+void mpp_get_var_bndname(int fid, int vid, char *bndname);
+int mpp_var_att_exist(int fid, int vid, const char *att);
+int mpp_global_att_exist(int fid, const char *att);
+int mpp_def_dim(int fid, const char* name, int size);
+int mpp_def_var(int fid, const char* name, nc_type type, int ndim, const int *dims, int natts, ...);
+void mpp_def_global_att(int fid, const char *name, const char *val);
+void mpp_def_global_att_double(int fid, const char *name, size_t len, const double *val);
+void mpp_def_var_att(int fid, int vid, const char *attname, const char *attval);
+void mpp_def_var_att_double(int fid, int vid, const char *attname, double attval);
+void mpp_copy_var_att(int fid_in, int vid_in, int fid_out, int vid_out);
+void mpp_copy_global_att(int fid_in, int fid_out);
+void mpp_put_var_value(int fid, int vid, const void* data);
+void mpp_put_var_value_block(int fid, int vid, const size_t *start, const size_t *nread, const void *data);
+void mpp_end_def(int fid);
+void mpp_redef(int fid);
+int mpp_file_exist(const char *file);
+int mpp_field_exist(const char *file, const char *field);
+int mpp_var_exist(int fid, const char *field);
+int mpp_dim_exist(int fid, const char *dimname);
+int get_great_circle_algorithm(int fid);
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/read_mosaic.c b/sorc/fre-nctools.fd/shared_lib/read_mosaic.c
new file mode 100644
index 0000000..460f2c4
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/read_mosaic.c
@@ -0,0 +1,830 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <string.h>
+#include "read_mosaic.h"
+#include "constant.h"
+#include "mosaic_util.h"
+#ifdef use_netCDF
+#include <netcdf.h>
+#endif
+/*********************************************************************
+    void netcdf_error( int status )
+    status is the returning value of netcdf call. this routine will
+    handle the error when status is not NC_NOERR.
+********************************************************************/
+void handle_netcdf_error(const char *msg, int status )
+{
+  char errmsg[512];
+
+  sprintf( errmsg, "%s: %s", msg, (char *)nc_strerror(status) );
+  error_handler(errmsg);
+
+}; /* handle_netcdf_error */
+
+/***************************************************************************
+  void get_file_dir(const char *file, char *dir)
+  get the directory where file is located. The dir will be the complate path
+  before the last "/". If no "/" exist in file, the path will be current ".".
+***************************************************************************/
+void get_file_dir(const char *file, char *dir)
+{
+  int len;
+  char *strptr = NULL;
+
+  /* get the diretory */
+ 
+  strptr = strrchr(file, '/');
+  if(strptr) {
+    len = strptr - file;
+    strncpy(dir, file, len);
+  }
+  else {
+    len = 1;
+    strcpy(dir, ".");
+  }
+  dir[len] = 0;
+
+}; /* get_file_dir */
+
+
+int field_exist(const char* file, const char *name)
+{
+  int ncid, varid, status, existed;
+  char msg[512];  
+#ifdef use_netCDF
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "field_exist: in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);  
+  if(status == NC_NOERR)
+    existed = 1;
+  else
+    existed = 0;
+    
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "field_exist: in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }
+
+  return existed;
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+
+#endif
+  return 0; 
+}; /* field_exist */
+
+int get_dimlen(const char* file, const char *name)
+{
+  int ncid, dimid, status, len;
+  size_t size;
+  char msg[512];
+
+  len = 0;
+#ifdef use_netCDF  
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  
+  status = nc_inq_dimid(ncid, name, &dimid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting dimid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  
+  status = nc_inq_dimlen(ncid, dimid, &size);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting dimension size of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }
+  
+  len = size;
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+  return len;
+  
+}; /* get_dimlen */
+
+/*******************************************************************************
+   void get_string_data(const char *file, const char *name, char *data)
+   get string data of field with "name" from "file".
+******************************************************************************/
+void get_string_data(const char *file, const char *name, char *data)
+{
+  int ncid, varid, status;
+  char msg[512];
+
+#ifdef use_netCDF    
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting varid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }     
+  status = nc_get_var_text(ncid, varid, data);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting data of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }  
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+}; /* get_string_data */
+
+/*******************************************************************************
+   void get_string_data_level(const char *file, const char *name, const size_t *start, const size_t *nread, char *data)
+   get string data of field with "name" from "file".
+******************************************************************************/
+void get_string_data_level(const char *file, const char *name, char *data, const int *level)
+{
+  int ncid, varid, status, i;
+  size_t start[4], nread[4];
+  char msg[512];
+
+#ifdef use_netCDF  
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting varid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  for(i=0; i<4; i++) {
+    start[i] = 0; nread[i] = 1;
+  }
+  start[0] = *level; nread[1] = STRING;
+  status = nc_get_vara_text(ncid, varid, start, nread, data);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting data of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }  
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+}; /* get_string_data_level */
+
+
+/*******************************************************************************
+   void get_var_data(const char *file, const char *name, double *data)
+   get var data of field with "name" from "file".
+******************************************************************************/
+void get_var_data(const char *file, const char *name, void *data)
+{
+
+  int ncid, varid, status;  
+  nc_type vartype;
+  char msg[512];
+
+#ifdef use_netCDF    
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting varid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+
+  status = nc_inq_vartype(ncid, varid, &vartype);
+  if(status != NC_NOERR) {
+    sprintf(msg, "get_var_data: in getting vartype of of %s in file %s ", name, file);
+    handle_netcdf_error(msg, status);
+  }
+
+  switch (vartype) {
+  case NC_DOUBLE:case NC_FLOAT:
+#ifdef OVERLOAD_R4
+  status = nc_get_var_float(ncid, varid, data);
+#else
+  status = nc_get_var_double(ncid, varid, data);
+#endif
+  break;
+  case NC_INT:
+    status = nc_get_var_int(ncid, varid, data);
+    break;
+  default:
+    sprintf(msg, "get_var_data: field %s in file %s has an invalid type, "
+            "the type should be NC_DOUBLE, NC_FLOAT or NC_INT", name, file);
+    error_handler(msg);
+  }
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting data of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }  
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+}; /* get_var_data */
+
+/*******************************************************************************
+   void get_var_data(const char *file, const char *name, double *data)
+   get var data of field with "name" from "file".
+******************************************************************************/
+void get_var_data_region(const char *file, const char *name, const size_t *start, const size_t *nread, void *data)
+{
+
+  int ncid, varid, status;  
+  nc_type vartype;
+  char msg[512];
+
+#ifdef use_netCDF    
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "get_var_data_region: in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting varid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+
+  status = nc_inq_vartype(ncid, varid, &vartype);
+  if(status != NC_NOERR) {
+    sprintf(msg, "get_var_data_region: in getting vartype of of %s in file %s ", name, file);
+    handle_netcdf_error(msg, status);
+  }
+
+  switch (vartype) {
+  case NC_DOUBLE:case NC_FLOAT:
+#ifdef OVERLOAD_R4
+    status = nc_get_vara_float(ncid, varid, start, nread, data);
+#else      
+    status = nc_get_vara_double(ncid, varid, start, nread, data);
+#endif
+    break;
+  case NC_INT:
+    status = nc_get_vara_int(ncid, varid, start, nread, data);
+    break;
+  default:
+    sprintf(msg, "get_var_data_region: field %s in file %s has an invalid type, "
+            "the type should be NC_DOUBLE, NC_FLOAT or NC_INT", name, file);
+    error_handler(msg);
+  }
+
+  if(status != NC_NOERR) {
+    sprintf(msg, "get_var_data_region: in getting data of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "get_var_data_region: in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }  
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+}; /* get_var_data_region */
+
+/******************************************************************************
+   void get_var_text_att(const char *file, const char *name, const char *attname, char *att)
+   get text attribute of field 'name' from 'file
+******************************************************************************/
+void get_var_text_att(const char *file, const char *name, const char *attname, char *att)
+{
+  int ncid, varid, status;  
+  char msg[512];
+
+#ifdef use_netCDF    
+  status = nc_open(file, NC_NOWRITE, &ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in opening file %s", file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_inq_varid(ncid, name, &varid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting varid of %s from file %s.", name, file);
+    handle_netcdf_error(msg, status);
+  }     
+  status = nc_get_att_text(ncid, varid, attname, att);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in getting attribute %s of %s from file %s.", attname, name, file);
+    handle_netcdf_error(msg, status);
+  }
+  status = nc_close(ncid);
+  if(status != NC_NOERR) {
+    sprintf(msg, "in closing file %s.", file);
+    handle_netcdf_error(msg, status);
+  }  
+#else
+  error_handler("read_mosaic: Add flag -Duse_netCDF when compiling");
+#endif
+  
+}; /* get_var_text_att */
+
+/***********************************************************************
+  return number of overlapping cells.
+***********************************************************************/
+#ifndef __AIX
+int read_mosaic_xgrid_size_( const char *xgrid_file )
+{
+  return read_mosaic_xgrid_size(xgrid_file);
+}
+#endif
+
+int read_mosaic_xgrid_size( const char *xgrid_file )
+{
+  int ncells;
+  
+  ncells = get_dimlen(xgrid_file, "ncells");
+  return ncells;
+}
+
+#ifdef OVERLOAD_R4
+float get_global_area(void) 
+{
+  float garea;
+#else
+double get_global_area(void) 
+{
+  double garea;
+#endif
+  garea = 4*M_PI*RADIUS*RADIUS;
+
+  return garea;
+};
+
+#ifndef __AIX
+#ifdef OVERLOAD_R4
+float get_global_area_(void)
+{
+  float garea;
+#else
+double get_global_area_(void)
+{
+  double garea;
+#endif
+  garea = 4*M_PI*RADIUS*RADIUS;
+
+  return garea;
+};
+#endif
+
+
+/****************************************************************************/
+#ifndef __AIX
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order1_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area )
+#else
+void read_mosaic_xgrid_order1_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area )
+#endif
+{
+  read_mosaic_xgrid_order1(xgrid_file, i1, j1, i2, j2, area);
+  
+};
+#endif
+
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order1(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area )
+#else
+void read_mosaic_xgrid_order1(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area )
+#endif
+{
+  int    ncells, n;
+  int    *tile1_cell, *tile2_cell;
+#ifdef OVERLOAD_R4  
+  float garea;
+#else
+  double garea;
+#endif
+  
+  ncells = get_dimlen(xgrid_file, "ncells");
+
+  tile1_cell       = (int *)malloc(ncells*2*sizeof(int));
+  tile2_cell       = (int *)malloc(ncells*2*sizeof(int));
+  get_var_data(xgrid_file, "tile1_cell", tile1_cell);
+  get_var_data(xgrid_file, "tile2_cell", tile2_cell);
+
+  get_var_data(xgrid_file, "xgrid_area", area);
+
+  garea = 4*M_PI*RADIUS*RADIUS;
+  
+  for(n=0; n<ncells; n++) {
+    i1[n] = tile1_cell[n*2] - 1;
+    j1[n] = tile1_cell[n*2+1] - 1;
+    i2[n] = tile2_cell[n*2] - 1;
+    j2[n] = tile2_cell[n*2+1] - 1;
+    area[n] /= garea; /* rescale the exchange grid area to unit earth area */
+  }
+
+  free(tile1_cell);
+  free(tile2_cell);
+  
+}; /* read_mosaic_xgrid_order1 */
+
+
+#ifndef __AIX
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order1_region_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area, int *isc, int *iec )
+#else
+void read_mosaic_xgrid_order1_region_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area, int *isc, int *iec )
+#endif
+{
+  read_mosaic_xgrid_order1_region(xgrid_file, i1, j1, i2, j2, area, isc, iec);
+  
+};
+#endif
+
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order1_region(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area, int *isc, int *iec )
+#else
+void read_mosaic_xgrid_order1_region(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area, int *isc, int *iec )
+#endif
+{
+  int    ncells, n, i;
+  int    *tile1_cell, *tile2_cell;
+  size_t start[4], nread[4];
+#ifdef OVERLOAD_R4  
+  float garea;
+#else
+  double garea;
+#endif
+  
+  ncells = *iec-*isc+1;
+
+  tile1_cell       = (int *)malloc(ncells*2*sizeof(int));
+  tile2_cell       = (int *)malloc(ncells*2*sizeof(int));
+  for(i=0; i<4; i++) {
+    start[i] = 0; nread[i] = 1;
+  }
+
+  start[0] = *isc;
+  nread[0] = ncells;
+  nread[1] = 2;
+
+  get_var_data_region(xgrid_file, "tile1_cell", start, nread, tile1_cell);
+  get_var_data_region(xgrid_file, "tile2_cell", start, nread, tile2_cell);
+
+  nread[1] = 1;
+  
+  get_var_data_region(xgrid_file, "xgrid_area", start, nread, area);
+
+  garea = 4*M_PI*RADIUS*RADIUS;
+  
+  for(n=0; n<ncells; n++) {
+    i1[n] = tile1_cell[n*2] - 1;
+    j1[n] = tile1_cell[n*2+1] - 1;
+    i2[n] = tile2_cell[n*2] - 1;
+    j2[n] = tile2_cell[n*2+1] - 1;
+    area[n] /= garea; /* rescale the exchange grid area to unit earth area */
+  }
+
+  free(tile1_cell);
+  free(tile2_cell);
+  
+}; /* read_mosaic_xgrid_order1 */
+
+/* NOTE: di, dj is for tile1, */
+/****************************************************************************/
+#ifndef __AIX
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order2_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area, float *di, float *dj )
+#else
+void read_mosaic_xgrid_order2_(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area, double *di, double *dj )
+#endif
+{
+  read_mosaic_xgrid_order2(xgrid_file, i1, j1, i2, j2, area, di, dj);
+  
+};
+#endif
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order2(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area, float *di, float *dj )
+#else
+void read_mosaic_xgrid_order2(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area, double *di, double *dj )
+#endif
+
+{
+  int    ncells, n;
+  int    *tile1_cell, *tile2_cell;
+  double *tile1_distance;
+#ifdef OVERLOAD_R4
+  float garea;
+#else
+  double garea;
+#endif
+  ncells = get_dimlen(xgrid_file, "ncells");
+
+  tile1_cell       = (int    *)malloc(ncells*2*sizeof(int   ));
+  tile2_cell       = (int    *)malloc(ncells*2*sizeof(int   ));
+  tile1_distance   = (double *)malloc(ncells*2*sizeof(double));
+  get_var_data(xgrid_file, "tile1_cell", tile1_cell);
+  get_var_data(xgrid_file, "tile2_cell", tile2_cell);
+  get_var_data(xgrid_file, "xgrid_area", area);
+  get_var_data(xgrid_file, "tile1_distance", tile1_distance);
+
+  garea = 4*M_PI*RADIUS*RADIUS;
+  
+  for(n=0; n<ncells; n++) {
+    i1[n] = tile1_cell[n*2] - 1;
+    j1[n] = tile1_cell[n*2+1] - 1;
+    i2[n] = tile2_cell[n*2] - 1;
+    j2[n] = tile2_cell[n*2+1] - 1;
+    di[n] = tile1_distance[n*2];
+    dj[n] = tile1_distance[n*2+1];
+    area[n] /= garea; /* rescale the exchange grid area to unit earth area */
+  }
+
+  free(tile1_cell);
+  free(tile2_cell);
+  free(tile1_distance);
+  
+}; /* read_mosaic_xgrid_order2 */
+
+/******************************************************************************
+  int read_mosaic_ntiles(const char *mosaic_file)
+  return number tiles in mosaic_file
+******************************************************************************/
+#ifndef __AIX
+int read_mosaic_ntiles_(const char *mosaic_file)
+{
+  return read_mosaic_ntiles(mosaic_file);
+}
+#endif
+int read_mosaic_ntiles(const char *mosaic_file)
+{
+
+  int ntiles;
+
+  ntiles = get_dimlen(mosaic_file, "ntiles");
+
+  return ntiles;
+  
+}; /* read_mosaic_ntiles */
+
+/******************************************************************************
+  int read_mosaic_ncontacts(const char *mosaic_file)
+  return number of contacts in mosaic_file
+******************************************************************************/
+#ifndef __AIX
+int read_mosaic_ncontacts_(const char *mosaic_file)
+{
+  return read_mosaic_ncontacts(mosaic_file);
+}
+#endif
+int read_mosaic_ncontacts(const char *mosaic_file)
+{
+
+  int ncontacts;
+
+  if(field_exist(mosaic_file, "contacts") )
+    ncontacts = get_dimlen(mosaic_file, "ncontact");
+  else
+    ncontacts = 0;
+  
+  return ncontacts;
+  
+}; /* read_mosaic_ncontacts */
+
+
+/*****************************************************************************
+  void read_mosaic_grid_sizes(const char *mosaic_file, int *nx, int *ny)
+  read mosaic grid size of each tile, currently we are assuming the refinement is 2.
+  We assume the grid files are located at the same directory as mosaic_file.
+*****************************************************************************/
+#ifndef __AIX
+void read_mosaic_grid_sizes_(const char *mosaic_file, int *nx, int *ny)
+{
+  read_mosaic_grid_sizes(mosaic_file, nx, ny);
+}
+#endif
+void read_mosaic_grid_sizes(const char *mosaic_file, int *nx, int *ny)
+{
+  int ntiles, n;
+  char gridfile[STRING], tilefile[2*STRING];
+  char dir[STRING];
+  const int x_refine = 2, y_refine = 2;
+
+  get_file_dir(mosaic_file, dir);  
+  ntiles = get_dimlen(mosaic_file, "ntiles");
+  for(n = 0; n < ntiles; n++) {
+    get_string_data_level(mosaic_file, "gridfiles", gridfile, &n);
+    sprintf(tilefile, "%s/%s", dir, gridfile);
+    nx[n] = get_dimlen(tilefile, "nx");
+    ny[n] = get_dimlen(tilefile, "ny");
+    if(nx[n]%x_refine != 0) error_handler("Error from read_mosaic_grid_sizes: nx is not divided by x_refine");
+    if(ny[n]%y_refine != 0) error_handler("Error from read_mosaic_grid_sizes: ny is not divided by y_refine");
+    nx[n] /= x_refine;
+    ny[n] /= y_refine;
+  }
+  
+}; /* read_mosaic_grid_sizes */
+  
+
+/******************************************************************************
+  void read_mosaic_contact(const char *mosaic_file)
+  read mosaic contact information
+******************************************************************************/
+#ifndef __AIX
+void read_mosaic_contact_(const char *mosaic_file, int *tile1, int *tile2, int *istart1, int *iend1,
+			 int *jstart1, int *jend1, int *istart2, int *iend2, int *jstart2, int *jend2)
+{
+  read_mosaic_contact(mosaic_file, tile1, tile2, istart1, iend1, jstart1, jend1, istart2, iend2, jstart2, jend2);
+}
+#endif
+
+/* transfer the index from supergrid to model grid 
+   return 0 if istart = iend
+   otherwise return 1.
+*/
+
+int transfer_to_model_index(int istart_in, int iend_in, int *istart_out, int *iend_out, int refine_ratio)
+{
+
+   int type;
+
+   if( istart_in == iend_in ) {
+      type = 0;
+      istart_out[0] = (istart_in+1)/refine_ratio-1;
+      iend_out[0]  = istart_out[0];
+   }   
+   else {
+      type = 1;
+      if( iend_in > istart_in ) {
+        istart_out[0] = istart_in - 1;
+        iend_out[0]   = iend_in - refine_ratio;
+      }
+      else {
+        istart_out[0] = istart_in - refine_ratio;
+        iend_out[0]   = iend_in - 1;
+      }
+
+      if( istart_out[0]%refine_ratio || iend_out[0]%refine_ratio)
+         error_handler("Error from read_mosaic: mismatch between refine_ratio and istart_in/iend_in");
+      istart_out[0] /= refine_ratio;
+      iend_out[0]   /= refine_ratio;
+   }      
+
+   return type;
+
+}
+
+
+void read_mosaic_contact(const char *mosaic_file, int *tile1, int *tile2, int *istart1, int *iend1,
+			 int *jstart1, int *jend1, int *istart2, int *iend2, int *jstart2, int *jend2)
+{
+  char contacts[STRING];
+  char **gridtiles;
+#define MAXVAR 40
+  char pstring[MAXVAR][STRING];
+  int ntiles, ncontacts, n, m, l, found;
+  unsigned int nstr;
+  const int x_refine = 2, y_refine = 2;
+  int i1_type, j1_type, i2_type, j2_type;  
+
+  ntiles = get_dimlen(mosaic_file, "ntiles");
+  gridtiles = (char **)malloc(ntiles*sizeof(char *));
+  for(n=0; n<ntiles; n++) {
+    gridtiles[n] = (char *)malloc(STRING*sizeof(char));
+    get_string_data_level(mosaic_file, "gridtiles", gridtiles[n], &n);
+  }
+    
+  ncontacts = get_dimlen(mosaic_file, "ncontact"); 
+  for(n = 0; n < ncontacts; n++) {
+    get_string_data_level(mosaic_file, "contacts", contacts, &n);
+    /* parse the string contacts to get tile number */
+    tokenize( contacts, ":", STRING, MAXVAR, (char *)pstring, &nstr);
+    if(nstr != 4) error_handler("Error from read_mosaic: number of elements "
+				 "in contact seperated by :/:: should be 4");
+    found = 0;
+    for(m=0; m<ntiles; m++) {
+      if(strcmp(gridtiles[m], pstring[1]) == 0) { /*found the tile name */
+	found = 1;
+	tile1[n] = m+1;
+	break;
+      }
+    }
+    if(!found) error_handler("error from read_mosaic: the first tile name specified "
+			     "in contact is not found in tile list");
+    found = 0;
+    for(m=0; m<ntiles; m++) {
+      if(strcmp(gridtiles[m], pstring[3]) == 0) { /*found the tile name */
+	found = 1;
+	tile2[n] = m+1;
+	break;
+      }
+    }
+    if(!found) error_handler("error from read_mosaic: the second tile name specified "
+			     "in contact is not found in tile list");    
+    get_string_data_level(mosaic_file, "contact_index", contacts, &n);
+    /* parse the string to get contact index */
+    tokenize( contacts, ":,", STRING, MAXVAR, (char *)pstring, &nstr);
+    if(nstr != 8) error_handler("Error from read_mosaic: number of elements "
+				 "in contact_index seperated by :/, should be 8");
+    /* make sure the string is only composed of numbers */
+    for(m=0; m<nstr; m++) for(l=0; l<strlen(pstring[m]); l++) {
+      if(pstring[m][l] > '9' ||  pstring[m][l] < '0' ) {
+	error_handler("Error from read_mosaic: some of the character in "
+		      "contact_indices except token is not digit number");
+      }
+    }
+    istart1[n] = atoi(pstring[0]);
+    iend1[n]   = atoi(pstring[1]);
+    jstart1[n] = atoi(pstring[2]);
+    jend1[n]   = atoi(pstring[3]);
+    istart2[n] = atoi(pstring[4]);
+    iend2[n]   = atoi(pstring[5]);
+    jstart2[n] = atoi(pstring[6]);
+    jend2[n]   = atoi(pstring[7]);
+    i1_type = transfer_to_model_index(istart1[n], iend1[n], istart1+n, iend1+n, x_refine);
+    j1_type = transfer_to_model_index(jstart1[n], jend1[n], jstart1+n, jend1+n, y_refine);
+    i2_type = transfer_to_model_index(istart2[n], iend2[n], istart2+n, iend2+n, x_refine);
+    j2_type = transfer_to_model_index(jstart2[n], jend2[n], jstart2+n, jend2+n, y_refine);
+    if( i1_type == 0 && j1_type == 0 )
+      error_handler("Error from read_mosaic_contact:istart1==iend1 and jstart1==jend1");
+    if( i2_type == 0 && j2_type == 0 )
+      error_handler("Error from read_mosaic_contact:istart2==iend2 and jstart2==jend2");
+    if( i1_type + j1_type != i2_type + j2_type )
+      error_handler("Error from read_mosaic_contact: It is not a line or overlap contact");
+
+  }
+
+  for(m=0; m<ntiles; m++) {
+    free(gridtiles[m]);
+  }
+
+  free(gridtiles);
+ 
+
+}; /* read_mosaic_contact */
+
+
+/******************************************************************************
+  void read_mosaic_grid_data(const char *mosaic_file, const char *name, int nx, int ny,
+                             double *data, int level, int ioff, int joff)
+  read mosaic grid information onto model grid. We assume the refinement is 2 right now.
+  We may remove this restriction in the future. nx and ny are model grid size. level
+  is the tile number. ioff and joff to indicate grid location. ioff =0 and joff = 0
+  for C-cell. ioff=0 and joff=1 for E-cell, ioff=1 and joff=0 for N-cell,
+  ioff=1 and joff=1 for T-cell
+******************************************************************************/
+void read_mosaic_grid_data(const char *mosaic_file, const char *name, int nx, int ny,
+                           double *data, int level, int ioff, int joff)
+{
+  char   tilefile[STRING], gridfile[STRING], dir[STRING];
+  double *tmp;
+  int    ni, nj, nxp, nyp, i, j;
+
+  get_file_dir(mosaic_file, dir);
+  
+  get_string_data_level(mosaic_file, "gridfiles", gridfile, &level);
+  sprintf(tilefile, "%s/%s", dir, gridfile);
+  
+  ni = get_dimlen(tilefile, "nx");
+  nj = get_dimlen(tilefile, "ny");
+
+  if( ni != nx*2 || nj != ny*2) error_handler("supergrid size should be double of the model grid size");
+  tmp = (double *)malloc((ni+1)*(nj+1)*sizeof(double));
+  get_var_data( tilefile, name, tmp);
+  nxp = nx + 1 - ioff;
+  nyp = ny + 1 - joff;
+  for(j=0; j<nyp; j++) for(i=0; i<nxp; i++) data[j*nxp+i] = tmp[(2*j+joff)*(ni+1)+2*i+ioff];
+  free(tmp);
+   
+}; /* read_mosaic_grid_data */
+
+
diff --git a/sorc/fre-nctools.fd/shared_lib/read_mosaic.h b/sorc/fre-nctools.fd/shared_lib/read_mosaic.h
new file mode 100644
index 0000000..cd56d15
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/read_mosaic.h
@@ -0,0 +1,26 @@
+#ifndef READ_MOSAIC_H_
+#define READ_MOSAIC_H_
+
+int read_mosaic_xgrid_size( const char *xgrid_file );
+#ifdef OVERLOAD_R4
+void read_mosaic_xgrid_order1(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area );
+void read_mosaic_xgrid_order1_region(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, float *area, int *isc, int *iec );
+void read_mosaic_xgrid_order2(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, 
+                              float *area, float *di, float *dj );
+float get_global_area(void);
+#else
+void read_mosaic_xgrid_order1(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area );
+void read_mosaic_xgrid_order1_region(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, double *area, int *isc, int *iec );
+void read_mosaic_xgrid_order2(const char *xgrid_file, int *i1, int *j1, int *i2, int *j2, 
+                              double *area, double *di, double *dj );
+double get_global_area(void);
+#endif
+int read_mosaic_ntiles(const char *mosaic_file);
+int read_mosaic_ncontacts(const char *mosaic_file);
+void read_mosaic_grid_sizes(const char *mosaic_file, int *nx, int *ny);
+void read_mosaic_contact(const char *mosaic_file, int *tile1, int *tile2, int *istart1, int *iend1,
+			 int *jstart1, int *jend1, int *istart2, int *iend2, int *jstart2, int *jend2);
+void read_mosaic_grid_data(const char *mosaic_file, const char *name, int nx, int ny,
+                           double *data, int level, int ioff, int joff);
+
+#endif
diff --git a/sorc/fre-nctools.fd/shared_lib/tool_util.c b/sorc/fre-nctools.fd/shared_lib/tool_util.c
new file mode 100644
index 0000000..58c9a30
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/tool_util.c
@@ -0,0 +1,751 @@
+#include <stdlib.h> 
+#include <stdio.h>
+#include <string.h>
+#include <math.h> 
+#include "constant.h" 
+#include "mosaic_util.h" 
+#include "read_mosaic.h"
+#include "tool_util.h"
+#include "interp.h"
+#include "mpp.h"
+#include "mpp_io.h"
+#define  D2R (M_PI/180.)
+#define  R2D (180./M_PI)
+
+const double SMALL = 1.0e-4;
+double distant(double a, double b, double met1, double met2);
+double bp_lam(double x, double y, double bpeq, double rp);
+double bp_phi(double x, double y, double bpsp, double bpnp);
+double lon_in_range(double lon, double lon_strt);
+void vtx_insert(double *x, double *y, int *n, int n_ins);
+void vtx_delete(double *x, double *y, int *n, int n_del);
+int lon_fix(double *x, double *y, int n_in, double tlon);
+
+int round_to_nearest_int(double r)
+{
+
+  return (r > 0.0) ? floor(r + 0.5) : ceil(r - 0.5);
+}
+
+/***************************************************************************
+  void get_file_path(const char *file, char *dir)
+  get the directory where file is located. The dir will be the complate path
+  before the last "/". If no "/" exist in file, the path will be current ".".
+***************************************************************************/
+void get_file_path(const char *file, char *dir)
+{
+  int len;
+  char *strptr = NULL;
+
+  /* get the diretory */
+ 
+  strptr = strrchr(file, '/');
+  if(strptr) {
+    len = strptr - file;
+    strncpy(dir, file, len);
+  }
+  else {
+    len = 1;
+    strcpy(dir, ".");
+  }
+  dir[len] = 0;
+
+}; /* get_file_path */
+
+int get_int_entry(char *line, int* value)
+{
+  char* pch;
+  int num;
+  
+  pch = strtok(line, ", ");
+  num = 0;
+  while( pch != NULL) {
+    value[num++] = atoi(pch);
+    pch = strtok(NULL, ", ");
+  }
+  return num;
+    
+};
+
+int get_double_entry(char *line, double *value)
+{
+  char* pch;
+  int num;
+  
+  pch = strtok(line, ", ");
+  num = 0;
+  while( pch != NULL) {
+    value[num++] = atof(pch);
+    pch = strtok(NULL, ", ");
+  }
+  return num;
+};
+
+/*********************************************************************
+  double spherical_dist(double x1, double y1, double x2, double y2)
+  return distance between spherical grid on the earth
+*********************************************************************/
+
+double spherical_dist(double x1, double y1, double x2, double y2)
+{
+  double dist = 0.0;
+  double h1, h2;
+  
+  if(x1 == x2) {
+    h1 = RADIUS;
+    h2 = RADIUS;
+    dist = distant(y1,y2,h1,h2);
+  }
+  else if(y1 == y2) {
+    h1 = RADIUS * cos(y1*D2R);
+    h2 = RADIUS * cos(y2*D2R);
+    dist = distant(x1,x2,h1,h2);
+  }
+  else 
+    mpp_error("tool_till: This is not rectangular grid");
+
+  return dist;
+}; /* spherical_dist */
+  
+
+/*********************************************************************
+  void double bipolar_dist(double x1, double y1, double x2, double y2)
+  return distance of bipolar grids
+*********************************************************************/
+double bipolar_dist(double x1, double y1, double x2, double y2,
+		    double bpeq, double bpsp, double bpnp, double rp )
+{
+  double dist, x[2],y[2], bp_lon[2], bp_lat[2], metric[2];
+  double h1[2], h2[2], chic;
+  int n;
+  
+  x[0] = x1;  x[1] = x2;
+  y[0] = y1;  y[1] = y2;
+  
+  /*--- get the bipolar grid and metric term ----------------------------*/
+  for(n=0; n<2; n++){
+    bp_lon[n] = bp_lam(x[n],y[n],bpeq, rp);     /* longitude (degrees) in bipolar grid system */
+    bp_lat[n] = bp_phi(x[n],y[n],bpsp, bpnp);  /* latitude (degrees) in bipolar grid system */
+    h1[n]     = RADIUS*cos(bp_lat[n]*D2R);
+    h2[n]     = RADIUS;
+    metric[n] = 1.0;
+    if (fabs(y[n]-90.0) < SMALL || fabs(bp_lon[n]*D2R) >= SMALL
+	|| fabs(bp_lat[n]*D2R) >= SMALL) {
+      chic = acos(cos(bp_lon[n]*D2R)*cos(bp_lat[n]*D2R));            /* eqn. 6 */
+      metric[n] = rp*(1/pow(cos(chic/2),2))/(1+(pow(rp,2))*(pow(tan(chic/2),2)));/* eq 3 */
+    }
+  }
+
+  /*--- then calculate the distance -------------------------------------*/
+  if(x1 == x2) 
+    dist = distant(bp_lon[0],bp_lon[1],metric[0]*h1[0],metric[1]*h1[1]);
+  else if(y1 == y2) 
+    dist = distant(bp_lat[0],bp_lat[1],metric[0]*h2[0],metric[1]*h2[1]);
+  else
+    mpp_error("tool_util: This tripolar grid not transformed from rectangular grid");    
+
+  return dist;
+  
+}; /* bipolar_dist */
+
+/*********************************************************************
+  double distant(double a, double b, double met1, double met2)
+  return distant on the earth
+*********************************************************************/
+double distant(double a, double b, double met1, double met2)
+{
+   return fabs(a-b)*D2R*(met1+met2)/2. ;
+}; /* distant */
+
+/*********************************************************************
+   double spherical_area(double x1, double y1, double x2, double y2,
+                   double x3, double y3, double x4, double y4 )            
+   rectangular grid box area
+ ********************************************************************/
+double spherical_area(double x1, double y1, double x2, double y2,
+		      double x3, double y3, double x4, double y4 )
+{
+  double area, dx, lat1, lat2, x[4],y[4];
+  int i, ip;
+  
+  x[0] = x1; y[0] = y1;
+  x[1] = x2; y[1] = y2;
+  x[2] = x3; y[2] = y3;
+  x[3] = x4; y[3] = y4;
+
+  area = 0.0;
+
+  for(i=0; i<4; i++) {
+    ip = i+1;
+    if(ip ==4) ip = 0;
+    dx = (x[ip] - x[i])*D2R;
+    lat1 = y[ip]*D2R;
+    lat2 = y[i]*D2R;
+    if(dx==0.0) continue;
+    if(dx > M_PI)  dx = dx - 2.0*M_PI;
+    if(dx < -M_PI) dx = dx + 2.0*M_PI;
+
+    if (lat1 == lat2) /* cheap area calculation along latitude  */
+      area = area - dx*sin(lat1);
+    else 
+      area = area - dx*(sin(lat1)+sin(lat2))/2;   /*  TRAPEZOID_RULE */
+  }
+
+  area = area * RADIUS * RADIUS;
+
+  return area;
+}; /* spherical_area */
+
+/*********************************************************************
+   double bipolar_area(double x1, double y1, double x2, double y2,
+                       double x3, double y3, double x4, double y4 )            
+   bipolar grid  area
+ ********************************************************************/
+double bipolar_area(double x1, double y1, double x2, double y2,
+			  double x3, double y3, double x4, double y4 )
+{
+  double area, dx, lat1, lat2, x[8],y[8];
+  int i, ip, n;
+  
+  x[0] = x1; y[0] = y1;
+  x[1] = x2; y[1] = y2;
+  x[2] = x3; y[2] = y3;
+  x[3] = x4; y[3] = y4;
+
+
+  /*--- first fix the longitude at the pole -----------------------------*/
+  n = lon_fix(x, y, 4, 180.);
+
+  /*--- calculate the area ----------------------------------------------  */
+  area = 0.0;  
+  for(i=0; i<n; i++){
+    ip = i+1;
+    if(ip == n) ip = 0;
+    dx   = (x[ip] - x[i])*D2R;
+    lat1 = y[ip]*D2R;
+    lat2 = y[i]*D2R;
+    if(dx==0.0) continue;
+    if(dx > M_PI)  dx = dx - 2.0*M_PI;
+    if(dx < -M_PI) dx = dx + 2.0*M_PI;
+
+    if (lat1 == lat2)  /* cheap area calculation along latitude */
+      area = area - dx*sin(lat1);
+    else
+      area = area - dx*(sin(lat1)+sin(lat2))/2;   /*  TRAPEZOID_RULE */
+  }
+  
+  area = area * RADIUS * RADIUS;
+
+  return area;
+}; /* bipolar_area */
+
+/*********************************************************************
+  double lat_dist(double x1, double x2)
+  distance (in degrees) between points on lat. circle
+ ********************************************************************/
+  double lat_dist(double x1, double x2)
+{
+  return min(fmod(x1-x2+720,360.),fmod(x2-x1+720,360.));
+};
+
+
+/*********************************************************************
+  double bp_lam(double x, double y, double bpeq)
+  find bipolar grid longitude given geo. coordinates
+ ********************************************************************/
+  double bp_lam(double x, double y, double bpeq, double rp)
+{
+  double bp_lam;
+
+  /*  bp_lam = ((90-y)/(90-lat_join))*90 */
+  /* invert eqn. 5 with phic=0 to place point at specified geo. lat */
+  bp_lam = 2.*atan(tan((0.5*M_PI-y*D2R)/2)/rp)*R2D;
+  if (lat_dist(x,bpeq)<90.) bp_lam = -bp_lam;
+  return bp_lam;
+}; /* bp_lam */
+
+/*********************************************************************
+   double bp_phi(double x, double y, double bpsp, double bpnp)
+   find bipolar grid latitude given geo. coordinates
+ ********************************************************************/
+   double bp_phi(double x, double y, double bpsp, double bpnp)
+{
+  double bp_phi;
+
+  if (lat_dist(x,bpsp)<90.)
+    return (-90+lat_dist(x,bpsp));
+  else
+    return ( 90-lat_dist(x,bpnp));
+}; /* bp_phi */
+
+
+/*********************************************************************
+  void tp_trans(double& lon, double& lat, double lon_ref)
+  calculate tripolar grid
+ ********************************************************************/
+void tp_trans(double *lon, double *lat, double lon_ref, double lon_start, 
+		    double lam0, double bpeq, double bpsp, double bpnp, double rp )
+{
+  double lamc, phic, lams, chic, phis;
+  
+  lamc = bp_lam(*lon, *lat, bpeq, rp )*D2R;
+  phic = bp_phi(*lon, *lat, bpsp, bpnp)*D2R;
+
+  if (fabs(*lat-90.) < SMALL) {
+       if (phic > 0) 
+	 *lon=lon_in_range(lon_start,lon_ref);
+       else
+	 *lon=lon_start+180.;
+       chic = acos(cos(lamc)*cos(phic));                     /* eqn. 6 */
+       phis = M_PI*0.5-2*atan(rp*tan(chic/2));                   /* eqn. 5 */
+       *lat = phis*R2D;
+       return;
+  }
+
+  if (fabs(lamc) < SMALL && fabs(phic) < SMALL) {
+    *lat=90.;
+    *lon=lon_ref;
+  }
+  else {
+    lams = fmod(lam0+M_PI+M_PI/2-atan2(sin(lamc),tan(phic)),2*M_PI);  /* eqn. 5 */
+    chic = acos(cos(lamc)*cos(phic));                          /* eqn. 6 */
+    phis = M_PI*0.5-2*atan(rp*tan(chic/2));                        /* eqn. 5 */
+    *lon = lams*R2D;
+    *lon = lon_in_range(*lon,lon_ref); 
+    *lat = phis*R2D;
+  }
+}; /* tp_trans */
+
+/*********************************************************************
+  double Lon_in_range(double lon, double lon_strt)
+  Returns lon_strt <= longitude <= lon_strt+360
+ ********************************************************************/
+double lon_in_range(double lon, double lon_strt)
+{
+  double lon_in_range, lon_end;
+
+  lon_in_range = lon;
+  lon_end = lon_strt+360.;
+
+  if (fabs(lon_in_range - lon_strt) < SMALL) 
+    lon_in_range = lon_strt;
+  else if (fabs(lon_in_range - lon_end) < SMALL)
+    lon_in_range = lon_strt;
+  else {
+    while(1) {
+      if (lon_in_range < lon_strt)          
+	lon_in_range = lon_in_range +  360.;
+      else if (lon_in_range  >  lon_end)
+	lon_in_range  = lon_in_range - 360.;
+      else
+	break;
+    }
+  }
+  return lon_in_range;
+}; /* lon_in_range */
+
+
+/*********************************************************************
+   int lon_fix(double *x, double *y, int n_in, double tlon) 
+   fix longitude at pole.
+ ********************************************************************/
+int lon_fix(double *x, double *y, int n_in, double tlon)
+{
+  int i, ip, im, n_out;
+  double x_sum, dx;
+  
+  n_out = n_in;
+  i     = 0;
+  while( i < n_out) {
+    if(fabs(y[i]) >= 90.-SMALL) {
+      im = i - 1;
+      if(im < 0) im = im + n_out;
+      ip = i + 1;
+      if(ip >= n_out) ip = ip - n_out;
+      /*--- all pole points must be paired ---------------------------- */
+      if(y[im] == y[i] && y[ip] == y[i] ) {
+	vtx_delete(x,y, &n_out, i);
+	i = i - 1;
+      }
+      else if(y[im] != y[i] && y[ip] != y[i] ) {
+        vtx_insert(x,y,&n_out,i);
+	i = i + 1;
+      }
+    }
+    i = i + 1;
+  }
+
+  /*--- first of pole pair has longitude of previous vertex -------------
+    --- second of pole pair has longitude of subsequent vertex ---------- */
+  for(i=0;i<n_out;i++){
+    if(fabs(y[i]) >= 90.-SMALL) {
+      im= i - 1;
+      if(im < 0) im = im + n_out;
+      ip = i + 1;
+      if(ip >= n_out) ip = ip - n_out;
+
+      if(y[im] != y[i]) x[i] = x[im];
+      if(y[ip] != y[i]) x[i] = x[ip];
+    }
+  }
+
+  if(n_out == 0) return 0;
+
+  x_sum = x[1];
+  for(i=1;i< n_out;i++){
+    dx = x[i] - x[i-1];
+    if(dx < -180) 
+      dx = dx + 360;
+    else if (dx >  180)
+      dx = dx - 360;
+
+    x[i] = x[i-1] + dx;
+    x_sum = x_sum + x[i];
+  }
+
+  dx = x_sum/(n_out) - tlon;
+  if (dx < -180.) 
+    for(i=0;i<n_out;i++) x[i] = x[i] + 360.;
+  else if (dx > 180.)
+    for(i=0;i<n_out;i++) x[i] = x[i] - 360.;
+
+  return n_out;
+  
+}; /* lon_fix */
+
+
+/*********************************************************************
+   void vtx_delete(double *x, double *y, int *n, int n_del)
+   delete vertex
+ ********************************************************************/
+void vtx_delete(double *x, double *y, int *n, int n_del)
+{
+  int i;
+
+  for(i=n_del; i<=*n-2; i++)
+    {
+      x[i] = x[i+1];
+      y[i] = y[i+1];
+    }
+  (*n)--;
+}; /* vtx_delete */
+
+/*********************************************************************
+   void Vtx_insert(double *x, double *y, int *n, int n_del)
+   insert vertex
+ ********************************************************************/
+void vtx_insert(double *x, double *y, int *n, int n_ins)
+{
+  int i;
+
+  for(i=*n-1; i>=n_ins; i--){
+    x[i+1] = x[i];
+    y[i+1] = y[i];
+  }
+  (*n)++;
+
+}; /* vtx_insert */
+
+
+/*----------------------------------------------------------------------
+    void vect_cross(e, p1, p2)
+    Perform cross products of 3D vectors: e = P1 X P2
+    -------------------------------------------------------------------*/
+    
+/********************************************************************************
+  void compute_grid_bound(int nb, const couble *bnds, const int *npts, int *grid_size, const char *center_cell)
+  compute the 1-D grid location. This algorithm is developed by Russell Fiedler
+********************************************************************************/
+double* compute_grid_bound(int nb, const double *bnds, const int *npts, int *grid_size, const char *center)
+{
+  int    refine, i, n, np;
+  double *grid=NULL, *tmp=NULL;
+  double *grid1=NULL, *grid2=NULL;
+
+  if(!strcmp(center, "none") )
+    refine = 1;
+  else if(!strcmp(center, "t_cell") || !strcmp(center, "c_cell") )
+    refine = 2;
+  else
+    mpp_error("tool_util: center should be 'none', 'c_cell' or 't_cell' ");
+	  
+  grid1 = (double *)malloc(nb*sizeof(double));
+  grid1[0] = 1;
+  n = 0;
+  for(i=1; i<nb; i++) {
+    if(npts[i-1]%refine) mpp_error("tool_util: when center_cell is not 'none', npts should be divided by 2");
+    n += npts[i-1]/refine;
+    grid1[i] = n+1;
+  }
+  np = n + 1;
+  *grid_size = n*refine;
+  tmp   = (double *)malloc(np*sizeof(double));
+  grid  = (double *)malloc((*grid_size+1)*sizeof(double));
+  grid2 = (double *)malloc(np*sizeof(double));
+  for(i=0;i<np;i++) grid2[i] = i + 1.0;
+/*
+  cubic_spline( nb, np, grid1, grid2, bnds, tmp, 1e30, 1e30);
+*/
+  cubic_spline_sp( nb, np, grid1, grid2, bnds, tmp);
+  if(!strcmp(center, "none")) {
+    for(i=0; i<np; i++) grid[i] = tmp[i];
+  }
+  else if(!strcmp(center, "t_cell")) {
+    for(i=0; i<np; i++) grid[2*i] = tmp[i];
+    for(i=0; i<n;  i++) grid[2*i+1] = 0.5*(tmp[i]+tmp[i+1]);
+  }
+  else if( !strcmp(center, "c_cell")) {
+    for(i=0; i<n;  i++) grid[2*i+1] = 0.5*(tmp[i]+tmp[i+1]);
+    grid[0] = tmp[0];
+    for(i=1; i<n;  i++) grid[2*i] = 0.5*(grid[2*i-1] + grid[2*i+1]);
+    grid[2*n] = tmp[n];
+/*
+  else if( !strcmp(center, "c_cell")) {
+    for(i=0; i<np; i++) grid[2*i] = tmp[i];
+    grid[1] = 0.5*(tmp[0]+tmp[1]);
+    for(i=1; i<n;  i++) grid[2*i+1] = 2*grid[2*i] - grid[2*i-1];
+*/
+  }
+    
+  free(grid1);
+  free(grid2);
+  free(tmp);  
+
+  return grid;
+  
+};/* compute_grid_bound */
+
+int get_legacy_grid_size(int nb, const double *bnds, const double *dbnds)
+{
+  int grid_size;
+  int refine, l;
+  double avg_res, chg_res, wid, an;
+  int ncells;
+  
+  refine = 2;
+  
+  grid_size = 0;
+  for(l=0; l<nb-1; l++) {
+    avg_res = 0.5*(dbnds[l] + dbnds[l+1]);
+    chg_res = (dbnds[l+1] - dbnds[l]);
+
+    wid   = fabs(bnds[l+1] - bnds[l]);
+    an    = wid/avg_res;
+    ncells = round(an);
+    grid_size += ncells;    
+  }
+
+  grid_size *= refine;
+
+  return grid_size;
+}
+
+
+/********************************************************************************
+  void compute_grid_bound_legacy(int nb, const couble *bnds, const double *dbnds, int *grid_size, const char *center_cell)
+  compute the 1-D grid location, based on the algorithm developed by Ron Pacanowski
+********************************************************************************/
+double* compute_grid_bound_legacy(int nb, const double *bnds, const double *dbnds, double stretch, int *grid_size, const char *center)
+{
+  int    refine, i, n, np, l;
+  double avg_res, chg_res, tol;
+  double wid, an, del, sum;
+  double *grid=NULL;
+  int    maxlen = MAX_GRID_LENGTH/2;
+  double delta[maxlen];
+  int    num, ncells, npts;
+  
+  if(!strcmp(center, "t_cell") || !strcmp(center, "c_cell") || nb == 2 )
+    refine = 2;	         
+  else
+    mpp_error("tool_util(compute_grid_bound_legacy): center should be 'c_cell' or 't_cell' when nb > 2 ");
+
+  /* when center is 't_cell', stretch must be 1 */
+  if( !strcmp(center, "t_cell") && stretch != 1 )
+    mpp_error("tool_util(ompute_grid_bound_legacy): stretch must be 1 when center = 't_cell' ");
+  
+  num = 0;
+  for(l=0; l<nb-1; l++) {
+    int keep_going;
+    /* avg_res = average resolution of T cells within region
+       chg_res = change in resolution across the region
+       wid     = width of region
+       tol     = tolerance for fitting T cels within region width
+    */
+      
+    /* provide for stretching last region if needed */
+
+    if( l == nb-2 ) {
+      avg_res = 0.5*(dbnds[l] + stretch*dbnds[l+1]);
+      chg_res = (stretch*dbnds[l+1] - dbnds[l]);
+    }
+    else {
+      avg_res = 0.5*(dbnds[l] + dbnds[l+1]);
+      chg_res = (dbnds[l+1] - dbnds[l]);
+    }
+
+    tol   = 1.e-5;
+    wid   = fabs(bnds[l+1] - bnds[l]);
+    an    = wid/avg_res;
+    ncells = round(an);
+    if( !strcmp(center, "t_cell") ) {
+      if( fabs(an-ncells) > tol )
+	mpp_error("tool_util(ompute_grid_bound_legacy): non integral number of cells in some subregion for 't_cell'");
+    
+      for(i=0; i<ncells; i++) {
+	del = avg_res - 0.5*chg_res*cos((M_PI/ncells)*(i+0.5));
+	num++;
+	if( num > maxlen ) mpp_error("tool_util(ompute_grid_bound_legacy): maxlen exceeded, increase size of MAX_GRID_LENGTH");
+	delta[num-1] = del;
+      }
+    }
+    else {
+      /* Calculate resolution of U cells: "deltau"
+	 U grid points will be centered in these cells
+	 n = number of T cells fitting within the region boundaries
+	 note: "sum" initially discounts half of the U cells widths
+	 at the boundaries
+      */
+       
+      sum = 0.5*dbnds[l] - 0.5*dbnds[l+1];
+      n   = 0;
+      i = 0;
+      while (i < 100000 ) {
+	i++;
+	del = avg_res - 0.5*chg_res*cos((M_PI/ncells)*i);
+	if (sum + del <= wid*(1.0 + tol)) {
+	  sum += del;
+	  num++;
+	  if( num > maxlen ) mpp_error("tool_util(compute_grid_bound_legacy): maxlen exceeded, increase size of MAX_GRID_LENGTH");
+	  delta[num-1] = del;
+	  n++;
+	}
+	else
+	  break;
+      }
+      if( stretch == 1 || l != nb-1 ) {
+	if( fabs(an-n) > tol ) {
+	  if(mpp_pe() == mpp_root_pe()) {
+	    printf("==>Error: non integral number of cells in region #%d, average resolution within "
+		   "region = %f14.7, this implies %f14.7 grid cells, Change grid specifications dbnds. "
+		   "Here is some help \n", l, avg_res, an );
+	  }
+	  mpp_error("tool_util(ompute_grid_bound_legacy): non integral number of cells in some subregion for 'c_cell'");
+	}
+      }      
+    }
+  }
+
+  npts = refine*num + 1;
+  *grid_size = refine*num;
+  grid = (double *)malloc(npts*sizeof(double));
+			  
+  grid[0] = bnds[0];
+  if( !strcmp(center, "t_cell") ) {
+    for(i = 0; i<num; i++ ) {
+      del = 0.5*delta[i];
+      grid[2*i+1] = grid[2*i] + del;
+      grid[2*i+2] = grid[2*i+1] + del;
+    }
+  }
+  else { /* c-cell centered */
+    grid[1] = grid[0] + 0.5*dbnds[0];
+    for( i = 0; i < num-1; i++ ) {
+      del = 0.5*delta[i];
+      grid[2*i+2] = grid[2*i+1] + del; 
+      grid[2*i+3] = grid[2*i+2] + del; 
+    }
+    grid[2*num] = grid[2*num-1] + 0.5*delta[num-1];
+  }
+    
+  return grid;
+  
+};/* compute_grid_bound_legacy */
+
+
+void get_boundary_type( const char *grid_file, int grid_version, int *cyclic_x, int *cyclic_y, int *is_tripolar )
+{
+  int ntiles, ncontacts;
+  int m, fid, vid;
+  char errmsg[512];
+  char attvalue[128];
+  int tile1[2], tile2[2];
+  int istart1[2], iend1[2], jstart1[2], jend1[2]; 
+  int istart2[2], iend2[2], jstart2[2], jend2[2];
+  
+  *cyclic_x = 0;
+  *cyclic_y = 0;
+  *is_tripolar = 0;
+
+
+  
+  if( grid_version == VERSION_2)  { /* mosaic grid */
+    /* make sure there is only one tile in the ocean mosaic */
+    ntiles = read_mosaic_ntiles(grid_file);
+      
+    if( ntiles != 1) mpp_error("==>Error from get_boundary_type: ntiles is not 1, contact developer");
+    
+    if(mpp_field_exist(grid_file, "contacts") ) {
+      ncontacts = read_mosaic_ncontacts(grid_file);
+      if(ncontacts < 1) {
+	sprintf(errmsg, "==>Error from get_boundary_type: number of contacts "
+		"number of contacts should be larger than 0 when field contacts exist in file %s",grid_file );
+	mpp_error(errmsg);
+      }  
+      if(ncontacts > 2) {
+	sprintf(errmsg, "==>Error from get_boundary_type: "
+                       "number of contacts should be no larger than 2 in file %s",grid_file );
+	mpp_error(errmsg);
+      }
+      read_mosaic_contact( grid_file, tile1, tile2, istart1, iend1, jstart1, jend1,
+			   istart2, iend2, jstart2, jend2 );
+
+      for(m=0; m<ncontacts; m++) {
+	if(istart1[m] == iend1[m] ) { /* x-direction contact, only cyclic condition */
+	  if(istart2[m] != iend2[m] )
+	    mpp_error("==>Error from get_boundary_type: only cyclic condition is allowed for x-boundary");
+	  *cyclic_x = 1;
+	}
+	else if( jstart1[m] == jend1[m] ) {  /* y-direction contact, cyclic or folded-north */
+	  if(jstart2[m] != jend2[m] )
+	    mpp_error("==>Error from get_boundary_type: only cyclic/folded-north condition is allowed for y-boundary");
+	  if( jstart1[m] == jstart2[m] )  /* folded north */
+	    *is_tripolar = 1;
+	  else
+	    *cyclic_y = 1;
+	}
+        else
+          mpp_error("==>Error from get_boundary_type: invalid boundary contact");
+      }
+    }
+  }
+  else if(grid_version == VERSION_1) {
+    fid = mpp_open(grid_file, MPP_READ);
+    mpp_get_global_att(fid, "x_boundary_type", attvalue);
+    if( ! strcmp(attvalue, "cyclic") ) *cyclic_x = 1;
+    mpp_get_global_att(fid, "y_boundary_type", attvalue);
+    if( ! strcmp(attvalue, "cyclic") )
+      *cyclic_y = 1;
+    else if(! strcmp(attvalue, "fold_north_edge") )
+      *is_tripolar = 1;
+    mpp_close(fid);
+  }
+  else {
+    mpp_error("==>Error from get_boundary_type: grid_version should be VERSION_1 or VERSION_2");
+  }
+
+  if(mpp_pe() == mpp_root_pe()) {
+     if(*cyclic_x)
+       printf("\n==>NOTE from get_boundary_type: x_boundary_type is cyclic\n");
+     else
+       printf("\n==>NOTE from get_boundary_type: x_boundary_type is solid_walls\n");
+
+     if(*cyclic_y) 
+       printf("\n==>NOTE from get_boundary_type: y_boundary_type is cyclic\n");
+     else if(*is_tripolar)
+       printf("\n==>NOTE from get_boundary_type: y_boundary_type is fold_north_edge\n");
+     else
+       printf("\n==>NOTE from get_boundary_type: y_boundary_type is solid_walls\n");
+  }
+
+}; /* get_boundary_type */
diff --git a/sorc/fre-nctools.fd/shared_lib/tool_util.h b/sorc/fre-nctools.fd/shared_lib/tool_util.h
new file mode 100644
index 0000000..ee8324a
--- /dev/null
+++ b/sorc/fre-nctools.fd/shared_lib/tool_util.h
@@ -0,0 +1,27 @@
+/***********************************************************************
+                      tool_util.h
+    This header file provide some utilities routine that will be used in many tools.
+    
+    contact: Zhi.Liang@noaa.gov
+***********************************************************************/
+#ifndef TOOL_UTIL_H_
+#define TOOL_UTIL_H_
+#define MAX_GRID_LENGTH (10000)
+#define VERSION_1 1
+#define VERSION_2 2
+#define VERSION_3 3
+int round_to_nearest_int(double r);
+void get_file_path(const char *file, char *dir);
+int get_int_entry(char *line, int *value); 
+int get_double_entry(char *line, double *value);
+double spherical_dist(double x1, double y1, double x2, double y2);
+double spherical_area(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 ); 
+double bipolar_dist(double x1, double y1, double x2, double y2, double bpeq, double bpsp, double bpnp, double rp );
+double bipolar_area(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4 );
+void tp_trans(double *lon, double *lat, double lon_ref, double lon_start, 
+              double lam0, double bpeq, double bpsp, double bpnp, double rp );
+double* compute_grid_bound(int nb, const double *bnds, const int *npts, int *grid_size, const char *center);
+double* compute_grid_bound_legacy(int nb, const double *bnds, const double *dbnds, double stretch, int *grid_size, const char *center);
+int get_legacy_grid_size(int nb, const double *bnds, const double *dbnds);
+void get_boundary_type( const char *grid_file, int grid_version, int *cyclic_x, int *cyclic_y, int *is_tripolar );
+#endif
diff --git a/sorc/fre-nctools.fd/tools/filter_topo/CMakeLists.txt b/sorc/fre-nctools.fd/tools/filter_topo/CMakeLists.txt
new file mode 100644
index 0000000..bd56685
--- /dev/null
+++ b/sorc/fre-nctools.fd/tools/filter_topo/CMakeLists.txt
@@ -0,0 +1,16 @@
+set(fortran_src
+    filter_topo.F90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -assume byterecl -real_size 64 -fno-alias -stack_temps -safe_cray_ptr -ftz")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -ffree-line-length-0 -fdefault-real-8")
+endif()
+
+set(exe_name filter_topo)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  NetCDF::NetCDF_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/fre-nctools.fd/tools/fregrid/CMakeLists.txt b/sorc/fre-nctools.fd/tools/fregrid/CMakeLists.txt
new file mode 100644
index 0000000..f376313
--- /dev/null
+++ b/sorc/fre-nctools.fd/tools/fregrid/CMakeLists.txt
@@ -0,0 +1,14 @@
+set(c_src
+  bilinear_interp.c
+  conserve_interp.c
+  fregrid.c
+  fregrid_util.c)
+
+add_executable(fregrid ${c_src})
+
+target_link_libraries(fregrid
+  m
+  shared_lib
+  NetCDF::NetCDF_C)
+
+install(TARGETS fregrid RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/fre-nctools.fd/tools/make_hgrid/CMakeLists.txt b/sorc/fre-nctools.fd/tools/make_hgrid/CMakeLists.txt
new file mode 100644
index 0000000..c59be2d
--- /dev/null
+++ b/sorc/fre-nctools.fd/tools/make_hgrid/CMakeLists.txt
@@ -0,0 +1,15 @@
+set(c_src
+  create_conformal_cubic_grid.c
+  create_gnomonic_cubic_grid.c
+  create_grid_from_file.c
+  create_lonlat_grid.c
+  make_hgrid.c)
+
+add_executable(make_hgrid ${c_src})
+
+target_link_libraries(make_hgrid
+  m
+  shared_lib
+  NetCDF::NetCDF_C)
+
+install(TARGETS make_hgrid RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/fre-nctools.fd/tools/make_solo_mosaic/CMakeLists.txt b/sorc/fre-nctools.fd/tools/make_solo_mosaic/CMakeLists.txt
new file mode 100644
index 0000000..87ef6be
--- /dev/null
+++ b/sorc/fre-nctools.fd/tools/make_solo_mosaic/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(c_src
+    make_solo_mosaic.c
+    get_contact.c)
+
+add_executable(make_solo_mosaic ${c_src})
+
+target_link_libraries(make_solo_mosaic
+  m
+  shared_lib
+  NetCDF::NetCDF_C)
+
+install(TARGETS make_solo_mosaic RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/fre-nctools.fd/tools/shave.fd/CMakeLists.txt b/sorc/fre-nctools.fd/tools/shave.fd/CMakeLists.txt
new file mode 100644
index 0000000..6f75df2
--- /dev/null
+++ b/sorc/fre-nctools.fd/tools/shave.fd/CMakeLists.txt
@@ -0,0 +1,10 @@
+set(fortran_src
+    shave_nc.F90)
+
+set(exe_name shave)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  NetCDF::NetCDF_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/global_chgres.fd/CMakeLists.txt b/sorc/global_chgres.fd/CMakeLists.txt
new file mode 100644
index 0000000..a329882
--- /dev/null
+++ b/sorc/global_chgres.fd/CMakeLists.txt
@@ -0,0 +1,39 @@
+set(fortran_src
+    chgres.f90
+    chgres_utils.f90
+    funcphys.f90
+    machine_8.f90
+    nrlmsise00_sub.f90
+    nsst_chgres.f90
+    nstio_module.f90
+    num_parthds.f90
+    physcons.f90
+    read_write.f90
+    sfcsub.F
+    surface_chgres.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -convert big_endian")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fdefault-real-8 -fconvert=big-endian")
+endif()
+
+set(exe_name global_chgres)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  gfsio_4
+  nemsiogfs
+  nemsio
+  sigio_4
+  sfcio_4
+  landsfcutil_d
+  ip_d
+  sp_d
+  w3emc_d
+  w3nco_d
+  bacio_4
+  NetCDF::NetCDF_Fortran
+  OpenMP::OpenMP_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/global_chgres.fd/chgres_utils.f90 b/sorc/global_chgres.fd/chgres_utils.f90
new file mode 100755
index 0000000..0f156da
--- /dev/null
+++ b/sorc/global_chgres.fd/chgres_utils.f90
@@ -0,0 +1,2264 @@
+      SUBROUTINE GL2ANY(IP,KM,G1,IM1,JM1,G2,IM2,JM2,RLON,RLAT) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    GL2ANY      INTERPOLATE GAUSSIAN GRID TO ANY GRID      
+!   PRGMMR: EMC              ORG: W/NMC23     DATE: JAN-18-2017
+!                                                                       
+! ABSTRACT: LINEARLY INTERPOLATES GAUSSIAN GRID TO ANY GRID.            
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   2017-JAN-18  EMC      INITIAL VERSION
+!                                                                       
+! USAGE:    CALL GL2ANY(IP,KM,G1,IM1,JM1,G2,IM2,JM2,RLON,RLAT)          
+!   INPUT ARGUMENT LIST:                                                
+!     IP           INTEGER INTERPOLATION TYPE                           
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     G1           REAL (IM1,JM1,KM) INPUT GAUSSIAN FIELD               
+!     IM1          INTEGER NUMBER OF INPUT LONGITUDES                   
+!     JM1          INTEGER NUMBER OF INPUT LATITUDES                    
+!     IM2          INTEGER NUMBER OF OUTPUT LONGITUDES                  
+!     JM2          INTEGER NUMBER OF OUTPUT LATITUDES                   
+!     RLON         REAL (IM2,JM2) OUTPUT GRID LONGITUDES                
+!     RLAT         REAL (IM2,JM2) OUTPUT GRID LATITUDES                 
+!   OUTPUT ARGUMENT LIST:                                               
+!     G2           REAL (IM2,JM2,KM) OUTPUT FIELD              
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   IPOLATES     IREDELL'S POLATE FOR SCALAR FIELDS                     
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER, INTENT(IN)     :: IP, KM, IM1, JM1, IM2, JM2 
+      REAL, INTENT(IN)        :: G1(IM1,JM1,KM) 
+      REAL, INTENT(IN)        :: RLAT(IM2,JM2),RLON(IM2,JM2) 
+      REAL, INTENT(OUT)       :: G2(IM2,JM2,KM) 
+      LOGICAL*1               :: L1(IM1,JM1,KM),L2(IM2,JM2,KM) 
+      INTEGER                 :: IB1(KM),IB2(KM) 
+      INTEGER                 :: KGDS1(200),KGDS2(200) 
+      INTEGER                 :: IPOPT(20), IRET, NO 
+      DATA KGDS1/4,0,0,90000,0,0,-90000,193*0/ 
+      DATA KGDS2/200*0/ 
+      DATA IPOPT/20*0/ 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      L1=.TRUE. 
+      KGDS2(1) = -1 
+      NO = IM2*JM2 
+      IB1=0 
+      KGDS1(2)=IM1 
+      KGDS1(3)=JM1 
+      KGDS1(8)=NINT(-360000./IM1) 
+      KGDS1(10)=JM1/2 
+      CALL IPOLATES(IP,IPOPT,KGDS1,KGDS2,IM1*JM1,IM2*JM2,KM,IB1,L1,G1,  &
+                    NO,RLAT,RLON,IB2,L2,G2,IRET)                        
+      IF(IRET/=0)THEN 
+        PRINT*,'FATAL ERROR IN ROUTINE GL2ANY, IRET: ', IRET 
+        CALL ERREXIT(23) 
+      ENDIF 
+      END SUBROUTINE GL2ANY 
+                                                                        
+!-----------------------------------------------------------------------
+      SUBROUTINE GL2ANYV(IP,KM,G1U,G1V,IM1,JM1,G2U,G2V,IM2,JM2,RLON,RLAT) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    GL2ANYV     INTERPOLATE GAUSSIAN GRID TO ANY GRID      
+!   PRGMMR: EMC              ORG: W/NMC23     DATE: JAN-23-2017
+!                                                                       
+! ABSTRACT: LINEARLY INTERPOLATES VECTOR FIELD FROM GAUSSIAN GRID TO
+!           ANY GRID.  OUTPUT WINDS ARE EARTH RELATIVE.
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   2017-JAN-23  ESRL/EMC    INITIAL VERSION
+!                                                                       
+! USAGE:    CALL GL2ANY(IP,KM,G1U,G1V,IM1,JM1,G2U,G2V,IM2,JM2,RLON,RLAT)
+!   INPUT ARGUMENT LIST:                                                
+!     IP           INTEGER INTERPOLATION TYPE                           
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     G1U          REAL (IM1,JM1,KM) INPUT GAUSSIAN U-COMPONENT FIELD               
+!     G1V          REAL (IM1,JM1,KM) INPUT GAUSSIAN V-COMPONENT FIELD               
+!     IM1          INTEGER NUMBER OF INPUT LONGITUDES                   
+!     JM1          INTEGER NUMBER OF INPUT LATITUDES                    
+!     IM2          INTEGER NUMBER OF OUTPUT LONGITUDES                  
+!     JM2          INTEGER NUMBER OF OUTPUT LATITUDES                   
+!     RLON         REAL (IM2,JM2) OUTPUT GRID LONGITUDES                
+!     RLAT         REAL (IM2,JM2) OUTPUT GRID LATITUDES                 
+!   OUTPUT ARGUMENT LIST:                                               
+!     G2U          REAL (IM2,JM2,KM) OUTPUT U-COMPONENT FIELD
+!     G2V          REAL (IM2,JM2,KM) OUTPUT V-COMPONENT FIELD
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   IPOLATEV     IREDELL'S POLATE FOR VECTOR FIELDS                     
+!                                                                       
+! ATTRIBUTES:                                                          
+!   LANGUAGE: FORTRAN 90
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER, INTENT(IN)     :: IP, KM, IM1, JM1, IM2, JM2 
+      REAL, INTENT(IN)        :: G1U(IM1,JM1,KM), G1V(IM1,JM1,KM)
+      REAL, INTENT(IN)        :: RLAT(IM2,JM2),RLON(IM2,JM2) 
+      REAL, INTENT(OUT)       :: G2U(IM2,JM2,KM), G2V(IM2,JM2,KM)
+      LOGICAL*1               :: L1(IM1,JM1,KM),L2(IM2,JM2,KM) 
+      INTEGER                 :: IB1(KM),IB2(KM) 
+      INTEGER                 :: KGDS1(200),KGDS2(200) 
+      INTEGER                 :: IPOPT(20), IRET, NO 
+      REAL                    :: CROT(IM2,JM2),SROT(IM2,JM2) 
+      DATA KGDS1/4,0,0,90000,0,0,-90000,193*0/ 
+      DATA KGDS2/200*0/ 
+      DATA IPOPT/20*0/ 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      L1=.TRUE. 
+      KGDS2(1) = -1  ! THE OUTPUT GRID IS A SERIES OF POINTS
+      NO = IM2*JM2 
+      IB1=0 
+      KGDS1(2)=IM1 
+      KGDS1(3)=JM1 
+      KGDS1(8)=NINT(-360000./IM1) 
+      KGDS1(10)=JM1/2 
+      CROT = 1.0    ! DONT ROTATE WINDS TO THE OUTPUT GRID.
+      SROT = 0.0    ! FV3 EXPECTS EARTH RELATIVE WINDS.
+      CALL IPOLATEV(IP,IPOPT,KGDS1,KGDS2,IM1*JM1,IM2*JM2,KM,IB1,L1,G1U,  &
+                    G1V,NO,RLAT,RLON,CROT,SROT,IB2,L2,G2U,G2V,IRET)                        
+      IF(IRET/=0)THEN 
+        PRINT*,'FATAL ERROR IN ROUTINE GL2ANYV, IRET: ', IRET 
+        CALL ERREXIT(23) 
+      ENDIF 
+      END SUBROUTINE GL2ANYV
+
+!-----------------------------------------------------------------------
+      SUBROUTINE NEWSIG(NSIL,IDVC,LEVS,NVCOORD,VCOORD,IRET) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM: NEWSIG         GET NEW SIGMA STRUCTURE                    
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 98-04-03            
+!                                                                       
+! ABSTRACT: READ IN INTERFACE SIGMA VALUES (OR USE OLD VALUES)          
+!   AND COMPUTE FULL SIGMA VALUES.                                      
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   98-04-03  IREDELL                                                   
+!                                                                       
+! USAGE:    CALL NEWSIG(NSIL,IDVC,LEVS,NVCOORD,VCOORD,IRET)             
+!   INPUT ARGUMENTS:                                                    
+!     NSIL         INTEGER UNIT NUMBER OF NEW SIGMA INTERFACE VALUES    
+!     IDVC         INTEGER VERTICAL COORDINATE ID                       
+!     LEVS         INTEGER NEW NUMBER OF LEVELS                         
+!     NVCOORD      INTEGER NEW NUMBER OF VERTICAL COORDINATES           
+!   OUTPUT ARGUMENTS:                                                   
+!     VCOORD       REAL (LEVS+1,NVCOORD) NEW VERTICAL COORDINATES       
+!     IRET         INTEGER RETURN CODE                                  
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+!                                                                       
+      INTEGER :: NSIL,IDVC,LEVS,NVCOORD,IRET 
+      REAL    :: VCOORD(LEVS+1,NVCOORD) 
+!                                                                       
+      INTEGER :: IDVCI,LEVSI,NVCOORDI,K,N 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  READ VERTICAL COORDINATES                                            
+      PRINT*,'' 
+      PRINT*,"READ VERTICAL COORDS FROM UNIT ",NSIL 
+      READ(NSIL,*,IOSTAT=IRET) IDVCI,LEVSI,NVCOORDI 
+      write(*,*)'IDVCI=',IDVCI,' LEVSI=',LEVSI,' NVCOORDI=',NVCOORDI 
+      IF(IRET == 0) THEN 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+                                 ! Added by Moorthi for gaea            
+        if (nvcoordi == 0) then 
+          nvcoordi = nvcoord 
+          backspace nsil 
+          if (idvci > 5) then 
+            levsi    = idvci 
+            idvci    = 0 
+            idvc     = idvci 
+            nvcoordi = 1 
+            nvcoord  = nvcoordi 
+                                                                        
+            backspace nsil 
+            READ(NSIL,*,IOSTAT=IRET) (VCOORD(K,1),K=2,LEVS) 
+            VCOORD(1,1)      = 1. 
+            VCOORD(LEVS+1,1) = 0. 
+          else 
+            READ(NSIL,*,IOSTAT=IRET)                                    &
+                        ((VCOORD(K,N),N=1,NVCOORD),K=1,LEVS+1)          
+          endif 
+        elseif (nvcoordi <= 3) then 
+          READ(NSIL,*,IOSTAT=IRET)                                      &
+                        ((VCOORD(K,N),N=1,NVCOORD),K=1,LEVS+1)          
+        else 
+          write(0,*)'FATAL ERROR: nvcoordi=',nvcoordi,' not available-abort chgres' 
+          call errexit(55)
+        endif 
+        IF(IRET    .NE. 0) RETURN 
+        IF(IDVCI   .NE. IDVC.OR.LEVSI .NE. LEVS) IRET = 28 
+        IF(NVCOORDI.NE. NVCOORD)                 IRET = 28 
+        IF(IRET .NE. 0) RETURN 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  READ INTERFACE HYBRID VALUES                                         
+      ELSE 
+        REWIND NSIL 
+        READ(NSIL,*,IOSTAT=IRET) IDVCI 
+        REWIND NSIL 
+        IF(IRET == 0 .AND. (IDVCI == 2 .OR. IDVCI == 3)) THEN 
+          READ(NSIL,*,IOSTAT=IRET) IDVCI, LEVSI 
+          READ(NSIL,*,IOSTAT=IRET) (VCOORD(K,1),VCOORD(K,2),K=1,LEVS+1) 
+          IF(IRET.NE.0) RETURN 
+          IF(IDVCI.NE.IDVC.OR.LEVSI.NE.LEVS) IRET = 28 
+          IF(IRET.NE.0) RETURN 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  READ INTERFACE SIGMA VALUES                                          
+        ELSE 
+          VCOORD(1,1)      = 1. 
+          VCOORD(LEVS+1,1) = 0. 
+          READ(NSIL,*,IOSTAT=IRET) LEVSI 
+          READ(NSIL,*,IOSTAT=IRET) (VCOORD(K,1),K=2,LEVS) 
+          IF(IRET.NE.0) RETURN 
+          IF(LEVSI.NE.LEVS) IRET = 28 
+          IF(IRET.NE.0) RETURN 
+        ENDIF 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      ENDIF 
+      IRET=0 
+      END SUBROUTINE NEWSIG 
+!-----------------------------------------------------------------------
+      SUBROUTINE TRSSC(JCAP,NC,KM,NTRAC,IDVM,                           &
+                       IDRT,LONB,LATB,IJN,J1,J2,JC,LONSPERLAT,          &
+                       SZS,SPS,ST,SD,SZ,SQ,ZS,PS,T,U,V,Q)               
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    TRSSC       TRANSFORM SIGMA SPECTRAL FIELDS TO GRID    
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!                                                                       
+! ABSTRACT: TRANSFORMS SIGMA SPECTRAL FIELDS TO GRID AND CONVERTS       
+!   LOG SURFACE PRESSURE TO SURFACE PRESSURE AND VIRTUAL TEMPERATURE    
+!   TO TEMPERATURE.                                                     
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   91-10-31  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL TRSSC(JCAP,NC,KM,NTRAC,IDVM,                           
+!    &                 IDRT,LONB,LATB,IJN,J1,J2,JC,LONSPERLAT,          
+!    &                 SZS,SPS,ST,SD,SZ,SQ,ZS,PS,T,U,V,Q)               
+!   INPUT ARGUMENT LIST:                                                
+!     JCAP         INTEGER SPECTRAL TRUNCATION                          
+!     NC           INTEGER FIRST DIMENSION (NC>=(JCAP+1)*(JCAP+2))      
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     NTRAC        INTEGER NUMBER OF TRACERS                            
+!     IDVM         INTEGER MASS VARIABLE ID                             
+!     IDRT         INTEGER DATA REPRESENTATION TYPE                     
+!     LONB         INTEGER NUMBER OF LONGITUDES                         
+!     LATB         INTEGER NUMBER OF LATITUDES                          
+!     IJN          INTEGER HORIZONTAL DIMENSION                         
+!     J1           INTEGER FIRST LATITUDE                               
+!     J2           INTEGER LAST LATITUDE                                
+!     JC           INTEGER NUMBER OF CPUS                               
+!     LONSPERLAT   INTEGER (J1:J2) NUMBER OF LONGITUDES PER LATITUDE    
+!     SZS          REAL (NC) OROGRAPHY                                  
+!     SPS          REAL (NC) LOG SURFACE PRESSURE                       
+!     ST           REAL (NC,LEVS) VIRTUAL TEMPERATURE                   
+!     SD           REAL (NC,LEVS) DIVERGENCE                            
+!     SZ           REAL (NC,LEVS) VORTICITY                             
+!     SQ           REAL (NC,LEVS*NTRAC) TRACERS                         
+!   OUTPUT ARGUMENT LIST:                                               
+!     ZS           REAL (IJN) OROGRAPHY                                 
+!     PS           REAL (IJN) SURFACE PRESSURE                          
+!     T            REAL (IJN,KM) TEMPERATURE                            
+!     U            REAL (IJN,KM) ZONAL WIND                             
+!     V            REAL (IJN,KM) MERIDIONAL WIND                        
+!     Q            REAL (IJN,KM*NTRAC) TRACERS                          
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   SPTRAN       PERFORM A SCALAR SPHERICAL TRANSFORM                   
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      INTEGER LONSPERLAT(J1:J2) 
+      REAL SZS(NC),SPS(NC),ST(NC,KM),SD(NC,KM),SZ(NC,KM),SQ(NC,KM*NTRAC) 
+      REAL ZS(IJN),PS(IJN),T(IJN,KM),U(IJN,KM),V(IJN,KM),Q(IJN,KM*NTRAC) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  SPECTRAL TRANSFORMS                                                  
+      LONB2=LONB*2 
+      IJ=LONB2*(J2-J1+1) 
+      IN=1 
+      IS=1+LONB 
+      CALL SPTRAN(0,JCAP,IDRT,LONB,LATB,1,1,1,LONB2,LONB2,NC,IJN,       &
+                  J1,J2,JC,SZS,ZS(IN),ZS(IS),1)                         
+      CALL SPTRAN(0,JCAP,IDRT,LONB,LATB,1,1,1,LONB2,LONB2,NC,IJN,       &
+                  J1,J2,JC,SPS,PS(IN),PS(IS),1)                         
+      CALL SPTRAN(0,JCAP,IDRT,LONB,LATB,KM,1,1,LONB2,LONB2,NC,IJN,      &
+                  J1,J2,JC,ST,T(IN,1),T(IS,1),1)                        
+      CALL SPTRANV(0,JCAP,IDRT,LONB,LATB,KM,1,1,LONB2,LONB2,NC,IJN,     &
+                   J1,J2,JC,SD,SZ,U(IN,1),U(IS,1),V(IN,1),V(IS,1),1)    
+      CALL SPTRAN(0,JCAP,IDRT,LONB,LATB,KM*NTRAC,1,1,LONB2,LONB2,NC,IJN,&
+                  J1,J2,JC,SQ,Q(IN,1),Q(IS,1),1)                        
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  TRANSFORM TO REDUCED GRID INSTEAD                                    
+      DO J=J1,J2 
+        JN=LONB2*(J-J1)+IN 
+        JS=LONB2*(J-J1)+IS 
+        CALL SPTRRJ(LONB,LONSPERLAT(J),ZS(JN),ZS(JN),1) 
+        CALL SPTRRJ(LONB,LONSPERLAT(J),ZS(JS),ZS(JS),1) 
+        CALL SPTRRJ(LONB,LONSPERLAT(J),PS(JN),PS(JN),1) 
+        CALL SPTRRJ(LONB,LONSPERLAT(J),PS(JS),PS(JS),1) 
+        DO K=1,KM 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),T(JN,K),T(JN,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),T(JS,K),T(JS,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),U(JN,K),U(JN,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),U(JS,K),U(JS,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),V(JN,K),V(JN,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),V(JS,K),V(JS,K),1) 
+        ENDDO 
+        DO K=1,KM*NTRAC 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),Q(JN,K),Q(JN,K),1) 
+          CALL SPTRRJ(LONB,LONSPERLAT(J),Q(JS,K),Q(JS,K),1) 
+        ENDDO 
+      ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  CONVERT TO SURFACE PRESSURE AND TEMPERATURE                          
+!     SELECT CASE(MOD(IDVM,10))                                         
+!     CASE(0,1)                                                         
+!       DO I=1,IJ                                                       
+!         PS(I)=1.E3*EXP(PS(I))                                         
+!       ENDDO                                                           
+!     CASE(2)                                                           
+!       DO I=1,IJ                                                       
+!         PS(I)=1.E3*PS(I)                                              
+!       ENDDO                                                           
+!     CASE DEFAULT                                                      
+!       DO I=1,IJ                                                       
+!         PS(I)=1.E3*EXP(PS(I))                                         
+!       ENDDO                                                           
+!     END SELECT                                                        
+!     SELECT CASE(MOD(IDVM/10,10))                                      
+!     CASE(0,1)                                                         
+!       DO K=1,KM                                                       
+!         DO I=1,IJ                                                     
+!           T(I,K)=T(I,K)/(1.+(461.50/287.05-1)*Q(I,K))                 
+!     if (t(i,k) .lt. 10) print *,' t=',t(i,k),' i=',i                  
+!         ENDDO                                                         
+!     print *,' T=',t(ij,k),' q=',Q(IJ,K),' k=',k                       
+!       ENDDO                                                           
+!     CASE DEFAULT                                                      
+!       DO K=1,KM                                                       
+!         DO I=1,IJ                                                     
+!           T(I,K)=T(I,K)/(1.+(461.50/287.05-1)*Q(I,K))                 
+!         ENDDO                                                         
+!       ENDDO                                                           
+!     END SELECT                                                        
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      END SUBROUTINE TRSSC 
+!-----------------------------------------------------------------------
+      SUBROUTINE NEWPS(IM,ZS,PS,IMX,KM,P,T,Q,ZSNEW,PSNEW) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    NEWPS       COMPUTE NEW SURFACE PRESSURE               
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!                                                                       
+! ABSTRACT: COMPUTES A NEW SURFACE PRESSURE GIVEN A NEW OROGRAPHY.      
+!   THE NEW PRESSURE IS COMPUTED ASSUMING A HYDROSTATIC BALANCE         
+!   AND A CONSTANT TEMPERATURE LAPSE RATE.  BELOW GROUND, THE           
+!   LAPSE RATE IS ASSUMED TO BE -6.5 K/KM.                              
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   91-10-31  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL NEWPS(IM,ZS,PS,IMX,KM,P,T,Q,ZSNEW,PSNEW)               
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF POINTS TO COMPUTE                  
+!     ZS           REAL (IM) OLD OROGRAPHY (M)                          
+!     PS           REAL (IM) OLD SURFACE PRESSURE (PA)                  
+!     IMX          INTEGER FIRST DIMENSION                              
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     P            REAL (IMX,KM) PRESSURES (PA)                         
+!     T            REAL (IMX,KM) TEMPERATURES (K)                       
+!     Q            REAL (IMX,KM) SPECIFIC HUMIDITIES (KG/KG)            
+!     ZSNEW        REAL (IM) NEW OROGRAPHY (M)                          
+!   OUTPUT ARGUMENT LIST:                                               
+!     PSNEW        REAL (IM) NEW SURFACE PRESSURE (PA)                  
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      INTEGER,INTENT(IN)::IM,IMX,KM 
+      REAL,INTENT(IN):: ZS(IM),PS(IM),P(IMX,KM) 
+      REAL,INTENT(IN):: T(IMX,KM),Q(IMX,KM) 
+      REAL,INTENT(IN):: ZSNEW(IM) 
+      REAL,INTENT(OUT):: PSNEW(IM) 
+      PARAMETER(BETA=-6.5E-3,EPSILON=1.E-9) 
+      PARAMETER(G=9.80665,RD=287.05,RV=461.50) 
+      PARAMETER(GOR=G/RD,FV=RV/RD-1.) 
+      REAL ZU(IM) 
+      FTV(AT,AQ)=AT*(1+FV*AQ) 
+      FGAM(APU,ATVU,APD,ATVD)=-GOR*LOG(ATVD/ATVU)/LOG(APD/APU) 
+      FZ0(AP,ATV,AZD,APD)=AZD+ATV/GOR*LOG(APD/AP) 
+      FZ1(AP,ATV,AZD,APD,AGAM)=AZD-ATV/AGAM*((APD/AP)**(-AGAM/GOR)-1) 
+      FP0(AZ,AZU,APU,ATVU)=APU*EXP(-GOR/ATVU*(AZ-AZU)) 
+      FP1(AZ,AZU,APU,ATVU,AGAM)=APU*(1+AGAM/ATVU*(AZ-AZU))**(-GOR/AGAM) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE SURFACE PRESSURE BELOW THE ORIGINAL GROUND                   
+      LS=0 
+      K=1 
+      GAMMA=BETA 
+      DO I=1,IM 
+!       if (zsnew(i) == zs(i)) then                                     
+!         psnew(i) = ps(i)                                              
+!       else                                                            
+          PU=P(I,K) 
+          TVU=FTV(T(I,K),Q(I,K)) 
+          ZU(I)=FZ1(PU,TVU,ZS(I),PS(I),GAMMA) 
+          IF(ZSNEW(I).LE.ZU(I)) THEN 
+            PU=P(I,K) 
+            TVU=FTV(T(I,K),Q(I,K)) 
+            IF(ABS(GAMMA).GT.EPSILON) THEN 
+              PSNEW(I)=FP1(ZSNEW(I),ZU(I),PU,TVU,GAMMA) 
+            ELSE 
+              PSNEW(I)=FP0(ZSNEW(I),ZU(I),PU,TVU) 
+            ENDIF 
+          ELSE 
+            PSNEW(I)=0 
+            LS=LS+1 
+          ENDIF 
+!       endif                                                           
+      ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE SURFACE PRESSURE ABOVE THE ORIGINAL GROUND                   
+      DO K=2,KM 
+        IF(LS.GT.0) THEN 
+          DO I=1,IM 
+            IF(PSNEW(I).EQ.0) THEN 
+              PU=P(I,K) 
+              TVU=FTV(T(I,K),Q(I,K)) 
+              PD=P(I,K-1) 
+              TVD=FTV(T(I,K-1),Q(I,K-1)) 
+              GAMMA=FGAM(PU,TVU,PD,TVD) 
+              IF(ABS(GAMMA).GT.EPSILON) THEN 
+                ZU(I)=FZ1(PU,TVU,ZU(I),PD,GAMMA) 
+              ELSE 
+                ZU(I)=FZ0(PU,TVU,ZU(I),PD) 
+              ENDIF 
+              IF(ZSNEW(I).LE.ZU(I)) THEN 
+                IF(ABS(GAMMA).GT.EPSILON) THEN 
+                  PSNEW(I)=FP1(ZSNEW(I),ZU(I),PU,TVU,GAMMA) 
+                ELSE 
+                  PSNEW(I)=FP0(ZSNEW(I),ZU(I),PU,TVU) 
+                ENDIF 
+                LS=LS-1 
+              ENDIF 
+            ENDIF 
+          ENDDO 
+        ENDIF 
+      ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE SURFACE PRESSURE OVER THE TOP                                
+      IF(LS.GT.0) THEN 
+        K=KM 
+        GAMMA=0 
+        DO I=1,IM 
+          IF(PSNEW(I).EQ.0) THEN 
+            PU=P(I,K) 
+            TVU=FTV(T(I,K),Q(I,K)) 
+            PSNEW(I)=FP0(ZSNEW(I),ZU(I),PU,TVU) 
+          ENDIF 
+        ENDDO 
+      ENDIF 
+      END SUBROUTINE NEWPS 
+!-----------------------------------------------------------------------
+      SUBROUTINE VINTG(IM,IX,KM1,KM2,NT,P1,U1,V1,T1,Q1,W1,P2,           &
+                       U2,V2,T2,Q2,W2)                            
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    VINTG       VERTICALLY INTERPOLATE UPPER-AIR FIELDS    
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!                                                                       
+! ABSTRACT: VERTICALLY INTERPOLATE UPPER-AIR FIELDS.                    
+!   WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS ARE INTERPOLATED.     
+!   THE INTERPOLATION IS CUBIC LAGRANGIAN IN LOG PRESSURE               
+!   WITH A MONOTONIC CONSTRAINT IN THE CENTER OF THE DOMAIN.            
+!   IN THE OUTER INTERVALS IT IS LINEAR IN LOG PRESSURE.                
+!   OUTSIDE THE DOMAIN, FIELDS ARE GENERALLY HELD CONSTANT,             
+!   EXCEPT FOR TEMPERATURE AND HUMIDITY BELOW THE INPUT DOMAIN,         
+!   WHERE THE TEMPERATURE LAPSE RATE IS HELD FIXED AT -6.5 K/KM AND     
+!   THE RELATIVE HUMIDITY IS HELD CONSTANT.                             
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   91-10-31  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL VINTG(IM,IX,KM1,KM2,NT,P1,U1,V1,T1,Q1,P2,              
+!    &                 U2,V2,T2,Q2)                                     
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF POINTS TO COMPUTE                  
+!     IX           INTEGER FIRST DIMENSION                              
+!     KM1          INTEGER NUMBER OF INPUT LEVELS                       
+!     KM2          INTEGER NUMBER OF OUTPUT LEVELS                      
+!     NT           INTEGER NUMBER OF TRACERS                            
+!     P1           REAL (IX,KM1) INPUT PRESSURES                        
+!                  ORDERED FROM BOTTOM TO TOP OF ATMOSPHERE             
+!     U1           REAL (IX,KM1) INPUT ZONAL WIND                       
+!     V1           REAL (IX,KM1) INPUT MERIDIONAL WIND                  
+!     T1           REAL (IX,KM1) INPUT TEMPERATURE (K)                  
+!     Q1           REAL (IX,KM1,NT) INPUT TRACERS (HUMIDITY FIRST)      
+!     P2           REAL (IX,KM2) OUTPUT PRESSURES                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     U2           REAL (IX,KM2) OUTPUT ZONAL WIND                      
+!     V2           REAL (IX,KM2) OUTPUT MERIDIONAL WIND                 
+!     T2           REAL (IX,KM2) OUTPUT TEMPERATURE (K)                 
+!     Q2           REAL (IX,KM2,NT) OUTPUT TRACERS (HUMIDITY FIRST)     
+!     DTDP2        REAL (IX,KM2) OUTPUT DTDP                            
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   TERP3        CUBICALLY INTERPOLATE IN ONE DIMENSION                 
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      REAL P1(IX,KM1),U1(IX,KM1),V1(IX,KM1),T1(IX,KM1),Q1(IX,KM1,NT)    &
+           ,W1(IX,KM1)                                                  
+      REAL P2(IX,KM2),U2(IX,KM2),V2(IX,KM2),T2(IX,KM2),Q2(IX,KM2,NT)    &
+           ,W2(IX,KM2)                                                  
+!     REAL,optional :: DTDP2(IX,KM2) 
+      PARAMETER(DLTDZ=-6.5E-3*287.05/9.80665) 
+      PARAMETER(DLPVDRT=-2.5E6/461.50) 
+                                                                        
+      REAL,allocatable :: Z1(:,:),Z2(:,:) 
+      REAL,allocatable :: C1(:,:,:),C2(:,:,:),J2(:,:,:) 
+                                                                        
+      allocate (Z1(IM+1,KM1),Z2(IM+1,KM2)) 
+      allocate (C1(IM+1,KM1,4+NT),C2(IM+1,KM2,4+NT),J2(IM+1,KM2,4+NT)) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE LOG PRESSURE INTERPOLATING COORDINATE                        
+!  AND COPY INPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS         
+!$OMP PARALLEL DO DEFAULT(SHARED), &
+!$OMP& PRIVATE(K,I)                                                     
+      DO K=1,KM1 
+        DO I=1,IM 
+          Z1(I,K)   = -LOG(P1(I,K)) 
+          C1(I,K,1) =  U1(I,K) 
+          C1(I,K,2) =  V1(I,K) 
+          C1(I,K,3) =  W1(I,K) 
+          C1(I,K,4) =  T1(I,K) 
+          C1(I,K,5) =  Q1(I,K,1) 
+        ENDDO 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+      DO N=2,NT 
+        DO K=1,KM1 
+          DO I=1,IM 
+            C1(I,K,4+N) = Q1(I,K,N) 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+!$OMP PARALLEL DO DEFAULT(SHARED), &
+!$OMP& PRIVATE(K,I)                                                     
+      DO K=1,KM2 
+        DO I=1,IM 
+          Z2(I,K) = -LOG(P2(I,K)) 
+        ENDDO 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  PERFORM LAGRANGIAN ONE-DIMENSIONAL INTERPOLATION                     
+!  THAT IS 4TH-ORDER IN INTERIOR, 2ND-ORDER IN OUTSIDE INTERVALS        
+!  AND 1ST-ORDER FOR EXTRAPOLATION.                                     
+      CALL TERP3(IM,1,1,1,1,4+NT,(IM+1)*KM1,(IM+1)*KM2,                 &
+                 KM1,IM+1,IM+1,Z1,C1,KM2,IM+1,IM+1,Z2,C2,J2)            
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COPY OUTPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS            
+!  EXCEPT BELOW THE INPUT DOMAIN, LET TEMPERATURE INCREASE WITH A FIXED 
+!  LAPSE RATE AND LET THE RELATIVE HUMIDITY REMAIN CONSTANT.            
+      DO K=1,KM2 
+        DO I=1,IM 
+          U2(I,K)=C2(I,K,1) 
+          V2(I,K)=C2(I,K,2) 
+          W2(I,K)=C2(I,K,3) 
+          DZ=Z2(I,K)-Z1(I,1) 
+          IF(DZ.GE.0) THEN 
+            T2(I,K)=C2(I,K,4) 
+            Q2(I,K,1)=C2(I,K,5) 
+!jaa        DTDP2(I,K)=-J2(I,K,4)/P2(I,K)                               
+          ELSE 
+            T2(I,K)=T1(I,1)*EXP(DLTDZ*DZ) 
+            Q2(I,K,1)=Q1(I,1,1)*EXP(DLPVDRT*(1/T2(I,K)-1/T1(I,1))-DZ) 
+!jaa        DTDP2(I,K)=-T2(I,K)*DLTDZ/P2(I,K)                           
+          ENDIF 
+        ENDDO 
+      ENDDO 
+      DO N=2,NT 
+        DO K=1,KM2 
+          DO I=1,IM 
+            Q2(I,K,N)=C2(I,K,4+N) 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+      DEALLOCATE (Z1,Z2,C1,C2,J2) 
+      END SUBROUTINE VINTG 
+!-----------------------------------------------------------------------
+      SUBROUTINE TERP3(IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2,             &
+     &                 KM1,KXZ1,KXQ1,Z1,Q1,KM2,KXZ2,KXQ2,Z2,Q2,J2)      
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    TERP3       CUBICALLY INTERPOLATE IN ONE DIMENSION     
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 98-05-01            
+!                                                                       
+! ABSTRACT: INTERPOLATE FIELD(S) IN ONE DIMENSION ALONG THE COLUMN(S).  
+!   THE INTERPOLATION IS CUBIC LAGRANGIAN WITH A MONOTONIC CONSTRAINT   
+!   IN THE CENTER OF THE DOMAIN.  IN THE OUTER INTERVALS IT IS LINEAR.  
+!   OUTSIDE THE DOMAIN, FIELDS ARE HELD CONSTANT.                       
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   98-05-01  MARK IREDELL                                              
+! 1999-01-04  IREDELL  USE ESSL SEARCH                                  
+!                                                                       
+! USAGE:    CALL TERP3(IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2,             
+!    &                 KM1,KXZ1,KXQ1,Z1,Q1,KM2,KXZ2,KXQ2,Z2,Q2,J2)      
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF COLUMNS                            
+!     IXZ1         INTEGER COLUMN SKIP NUMBER FOR Z1                    
+!     IXQ1         INTEGER COLUMN SKIP NUMBER FOR Q1                    
+!     IXZ2         INTEGER COLUMN SKIP NUMBER FOR Z2                    
+!     IXQ2         INTEGER COLUMN SKIP NUMBER FOR Q2                    
+!     NM           INTEGER NUMBER OF FIELDS PER COLUMN                  
+!     NXQ1         INTEGER FIELD SKIP NUMBER FOR Q1                     
+!     NXQ2         INTEGER FIELD SKIP NUMBER FOR Q2                     
+!     KM1          INTEGER NUMBER OF INPUT POINTS                       
+!     KXZ1         INTEGER POINT SKIP NUMBER FOR Z1                     
+!     KXQ1         INTEGER POINT SKIP NUMBER FOR Q1                     
+!     Z1           REAL (1+(IM-1)*IXZ1+(KM1-1)*KXZ1)                    
+!                  INPUT COORDINATE VALUES IN WHICH TO INTERPOLATE      
+!                  (Z1 MUST BE STRICTLY MONOTONIC IN EITHER DIRECTION)  
+!     Q1           REAL (1+(IM-1)*IXQ1+(KM1-1)*KXQ1+(NM-1)*NXQ1)        
+!                  INPUT FIELDS TO INTERPOLATE                          
+!     KM2          INTEGER NUMBER OF OUTPUT POINTS                      
+!     KXZ2         INTEGER POINT SKIP NUMBER FOR Z2                     
+!     KXQ2         INTEGER POINT SKIP NUMBER FOR Q2                     
+!     Z2           REAL (1+(IM-1)*IXZ2+(KM2-1)*KXZ2)                    
+!                  OUTPUT COORDINATE VALUES TO WHICH TO INTERPOLATE     
+!                  (Z2 NEED NOT BE MONOTONIC)                           
+!                                                                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     Q2           REAL (1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2)        
+!                  OUTPUT INTERPOLATED FIELDS                           
+!     J2           REAL (1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2)        
+!                  OUTPUT INTERPOLATED FIELDS CHANGE WRT Z2             
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   RSEARCH      SEARCH FOR A SURROUNDING REAL INTERVAL                 
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2 
+      INTEGER KM1,KXZ1,KXQ1,KM2,KXZ2,KXQ2 
+      INTEGER I,K1,K2,N 
+      REAL Z1(1+(IM-1)*IXZ1+(KM1-1)*KXZ1) 
+      REAL Q1(1+(IM-1)*IXQ1+(KM1-1)*KXQ1+(NM-1)*NXQ1) 
+      REAL Z2(1+(IM-1)*IXZ2+(KM2-1)*KXZ2) 
+      REAL Q2(1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2) 
+      REAL J2(1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2) 
+      REAL FFA(IM),FFB(IM),FFC(IM),FFD(IM) 
+      REAL GGA(IM),GGB(IM),GGC(IM),GGD(IM) 
+      INTEGER K1S(IM,KM2) 
+      REAL Z1A,Z1B,Z1C,Z1D,Q1A,Q1B,Q1C,Q1D,Z2S,Q2S,J2S 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  FIND THE SURROUNDING INPUT INTERVAL FOR EACH OUTPUT POINT.           
+      CALL RSEARCH(IM,KM1,IXZ1,KXZ1,Z1,KM2,IXZ2,KXZ2,Z2,1,IM,K1S) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  GENERALLY INTERPOLATE CUBICALLY WITH MONOTONIC CONSTRAINT            
+!  FROM TWO NEAREST INPUT POINTS ON EITHER SIDE OF THE OUTPUT POINT,    
+!  BUT WITHIN THE TWO EDGE INTERVALS INTERPOLATE LINEARLY.              
+!  KEEP THE OUTPUT FIELDS CONSTANT OUTSIDE THE INPUT DOMAIN.            
+                                                                        
+!$OMP PARALLEL DO DEFAULT(PRIVATE) SHARED(IM,IXZ1,IXQ1,IXZ2)  , &
+!$OMP& SHARED(IXQ2,NM,NXQ1,NXQ2,KM1,KXZ1,KXQ1,Z1,Q1,KM2,KXZ2) , & 
+!$OMP& SHARED(KXQ2,Z2,Q2,J2,K1S)                                        
+                                                                        
+      DO K2=1,KM2 
+        DO I=1,IM 
+          K1=K1S(I,K2) 
+          IF(K1.EQ.1.OR.K1.EQ.KM1-1) THEN 
+            Z2S=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            Z1A=Z1(1+(I-1)*IXZ1+(K1-1)*KXZ1) 
+            Z1B=Z1(1+(I-1)*IXZ1+(K1+0)*KXZ1) 
+            FFA(I)=(Z2S-Z1B)/(Z1A-Z1B) 
+            FFB(I)=(Z2S-Z1A)/(Z1B-Z1A) 
+            GGA(I)=1/(Z1A-Z1B) 
+            GGB(I)=1/(Z1B-Z1A) 
+          ELSEIF(K1.GT.1.AND.K1.LT.KM1-1) THEN 
+            Z2S=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            Z1A=Z1(1+(I-1)*IXZ1+(K1-2)*KXZ1) 
+            Z1B=Z1(1+(I-1)*IXZ1+(K1-1)*KXZ1) 
+            Z1C=Z1(1+(I-1)*IXZ1+(K1+0)*KXZ1) 
+            Z1D=Z1(1+(I-1)*IXZ1+(K1+1)*KXZ1) 
+            FFA(I)=(Z2S-Z1B)/(Z1A-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1A-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1A-Z1D)                                  
+            FFB(I)=(Z2S-Z1A)/(Z1B-Z1A)*                                 &
+                   (Z2S-Z1C)/(Z1B-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1B-Z1D)                                  
+            FFC(I)=(Z2S-Z1A)/(Z1C-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1C-Z1B)*                                 &
+                   (Z2S-Z1D)/(Z1C-Z1D)                                  
+            FFD(I)=(Z2S-Z1A)/(Z1D-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1D-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1D-Z1C)                                  
+            GGA(I)=        1/(Z1A-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1A-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1A-Z1D)+                                 &
+                   (Z2S-Z1B)/(Z1A-Z1B)*                                 &
+                           1/(Z1A-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1A-Z1D)+                                 &
+                   (Z2S-Z1B)/(Z1A-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1A-Z1C)*                                 &
+                           1/(Z1A-Z1D)                                  
+            GGB(I)=        1/(Z1B-Z1A)*                                 &
+                   (Z2S-Z1C)/(Z1B-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1B-Z1D)+                                 &
+                   (Z2S-Z1A)/(Z1B-Z1A)*                                 &
+                           1/(Z1B-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1B-Z1D)+                                 &
+                   (Z2S-Z1A)/(Z1B-Z1A)*                                 &
+                   (Z2S-Z1C)/(Z1B-Z1C)*                                 &
+                           1/(Z1B-Z1D)                                  
+            GGC(I)=        1/(Z1C-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1C-Z1B)*                                 &
+                   (Z2S-Z1D)/(Z1C-Z1D)+                                 &
+                   (Z2S-Z1A)/(Z1C-Z1A)*                                 &
+                           1/(Z1C-Z1B)*                                 &
+                   (Z2S-Z1D)/(Z1C-Z1D)+                                 &
+                   (Z2S-Z1A)/(Z1C-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1C-Z1B)*                                 &
+                           1/(Z1C-Z1D)                                  
+            GGD(I)=        1/(Z1D-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1D-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1D-Z1C)+                                 &
+                   (Z2S-Z1A)/(Z1D-Z1A)*                                 &
+                           1/(Z1D-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1D-Z1C)+                                 &
+                   (Z2S-Z1A)/(Z1D-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1D-Z1B)*                                 &
+                           1/(Z1D-Z1C)                                  
+          ENDIF 
+        ENDDO 
+!  INTERPOLATE.                                                         
+        DO N=1,NM 
+          DO I=1,IM 
+            K1=K1S(I,K2) 
+            IF(K1.EQ.0) THEN 
+              Q2S=Q1(1+(I-1)*IXQ1+(N-1)*NXQ1) 
+              J2S=0 
+            ELSEIF(K1.EQ.KM1) THEN 
+              Q2S=Q1(1+(I-1)*IXQ1+(KM1-1)*KXQ1+(N-1)*NXQ1) 
+              J2S=0 
+            ELSEIF(K1.EQ.1.OR.K1.EQ.KM1-1) THEN 
+              Q1A=Q1(1+(I-1)*IXQ1+(K1-1)*KXQ1+(N-1)*NXQ1) 
+              Q1B=Q1(1+(I-1)*IXQ1+(K1+0)*KXQ1+(N-1)*NXQ1) 
+              Q2S=FFA(I)*Q1A+FFB(I)*Q1B 
+              J2S=GGA(I)*Q1A+GGB(I)*Q1B 
+            ELSE 
+              Q1A=Q1(1+(I-1)*IXQ1+(K1-2)*KXQ1+(N-1)*NXQ1) 
+              Q1B=Q1(1+(I-1)*IXQ1+(K1-1)*KXQ1+(N-1)*NXQ1) 
+              Q1C=Q1(1+(I-1)*IXQ1+(K1+0)*KXQ1+(N-1)*NXQ1) 
+              Q1D=Q1(1+(I-1)*IXQ1+(K1+1)*KXQ1+(N-1)*NXQ1) 
+              Q2S=FFA(I)*Q1A+FFB(I)*Q1B+FFC(I)*Q1C+FFD(I)*Q1D 
+              J2S=GGA(I)*Q1A+GGB(I)*Q1B+GGC(I)*Q1C+GGD(I)*Q1D 
+              IF(Q2S.LT.MIN(Q1B,Q1C)) THEN 
+                Q2S=MIN(Q1B,Q1C) 
+                J2S=0 
+              ELSEIF(Q2S.GT.MAX(Q1B,Q1C)) THEN 
+                Q2S=MAX(Q1B,Q1C) 
+                J2S=0 
+              ENDIF 
+            ENDIF 
+            Q2(1+(I-1)*IXQ2+(K2-1)*KXQ2+(N-1)*NXQ2)=Q2S 
+            J2(1+(I-1)*IXQ2+(K2-1)*KXQ2+(N-1)*NXQ2)=J2S 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      END SUBROUTINE TERP3 
+!-----------------------------------------------------------------------
+      SUBROUTINE RSEARCH(IM,KM1,IXZ1,KXZ1,Z1,KM2,IXZ2,KXZ2,Z2,IXL2,KXL2,&
+     &                   L2)                                            
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    RSEARCH     SEARCH FOR A SURROUNDING REAL INTERVAL     
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 98-05-01            
+!                                                                       
+! ABSTRACT: THIS SUBPROGRAM SEARCHES MONOTONIC SEQUENCES OF REAL NUMBERS
+!   FOR INTERVALS THAT SURROUND A GIVEN SEARCH SET OF REAL NUMBERS.     
+!   THE SEQUENCES MAY BE MONOTONIC IN EITHER DIRECTION; THE REAL NUMBERS
+!   MAY BE SINGLE OR DOUBLE PRECISION; THE INPUT SEQUENCES AND SETS     
+!   AND THE OUTPUT LOCATIONS MAY BE ARBITRARILY DIMENSIONED.            
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+! 1999-01-05  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL RSEARCH(IM,KM1,IXZ1,KXZ1,Z1,KM2,IXZ2,KXZ2,Z2,IXL2,KXL2,
+!    &                   L2)                                            
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF SEQUENCES TO SEARCH                
+!     KM1          INTEGER NUMBER OF POINTS IN EACH SEQUENCE            
+!     IXZ1         INTEGER SEQUENCE SKIP NUMBER FOR Z1                  
+!     KXZ1         INTEGER POINT SKIP NUMBER FOR Z1                     
+!     Z1           REAL (1+(IM-1)*IXZ1+(KM1-1)*KXZ1)                    
+!                  SEQUENCE VALUES TO SEARCH                            
+!                  (Z1 MUST BE MONOTONIC IN EITHER DIRECTION)           
+!     KM2          INTEGER NUMBER OF POINTS TO SEARCH FOR               
+!                  IN EACH RESPECTIVE SEQUENCE                          
+!     IXZ2         INTEGER SEQUENCE SKIP NUMBER FOR Z2                  
+!     KXZ2         INTEGER POINT SKIP NUMBER FOR Z2                     
+!     Z2           REAL (1+(IM-1)*IXZ2+(KM2-1)*KXZ2)                    
+!                  SET OF VALUES TO SEARCH FOR                          
+!                  (Z2 NEED NOT BE MONOTONIC)                           
+!     IXL2         INTEGER SEQUENCE SKIP NUMBER FOR L2                  
+!     KXL2         INTEGER POINT SKIP NUMBER FOR L2                     
+!                                                                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     L2           INTEGER (1+(IM-1)*IXL2+(KM2-1)*KXL2)                 
+!                  INTERVAL LOCATIONS HAVING VALUES FROM 0 TO KM1       
+!                  (Z2 WILL BE BETWEEN Z1(L2) AND Z1(L2+1))             
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   SBSRCH       ESSL BINARY SEARCH                                     
+!   DBSRCH       ESSL BINARY SEARCH                                     
+!                                                                       
+! REMARKS:                                                              
+!   IF THE ARRAY Z1 IS DIMENSIONED (IM,KM1), THEN THE SKIP NUMBERS ARE  
+!   IXZ1=1 AND KXZ1=IM; IF IT IS DIMENSIONED (KM1,IM), THEN THE SKIP    
+!   NUMBERS ARE IXZ1=KM1 AND KXZ1=1; IF IT IS DIMENSIONED (IM,JM,KM1),  
+!   THEN THE SKIP NUMBERS ARE IXZ1=1 AND KXZ1=IM*JM; ETCETERA.          
+!   SIMILAR EXAMPLES APPLY TO THE SKIP NUMBERS FOR Z2 AND L2.           
+!                                                                       
+!   RETURNED VALUES OF 0 OR KM1 INDICATE THAT THE GIVEN SEARCH VALUE    
+!   IS OUTSIDE THE RANGE OF THE SEQUENCE.                               
+!                                                                       
+!   IF A SEARCH VALUE IS IDENTICAL TO ONE OF THE SEQUENCE VALUES        
+!   THEN THE LOCATION RETURNED POINTS TO THE IDENTICAL VALUE.           
+!   IF THE SEQUENCE IS NOT STRICTLY MONOTONIC AND A SEARCH VALUE IS     
+!   IDENTICAL TO MORE THAN ONE OF THE SEQUENCE VALUES, THEN THE         
+!   LOCATION RETURNED MAY POINT TO ANY OF THE IDENTICAL VALUES.         
+!                                                                       
+!   TO BE EXACT, FOR EACH I FROM 1 TO IM AND FOR EACH K FROM 1 TO KM2,  
+!   Z=Z2(1+(I-1)*IXZ2+(K-1)*KXZ2) IS THE SEARCH VALUE AND               
+!   L=L2(1+(I-1)*IXL2+(K-1)*KXL2) IS THE LOCATION RETURNED.             
+!   IF L=0, THEN Z IS LESS THAN THE START POINT Z1(1+(I-1)*IXZ1)        
+!   FOR ASCENDING SEQUENCES (OR GREATER THAN FOR DESCENDING SEQUENCES). 
+!   IF L=KM1, THEN Z IS GREATER THAN OR EQUAL TO THE END POINT          
+!   Z1(1+(I-1)*IXZ1+(KM1-1)*KXZ1) FOR ASCENDING SEQUENCES               
+!   (OR LESS THAN OR EQUAL TO FOR DESCENDING SEQUENCES).                
+!   OTHERWISE Z IS BETWEEN THE VALUES Z1(1+(I-1)*IXZ1+(L-1)*KXZ1) AND   
+!   Z1(1+(I-1)*IXZ1+(L-0)*KXZ1) AND MAY EQUAL THE FORMER.               
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+!     IMPLICIT NONE                                                     
+!     INTEGER,INTENT(IN):: IM,KM1,IXZ1,KXZ1,KM2,IXZ2,KXZ2,IXL2,KXL2     
+!     REAL,INTENT(IN):: Z1(1+(IM-1)*IXZ1+(KM1-1)*KXZ1)                  
+!     REAL,INTENT(IN):: Z2(1+(IM-1)*IXZ2+(KM2-1)*KXZ2)                  
+!     INTEGER,INTENT(OUT):: L2(1+(IM-1)*IXL2+(KM2-1)*KXL2)              
+!     INTEGER(4) INCX,N,INCY,M,INDX(KM2),RC(KM2),IOPT                   
+!     INTEGER I,K2                                                      
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  FIND THE SURROUNDING INPUT INTERVAL FOR EACH OUTPUT POINT.           
+!     DO I=1,IM                                                         
+!       IF(Z1(1+(I-1)*IXZ1).LE.Z1(1+(I-1)*IXZ1+(KM1-1)*KXZ1)) THEN      
+!  INPUT COORDINATE IS MONOTONICALLY ASCENDING.                         
+!         INCX=KXZ2                                                     
+!         N=KM2                                                         
+!         INCY=KXZ1                                                     
+!         M=KM1                                                         
+!         IOPT=1                                                        
+!         IF(DIGITS(1.).LT.DIGITS(1._8)) THEN                           
+!           CALL SBSRCH(Z2(1+(I-1)*IXZ2),INCX,N,                        
+!    &                  Z1(1+(I-1)*IXZ1),INCY,M,INDX,RC,IOPT)           
+!         ELSE                                                          
+!           CALL DBSRCH(Z2(1+(I-1)*IXZ2),INCX,N,                        
+!    &                  Z1(1+(I-1)*IXZ1),INCY,M,INDX,RC,IOPT)           
+!         ENDIF                                                         
+!         DO K2=1,KM2                                                   
+!           L2(1+(I-1)*IXL2+(K2-1)*KXL2)=INDX(K2)-RC(K2)                
+!         ENDDO                                                         
+!       ELSE                                                            
+!  INPUT COORDINATE IS MONOTONICALLY DESCENDING.                        
+!         INCX=KXZ2                                                     
+!         N=KM2                                                         
+!         INCY=-KXZ1                                                    
+!         M=KM1                                                         
+!         IOPT=0                                                        
+!         IF(DIGITS(1.).LT.DIGITS(1._8)) THEN                           
+!           CALL SBSRCH(Z2(1+(I-1)*IXZ2),INCX,N,                        
+!    &                  Z1(1+(I-1)*IXZ1),INCY,M,INDX,RC,IOPT)           
+!         ELSE                                                          
+!           CALL DBSRCH(Z2(1+(I-1)*IXZ2),INCX,N,                        
+!    &                  Z1(1+(I-1)*IXZ1),INCY,M,INDX,RC,IOPT)           
+!         ENDIF                                                         
+!         DO K2=1,KM2                                                   
+!           L2(1+(I-1)*IXL2+(K2-1)*KXL2)=KM1+1-INDX(K2)                 
+!         ENDDO                                                         
+!       ENDIF                                                           
+!     ENDDO                                                             
+!                                                                       
+      IMPLICIT NONE 
+      INTEGER,INTENT(IN):: IM,KM1,IXZ1,KXZ1,KM2,IXZ2,KXZ2,IXL2,KXL2 
+      REAL,INTENT(IN):: Z1(1+(IM-1)*IXZ1+(KM1-1)*KXZ1) 
+      REAL,INTENT(IN):: Z2(1+(IM-1)*IXZ2+(KM2-1)*KXZ2) 
+      INTEGER,INTENT(OUT):: L2(1+(IM-1)*IXL2+(KM2-1)*KXL2) 
+      INTEGER I,K2,L 
+      REAL Z 
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  FIND THE SURROUNDING INPUT INTERVAL FOR EACH OUTPUT POINT.          
+      DO I=1,IM 
+        IF(Z1(1+(I-1)*IXZ1).LE.Z1(1+(I-1)*IXZ1+(KM1-1)*KXZ1)) THEN 
+!C  INPUT COORDINATE IS MONOTONICALLY ASCENDING.                        
+          DO K2=1,KM2 
+            Z=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            L=0 
+            DO 
+              IF(Z.LT.Z1(1+(I-1)*IXZ1+L*KXZ1)) EXIT 
+              L=L+1 
+              IF(L.EQ.KM1) EXIT 
+            ENDDO 
+            L2(1+(I-1)*IXL2+(K2-1)*KXL2)=L 
+          ENDDO 
+        ELSE 
+!C  INPUT COORDINATE IS MONOTONICALLY DESCENDING.                       
+          DO K2=1,KM2 
+            Z=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            L=0 
+            DO 
+              IF(Z.GT.Z1(1+(I-1)*IXZ1+L*KXZ1)) EXIT 
+              L=L+1 
+              IF(L.EQ.KM1) EXIT 
+            ENDDO 
+            L2(1+(I-1)*IXL2+(K2-1)*KXL2)=L 
+          ENDDO 
+        ENDIF 
+      ENDDO 
+                                                                        
+      END SUBROUTINE RSEARCH 
+!-----------------------------------------------------------------------
+      SUBROUTINE SPPAD(I1,M1,Q1,I2,M2,Q2) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    SPPAD       PAD OR TRUNCATE A SPECTRAL FIELD           
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!                                                                       
+! ABSTRACT: PAD OR TRUNCATE A SPECTRAL FIELD                            
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   91-10-31  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL SPPAD(I1,M1,Q1,I2,M2,Q2)                               
+!                                                                       
+!   INPUT ARGUMENT LIST:                                                
+!     I1       - INTEGER INPUT SPECTRAL DOMAIN SHAPE                    
+!                (0 FOR TRIANGULAR, 1 FOR RHOMBOIDAL)                   
+!     M1       - INTEGER INPUT SPECTRAL TRUNCATION                      
+!     Q1       - REAL ((M+1)*((I+1)*M+2)) INPUT FIELD                   
+!     I2       - INTEGER OUTPUT SPECTRAL DOMAIN SHAPE                   
+!                (0 FOR TRIANGULAR, 1 FOR RHOMBOIDAL)                   
+!     M2       - INTEGER OUTPUT SPECTRAL TRUNCATION                     
+!                                                                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     Q2       - REAL ((M+1)*((I+1)*M+2)) OUTPUT FIELD                  
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      REAL Q1((M1+1)*((I1+1)*M1+2)) 
+      REAL Q2((M2+1)*((I2+1)*M2+2)) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      DO L=0,M2 
+        DO N=L,I2*L+M2 
+          KS2=L*(2*M2+(I2-1)*(L-1))+2*N 
+          IF(L.LE.M1.AND.N.LE.I1*L+M1) THEN 
+            KS1=L*(2*M1+(I1-1)*(L-1))+2*N 
+            Q2(KS2+1)=Q1(KS1+1) 
+            Q2(KS2+2)=Q1(KS1+2) 
+          ELSE 
+            Q2(KS2+1)=0 
+            Q2(KS2+2)=0 
+          ENDIF 
+        ENDDO 
+      ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      RETURN 
+      END SUBROUTINE SPPAD 
+      SUBROUTINE SPECSETS(H,D,IDRT) 
+!-----------------------------------------------------------------------
+!$$$  Subprogram documentation block                                    
+!                                                                       
+! Subprogram: specsets       Create special tracer sets                 
+!   Prgmmr: Iredell          Org: W/NP23      Date: 2004-09-24          
+!                                                                       
+! Abstract: This subprogram optionally augments the tracers             
+!   in the global model initial conditions if special tracer set        
+!   are requested, based on the value of the tracer variable ID.        
+!                                                                       
+! Program history log:                                                  
+!   2004-09-24   Iredell                                                
+!                                                                       
+! Modules used:                                                         
+!   sigio_module   global model sigma file types and I/O                
+!                                                                       
+! Usage:    call specsets(h,d,idrt)                                     
+!   Input arguments:                                                    
+!     h            type(sigio_head) sigma file header                   
+!       ak                                                              
+!       bk                                                              
+!       idsl                                                            
+!       idvc                                                            
+!       idvt                                                            
+!       jcap                                                            
+!       latb                                                            
+!       levs                                                            
+!       lonb                                                            
+!       ntrac                                                           
+!       si                                                              
+!     d            type(sigio_data) sigma file data                     
+!       hs                                                              
+!       ps                                                              
+!       t                                                               
+!       d                                                               
+!       z                                                               
+!       q                                                               
+!                                                                       
+!   Output arguments:                                                   
+!     d            type(sigio_data) sigma file data                     
+!       q                                                               
+!                                                                       
+! Attributes:                                                           
+!   Language: Fortran90                                                 
+!                                                                       
+! Remarks:                                                              
+!   Pertinent values of h%idvt and h%ntrac                              
+!   idvt  ntrac                                                         
+!    100     20    set 1: vapor,ozone,cloud, and initial values of      
+!                  clat*clon,clat*slon,slat,                            
+!                  v*slon-u*slat*clon,-v*clon-u*slat*slon,u*clat        
+!                  one,k,sigma,ps,pres,temp,entropy,moist entropy       
+!                  vapor,ozone,cloud                                    
+!                                                                       
+!C$$$                                                                   
+        use sigio_module 
+        implicit none 
+        type(sigio_head),intent(in):: h 
+        type(sigio_dbta),intent(inout):: d 
+        integer, intent(in)   :: idrt 
+        real,dimension(h%latb):: slat,wlat 
+        real,dimension(h%lonb,h%latb):: hs,ps 
+        real,dimension(h%lonb,h%latb,h%levs):: pm,pd 
+        real,dimension(h%lonb,h%latb,h%levs):: t,u,v 
+        real,dimension(h%lonb,h%latb,h%levs,h%ntrac):: q 
+        real clat,rlon 
+        real, allocatable :: vcoord(:,:) 
+                                                                        
+        integer i,j,k,iret 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+        call splat(idrt,h%latb,slat,wlat) 
+        call sptez(0,h%jcap,idrt,h%lonb,h%latb,d%hs,hs,+1) 
+        call sptez(0,h%jcap,idrt,h%lonb,h%latb,d%ps,ps,+1) 
+        call sptezm(0,h%jcap,idrt,h%lonb,h%latb,h%levs,d%t,t,+1) 
+        call sptezmv(0,h%jcap,idrt,h%lonb,h%latb,h%levs,d%d,d%z,u,v,+1) 
+        call sptezm(0,h%jcap,idrt,h%lonb,h%latb,h%levs*3,d%q,q,+1) 
+        ps=1.e3*exp(ps) 
+        t=t/(1.+(461.50/287.05-1)*q(:,:,:,1)) 
+        allocate(vcoord(h%levs+1,h%nvcoord)) 
+        vcoord = h%vcoord 
+        call sigio_modprd(h%lonb*h%latb,h%lonb*h%latb,h%levs,h%nvcoord, &
+                          h%idvc,h%idsl,vcoord,iret,                    &
+                          ps=ps,t=t,pm=pm,pd=pd)                        
+       deallocate (vcoord) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+        if(h%idvt==100.and.h%ntrac==20) then 
+!$OMP PARALLEL DO DEFAULT(SHARED) , &
+!$OMP& PRIVATE(i,j,clat,rlon,k)                                         
+          do j=1,h%latb 
+            clat=sqrt(1-slat(j)**2) 
+            do i=1,h%lonb 
+              rlon=2*acos(-1.)*(i-1)/h%lonb 
+              q(i,j,:,4)=clat*cos(rlon) 
+              q(i,j,:,5)=clat*sin(rlon) 
+              q(i,j,:,6)=slat(j) 
+              q(i,j,:,7)=v(i,j,:)*sin(rlon)-u(i,j,:)*slat(j)*cos(rlon) 
+              q(i,j,:,8)=-v(i,j,:)*cos(rlon)-u(i,j,:)*slat(j)*sin(rlon) 
+              q(i,j,:,9)=u(i,j,:)*clat 
+              q(i,j,:,10)=1 
+              q(i,j,:,11)=(/(k,k=1,h%levs)/) 
+              q(i,j,:,12)=pm(i,j,:)/ps(i,j) 
+              q(i,j,:,13)=ps(i,j) 
+              q(i,j,:,14)=pm(i,j,:) 
+              q(i,j,:,15)=t(i,j,:) 
+              call dothe(1,1,h%levs,pm(i,j,:),t(i,j,:),q(i,j,:,1),      &
+                         q(i,j,:,16),q(i,j,:,17))                       
+              q(i,j,:,16)=1004.6*log(q(i,j,:,16)/273.15) 
+              q(i,j,:,17)=1004.6*log(q(i,j,:,17)/273.15) 
+              q(i,j,:,18)=q(i,j,:,1) 
+              q(i,j,:,19)=q(i,j,:,2) 
+              q(i,j,:,20)=q(i,j,:,3) 
+            enddo 
+          enddo 
+!$OMP END PARALLEL DO                                                   
+          call sptezm(0,h%jcap,idrt,h%lonb,h%latb,h%levs*(h%ntrac-3),   &
+                      d%q(1,1,4),q(1,1,1,4),-1)                         
+        endif 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      end subroutine specsets 
+!-----------------------------------------------------------------------
+      subroutine dothe(im,ix,km,p,t,q,th,the) 
+      use physcons 
+      use funcphys 
+      implicit none 
+      integer,intent(in):: im,ix,km 
+      real,intent(in):: p(ix,km),t(ix,km),q(ix,km) 
+      real,intent(out):: th(ix,km),the(ix,km) 
+      integer i,k 
+      real(krealfp) pr,tr,qr 
+      real(krealfp) qminr,elr,pvr,tdpdr,tlclr,pklclr 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  potential temperature                                                
+      do k=1,km 
+        do i=1,im 
+          pr=p(i,k) 
+          tr=t(i,k) 
+          th(i,k)=tr/fpkapx(pr) 
+        enddo 
+      enddo 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  equivalent potential temperature                                     
+      qminr=1.e-6 
+      do k=1,km 
+        do i=1,im 
+          pr=p(i,k) 
+          tr=t(i,k) 
+          qr=q(i,k) 
+          if(qr.lt.qminr) then 
+            elr=con_hvap+con_dldt*(tr-con_ttp) 
+            elr=elr*exp(-con_dldt/con_cp*(qminr-qr)) 
+            tr=(elr-con_hvap)/con_dldt+con_ttp 
+            qr=qminr 
+          endif 
+          pvr=pr*qr/(con_eps-con_epsm1*qr) 
+          tdpdr=tr-ftdpx(pvr) 
+          tlclr=ftlclx(tr,tdpdr) 
+          pklclr=fpkapx(pr)*tlclr/tr 
+          the(i,k)=fthex(tlclr,pklclr) 
+        enddo 
+      enddo 
+      end subroutine dothe 
+!-----------------------------------------------------------------------
+      SUBROUTINE NEWPR1(IM,IX,KM,KMP,IDVC,IDVM,IDSL,NVCOORD,VCOORD,     &
+     &                  RI, CPI, NTRACM,PP,TP,QP,PS,PM)
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    NEWPR1      COMPUTE MODEL PRESSURES                    
+!   PRGMMR: JUANG          ORG: W/NMC23     DATE: 2005-04-11            
+!   PRGMMR: Fanglin Yang   ORG: W/NMC23     DATE: 2006-11-28            
+!   PRGMMR: S. Moorthi     ORG: NCEP/EMC    DATE: 2006-12-12            
+!   PRGMMR: S. Moorthi     ORG: NCEP/EMC    DATE: 2007-01-02            
+!                                                                       
+! ABSTRACT: COMPUTE MODEL PRESSURES.                                    
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+! 2005-04-11  HANN_MING HENRY JUANG    hybrid sigma, sigma-p, and sigma-
+!                                                                       
+! USAGE:    CALL NEWPR1(IM,IX,KM,KMP,IDVC,IDSL,NVCOORD,VCOORD,PP,TP,QP,P
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF POINTS TO COMPUTE                  
+!     IX           INTEGER FIRST DIMENSION                              
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     KMP          INTEGER NUMBER OF OLD LEVELS                         
+!     IDVC         INTEGER VERTICAL COORDINATE ID                       
+!                  (1 FOR SIGMA AND 2 FOR HYBRID)                       
+!     IDSL         INTEGER TYPE OF SIGMA STRUCTURE                      
+!                  (1 FOR PHILLIPS OR 2 FOR MEAN)                       
+!     NVCOORD      INTEGER NUMBER OF VERTICAL COORDINATES               
+!     VCOORD       REAL (KM+1,NVCOORD) VERTICAL COORDINATE VALUES       
+!                  FOR IDVC=1, NVCOORD=1: SIGMA INTERFACE               
+!                  FOR IDVC=2, NVCOORD=2: HYBRID INTERFACE A AND B      
+!                  FOR IDVC=3, NVCOORD=3: JUANG GENERAL HYBRID INTERFACE
+!                     AK  REAL (KM+1) HYBRID INTERFACE A                
+!                     BK  REAL (KM+1) HYBRID INTERFACE B                
+!                     CK  REAL (KM+1) HYBRID INTERFACE C                
+!     PP           REAL (IX,KM) OLD PRESSURE                            
+!     TP           REAL (IX,KM) OLD TEMPERATURE                         
+!     QP           REAL (IX,KM) OLD SPECIFIC HUMIDITY                   
+!     PS           REAL (IX) SURFACE PRESSURE (PA)                      
+!   OUTPUT ARGUMENT LIST:                                               
+!     PM           REAL (IX,KM) MID-LAYER PRESSURE (PA)                 
+!     DP           REAL (IX,KM) LAYER DELTA PRESSURE (PA)               
+!   TEMPORARY                                                           
+!     PI           REAL (IX,KM+1) INTERFACE PRESSURE (PA)               
+!     SI           REAL (KM+1) SIGMA INTERFACE VALUES (IDVC=1)          
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      REAL, PARAMETER :: RD=287.05,  RV=461.50,    CP=1004.6,           &
+                         ROCP=RD/CP, ROCP1=ROCP+1, ROCPR=1/ROCP,        &
+                         FV=RV/RD-1.                                    
+      integer im, ix, km, kmp, idvc, idvm, idsl, nvcoord, ntracm 
+      real ri(0:ntracm), cpi(0:ntracm) 
+      REAL SI(KM+1),AK(KM+1),BK(KM+1),CK(KM+1) 
+      REAL VCOORD(KM+1,NVCOORD) 
+      REAL PS(IX),PI(IX,KM+1),PM(IX,KM) 
+!     REAL DP(IX,KM) 
+      REAL PP(IX,KMP),TP(IX,KMP),QP(IX,KMP,NTRACM) 
+      REAL PO(KMP),TO(KMP),QO(KMP,ntracm) 
+      REAL PN(KM ),TN(KM ),QN(KM,ntracm ), AKBKPS(KM) 
+      REAL TOV(KM),TRK,PIO(KM+1) 
+!                                                                       
+      real xcp, sumq, xcp2, sumq2, temu, temd, converg, dpmin,          &
+           dpminall, tvu, tvd, tem, tem1, cp0i, qnk                     
+      integer sfcpress_id, thermodyn_id, i, k, n, nit 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+                                                                        
+      sfcpress_id  = mod(IDVM,1) 
+      thermodyn_id = mod(IDVM/10,10) 
+                          ! hmhj for s-t                                
+      IF(IDVC.EQ.3) THEN 
+        DO K=1,KM 
+          AK(K)  = VCOORD(K,1) 
+          BK(K)  = VCOORD(K,2) 
+          CK(K)  = VCOORD(K,3) 
+          TOV(K) = 300.0 
+        ENDDO 
+        PI(1:IM,1)    = PS(1:IM) 
+        PI(1:IM,KM+1) = 0.0 
+!                                                                       
+! first guess : assume KMP=KM                                           
+!                                                                       
+        if (thermodyn_id <= 1) then 
+!!$OMP PARALLEL DO DEFAULT(PRIVATE) SHARED(KM,kmp,IM)                   
+!!$OMP+ SHARED(qn,qp,TOV,PI,AK,BK,PS,CK)                                
+!$omp  parallel do shared(km,kmp,im,qp,tp,tov,pi,ak,bk,ck) , &
+!$omp& private(i,k,tem,qnk,trk)                                         
+          DO K=2,KM 
+            tem = float(k-1) / float(kmp-1) 
+            DO I=1,IM 
+              qnk     = qp(i,1,1)  + (qp(i,kmp,1)-qp(i,1,1))*TEM 
+              TRK     = (TP(I,K)*(1.0+FV*QNK)/TOV(K)) ** ROCPR 
+                                                        ! p at interface
+              PI(I,K) = AK(K) + BK(K)*PS(I) + CK(K)*TRK	 
+            ENDDO 
+          ENDDO 
+!!$OMP END PARALLEL DO                                                  
+        elseif (thermodyn_id == 3) then 
+          cp0i = 1.0 / cpi(0) 
+          DO K=2,KM 
+            tem = float(k-1) / float(kmp-1) 
+            DO I=1,IM 
+              xcp  = 0.0 
+              sumq = 0.0 
+              do n=1,NTRACM 
+                qn(k,n) = qp(i,1,n)  + (qp(i,kmp,n)-qp(i,1,n))*TEM 
+                if( cpi(n).ne.0.0 ) then 
+                  xcp  = xcp  + cpi(n)*qn(k,n) 
+                  sumq = sumq + qn(k,n) 
+                endif 
+              enddo 
+              xcp  = (1.-sumq) + xcp * cp0i 
+              tem1 = tp(i,1) + (tp(i,kmp)-tp(i,1))*tem 
+              trk  = (tem1*xcp/tov(k)) ** ROCPR 
+                                                        ! p at interface
+              PI(I,K) = AK(K) + BK(K)*PS(I) + CK(K)*TRK	 
+            enddo 
+          enddo 
+        endif 
+                                                                        
+        DPMINALL=1000.0 
+!$omp parallel do   & 
+!$omp& shared(im,km,kmp,ntracm,thermodyn_id,pp,tp,qp,cpi,cp0i)  , &
+!$omp& shared(ak,bk,ck,pi)                                      ,&        
+!$omp& private(i,k,nit,converg,dpmin,tvu,tvd,trk)               ,&        
+!$omp& private(pio,po,to,qo,pn,tn,qn,akbkps)                    ,&        
+!$omp& private(xcp,xcp2,sumq,sumq2,temu,temd)                           
+!                                                                       
+        DO I=1,IM 
+          DO K=1,KMP 
+            PO(K)   = PP(I,K) 
+            TO(K)   = TP(I,K) 
+            QO(K,:) = QP(I,K,:) 
+          ENDDO 
+          do k=2,km 
+            akbkps(k) = ak(k) + bk(k)*ps(i) 
+          enddo 
+! iteration                                                             
+                      ! default number of iterations                    
+         DO Nit=1,400	 
+           CONVERG = 0.0 
+           DPMIN   = 1000.0 
+           DO K=1,KM+1 
+             PIO(K) = PI(I,K) 
+           ENDDO 
+           DO K=1,KM 
+             PN(K) = 0.5*(PIO(K)+PIO(K+1)) 
+           ENDDO 
+! do interpolation by the intrinsic method to get TN and QN             
+           if (thermodyn_id <= 1) then 
+             CALL VINTTQ(KMP,KM,PO,TO,QO(1,1),PN,TN,QN(1,1)) 
+             DO K=2,KM 
+               TVU = TN(K  )*(1.0+FV*QN(K,1)) 
+               TVD = TN(K-1)*(1.0+FV*QN(K-1,1)) 
+               TRK = ((TVD+TVU)/(TOV(K-1)+TOV(K))) ** ROCPR 
+               PI(I,K) = AKBKPS(K) + CK(K)*TRK 
+               CONVERG = MAX(CONVERG,ABS(PI(I,K)-PIO(K))                &
+                                       /(PI(I,K)+PIO(K)))               
+                                              ! make it converged faster
+               PI(I,K) = 0.5*(PI(I,K)+PIO(K))	 
+               DPMIN   = MIN(DPMIN,PI(I,K-1)-PI(I,K)) 
+             ENDDO 
+           elseif (thermodyn_id == 3) then 
+             CALL VINTTR(1,1,KMP,KM,NTRACM,PO,TO,QO,PN,TN,QN) 
+             DO K=2,KM 
+               xcp   = 0.0 
+               xcp2  = 0.0 
+               sumq  = 0.0 
+               sumq2 = 0.0 
+               do n=1,NTRACM 
+                 if( cpi(n).ne.0.0 ) then 
+                   xcp   = xcp   + cpi(n)*qn(k,n) 
+                   sumq  = sumq  + qn(k,n) 
+                   xcp2  = xcp2  + cpi(n)*qn(k-1,n) 
+                   sumq2 = sumq2 + qn(k-1,n) 
+                 endif 
+               enddo 
+               temu    = (1.-sumq)  + xcp*cp0i 
+               temd    = (1.-sumq2) + xcp2*cp0i 
+               trk     = ((tn(k)*temu + tn(k-1)*temd)                   &
+                       /  (TOV(K)     + TOV(K-1))) ** ROCPR             
+               PI(I,K) = AKBKPS(K) + CK(K)*TRK 
+               CONVERG = MAX(CONVERG,ABS(PI(I,K)-PIO(K))                &
+                                       /(PI(I,K)+PIO(K)))               
+                                                   ! make it converged f
+               PI(I,K) = 0.5*(PI(I,K)+PIO(K)) 
+               DPMIN   = MIN(DPMIN,PI(I,K-1)-PI(I,K)) 
+             ENDDO 
+!     if (i .eq. 1) print *,' converg=',converg,' nit=',nit             
+           endif 
+           IF( CONVERG.LE.1.E-6 ) GOTO 100 
+         ENDDO 
+  100    CONTINUE 
+!        PRINT *,'I=',I,' CONVERGED AT',Nit,' ITERATIONS',' DPMIN='     
+!    &,          DPMIN                                                  
+         DPMINALL = MIN(DPMINALL,DPMIN) 
+        ENDDO 
+!!$OMP END PARALLEL DO                                                  
+!       PRINT *,' ---- THE MINIMUM DP FOR A GROUP IS ',DPMINALL         
+      ELSE IF(IDVC.EQ.2) THEN 
+        DO K=1,KM+1 
+          AK(K)      = VCOORD(K,1) 
+          BK(K)      = VCOORD(K,2) 
+          PI(1:IM,K) = AK(K) + BK(K)*PS(1:IM) 
+        ENDDO 
+      ELSE 
+        DO K=1,KM+1 
+          SI(K)      = VCOORD(K,1) 
+          PI(1:IM,K) = SI(K)*PS(1:IM) 
+        ENDDO 
+      ENDIF 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      IF(IDSL.EQ.2) THEN 
+        DO K=1,KM 
+          PM(1:IM,K) = (PI(1:IM,K)+PI(1:IM,K+1))/2 
+        ENDDO 
+      ELSE 
+!$OMP PARALLEL DO DEFAULT(PRIVATE) SHARED(KM,PM,IM,PI)                  
+        DO K=1,KM 
+          PM(1:IM,K) = ((PI(1:IM,K)**ROCP1-PI(1:IM,K+1)**ROCP1)/        &
+                       (ROCP1*(PI(1:IM,K)-PI(1:IM,K+1))))**ROCPR        
+        ENDDO 
+!$OMP END PARALLEL DO                                                   
+      ENDIF 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!     DO K=1,KM 
+!       DO I=1,IM 
+!         DP(I,K) = PI(I,K) - PI(I,K+1) 
+!       ENDDO 
+!     ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      END SUBROUTINE NEWPR1 
+!-----------------------------------------------------------------------
+      SUBROUTINE CHECKDP(IM,IX,KM,AK,BK,CK,PS,TP,QP) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    CHECKDP       COMPUTE MODEL PRESSURES                  
+!   PRGMMR: JUANG          ORG: W/NMC23     DATE: 2005-04-11            
+!                                                                       
+! ABSTRACT: CHECK THICKNESS FOR SIGMA-THETA COORDINATE                  
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+! 2005-04-11  HANN_MING HENRY JUANG    hybrid sigma, sigma-p, and sigma-
+!                                                                       
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF POINTS TO COMPUTE                  
+!     IX           INTEGER FIRST DIMENSION                              
+!     KM           INTEGER NUMBER OF LEVELS                             
+!     AK           REAL (KM+1) HYBRID INTERFACE A                       
+!     BK           REAL (KM+1) HYBRID INTERFACE B                       
+!     CK           REAL (KM+1) HYBRID INTERFACE C                       
+!     TP           REAL (IX,KM) OLD TEMPERATURE                         
+!     QP           REAL (IX,KM) OLD SPECIFIC HUMIDITY                   
+!     PS           REAL (IX) SURFACE PRESSURE (PA)                      
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER IM,IX,KM 
+      REAL,PARAMETER  :: RD=287.05,RV=461.50,CP=1004.6 
+      REAL,PARAMETER  :: ROCP=RD/CP,ROCP1=ROCP+1,ROCPR=1./ROCP,         &
+                         FV=RV/RD-1.                                    
+      REAL AK(KM+1),BK(KM+1),CK(KM+1),PS(IX) 
+      REAL TP(IX,KM),QP(IX,KM),PI(IM,KM+1) 
+      REAL TOV(KM),TRK,TVU,TVD 
+      INTEGER K,I,KMIN 
+      REAL DPMIN,FTV,AT,AQ 
+!                                                                       
+      FTV(AT,AQ)=AT*(1+FV*AQ) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+        DO K=1,KM 
+          TOV(K) = 300.0 
+        ENDDO 
+        PI(1:IM,1)=PS(1:IM) 
+        PI(1:IM,KM+1)=0.0 
+!$OMP PARALLEL DO DEFAULT(SHARED)                  , &
+!$OMP& PRIVATE(K,I,TVU,TVD,TRK)                                         
+        DO K=2,KM 
+          DO I=1,IM 
+            TVU=FTV(TP(I,K  ),QP(I,K  )) 
+            TVD=FTV(TP(I,K-1),QP(I,K-1)) 
+            TRK = (TVD+TVU)/(TOV(K-1)+TOV(K)) 
+            TRK = TRK ** ROCPR 
+            PI(I,K)=AK(K)+BK(K)*PS(I)+CK(K)*TRK 
+          ENDDO 
+        ENDDO 
+!$OMP END PARALLEL DO                                                   
+                                                                        
+        DO I=1,IM 
+          DPMIN=1000. 
+          DO K=1,KM 
+            IF( PI(I,K)-PI(I,K+1) .LT. DPMIN ) THEN 
+              KMIN=K 
+              DPMIN=PI(I,K)-PI(I,K+1) 
+            ENDIF 
+          ENDDO 
+          IF( DPMIN.LT.0.0 )PRINT *,' I KMIN DPMIN ',I,KMIN,DPMIN 
+        ENDDO 
+      RETURN 
+      END SUBROUTINE CHECKDP 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      SUBROUTINE VINTTQ(KM1,KM2,P1,T1,Q1,P2,T2,Q2) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    VINTTQ   VERTICALLY INTERPOLATE UPPER-AIR T AND Q      
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!                                                                       
+! ABSTRACT: VERTICALLY INTERPOLATE UPPER-AIR FIELDS.                    
+!   WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS ARE INTERPOLATED.     
+!   THE INTERPOLATION IS CUBIC LAGRANGIAN IN LOG PRESSURE               
+!   WITH A MONOTONIC CONSTRAINT IN THE CENTER OF THE DOMAIN.            
+!   IN THE OUTER INTERVALS IT IS LINEAR IN LOG PRESSURE.                
+!   OUTSIDE THE DOMAIN, FIELDS ARE GENERALLY HELD CONSTANT,             
+!   EXCEPT FOR TEMPERATURE AND HUMIDITY BELOW THE INPUT DOMAIN,         
+!   WHERE THE TEMPERATURE LAPSE RATE IS HELD FIXED AT -6.5 K/KM AND     
+!   THE RELATIVE HUMIDITY IS HELD CONSTANT.                             
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   1991-10-31  MARK IREDELL                                            
+!   2005-08-31  Henry JUANG MODIFIED IT TO DO T AND Q FROM VINTG        
+!                                                                       
+! USAGE:    CALL VINTTQ(IM,IX,KM1,KM2,P1,T1,Q1,P2,T2,Q2)                
+!   INPUT ARGUMENT LIST:                                                
+!     KM1          INTEGER NUMBER OF INPUT LEVELS                       
+!     KM2          INTEGER NUMBER OF OUTPUT LEVELS                      
+!     P1           REAL (IX,KM1) INPUT PRESSURES                        
+!                  ORDERED FROM BOTTOM TO TOP OF ATMOSPHERE             
+!     T1           REAL (IX,KM1) INPUT TEMPERATURE (K)                  
+!     Q1           REAL (IX,KM1,NT) INPUT TRACERS (HUMIDITY FIRST)      
+!     P2           REAL (IX,KM2) OUTPUT PRESSURES                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     T2           REAL (IX,KM2) OUTPUT TEMPERATURE (K)                 
+!     Q2           REAL (IX,KM2,NT) OUTPUT TRACERS (HUMIDITY FIRST)     
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   TERP3_HJ     CUBICALLY INTERPOLATE IN ONE DIMENSION                 
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER KM1,KM2 
+      REAL P1(KM1),T1(KM1),Q1(KM1) 
+      REAL P2(KM2),T2(KM2),Q2(KM2) 
+      REAL,PARAMETER :: DLTDZ=-6.5E-3*287.05/9.80665 
+      REAL,PARAMETER :: DLPVDRT=-2.5E6/461.50 
+      REAL Z1(2,KM1),Z2(2,KM2) 
+      REAL C1(2,KM1,2),C2(2,KM2,2) 
+      INTEGER K 
+      REAL DZ 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE LOG PRESSURE INTERPOLATING COORDINATE                        
+!  AND COPY INPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS         
+!$OMP PARALLEL DO DEFAULT(SHARED)      , &
+!$OMP& PRIVATE(K)                                                       
+      DO K=1,KM1 
+        Z1(1,K)=-LOG(P1(K)) 
+        C1(1,K,1)=T1(K) 
+        C1(1,K,2)=Q1(K) 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+!$OMP PARALLEL DO DEFAULT(SHARED), &
+!$OMP& PRIVATE(K)                                                       
+      DO K=1,KM2 
+        Z2(1,K)=-LOG(P2(K)) 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  PERFORM LAGRANGIAN ONE-DIMENSIONAL INTERPOLATION                     
+!  THAT IS 4TH-ORDER IN INTERIOR, 2ND-ORDER IN OUTSIDE INTERVALS        
+!  AND 1ST-ORDER FOR EXTRAPOLATION.                                     
+      CALL TERP3_HJ(1,1,1,1,1,2,2*KM1,2*KM2,                            &
+                 KM1,2,2,Z1,C1,KM2,2,2,Z2,C2)                           
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COPY OUTPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS            
+!  EXCEPT BELOW THE INPUT DOMAIN, LET TEMPERATURE INCREASE WITH A FIXED 
+!  LAPSE RATE AND LET THE RELATIVE HUMIDITY REMAIN CONSTANT.            
+      DO K=1,KM2 
+        DZ=Z2(1,K)-Z1(1,1) 
+        IF(DZ.GE.0) THEN 
+          T2(K)=C2(1,K,1) 
+          Q2(K)=C2(1,K,2) 
+        ELSE 
+          T2(K)=T1(1)*EXP(DLTDZ*DZ) 
+          Q2(K)=Q1(1)*EXP(DLPVDRT*(1/T2(K)-1/T1(1))-DZ) 
+        ENDIF 
+      ENDDO 
+      END SUBROUTINE VINTTQ 
+!-----------------------------------------------------------------------
+      SUBROUTINE TERP3_HJ(IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2,          &
+                       KM1,KXZ1,KXQ1,Z1,Q1,KM2,KXZ2,KXQ2,Z2,Q2)         
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    TERP3_HJ    CUBICALLY INTERPOLATE IN ONE DIMENSION     
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 98-05-01            
+!                                                                       
+! ABSTRACT: INTERPOLATE FIELD(S) IN ONE DIMENSION ALONG THE COLUMN(S).  
+!   THE INTERPOLATION IS CUBIC LAGRANGIAN WITH A MONOTONIC CONSTRAINT   
+!   IN THE CENTER OF THE DOMAIN.  IN THE OUTER INTERVALS IT IS LINEAR.  
+!   OUTSIDE THE DOMAIN, FIELDS ARE HELD CONSTANT.                       
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   98-05-01  MARK IREDELL                                              
+! 1999-01-04  IREDELL  USE ESSL SEARCH                                  
+! 2006-11-10  SIMPLIFIED VERSION OF TERP3                               
+!                                                                       
+! USAGE:    CALL TERP3_HJ(IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2,          
+!    &                 KM1,KXZ1,KXQ1,Z1,Q1,KM2,KXZ2,KXQ2,Z2,Q2)         
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF COLUMNS                            
+!     IXZ1         INTEGER COLUMN SKIP NUMBER FOR Z1                    
+!     IXQ1         INTEGER COLUMN SKIP NUMBER FOR Q1                    
+!     IXZ2         INTEGER COLUMN SKIP NUMBER FOR Z2                    
+!     IXQ2         INTEGER COLUMN SKIP NUMBER FOR Q2                    
+!     NM           INTEGER NUMBER OF FIELDS PER COLUMN                  
+!     NXQ1         INTEGER FIELD SKIP NUMBER FOR Q1                     
+!     NXQ2         INTEGER FIELD SKIP NUMBER FOR Q2                     
+!     KM1          INTEGER NUMBER OF INPUT POINTS                       
+!     KXZ1         INTEGER POINT SKIP NUMBER FOR Z1                     
+!     KXQ1         INTEGER POINT SKIP NUMBER FOR Q1                     
+!     Z1           REAL (1+(IM-1)*IXZ1+(KM1-1)*KXZ1)                    
+!                  INPUT COORDINATE VALUES IN WHICH TO INTERPOLATE      
+!                  (Z1 MUST BE STRICTLY MONOTONIC IN EITHER DIRECTION)  
+!     Q1           REAL (1+(IM-1)*IXQ1+(KM1-1)*KXQ1+(NM-1)*NXQ1)        
+!                  INPUT FIELDS TO INTERPOLATE                          
+!     KM2          INTEGER NUMBER OF OUTPUT POINTS                      
+!     KXZ2         INTEGER POINT SKIP NUMBER FOR Z2                     
+!     KXQ2         INTEGER POINT SKIP NUMBER FOR Q2                     
+!     Z2           REAL (1+(IM-1)*IXZ2+(KM2-1)*KXZ2)                    
+!                  OUTPUT COORDINATE VALUES TO WHICH TO INTERPOLATE     
+!                  (Z2 NEED NOT BE MONOTONIC)                           
+!                                                                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     Q2           REAL (1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2)        
+!                  OUTPUT INTERPOLATED FIELDS                           
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   RSEARCH      SEARCH FOR A SURROUNDING REAL INTERVAL                 
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER IM,IXZ1,IXQ1,IXZ2,IXQ2,NM,NXQ1,NXQ2,KM1,KXZ1,KXQ1,        &
+              KM2,KXZ2,KXQ2                                             
+      REAL Z1(1+(IM-1)*IXZ1+(KM1-1)*KXZ1) 
+      REAL Q1(1+(IM-1)*IXQ1+(KM1-1)*KXQ1+(NM-1)*NXQ1) 
+      REAL Z2(1+(IM-1)*IXZ2+(KM2-1)*KXZ2) 
+      REAL Q2(1+(IM-1)*IXQ2+(KM2-1)*KXQ2+(NM-1)*NXQ2) 
+      REAL FFA(IM),FFB(IM),FFC(IM),FFD(IM) 
+      INTEGER K1S(IM,KM2) 
+      REAL Q2S,Q1A,Q1B,Q1C,Q1D,Z2S,Z1A,Z1B,Z1C,Z1D 
+      INTEGER I,K1,K2,N 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  FIND THE SURROUNDING INPUT INTERVAL FOR EACH OUTPUT POINT.           
+      CALL RSEARCH(IM,KM1,IXZ1,KXZ1,Z1,KM2,IXZ2,KXZ2,Z2,1,IM,K1S) 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  GENERALLY INTERPOLATE CUBICALLY WITH MONOTONIC CONSTRAINT            
+!  FROM TWO NEAREST INPUT POINTS ON EITHER SIDE OF THE OUTPUT POINT,    
+!  BUT WITHIN THE TWO EDGE INTERVALS INTERPOLATE LINEARLY.              
+!  KEEP THE OUTPUT FIELDS CONSTANT OUTSIDE THE INPUT DOMAIN.            
+      DO K2=1,KM2 
+        DO I=1,IM 
+          K1=K1S(I,K2) 
+          IF(K1.EQ.1.OR.K1.EQ.KM1-1) THEN 
+            Z2S=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            Z1A=Z1(1+(I-1)*IXZ1+(K1-1)*KXZ1) 
+            Z1B=Z1(1+(I-1)*IXZ1+(K1+0)*KXZ1) 
+            FFA(I)=(Z2S-Z1B)/(Z1A-Z1B) 
+            FFB(I)=(Z2S-Z1A)/(Z1B-Z1A) 
+          ELSEIF(K1.GT.1.AND.K1.LT.KM1-1) THEN 
+            Z2S=Z2(1+(I-1)*IXZ2+(K2-1)*KXZ2) 
+            Z1A=Z1(1+(I-1)*IXZ1+(K1-2)*KXZ1) 
+            Z1B=Z1(1+(I-1)*IXZ1+(K1-1)*KXZ1) 
+            Z1C=Z1(1+(I-1)*IXZ1+(K1+0)*KXZ1) 
+            Z1D=Z1(1+(I-1)*IXZ1+(K1+1)*KXZ1) 
+            FFA(I)=(Z2S-Z1B)/(Z1A-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1A-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1A-Z1D)                                  
+            FFB(I)=(Z2S-Z1A)/(Z1B-Z1A)*                                 &
+                   (Z2S-Z1C)/(Z1B-Z1C)*                                 &
+                   (Z2S-Z1D)/(Z1B-Z1D)                                  
+            FFC(I)=(Z2S-Z1A)/(Z1C-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1C-Z1B)*                                 &
+                   (Z2S-Z1D)/(Z1C-Z1D)                                  
+            FFD(I)=(Z2S-Z1A)/(Z1D-Z1A)*                                 &
+                   (Z2S-Z1B)/(Z1D-Z1B)*                                 &
+                   (Z2S-Z1C)/(Z1D-Z1C)                                  
+          ENDIF 
+        ENDDO 
+!  INTERPOLATE.                                                         
+        DO N=1,NM 
+          DO I=1,IM 
+            K1=K1S(I,K2) 
+            IF(K1.EQ.0) THEN 
+              Q2S=Q1(1+(I-1)*IXQ1+(N-1)*NXQ1) 
+            ELSEIF(K1.EQ.KM1) THEN 
+              Q2S=Q1(1+(I-1)*IXQ1+(KM1-1)*KXQ1+(N-1)*NXQ1) 
+            ELSEIF(K1.EQ.1.OR.K1.EQ.KM1-1) THEN 
+              Q1A=Q1(1+(I-1)*IXQ1+(K1-1)*KXQ1+(N-1)*NXQ1) 
+              Q1B=Q1(1+(I-1)*IXQ1+(K1+0)*KXQ1+(N-1)*NXQ1) 
+              Q2S=FFA(I)*Q1A+FFB(I)*Q1B 
+            ELSE 
+              Q1A=Q1(1+(I-1)*IXQ1+(K1-2)*KXQ1+(N-1)*NXQ1) 
+              Q1B=Q1(1+(I-1)*IXQ1+(K1-1)*KXQ1+(N-1)*NXQ1) 
+              Q1C=Q1(1+(I-1)*IXQ1+(K1+0)*KXQ1+(N-1)*NXQ1) 
+              Q1D=Q1(1+(I-1)*IXQ1+(K1+1)*KXQ1+(N-1)*NXQ1) 
+              Q2S=MIN(MAX(                                              &
+                  FFA(I)*Q1A+FFB(I)*Q1B+FFC(I)*Q1C+FFD(I)*Q1D,          &
+                  MIN(Q1B,Q1C)),MAX(Q1B,Q1C))                           
+            ENDIF 
+            Q2(1+(I-1)*IXQ2+(K2-1)*KXQ2+(N-1)*NXQ2)=Q2S 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+      END SUBROUTINE TERP3_HJ 
+!-----------------------------------------------------------------------
+      SUBROUTINE VINTTR(IM,IX,KM1,KM2,NT,P1,T1,Q1,P2,T2,Q2) 
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! SUBPROGRAM:    VINTG       VERTICALLY INTERPOLATE UPPER-AIR FIELDS    
+!   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31            
+!   PRGMMR: S. MOORTHI       ORG: NCEP/EMC    DATE: 2006-12-12          
+!                                                                       
+! ABSTRACT: VERTICALLY INTERPOLATE UPPER-AIR FIELDS.                    
+!   WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS ARE INTERPOLATED.     
+!   THE INTERPOLATION IS CUBIC LAGRANGIAN IN LOG PRESSURE               
+!   WITH A MONOTONIC CONSTRAINT IN THE CENTER OF THE DOMAIN.            
+!   IN THE OUTER INTERVALS IT IS LINEAR IN LOG PRESSURE.                
+!   OUTSIDE THE DOMAIN, FIELDS ARE GENERALLY HELD CONSTANT,             
+!   EXCEPT FOR TEMPERATURE AND HUMIDITY BELOW THE INPUT DOMAIN,         
+!   WHERE THE TEMPERATURE LAPSE RATE IS HELD FIXED AT -6.5 K/KM AND     
+!   THE RELATIVE HUMIDITY IS HELD CONSTANT.                             
+!                                                                       
+! PROGRAM HISTORY LOG:                                                  
+!   91-10-31  MARK IREDELL                                              
+!                                                                       
+! USAGE:    CALL VINTTR(IM,IX,KM1,KM2,NT,P1,T1,Q1,P2,T2,Q2)             
+!   INPUT ARGUMENT LIST:                                                
+!     IM           INTEGER NUMBER OF POINTS TO COMPUTE                  
+!     IX           INTEGER FIRST DIMENSION                              
+!     KM1          INTEGER NUMBER OF INPUT LEVELS                       
+!     KM2          INTEGER NUMBER OF OUTPUT LEVELS                      
+!     NT           INTEGER NUMBER OF TRACERS                            
+!     P1           REAL (IX,KM1) INPUT PRESSURES                        
+!                  ORDERED FROM BOTTOM TO TOP OF ATMOSPHERE             
+!     T1           REAL (IX,KM1) INPUT TEMPERATURE (K)                  
+!     Q1           REAL (IX,KM1,NT) INPUT TRACERS (HUMIDITY FIRST)      
+!     P2           REAL (IX,KM2) OUTPUT PRESSURES                       
+!   OUTPUT ARGUMENT LIST:                                               
+!     T2           REAL (IX,KM2) OUTPUT TEMPERATURE (K)                 
+!     Q2           REAL (IX,KM2,NT) OUTPUT TRACERS (HUMIDITY FIRST)     
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   TERP3        CUBICALLY INTERPOLATE IN ONE DIMENSION                 
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER IM,IX,KM1,KM2,NT 
+      REAL P1(IX,KM1),T1(IX,KM1),Q1(IX,KM1,NT) 
+      REAL P2(IX,KM2),T2(IX,KM2),Q2(IX,KM2,NT) 
+      REAL,PARAMETER :: DLTDZ=-6.5E-3*287.05/9.80665 
+      REAL,PARAMETER :: DLPVDRT=-2.5E6/461.50 
+      REAL Z1(IM+1,KM1),Z2(IM+1,KM2) 
+      REAL C1(IM+1,KM1,1+NT),C2(IM+1,KM2,1+NT),J2(IM+1,KM2,1+NT) 
+      INTEGER I,N,K 
+      REAL DZ 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COMPUTE LOG PRESSURE INTERPOLATING COORDINATE                        
+!  AND COPY INPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS         
+                                                                        
+!$OMP PARALLEL DO DEFAULT(SHARED)       , &
+!$OMP& PRIVATE(K,I)                                                     
+      DO K=1,KM1 
+        DO I=1,IM 
+          Z1(I,K)=-LOG(P1(I,K)) 
+          C1(I,K,1)=T1(I,K) 
+          C1(I,K,2)=Q1(I,K,1) 
+        ENDDO 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+      DO N=2,NT 
+        DO K=1,KM1 
+          DO I=1,IM 
+            C1(I,K,1+N)=Q1(I,K,N) 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+!$OMP PARALLEL DO DEFAULT(SHARED)  , &
+!$OMP& PRIVATE(K,I)                                                     
+      DO K=1,KM2 
+        DO I=1,IM 
+          Z2(I,K)=-LOG(P2(I,K)) 
+        ENDDO 
+      ENDDO 
+!$OMP END PARALLEL DO                                                   
+                                                                        
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  PERFORM LAGRANGIAN ONE-DIMENSIONAL INTERPOLATION                     
+!  THAT IS 4TH-ORDER IN INTERIOR, 2ND-ORDER IN OUTSIDE INTERVALS        
+!  AND 1ST-ORDER FOR EXTRAPOLATION.                                     
+      CALL TERP3(IM,1,1,1,1,1+NT,(IM+1)*KM1,(IM+1)*KM2,                 &
+                 KM1,IM+1,IM+1,Z1,C1,KM2,IM+1,IM+1,Z2,C2,J2)            
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+!  COPY OUTPUT WIND, TEMPERATURE, HUMIDITY AND OTHER TRACERS            
+!  EXCEPT BELOW THE INPUT DOMAIN, LET TEMPERATURE INCREASE WITH A FIXED 
+!  LAPSE RATE AND LET THE RELATIVE HUMIDITY REMAIN CONSTANT.            
+      DO K=1,KM2 
+!       print *,' p2=',p2(1,k),' k=',k                                  
+!       print *,' J2=',j2(1,k,3),' k=',k                                
+        DO I=1,IM 
+          DZ=Z2(I,K)-Z1(I,1) 
+          IF(DZ.GE.0) THEN 
+            T2(I,K)=C2(I,K,1) 
+            Q2(I,K,1)=C2(I,K,2) 
+          ELSE 
+            T2(I,K)=T1(I,1)*EXP(DLTDZ*DZ) 
+            Q2(I,K,1)=Q1(I,1,1)*EXP(DLPVDRT*(1/T2(I,K)-1/T1(I,1))-DZ) 
+          ENDIF 
+        ENDDO 
+      ENDDO 
+      DO N=2,NT 
+        DO K=1,KM2 
+          DO I=1,IM 
+            Q2(I,K,N)=C2(I,K,1+N) 
+          ENDDO 
+        ENDDO 
+      ENDDO 
+      END SUBROUTINE VINTTR 
+                                                                        
+!-----------------------------------------------------------------------
+       subroutine getomega(jcap,nc,km,idvc,idvm,idrt,idsl,nvcoord,      &
+            vcoord,lonb,latb,ijl,ijn,j1,j2,jc,sd,sps,psi,ti,ui,vi,wi)
+       use sigio_module, only : sigio_modprd 
+       implicit none 
+!                                                                       
+       integer,intent(in):: jcap,nc,km,idvc,idvm,idrt,idsl,nvcoord 
+       integer,intent(in):: lonb,latb,ijl,j1,j2,jc,ijn 
+       real,intent(in):: vcoord(km+1,nvcoord) 
+       real,intent(in):: sd(nc,km),sps(nc) 
+       real,intent(in):: psi(ijn),ti(ijn,km),ui(ijn,km),vi(ijn,km) 
+       real,intent(out):: wi(ijn,km) 
+       real :: pd(ijn,km),pi(ijn,km+1),pm(ijn,km) 
+       real :: os 
+       real dpmdps(ijn,km),dpddps(ijn,km),dpidps(ijn,km+1),vgradp,psmean 
+       real di(ijn,km),psx(ijn),psy(ijn) 
+       integer k,i,ij,lonb2,in,is,iret 
+!----1. spectral transform                                              
+      lonb2=lonb*2 
+      ij=lonb2*(j2-j1+1) 
+      in=1 
+      is=1+lonb 
+      call sptrand(0,jcap,idrt,lonb,latb,1,1,1,lonb2,lonb2,nc,ijn,      &
+           j1,j2,jc,sps,psmean,                                         &
+           psx(in),psx(is),psy(in),psy(is),1)                           
+      SELECT CASE(MOD(IDVM,10)) 
+      CASE(0,1) 
+          continue 
+      CASE(2) 
+!$OMP PARALLEL DO DEFAULT(SHARED)                , &
+!$OMP& PRIVATE(i)                                                       
+          do i=1,ijn 
+           psx(i)=psx(i)/(psi(i)*1.0E-3) 
+           psy(i)=psy(i)/(psi(i)*1.0E-3) 
+          enddo 
+!$OMP END PARALLEL DO                                                   
+      CASE DEFAULT 
+!$OMP PARALLEL DO DEFAULT(SHARED)        , &
+!$OMP& PRIVATE(i)                                                       
+          do i=1,ijn 
+           psx(i)=psx(i)/psi(i) 
+           psy(i)=psy(i)/psi(i) 
+          enddo 
+!$OMP END PARALLEL DO                                                   
+      END SELECT 
+                                                                        
+!$OMP PARALLEL DO DEFAULT(SHARED)                             , &
+!$OMP& PRIVATE(K)                                                       
+      do K=1,km 
+        call sptran(0,jcap,idrt,lonb,latb,1,1,1,lonb2,lonb2,nc,ijn,     &
+           j1,j2,jc,sd(1,k),di(in,k),di(is,k),1)                        
+      enddo 
+!$OMP END PARALLEL DO                                                   
+                                                                        
+       call sigio_modprd(ijl,ijn,km,nvcoord,idvc,idsl,vcoord,iret,      &
+                   ps=psi,t=ti,pm=pm,pd=pd,dpmdps=dpmdps,dpddps=dpddps) 
+                                                                        
+!----3.omeda from modstuff                                              
+!$OMP PARALLEL DO DEFAULT(SHARED)                     , &
+!$OMP& PRIVATE(i)                                                       
+      do i=1,ijl 
+       pi(i,1)=psi(i) 
+       dpidps(i,1)=1. 
+       do k=1,km 
+         pi(i,k+1)=pi(i,k)-pd(i,k) 
+         dpidps(i,k+1)=dpidps(i,k)-dpddps(i,k) 
+       enddo 
+       os=0. 
+       do k=km,1,-1 
+        vgradp=ui(i,k)*psx(i)+vi(i,k)*psy(i) 
+        os=os-vgradp*psi(i)*(dpmdps(i,k)-dpidps(i,k+1))-                &
+           di(i,k)*(pm(i,k)-pi(i,k+1))                                  
+        wi(i,k)=vgradp*psi(i)*dpmdps(i,k)+os 
+        os=os-vgradp*psi(i)*(dpidps(i,k)-dpmdps(i,k))-                  &
+           di(i,k)*(pi(i,k)-pm(i,k))                                    
+       enddo 
+!                                                                       
+      enddo 
+!$OMP END PARALLEL DO                                                   
+       return 
+       end subroutine getomega 
+      subroutine sptrrj(imax,lonsperlat,grid,gred,idir) 
+        implicit none 
+        integer,intent(in):: imax,lonsperlat,idir 
+        real,intent(inout):: grid(imax),gred(imax) 
+        real four(imax+2),gour(lonsperlat) 
+        integer i,iour 
+        real rred 
+                                                                        
+        rred = lonsperlat/real(imax) 
+        four = 0 
+!! take transformed to full 'grid' and make it like transformed to reduc
+        if(idir > 0) then 
+          call spfft1(imax,imax/2+1,imax,1,four,grid,-idir) 
+          call spfft1(lonsperlat,imax/2+1,imax,1,four,gour,idir) 
+          do i=1,imax 
+            iour = nint((i-1)*rred)+1 
+            if(iour == lonsperlat+1) iour  =1 
+            gred(i) = gour(iour) 
+          enddo 
+!! take transformed to reduced and interpolated 'gred' and make it like 
+        elseif(idir < 0) then 
+          do iour=1,lonsperlat 
+            i = nint((iour-1)/rred)+1 
+            if(i == imax+1) i = 1 
+            gour(iour) = gred(i) 
+          enddo 
+          call spfft1(lonsperlat,imax/2+1,imax,1,four,gour,idir) 
+          call spfft1(imax,imax/2+1,imax,1,four,grid,-idir) 
+        endif 
+      end subroutine sptrrj 
+      subroutine compute_zh(im, jm, levp, ak_in, bk_in, ps, zs, t, sphum, zh) 
+       implicit none 
+       integer, intent(in):: levp, im,jm 
+       real,    intent(in), dimension(levp+1):: ak_in, bk_in 
+       real,    intent(in), dimension(im,jm):: ps, zs 
+       real,    intent(in), dimension(im,jm,levp):: t 
+       real,    intent(in), dimension(im,jm,levp):: sphum 
+       real,    intent(out), dimension(im,jm,levp+1):: zh 
+       ! Local:                                                         
+       real, dimension(im,levp+1):: pe0, pn0 
+       real, dimension(levp+1) :: ak, bk 
+       integer i,j,k 
+       real, parameter :: GRAV   = 9.80665 
+       real, parameter :: RDGAS  = 287.05 
+       real, parameter :: RVGAS = 461.50 
+       real, parameter :: e0 = 610.71 
+       real, parameter :: hlv = 2.501e6 
+       real, parameter :: tfreeze = 273.15 
+       real  :: zvir 
+       real:: grd 
+       grd = grav/rdgas 
+       zvir = rvgas/rdgas - 1. 
+       ak = ak_in 
+       bk = bk_in 
+       ak(levp+1) = max(1.e-9, ak(levp+1)) 
+                                                                        
+       do j = 1, jm 
+         do i=1, im 
+           pe0(i,levp+1) = ak(levp+1) 
+           pn0(i,levp+1) = log(pe0(i,levp+1)) 
+         enddo 
+                                                                        
+         do k=levp,1, -1 
+            do i=1,im 
+              pe0(i,k) = ak(k) + bk(k)*ps(i,j) 
+              pn0(i,k) = log(pe0(i,k)) 
+            enddo 
+         enddo 
+                                                                        
+         zh(1:im,j,1) = zs(1:im,j) 
+         do k = 2, levp+1 
+           do i = 1, im 
+       zh(i,j,k) = zh(i,j,k-1)+t(i,j,k-1)*(1.+zvir*sphum(i,j,k-1))*     &
+              (pn0(i,k-1)-pn0(i,k))/grd                                 
+           enddo 
+         enddo 
+                                                                        
+       enddo 
+                                                                        
+      end subroutine compute_zh 
+      SUBROUTINE GET_TRACERS(IDVT, NTRACO, I_CLD, I_OZN, TRAC_NAME)
+                                                                        
+      IMPLICIT NONE 
+                                                                        
+      INTEGER, INTENT(IN)            :: IDVT, NTRACO 
+                                                                        
+      CHARACTER(LEN=16), INTENT(OUT) :: TRAC_NAME(NTRACO) 
+                                                                        
+      INTEGER, INTENT(OUT)           :: I_CLD, I_OZN 
+                                                                        
+      TRAC_NAME = ' ' 
+                                                                        
+      TRAC_NAME(1) = 'spfh' 
+      IF (NTRACO == 2) THEN 
+        IF(IDVT  == 1) THEN 
+          TRAC_NAME(2) = 'o3mr' 
+          I_OZN = 2 
+          I_CLD = 0 
+        ELSEIF(IDVT == 2) THEN 
+          TRAC_NAME(2) = 'clwmr' 
+          I_OZN = 0 
+          I_CLD = 2 
+        ENDIF 
+      ELSEIF (NTRACO == 3) THEN 
+        IF(IDVT == 0) THEN 
+          TRAC_NAME(2) = 'o3mr' 
+          TRAC_NAME(3) = 'clwmr' 
+          I_OZN = 2 
+          I_CLD = 0 
+        ELSEIF(IDVT == 21) THEN 
+          TRAC_NAME(2) = 'o3mr' 
+          TRAC_NAME(3) = 'clwmr' 
+          I_OZN = 2 
+          I_CLD = 3 
+        ELSEIF(IDVT == 12) THEN 
+          TRAC_NAME(2) = 'clwmr' 
+          TRAC_NAME(3) = 'o3mr' 
+          I_OZN = 3 
+          I_CLD = 2 
+        ENDIF 
+      ELSEIF (NTRACO == 4) THEN 
+        TRAC_NAME(4) = 'tke' 
+        IF(IDVT == 0) THEN 
+          TRAC_NAME(2) = 'o3mr' 
+          TRAC_NAME(3) = 'clwmr' 
+          I_OZN = 2 
+          I_CLD = 0 
+        ELSEIF(IDVT == 21) THEN 
+          TRAC_NAME(2) = 'o3mr' 
+          TRAC_NAME(3) = 'clwmr' 
+          I_OZN = 2 
+          I_CLD = 3 
+        ELSEIF(IDVT == 12) THEN 
+          TRAC_NAME(2) = 'clwmr' 
+          TRAC_NAME(3) = 'o3mr' 
+          I_OZN = 3 
+          I_CLD = 2 
+        ENDIF 
+      ELSEIF(IDVT == 100) THEN 
+        TRAC_NAME(2) = 'clwmr' 
+        TRAC_NAME(3) = 'o3mr' 
+        I_OZN = 2 
+        I_CLD = 3 
+                                   ! for WAM                            
+      ELSEIF(IDVT == 200) THEN 
+        TRAC_NAME(2) = 'clwmr' 
+        TRAC_NAME(3) = 'o3mr' 
+        TRAC_NAME(4) = 'o' 
+        TRAC_NAME(5) = 'o2' 
+        I_OZN = 2 
+        I_CLD = 3 
+      ENDIF 
+                                                                        
+      END SUBROUTINE GET_TRACERS 
+      SUBROUTINE VINTG_IDEA(IMO,LATCH,KM2,NT,P2,RLAT,JMO,J1,J2,IDAY,    &
+      U2,V2,T2,Q2)                                                      
+!$$$  SUBPROGRAM DOCUMENTATION BLOCK                                    
+!                                                                       
+! ABSTRACT: MAKE UPPER-AIR FIELDS MORE REAL                             
+!   WIND, TEMPERATURE, HUMIDITY AND OTHER TRACER                        
+!                                                                       
+! USAGE:    CALL VINTG_IDEA(IMO,LATCH,KM2,NT,P2,RLAT,JMO,J1,J2,IDAY,    
+!    &U2,V2,T2,Q2)                                                      
+!   INPUT ARGUMENT LIST:                                                
+!     IMO          INTEGER NUMBER OF LOGITUDE                           
+!     LATCH        INTEGER MAX NUMBER OF LAT TO PROCCESS                
+!     KM2          INTEGER NUMBER OF OUTPUT LEVELS                      
+!     NT           INTEGER NUMBER OF TRACERS INPUT                      
+!     JMO          INTEGER NUMDER OF LATITUDE                           
+!     J1           INTEGER FIRST LATITUDE INDEX,(NORTH TO SOUTH)        
+!     J2           INTEGER LAST LATITUDE INDEX,                         
+!     IDAY         INTEGER (4) HOUR MONTH DAY YEAR                      
+!     RLAT         REAL (JMO) LATITUDE IN DEGREE                        
+!     P2           REAL (IMO,2*LATCH,KM2) PRESSURES                     
+!                  ORDERED FROM BOTTOM TO TOP OF ATMOSPHERE             
+!   OUTPUT AND INPUT  ARGUMENT LIST:                                    
+!     U2           REAL (IMO,2*LATCH,KM2)  ZONAL WIND                   
+!     V2           REAL (IMO,2*LATCH,KM2)  MERIDIONAL WIND              
+!     T2           REAL (IMO,2*LATCH,KM2)  TEMPERATURE (K)              
+!     Q2           REAL (IMO,2*LATCH,KM2,NT+2)  TRACERS (HUMIDITY FIRST)
+!                                                                       
+! SUBPROGRAMS CALLED:                                                   
+!   GETTEMP        Calculate temperature                                
+!                                                                       
+! ATTRIBUTES:                                                           
+!   LANGUAGE: FORTRAN                                                   
+!                                                                       
+!C$$$                                                                   
+      IMPLICIT NONE 
+      INTEGER, INTENT(IN)    :: imo,latch,km2,nt,jmo,j1,j2,iday(4) 
+      REAL   , INTENT(IN)    :: rlat(jmo),p2(imo,2*latch,km2) 
+      REAL   , INTENT(INOUT) :: u2(imo,2*latch,km2),                    &
+                                v2(imo,2*latch,km2),                    &
+                                t2(imo,2*latch,km2),                    &
+                                q2(imo,2*latch,km2,nt)                  
+      REAL, parameter:: top=64.25 
+                                     ! molecular wght of O (g/mol)      
+      REAL, parameter:: amo=15.9994 
+                                     ! molecular wght of O2 (g/mol)     
+      REAL, parameter:: amo2=31.999 
+                                     ! molecular wght of N2 (g/mol)     
+      REAL, parameter:: amn2=28.013 
+      REAL  temps(km2),tempn(km2),zmprn(km2),zmprs(km2),wfun(10) 
+      REAL  n_os(km2),n_on(km2),n_o2s(km2),n_o2n(km2) 
+      REAL  n_n2s(km2),n_n2n(km2) 
+      REAL  sumn,sums,rlats,coe,hold 
+      INTEGER i, j, k, kref, jjn, jjs, ciday, ik,idat(8),jdow,jday 
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
+! get weight function at joints                                         
+      do i=1,10 
+      wfun(i)=(i-1)/9. 
+      enddo 
+! get calendar day                                                      
+!     call getcday(iday,ciday)                                          
+!     ciday=iday(3)+30*(iday(2)-1)                                      
+      idat(1)=iday(4) 
+      idat(2)=iday(2) 
+      idat(3)=iday(3) 
+      idat(5)=iday(1) 
+      call w3doxdat(idat,jdow,ciday,jday) 
+!     print*,idat                                                       
+      print*,iday 
+      print*,'ciday',ciday 
+!                                                                       
+      do i=1,imo 
+      do j=1,16 
+      do k=1,km2 
+      if(p2(i,j,k).le.0.) print*,i,j,k 
+      enddo 
+      enddo 
+      enddo 
+!  For EACH LATITUDE couple                                             
+      do j=j1,j2 
+! second index of data array for latitude couple                        
+      jjn=2*(j-j1)+1 
+      jjs=2*(j-j1)+2 
+! Get zonal meam pressure                                               
+        do k=1,km2 
+        sumn=0. 
+        sums=0. 
+          do i=1,imo 
+          sumn=sumn+p2(i,jjn,k) 
+          sums=sums+p2(i,jjs,k) 
+          enddo 
+        zmprn(k)=sumn/float(imo)*.01 
+        zmprs(k)=sums/float(imo)*.01 
+        enddo 
+! GET TEMP PROFILE                                                      
+        call gettemp(ciday,1,rlat(j),1,zmprn,km2,tempn,n_on,n_o2n,      &
+         n_n2n)                                                         
+        rlats=-1.*rlat(j) 
+        call gettemp(ciday,1,rlats,1,zmprs,km2,temps,n_os,n_o2s,        &
+         n_n2s)                                                         
+! JIONT WITH EACH LONGITUDE north                                       
+        do i=1,imo 
+           do k=1,km2 
+             hold = 1./(n_on(k)*amo+amo2*n_o2n(k)+amn2*n_n2n(k)) 
+!            q2(i,jjn,k,nt+1)=(amo*n_on(k))*hold                        
+!            q2(i,jjn,k,nt+2)=(amo2*n_o2n(k))*hold                      
+             q2(i,jjn,k,nt-1) = (amo*n_on(k))   * hold 
+             q2(i,jjn,k,nt)   = (amo2*n_o2n(k)) * hold 
+           enddo 
+! find joint location (orig data top)                                   
+           do k=1,km2 
+             if(p2(i,jjn,k).le.top) then 
+               kref=k 
+               go to 10 
+             endif 
+           enddo 
+   10 continue 
+! temperature joint                                                     
+           do k=kref,km2 
+             t2(i,jjn,k) = tempn(k) 
+           enddo 
+           do k=kref-10,kref-1 
+             t2(i,jjn,k) =    wfun(k-kref+11)  * tempn(k)+              &
+                          (1.-wfun(k-kref+11)) * t2(i,jjn,k)            
+           enddo 
+! others : u v q                                                        
+           do k=kref,km2 
+             coe = p2(i,jjn,k)/p2(i,jjn,kref) 
+!            coe = log(p2(i,jjn,kref))/log(p2(i,jjn,k))                 
+             u2(i,jjn,k) = coe*u2(i,jjn,kref) 
+             v2(i,jjn,k) = coe*v2(i,jjn,kref) 
+           enddo 
+        enddo 
+! JIONT WITH EACH LONGITUDE south                                       
+        do i=1,imo 
+           do k=1,km2 
+             hold = 1./(n_os(k)*amo+amo2*n_o2s(k)+amn2*n_n2s(k)) 
+             q2(i,jjs,k,nt-1) = (amo*n_os(k))   * hold 
+             q2(i,jjs,k,nt)   = (amo2*n_o2s(k)) * hold 
+           enddo 
+! find joint location (orig data top)                                   
+           do k=1,km2 
+             if(p2(i,jjs,k).le.top) then 
+               kref=k 
+               go to 11 
+             endif 
+           enddo 
+   11      continue 
+! temperature joint                                                     
+           do k=kref,km2 
+             t2(i,jjs,k) = temps(k) 
+           enddo 
+           do k=kref-10,kref-1 
+             t2(i,jjs,k) = wfun(k-kref+11)  * temps(k)+                 &
+                      (1.- wfun(k-kref+11)) * t2(i,jjs,k)               
+           enddo 
+! others : u v q ...........                                            
+           do k=kref,km2 
+             coe = p2(i,jjs,k)/p2(i,jjs,kref) 
+!            coe = log(p2(i,jjs,kref))/log(p2(i,jjs,k))                 
+             u2(i,jjs,k) = coe*u2(i,jjs,kref) 
+             v2(i,jjs,k) = coe*v2(i,jjs,kref) 
+           enddo 
+              !logitude                                                 
+        enddo 
+      enddo 
+!     print*,'www1'                                                     
+!     print'(12f6.1)',(q2(1,i,km2,4),i=1,2*latch)                       
+      end subroutine vintg_idea 
+!-----------------------------------------------------------------------
+      subroutine gettemp(iday,nday,xlat,nlat,pr,np,temp,n_o,n_o2,n_n2) 
+!  calculate temperature at each grid point useing nrlmsise00_sub       
+      implicit none 
+                                                  !number of days       
+      integer, intent(in) :: nday 
+                                                  !number of latitudes  
+      integer, intent(in) :: nlat 
+                                                  !number of pressure le
+      integer, intent(in) :: np 
+                                                  ! pressure in mb      
+      real,    intent(in) :: pr(np) 
+                                                  !latitude in degree   
+      real,    intent(in) :: xlat(nlat) 
+                                                  !calender day         
+      integer, intent(in) :: iday(nday) 
+                                                  ! temperature         
+      real,   intent(out) :: temp(np,nlat,nday) 
+                                                 ! number density of o (
+      real,   intent(out) :: n_o(np,nlat,nday) 
+                                                  ! number density of o2
+      real,   intent(out) :: n_o2(np,nlat,nday) 
+                                                  ! number density of N2
+      real,   intent(out) :: n_n2(np,nlat,nday) 
+                                                  ! altitude in km      
+      real                :: alt(np,nlat,nday) 
+      real                :: D(9),T(2),SW(25),AP(7),ut,xlong,xlst,f107, &
+                             f107a                                      
+      integer             :: k,il,ip 
+! set magnetic index average value                                      
+      DATA AP/7*9./ 
+! set swich 7,8,10,14  zero to avoid diurnal changes in output temperatu
+! swich #7 is for diurnal,#8 is for semidiurnal,# 10 is for all UT/longi
+! effect,#14 is for terdiurnal                                          
+      data sw/1.,1.,1.,1.,1.,1.,0.,0.,1.,0.,1.,1.,1.,0.,1.,1.,1.,1.,1., &
+      1.,1.,1.,1.,1.,1./                                                
+! set 10.7cm flux be average value                                      
+      f107=150. 
+      f107a=150. 
+! turn on swich                                                         
+      CALL TSELEC(SW) 
+! set longitude, UT, local time , It should not make difference to outpu
+      ut=0. 
+      xlong=0. 
+      xlst=ut/3600.+xlong/15. 
+! calculate temperature for each lat,pres level,day                     
+      do k=1,nday 
+      do il=1,nlat 
+      do ip=1,np 
+      CALL GHP7(IDAY(k),UT,ALT(ip,il,k),XLAT(il),XLONG,XLST,F107A,F107, &
+      AP,D,T,pr(ip))                                                    
+      temp(ip,il,k)=t(2) 
+      n_o(ip,il,k)=D(2) 
+      n_o2(ip,il,k)=D(4) 
+      n_n2(ip,il,k)=D(3) 
+      enddo 
+      enddo 
+      enddo 
+      end subroutine gettemp 
diff --git a/sorc/global_chgres.fd/nrlmsise00_sub.f90 b/sorc/global_chgres.fd/nrlmsise00_sub.f90
new file mode 100755
index 0000000..ee23a98
--- /dev/null
+++ b/sorc/global_chgres.fd/nrlmsise00_sub.f90
@@ -0,0 +1,2427 @@
+      SUBROUTINE GTD7(IYD,SEC,ALT,GLAT,GLONG,STL,F107A,F107,AP,MASS,D,T) 
+!                                                                       
+!     NRLMSISE-00                                                       
+!     -----------                                                       
+!        Neutral Atmosphere Empirical Model from the surface to lower   
+!        exosphere                                                      
+!                                                                       
+!        NEW FEATURES:                                                  
+!          *Extensive satellite drag database used in model generation  
+!          *Revised O2 (and O) in lower thermosphere                    
+!          *Additional nonlinear solar activity term                    
+!          *"ANOMALOUS OXYGEN" NUMBER DENSITY, OUTPUT D(9)              
+!           At high altitudes (> 500 km), hot atomic oxygen or ionized  
+!           oxygen can become appreciable for some ranges of subroutine 
+!           inputs, thereby affecting drag on satellites and debris. We 
+!           group these species under the term "anomalous oxygen," since
+!           their individual variations are not presently separable with
+!           the drag data used to define this model component.          
+!                                                                       
+!        SUBROUTINES FOR SPECIAL OUTPUTS:                               
+!                                                                       
+!        HIGH ALTITUDE DRAG: EFFECTIVE TOTAL MASS DENSITY               
+!        (SUBROUTINE GTD7D, OUTPUT D(6))                                
+!           For atmospheric drag calculations at altitudes above 500 km,
+!           call SUBROUTINE GTD7D to compute the "effective total mass  
+!           density" by including contributions from "anomalous oxygen."
+!           See "NOTES ON OUTPUT VARIABLES" below on D(6).              
+!                                                                       
+!        PRESSURE GRID (SUBROUTINE GHP7)                                
+!          See subroutine GHP7 to specify outputs at a pressure level   
+!          rather than at an altitude.                                  
+!                                                                       
+!        OUTPUT IN M-3 and KG/M3:   CALL METERS(.TRUE.)                 
+!                                                                       
+!     INPUT VARIABLES:                                                  
+!        IYD - YEAR AND DAY AS YYDDD (day of year from 1 to 365 (or 366)
+!              (Year ignored in current model)                          
+!        SEC - UT(SEC)                                                  
+!        ALT - ALTITUDE(KM)                                             
+!        GLAT - GEODETIC LATITUDE(DEG)                                  
+!        GLONG - GEODETIC LONGITUDE(DEG)                                
+!        STL - LOCAL APPARENT SOLAR TIME(HRS; see Note below)           
+!        F107A - 81 day AVERAGE OF F10.7 FLUX (centered on day DDD)     
+!        F107 - DAILY F10.7 FLUX FOR PREVIOUS DAY                       
+!        AP - MAGNETIC INDEX(DAILY) OR WHEN SW(9)=-1. :                 
+!           - ARRAY CONTAINING:                                         
+!             (1) DAILY AP                                              
+!             (2) 3 HR AP INDEX FOR CURRENT TIME                        
+!             (3) 3 HR AP INDEX FOR 3 HRS BEFORE CURRENT TIME           
+!             (4) 3 HR AP INDEX FOR 6 HRS BEFORE CURRENT TIME           
+!             (5) 3 HR AP INDEX FOR 9 HRS BEFORE CURRENT TIME           
+!             (6) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 12 TO 33 HRS PR
+!                    TO CURRENT TIME                                    
+!             (7) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 36 TO 57 HRS PR
+!                    TO CURRENT TIME                                    
+!        MASS - MASS NUMBER (ONLY DENSITY FOR SELECTED GAS IS           
+!                 CALCULATED.  MASS 0 IS TEMPERATURE.  MASS 48 FOR ALL. 
+!                 MASS 17 IS Anomalous O ONLY.)                         
+!                                                                       
+!     NOTES ON INPUT VARIABLES:                                         
+!        UT, Local Time, and Longitude are used independently in the    
+!        model and are not of equal importance for every situation.     
+!        For the most physically realistic calculation these three      
+!        variables should be consistent (STL=SEC/3600+GLONG/15).        
+!        The Equation of Time departures from the above formula         
+!        for apparent local time can be included if available but       
+!        are of minor importance.                                       
+!                                                                       
+!        F107 and F107A values used to generate the model correspond    
+!        to the 10.7 cm radio flux at the actual distance of the Earth  
+!        from the Sun rather than the radio flux at 1 AU. The following 
+!        site provides both classes of values:                          
+!        ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/       
+!                                                                       
+!        F107, F107A, and AP effects are neither large nor well         
+!        established below 80 km and these parameters should be set to  
+!        150., 150., and 4. respectively.                               
+!                                                                       
+!     OUTPUT VARIABLES:                                                 
+!        D(1) - HE NUMBER DENSITY(CM-3)                                 
+!        D(2) - O NUMBER DENSITY(CM-3)                                  
+!        D(3) - N2 NUMBER DENSITY(CM-3)                                 
+!        D(4) - O2 NUMBER DENSITY(CM-3)                                 
+!        D(5) - AR NUMBER DENSITY(CM-3)                                 
+!        D(6) - TOTAL MASS DENSITY(GM/CM3)                              
+!        D(7) - H NUMBER DENSITY(CM-3)                                  
+!        D(8) - N NUMBER DENSITY(CM-3)                                  
+!        D(9) - Anomalous oxygen NUMBER DENSITY(CM-3)                   
+!        T(1) - EXOSPHERIC TEMPERATURE                                  
+!        T(2) - TEMPERATURE AT ALT                                      
+!                                                                       
+!     NOTES ON OUTPUT VARIABLES:                                        
+!        TO GET OUTPUT IN M-3 and KG/M3:   CALL METERS(.TRUE.)          
+!                                                                       
+!        O, H, and N are set to zero below 72.5 km                      
+!                                                                       
+!        T(1), Exospheric temperature, is set to global average for     
+!        altitudes below 120 km. The 120 km gradient is left at global  
+!        average value for altitudes below 72 km.                       
+!                                                                       
+!        D(6), TOTAL MASS DENSITY, is NOT the same for subroutines GTD7 
+!        and GTD7D                                                      
+!                                                                       
+!          SUBROUTINE GTD7 -- D(6) is the sum of the mass densities of t
+!          species labeled by indices 1-5 and 7-8 in output variable D. 
+!          This includes He, O, N2, O2, Ar, H, and N but does NOT includ
+!          anomalous oxygen (species index 9).                          
+!                                                                       
+!          SUBROUTINE GTD7D -- D(6) is the "effective total mass density
+!          for drag" and is the sum of the mass densities of all species
+!          in this model, INCLUDING anomalous oxygen.                   
+!                                                                       
+!     SWITCHES: The following is for test and special purposes:         
+!                                                                       
+!        TO TURN ON AND OFF PARTICULAR VARIATIONS CALL TSELEC(SW),      
+!        WHERE SW IS A 25 ELEMENT ARRAY CONTAINING 0. FOR OFF, 1.       
+!        FOR ON, OR 2. FOR MAIN EFFECTS OFF BUT CROSS TERMS ON          
+!        FOR THE FOLLOWING VARIATIONS                                   
+!               1 - F10.7 EFFECT ON MEAN  2 - TIME INDEPENDENT          
+!               3 - SYMMETRICAL ANNUAL    4 - SYMMETRICAL SEMIANNUAL    
+!               5 - ASYMMETRICAL ANNUAL   6 - ASYMMETRICAL SEMIANNUAL   
+!               7 - DIURNAL               8 - SEMIDIURNAL               
+!               9 - DAILY AP             10 - ALL UT/LONG EFFECTS       
+!              11 - LONGITUDINAL         12 - UT AND MIXED UT/LONG      
+!              13 - MIXED AP/UT/LONG     14 - TERDIURNAL                
+!              15 - DEPARTURES FROM DIFFUSIVE EQUILIBRIUM               
+!              16 - ALL TINF VAR         17 - ALL TLB VAR               
+!              18 - ALL TN1 VAR           19 - ALL S VAR                
+!              20 - ALL TN2 VAR           21 - ALL NLB VAR              
+!              22 - ALL TN3 VAR           23 - TURBO SCALE HEIGHT VAR   
+!                                                                       
+!        To get current values of SW: CALL TRETRV(SW)                   
+!                                                                       
+      DIMENSION D(9),T(2),AP(7),DS(9),TS(2) 
+      DIMENSION ZN3(5),ZN2(4),SV(25) 
+      COMMON/GTS3C/TLB,S,DB04,DB16,DB28,DB32,DB40,DB48,DB01,ZA,T0,Z0    &
+       ,G0,RL,DD,DB14,TR12                                              
+      COMMON/MESO7/TN1(5),TN2(4),TN3(5),TGN1(2),TGN2(2),TGN3(2) 
+      COMMON/LOWER7/PTM(10),PDM(10,8) 
+      COMMON/PARM7/PT(150),PD(150,9),PS(150),PDL(25,2),PTL(100,4),      &
+       PMA(100,10),SAM(100)                                             
+      COMMON/DATIM7/ISD(3),IST(2),NAM(2) 
+      COMMON/DATIME/ISDATE(3),ISTIME(2),NAME(2) 
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      COMMON/MAVG7/PAVGM(10) 
+      COMMON/DMIX/DM04,DM16,DM28,DM32,DM40,DM01,DM14 
+      COMMON/PARMB/GSURF,RE 
+      COMMON/METSEL/IMR 
+      SAVE 
+      EXTERNAL GTD7BK 
+      DATA MN3/5/,ZN3/32.5,20.,15.,10.,0./ 
+      DATA MN2/4/,ZN2/72.5,55.,45.,32.5/ 
+      DATA ZMIX/62.5/,ALAST/99999./,MSSL/-999/ 
+      DATA SV/25*1./ 
+      IF(ISW.NE.64999) CALL TSELEC(SV) 
+!      Put identification data into common/datime/                      
+      DO 1 I=1,3 
+        ISDATE(I)=ISD(I) 
+    1 END DO 
+      DO 2 I=1,2 
+        ISTIME(I)=IST(I) 
+        NAME(I)=NAM(I) 
+    2 END DO 
+!                                                                       
+!        Test for changed input                                         
+      V1=VTST7(IYD,SEC,GLAT,GLONG,STL,F107A,F107,AP,1) 
+!       Latitude variation of gravity (none for SW(2)=0)                
+      XLAT=GLAT 
+      IF(SW(2).EQ.0) XLAT=45. 
+      CALL GLATF(XLAT,GSURF,RE) 
+!                                                                       
+      XMM=PDM(5,3) 
+!                                                                       
+!       THERMOSPHERE/MESOSPHERE (above ZN2(1))                          
+      ALTT=AMAX1(ALT,ZN2(1)) 
+      MSS=MASS 
+!       Only calculate N2 in thermosphere if alt in mixed region        
+      IF(ALT.LT.ZMIX.AND.MASS.GT.0) MSS=28 
+!       Only calculate thermosphere if input parameters changed         
+!         or altitude above ZN2(1) in mesosphere                        
+      IF(V1.EQ.1..OR.ALT.GT.ZN2(1).OR.ALAST.GT.ZN2(1).OR.MSS.NE.MSSL) THEN
+        CALL GTS7(IYD,SEC,ALTT,GLAT,GLONG,STL,F107A,F107,AP,MSS,DS,TS) 
+        DM28M=DM28 
+!         metric adjustment                                             
+        IF(IMR.EQ.1) DM28M=DM28*1.E6 
+        MSSL=MSS 
+      ENDIF 
+      T(1)=TS(1) 
+      T(2)=TS(2) 
+      IF(ALT.GE.ZN2(1)) THEN 
+        DO 5 J=1,9 
+          D(J)=DS(J) 
+    5   CONTINUE 
+        GOTO 10 
+      ENDIF 
+!                                                                       
+!       LOWER MESOSPHERE/UPPER STRATOSPHERE [between ZN3(1) and ZN2(1)] 
+!         Temperature at nodes and gradients at end nodes               
+!         Inverse temperature a linear function of spherical harmonics  
+!         Only calculate nodes if input changed                         
+       IF(V1.EQ.1..OR.ALAST.GE.ZN2(1)) THEN 
+        TGN2(1)=TGN1(2) 
+        TN2(1)=TN1(5) 
+        TN2(2)=PMA(1,1)*PAVGM(1)/(1.-SW(20)*GLOB7S(PMA(1,1))) 
+        TN2(3)=PMA(1,2)*PAVGM(2)/(1.-SW(20)*GLOB7S(PMA(1,2))) 
+        TN2(4)=PMA(1,3)*PAVGM(3)/(1.-SW(20)*SW(22)*GLOB7S(PMA(1,3))) 
+        TGN2(2)=PAVGM(9)*PMA(1,10)*(1.+SW(20)*SW(22)*GLOB7S(PMA(1,10))) &
+        *TN2(4)*TN2(4)/(PMA(1,3)*PAVGM(3))**2                           
+        TN3(1)=TN2(4) 
+       ENDIF 
+       IF(ALT.GE.ZN3(1)) GOTO 6 
+!                                                                       
+!       LOWER STRATOSPHERE AND TROPOSPHERE [below ZN3(1)]               
+!         Temperature at nodes and gradients at end nodes               
+!         Inverse temperature a linear function of spherical harmonics  
+!         Only calculate nodes if input changed                         
+        IF(V1.EQ.1..OR.ALAST.GE.ZN3(1)) THEN 
+         TGN3(1)=TGN2(2) 
+         TN3(2)=PMA(1,4)*PAVGM(4)/(1.-SW(22)*GLOB7S(PMA(1,4))) 
+         TN3(3)=PMA(1,5)*PAVGM(5)/(1.-SW(22)*GLOB7S(PMA(1,5))) 
+         TN3(4)=PMA(1,6)*PAVGM(6)/(1.-SW(22)*GLOB7S(PMA(1,6))) 
+         TN3(5)=PMA(1,7)*PAVGM(7)/(1.-SW(22)*GLOB7S(PMA(1,7))) 
+         TGN3(2)=PMA(1,8)*PAVGM(8)*(1.+SW(22)*GLOB7S(PMA(1,8)))         &
+         *TN3(5)*TN3(5)/(PMA(1,7)*PAVGM(7))**2                          
+        ENDIF 
+    6   CONTINUE 
+        IF(MASS.EQ.0) GOTO 50 
+!          LINEAR TRANSITION TO FULL MIXING BELOW ZN2(1)                
+        DMC=0 
+        IF(ALT.GT.ZMIX) DMC=1.-(ZN2(1)-ALT)/(ZN2(1)-ZMIX) 
+        DZ28=DS(3) 
+!      ***** N2 DENSITY ****                                            
+        DMR=DS(3)/DM28M-1. 
+        D(3)=DENSM(ALT,DM28M,XMM,TZ,MN3,ZN3,TN3,TGN3,MN2,ZN2,TN2,TGN2) 
+        D(3)=D(3)*(1.+DMR*DMC) 
+!      ***** HE DENSITY ****                                            
+        D(1)=0 
+        IF(MASS.NE.4.AND.MASS.NE.48) GOTO 204 
+          DMR=DS(1)/(DZ28*PDM(2,1))-1. 
+          D(1)=D(3)*PDM(2,1)*(1.+DMR*DMC) 
+  204   CONTINUE 
+!      **** O DENSITY ****                                              
+        D(2)=0 
+        D(9)=0 
+  216   CONTINUE 
+!      ***** O2 DENSITY ****                                            
+        D(4)=0 
+        IF(MASS.NE.32.AND.MASS.NE.48) GOTO 232 
+          DMR=DS(4)/(DZ28*PDM(2,4))-1. 
+          D(4)=D(3)*PDM(2,4)*(1.+DMR*DMC) 
+  232   CONTINUE 
+!      ***** AR DENSITY ****                                            
+        D(5)=0 
+        IF(MASS.NE.40.AND.MASS.NE.48) GOTO 240 
+          DMR=DS(5)/(DZ28*PDM(2,5))-1. 
+          D(5)=D(3)*PDM(2,5)*(1.+DMR*DMC) 
+  240   CONTINUE 
+!      ***** HYDROGEN DENSITY ****                                      
+        D(7)=0 
+!      ***** ATOMIC NITROGEN DENSITY ****                               
+        D(8)=0 
+!                                                                       
+!       TOTAL MASS DENSITY                                              
+!                                                                       
+        IF(MASS.EQ.48) THEN 
+         D(6) = 1.66E-24*(4.*D(1)+16.*D(2)+28.*D(3)+32.*D(4)+40.*D(5)+  &
+             D(7)+14.*D(8))                                             
+         IF(IMR.EQ.1) D(6)=D(6)/1000. 
+         ENDIF 
+         T(2)=TZ 
+   10 CONTINUE 
+      GOTO 90 
+   50 CONTINUE 
+      DD=DENSM(ALT,1.,0,TZ,MN3,ZN3,TN3,TGN3,MN2,ZN2,TN2,TGN2) 
+      T(2)=TZ 
+   90 CONTINUE 
+      ALAST=ALT 
+      RETURN 
+      END SUBROUTINE GTD7                                         
+!-----------------------------------------------------------------------
+      SUBROUTINE GTD7D(IYD,SEC,ALT,GLAT,GLONG,STL,F107A,F107,AP,MASS,D,T)
+!                                                                       
+!     NRLMSISE-00                                                       
+!     -----------                                                       
+!        This subroutine provides Effective Total Mass Density for      
+!        output D(6) which includes contributions from "anomalous       
+!        oxygen" which can affect satellite drag above 500 km.  This    
+!        subroutine is part of the distribution package for the         
+!        Neutral Atmosphere Empirical Model from the surface to lower   
+!        exosphere.  See subroutine GTD7 for more extensive comments.   
+!                                                                       
+!     INPUT VARIABLES:                                                  
+!        IYD - YEAR AND DAY AS YYDDD (day of year from 1 to 365 (or 366)
+!              (Year ignored in current model)                          
+!        SEC - UT(SEC)                                                  
+!        ALT - ALTITUDE(KM)                                             
+!        GLAT - GEODETIC LATITUDE(DEG)                                  
+!        GLONG - GEODETIC LONGITUDE(DEG)                                
+!        STL - LOCAL APPARENT SOLAR TIME(HRS; see Note below)           
+!        F107A - 81 day AVERAGE OF F10.7 FLUX (centered on day DDD)     
+!        F107 - DAILY F10.7 FLUX FOR PREVIOUS DAY                       
+!        AP - MAGNETIC INDEX(DAILY) OR WHEN SW(9)=-1. :                 
+!           - ARRAY CONTAINING:                                         
+!             (1) DAILY AP                                              
+!             (2) 3 HR AP INDEX FOR CURRENT TIME                        
+!             (3) 3 HR AP INDEX FOR 3 HRS BEFORE CURRENT TIME           
+!             (4) 3 HR AP INDEX FOR 6 HRS BEFORE CURRENT TIME           
+!             (5) 3 HR AP INDEX FOR 9 HRS BEFORE CURRENT TIME           
+!             (6) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 12 TO 33 HRS PR
+!                    TO CURRENT TIME                                    
+!             (7) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 36 TO 57 HRS PR
+!                    TO CURRENT TIME                                    
+!        MASS - MASS NUMBER (ONLY DENSITY FOR SELECTED GAS IS           
+!                 CALCULATED.  MASS 0 IS TEMPERATURE.  MASS 48 FOR ALL. 
+!                 MASS 17 IS Anomalous O ONLY.)                         
+!                                                                       
+!     NOTES ON INPUT VARIABLES:                                         
+!        UT, Local Time, and Longitude are used independently in the    
+!        model and are not of equal importance for every situation.     
+!        For the most physically realistic calculation these three      
+!        variables should be consistent (STL=SEC/3600+GLONG/15).        
+!        The Equation of Time departures from the above formula         
+!        for apparent local time can be included if available but       
+!        are of minor importance.                                       
+!                                                                       
+!        F107 and F107A values used to generate the model correspond    
+!        to the 10.7 cm radio flux at the actual distance of the Earth  
+!        from the Sun rather than the radio flux at 1 AU.               
+!                                                                       
+!     OUTPUT VARIABLES:                                                 
+!        D(1) - HE NUMBER DENSITY(CM-3)                                 
+!        D(2) - O NUMBER DENSITY(CM-3)                                  
+!        D(3) - N2 NUMBER DENSITY(CM-3)                                 
+!        D(4) - O2 NUMBER DENSITY(CM-3)                                 
+!        D(5) - AR NUMBER DENSITY(CM-3)                                 
+!        D(6) - TOTAL MASS DENSITY(GM/CM3) [includes anomalous oxygen]  
+!        D(7) - H NUMBER DENSITY(CM-3)                                  
+!        D(8) - N NUMBER DENSITY(CM-3)                                  
+!        D(9) - Anomalous oxygen NUMBER DENSITY(CM-3)                   
+!        T(1) - EXOSPHERIC TEMPERATURE                                  
+!        T(2) - TEMPERATURE AT ALT                                      
+!                                                                       
+      DIMENSION D(9),T(2),AP(7),DS(9),TS(2) 
+      COMMON/METSEL/IMR 
+      CALL GTD7(IYD,SEC,ALT,GLAT,GLONG,STL,F107A,F107,AP,MASS,D,T) 
+!       TOTAL MASS DENSITY                                              
+!                                                                       
+        IF(MASS.EQ.48) THEN 
+         D(6) = 1.66E-24*(4.*D(1)+16.*D(2)+28.*D(3)+32.*D(4)+40.*D(5)+  &
+             D(7)+14.*D(8)+16.*D(9))                                    
+         IF(IMR.EQ.1) D(6)=D(6)/1000. 
+         ENDIF 
+      RETURN 
+      END SUBROUTINE GTD7D
+!-----------------------------------------------------------------------
+      SUBROUTINE GHP7(IYD,SEC,ALT,GLAT,GLONG,STL,F107A,F107,AP,D,T,PRESS)
+!       FIND ALTITUDE OF PRESSURE SURFACE (PRESS) FROM GTD7             
+!     INPUT:                                                            
+!        IYD - YEAR AND DAY AS YYDDD                                    
+!        SEC - UT(SEC)                                                  
+!        GLAT - GEODETIC LATITUDE(DEG)                                  
+!        GLONG - GEODETIC LONGITUDE(DEG)                                
+!        STL - LOCAL APPARENT SOLAR TIME(HRS)                           
+!        F107A - 3 MONTH AVERAGE OF F10.7 FLUX                          
+!        F107 - DAILY F10.7 FLUX FOR PREVIOUS DAY                       
+!        AP - MAGNETIC INDEX(DAILY) OR WHEN SW(9)=-1. :                 
+!           - ARRAY CONTAINING:                                         
+!             (1) DAILY AP                                              
+!             (2) 3 HR AP INDEX FOR CURRENT TIME                        
+!             (3) 3 HR AP INDEX FOR 3 HRS BEFORE CURRENT TIME           
+!             (4) 3 HR AP INDEX FOR 6 HRS BEFORE CURRENT TIME           
+!             (5) 3 HR AP INDEX FOR 9 HRS BEFORE CURRENT TIME           
+!             (6) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 12 TO 33 HRS PR
+!                    TO CURRENT TIME                                    
+!             (7) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 36 TO 59 HRS PR
+!                    TO CURRENT TIME                                    
+!        PRESS - PRESSURE LEVEL(MB)                                     
+!     OUTPUT:                                                           
+!        ALT - ALTITUDE(KM)                                             
+!        D(1) - HE NUMBER DENSITY(CM-3)                                 
+!        D(2) - O NUMBER DENSITY(CM-3)                                  
+!        D(3) - N2 NUMBER DENSITY(CM-3)                                 
+!        D(4) - O2 NUMBER DENSITY(CM-3)                                 
+!        D(5) - AR NUMBER DENSITY(CM-3)                                 
+!        D(6) - TOTAL MASS DENSITY(GM/CM3)                              
+!        D(7) - H NUMBER DENSITY(CM-3)                                  
+!        D(8) - N NUMBER DENSITY(CM-3)                                  
+!        D(9) - HOT O NUMBER DENSITY(CM-3)                              
+!        T(1) - EXOSPHERIC TEMPERATURE                                  
+!        T(2) - TEMPERATURE AT ALT                                      
+!                                                                       
+      COMMON/PARMB/GSURF,RE 
+      COMMON/METSEL/IMR 
+      DIMENSION D(9),T(2),AP(7) 
+      SAVE 
+      DATA BM/1.3806E-19/,RGAS/831.4/ 
+      DATA TEST/.00043/,LTEST/12/ 
+      PL=ALOG10(PRESS) 
+!      Initial altitude estimate                                        
+      IF(PL.GE.-5.) THEN 
+         IF(PL.GT.2.5) ZI=18.06*(3.00-PL) 
+         IF(PL.GT..75.AND.PL.LE.2.5) ZI=14.98*(3.08-PL) 
+         IF(PL.GT.-1..AND.PL.LE..75) ZI=17.8*(2.72-PL) 
+         IF(PL.GT.-2..AND.PL.LE.-1.) ZI=14.28*(3.64-PL) 
+         IF(PL.GT.-4..AND.PL.LE.-2.) ZI=12.72*(4.32-PL) 
+         IF(PL.LE.-4.) ZI=25.3*(.11-PL) 
+         IDAY=MOD(IYD,1000) 
+         CL=GLAT/90. 
+         CL2=CL*CL 
+         IF(IDAY.LT.182) CD=1.-IDAY/91.25 
+         IF(IDAY.GE.182) CD=IDAY/91.25-3. 
+         CA=0 
+         IF(PL.GT.-1.11.AND.PL.LE.-.23) CA=1.0 
+         IF(PL.GT.-.23) CA=(2.79-PL)/(2.79+.23) 
+         IF(PL.LE.-1.11.AND.PL.GT.-3.) CA=(-2.93-PL)/(-2.93+1.11) 
+         Z=ZI-4.87*CL*CD*CA-1.64*CL2*CA+.31*CA*CL 
+      ENDIF 
+      IF(PL.LT.-5.) Z=22.*(PL+4.)**2+110 
+!      ITERATION LOOP                                                   
+      L=0 
+   10 CONTINUE 
+        L=L+1 
+        CALL GTD7(IYD,SEC,Z,GLAT,GLONG,STL,F107A,F107,AP,48,D,T) 
+        XN=D(1)+D(2)+D(3)+D(4)+D(5)+D(7)+D(8) 
+        P=BM*XN*T(2) 
+        IF(IMR.EQ.1) P=P*1.E-6 
+        DIFF=PL-ALOG10(P) 
+        IF(ABS(DIFF).LT.TEST .OR. L.EQ.LTEST) GOTO 20 
+        XM=D(6)/XN/1.66E-24 
+        IF(IMR.EQ.1) XM = XM*1.E3 
+        G=GSURF/(1.+Z/RE)**2 
+        SH=RGAS*T(2)/(XM*G) 
+!         New altitude estimate using scale height                      
+        IF(L.LT.6) THEN 
+          Z=Z-SH*DIFF*2.302 
+        ELSE 
+          Z=Z-SH*DIFF 
+        ENDIF 
+        GOTO 10 
+   20 CONTINUE 
+      IF(L.EQ.LTEST) WRITE(6,100) PRESS,DIFF 
+  100 FORMAT(1X,29HGHP7 NOT CONVERGING FOR PRESS, 1PE12.2,E12.2) 
+      ALT=Z 
+      RETURN 
+      END SUBROUTINE GHP7
+!-----------------------------------------------------------------------
+      SUBROUTINE GLATF(LAT,GV,REFF) 
+!      CALCULATE LATITUDE VARIABLE GRAVITY (GV) AND EFFECTIVE           
+!      RADIUS (REFF)                                                    
+      REAL LAT 
+      SAVE 
+      DATA DGTR/1.74533E-2/ 
+      C2 = COS(2.*DGTR*LAT) 
+      GV = 980.616*(1.-.0026373*C2) 
+      REFF = 2.*GV/(3.085462E-6 + 2.27E-9*C2)*1.E-5 
+      RETURN 
+      END SUBROUTINE GLATF
+!-----------------------------------------------------------------------
+      FUNCTION VTST7(IYD,SEC,GLAT,GLONG,STL,F107A,F107,AP,IC) 
+!       Test if geophysical variables or switches changed and save      
+!       Return 0 if unchanged and 1 if changed                          
+      DIMENSION AP(7),IYDL(2),SECL(2),GLATL(2),GLL(2),STLL(2) 
+      DIMENSION FAL(2),FL(2),APL(7,2),SWL(25,2),SWCL(25,2) 
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      SAVE 
+      DATA IYDL/2*-999/,SECL/2*-999./,GLATL/2*-999./,GLL/2*-999./ 
+      DATA STLL/2*-999./,FAL/2*-999./,FL/2*-999./,APL/14*-999./ 
+      DATA SWL/50*-999./,SWCL/50*-999./ 
+      VTST7=0 
+      IF(IYD.NE.IYDL(IC)) GOTO 10 
+      IF(SEC.NE.SECL(IC)) GOTO 10 
+      IF(GLAT.NE.GLATL(IC)) GOTO 10 
+      IF(GLONG.NE.GLL(IC)) GOTO 10 
+      IF(STL.NE.STLL(IC)) GOTO 10 
+      IF(F107A.NE.FAL(IC)) GOTO 10 
+      IF(F107.NE.FL(IC)) GOTO 10 
+      DO 5 I=1,7 
+        IF(AP(I).NE.APL(I,IC)) GOTO 10 
+    5 END DO 
+      DO 7 I=1,25 
+        IF(SW(I).NE.SWL(I,IC)) GOTO 10 
+        IF(SWC(I).NE.SWCL(I,IC)) GOTO 10 
+    7 END DO 
+      GOTO 20 
+   10 CONTINUE 
+      VTST7=1 
+      IYDL(IC)=IYD 
+      SECL(IC)=SEC 
+      GLATL(IC)=GLAT 
+      GLL(IC)=GLONG 
+      STLL(IC)=STL 
+      FAL(IC)=F107A 
+      FL(IC)=F107 
+      DO 15 I=1,7 
+        APL(I,IC)=AP(I) 
+   15 END DO 
+      DO 16 I=1,25 
+        SWL(I,IC)=SW(I) 
+        SWCL(I,IC)=SWC(I) 
+   16 END DO 
+   20 CONTINUE 
+      RETURN 
+      END FUNCTION VTST7                               
+!-----------------------------------------------------------------------
+      SUBROUTINE GTS7(IYD,SEC,ALT,GLAT,GLONG,STL,F107A,F107,AP,MASS,D,T) 
+!                                                                       
+!     Thermospheric portion of NRLMSISE-00                              
+!     See GTD7 for more extensive comments                              
+!                                                                       
+!        OUTPUT IN M-3 and KG/M3:   CALL METERS(.TRUE.)                 
+!                                                                       
+!     INPUT VARIABLES:                                                  
+!        IYD - YEAR AND DAY AS YYDDD (day of year from 1 to 365 (or 366)
+!              (Year ignored in current model)                          
+!        SEC - UT(SEC)                                                  
+!        ALT - ALTITUDE(KM) (>72.5 km)                                  
+!        GLAT - GEODETIC LATITUDE(DEG)                                  
+!        GLONG - GEODETIC LONGITUDE(DEG)                                
+!        STL - LOCAL APPARENT SOLAR TIME(HRS; see Note below)           
+!        F107A - 81 day AVERAGE OF F10.7 FLUX (centered on day DDD)     
+!        F107 - DAILY F10.7 FLUX FOR PREVIOUS DAY                       
+!        AP - MAGNETIC INDEX(DAILY) OR WHEN SW(9)=-1. :                 
+!           - ARRAY CONTAINING:                                         
+!             (1) DAILY AP                                              
+!             (2) 3 HR AP INDEX FOR CURRENT TIME                        
+!             (3) 3 HR AP INDEX FOR 3 HRS BEFORE CURRENT TIME           
+!             (4) 3 HR AP INDEX FOR 6 HRS BEFORE CURRENT TIME           
+!             (5) 3 HR AP INDEX FOR 9 HRS BEFORE CURRENT TIME           
+!             (6) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 12 TO 33 HRS PR
+!                    TO CURRENT TIME                                    
+!             (7) AVERAGE OF EIGHT 3 HR AP INDICIES FROM 36 TO 57 HRS PR
+!                    TO CURRENT TIME                                    
+!        MASS - MASS NUMBER (ONLY DENSITY FOR SELECTED GAS IS           
+!                 CALCULATED.  MASS 0 IS TEMPERATURE.  MASS 48 FOR ALL. 
+!                 MASS 17 IS Anomalous O ONLY.)                         
+!                                                                       
+!     NOTES ON INPUT VARIABLES:                                         
+!        UT, Local Time, and Longitude are used independently in the    
+!        model and are not of equal importance for every situation.     
+!        For the most physically realistic calculation these three      
+!        variables should be consistent (STL=SEC/3600+GLONG/15).        
+!        The Equation of Time departures from the above formula         
+!        for apparent local time can be included if available but       
+!        are of minor importance.                                       
+!                                                                       
+!        F107 and F107A values used to generate the model correspond    
+!        to the 10.7 cm radio flux at the actual distance of the Earth  
+!        from the Sun rather than the radio flux at 1 AU. The following 
+!        site provides both classes of values:                          
+!        ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/       
+!                                                                       
+!        F107, F107A, and AP effects are neither large nor well         
+!        established below 80 km and these parameters should be set to  
+!        150., 150., and 4. respectively.                               
+!                                                                       
+!     OUTPUT VARIABLES:                                                 
+!        D(1) - HE NUMBER DENSITY(CM-3)                                 
+!        D(2) - O NUMBER DENSITY(CM-3)                                  
+!        D(3) - N2 NUMBER DENSITY(CM-3)                                 
+!        D(4) - O2 NUMBER DENSITY(CM-3)                                 
+!        D(5) - AR NUMBER DENSITY(CM-3)                                 
+!        D(6) - TOTAL MASS DENSITY(GM/CM3) [Anomalous O NOT included]   
+!        D(7) - H NUMBER DENSITY(CM-3)                                  
+!        D(8) - N NUMBER DENSITY(CM-3)                                  
+!        D(9) - Anomalous oxygen NUMBER DENSITY(CM-3)                   
+!        T(1) - EXOSPHERIC TEMPERATURE                                  
+!        T(2) - TEMPERATURE AT ALT                                      
+!                                                                       
+      DIMENSION ZN1(5),ALPHA(9) 
+      COMMON/GTS3C/TLB,S,DB04,DB16,DB28,DB32,DB40,DB48,DB01,ZA,T0,Z0    &
+       ,G0,RL,DD,DB14,TR12                                              
+      COMMON/MESO7/TN1(5),TN2(4),TN3(5),TGN1(2),TGN2(2),TGN3(2) 
+      DIMENSION D(9),T(2),MT(11),AP(*),ALTL(8) 
+      COMMON/LOWER7/PTM(10),PDM(10,8) 
+      COMMON/PARM7/PT(150),PD(150,9),PS(150),PDL(25,2),PTL(100,4),      &
+       PMA(100,10),SAM(100)                                             
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      COMMON/TTEST/TINFG,GB,ROUT,TT(15) 
+      COMMON/DMIX/DM04,DM16,DM28,DM32,DM40,DM01,DM14 
+      COMMON/METSEL/IMR 
+      SAVE 
+      DATA MT/48,0,4,16,28,32,40,1,49,14,17/ 
+      DATA ALTL/200.,300.,160.,250.,240.,450.,320.,450./ 
+      DATA MN1/5/,ZN1/120.,110.,100.,90.,72.5/ 
+      DATA DGTR/1.74533E-2/,DR/1.72142E-2/,ALAST/-999./ 
+      DATA ALPHA/-0.38,0.,0.,0.,0.17,0.,-0.38,0.,0./ 
+!        Test for changed input                                         
+      V2=VTST7(IYD,SEC,GLAT,GLONG,STL,F107A,F107,AP,2) 
+!                                                                       
+      YRD=IYD 
+      ZA=PDL(16,2) 
+      ZN1(1)=ZA 
+      DO 2 J=1,9 
+        D(J)=0. 
+    2 END DO 
+!        TINF VARIATIONS NOT IMPORTANT BELOW ZA OR ZN1(1)               
+      IF(ALT.GT.ZN1(1)) THEN 
+        IF(V2.EQ.1..OR.ALAST.LE.ZN1(1)) TINF=PTM(1)*PT(1)               &
+        *(1.+SW(16)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PT))    
+      ELSE 
+        TINF=PTM(1)*PT(1) 
+      ENDIF 
+      T(1)=TINF 
+!          GRADIENT VARIATIONS NOT IMPORTANT BELOW ZN1(5)               
+      IF(ALT.GT.ZN1(5)) THEN 
+        IF(V2.EQ.1.OR.ALAST.LE.ZN1(5)) G0=PTM(4)*PS(1)                  &
+         *(1.+SW(19)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PS))   
+      ELSE 
+        G0=PTM(4)*PS(1) 
+      ENDIF 
+!      Calculate these temperatures only if input changed               
+      IF(V2.EQ.1. .OR. ALT.LT.300.)                                     &
+        TLB=PTM(2)*(1.+SW(17)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,            &
+        F107A,F107,AP,PD(1,4)))*PD(1,4)                                 
+       S=G0/(TINF-TLB) 
+!       Lower thermosphere temp variations not significant for          
+!        density above 300 km                                           
+       IF(ALT.LT.300.) THEN 
+        IF(V2.EQ.1..OR.ALAST.GE.300.) THEN 
+         TN1(2)=PTM(7)*PTL(1,1)/(1.-SW(18)*GLOB7S(PTL(1,1))) 
+         TN1(3)=PTM(3)*PTL(1,2)/(1.-SW(18)*GLOB7S(PTL(1,2))) 
+         TN1(4)=PTM(8)*PTL(1,3)/(1.-SW(18)*GLOB7S(PTL(1,3))) 
+         TN1(5)=PTM(5)*PTL(1,4)/(1.-SW(18)*SW(20)*GLOB7S(PTL(1,4))) 
+         TGN1(2)=PTM(9)*PMA(1,9)*(1.+SW(18)*SW(20)*GLOB7S(PMA(1,9)))    &
+         *TN1(5)*TN1(5)/(PTM(5)*PTL(1,4))**2                            
+        ENDIF 
+       ELSE 
+        TN1(2)=PTM(7)*PTL(1,1) 
+        TN1(3)=PTM(3)*PTL(1,2) 
+        TN1(4)=PTM(8)*PTL(1,3) 
+        TN1(5)=PTM(5)*PTL(1,4) 
+        TGN1(2)=PTM(9)*PMA(1,9)                                         &
+        *TN1(5)*TN1(5)/(PTM(5)*PTL(1,4))**2                             
+       ENDIF 
+!                                                                       
+      Z0=ZN1(4) 
+      T0=TN1(4) 
+      TR12=1. 
+!                                                                       
+      IF(MASS.EQ.0) GO TO 50 
+!       N2 variation factor at Zlb                                      
+      G28=SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,              &
+       AP,PD(1,3))                                                      
+      DAY=AMOD(YRD,1000.) 
+!        VARIATION OF TURBOPAUSE HEIGHT                                 
+      ZHF=PDL(25,2)                                                     &
+          *(1.+SW(5)*PDL(25,1)*SIN(DGTR*GLAT)*COS(DR*(DAY-PT(14))))     
+      YRD=IYD 
+      T(1)=TINF 
+      XMM=PDM(5,3) 
+      Z=ALT 
+!                                                                       
+      DO 10 J = 1,11 
+      IF(MASS.EQ.MT(J))   GO TO 15 
+   10 END DO 
+      WRITE(6,100) MASS 
+      GO TO 90 
+   15 IF(Z.GT.ALTL(6).AND.MASS.NE.28.AND.MASS.NE.48) GO TO 17 
+!                                                                       
+!       **** N2 DENSITY ****                                            
+!                                                                       
+!      Diffusive density at Zlb                                         
+      DB28 = PDM(1,3)*EXP(G28)*PD(1,3) 
+!      Diffusive density at Alt                                         
+      D(3)=DENSU(Z,DB28,TINF,TLB, 28.,ALPHA(3),T(2),PTM(6),S,MN1,ZN1,   &
+       TN1,TGN1)                                                        
+      DD=D(3) 
+!      Turbopause                                                       
+      ZH28=PDM(3,3)*ZHF 
+      ZHM28=PDM(4,3)*PDL(6,2) 
+      XMD=28.-XMM 
+!      Mixed density at Zlb                                             
+      B28=DENSU(ZH28,DB28,TINF,TLB,XMD,ALPHA(3)-1.,TZ,PTM(6),S,MN1,     &
+       ZN1,TN1,TGN1)                                                    
+      IF(Z.GT.ALTL(3).OR.SW(15).EQ.0.) GO TO 17 
+!      Mixed density at Alt                                             
+      DM28=DENSU(Z,B28,TINF,TLB,XMM,ALPHA(3),TZ,PTM(6),S,MN1,           &
+       ZN1,TN1,TGN1)                                                    
+!      Net density at Alt                                               
+      D(3)=DNET(D(3),DM28,ZHM28,XMM,28.) 
+   17 CONTINUE 
+      GO TO (20,50,20,25,90,35,40,45,25,48,46),  J 
+   20 CONTINUE 
+!                                                                       
+!       **** HE DENSITY ****                                            
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G4 = SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,1)) 
+!      Diffusive density at Zlb                                         
+      DB04 = PDM(1,1)*EXP(G4)*PD(1,1) 
+!      Diffusive density at Alt                                         
+      D(1)=DENSU(Z,DB04,TINF,TLB, 4.,ALPHA(1),T(2),PTM(6),S,MN1,ZN1,    &
+       TN1,TGN1)                                                        
+      DD=D(1) 
+      IF(Z.GT.ALTL(1).OR.SW(15).EQ.0.) GO TO 24 
+!      Turbopause                                                       
+      ZH04=PDM(3,1) 
+!      Mixed density at Zlb                                             
+      B04=DENSU(ZH04,DB04,TINF,TLB,4.-XMM,ALPHA(1)-1.,                  &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM04=DENSU(Z,B04,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM04=ZHM28 
+!      Net density at Alt                                               
+      D(1)=DNET(D(1),DM04,ZHM04,XMM,4.) 
+!      Correction to specified mixing ratio at ground                   
+      RL=ALOG(B28*PDM(2,1)/B04) 
+      ZC04=PDM(5,1)*PDL(1,2) 
+      HC04=PDM(6,1)*PDL(2,2) 
+!      Net density corrected at Alt                                     
+      D(1)=D(1)*CCOR(Z,RL,HC04,ZC04) 
+   24 CONTINUE 
+      IF(MASS.NE.48)   GO TO 90 
+   25 CONTINUE 
+!                                                                       
+!      **** O DENSITY ****                                              
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G16= SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,2)) 
+!      Diffusive density at Zlb                                         
+      DB16 =  PDM(1,2)*EXP(G16)*PD(1,2) 
+!       Diffusive density at Alt                                        
+      D(2)=DENSU(Z,DB16,TINF,TLB, 16.,ALPHA(2),T(2),PTM(6),S,MN1,       &
+       ZN1,TN1,TGN1)                                                    
+      DD=D(2) 
+      IF(Z.GT.ALTL(2).OR.SW(15).EQ.0.) GO TO 34 
+!  Corrected from PDM(3,1) to PDM(3,2)  12/2/85                         
+!       Turbopause                                                      
+      ZH16=PDM(3,2) 
+!      Mixed density at Zlb                                             
+      B16=DENSU(ZH16,DB16,TINF,TLB,16-XMM,ALPHA(2)-1.,                  &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM16=DENSU(Z,B16,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM16=ZHM28 
+!      Net density at Alt                                               
+      D(2)=DNET(D(2),DM16,ZHM16,XMM,16.) 
+!   3/16/99 Change form to match O2 departure from diff equil near 150  
+!   km and add dependence on F10.7                                      
+!      RL=ALOG(B28*PDM(2,2)*ABS(PDL(17,2))/B16)                         
+      RL=PDM(2,2)*PDL(17,2)*(1.+SW(1)*PDL(24,1)*(F107A-150.)) 
+      HC16=PDM(6,2)*PDL(4,2) 
+      ZC16=PDM(5,2)*PDL(3,2) 
+      HC216=PDM(6,2)*PDL(5,2) 
+      D(2)=D(2)*CCOR2(Z,RL,HC16,ZC16,HC216) 
+!       Chemistry correction                                            
+      HCC16=PDM(8,2)*PDL(14,2) 
+      ZCC16=PDM(7,2)*PDL(13,2) 
+      RC16=PDM(4,2)*PDL(15,2) 
+!      Net density corrected at Alt                                     
+      D(2)=D(2)*CCOR(Z,RC16,HCC16,ZCC16) 
+   34 CONTINUE 
+      IF(MASS.NE.48.AND.MASS.NE.49) GO TO 90 
+   35 CONTINUE 
+!                                                                       
+!       **** O2 DENSITY ****                                            
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G32= SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,5)) 
+!      Diffusive density at Zlb                                         
+      DB32 = PDM(1,4)*EXP(G32)*PD(1,5) 
+!       Diffusive density at Alt                                        
+      D(4)=DENSU(Z,DB32,TINF,TLB, 32.,ALPHA(4),T(2),PTM(6),S,MN1,       &
+       ZN1,TN1,TGN1)                                                    
+      IF(MASS.EQ.49) THEN 
+         DD=DD+2.*D(4) 
+      ELSE 
+         DD=D(4) 
+      ENDIF 
+      IF(SW(15).EQ.0.) GO TO 39 
+      IF(Z.GT.ALTL(4)) GO TO 38 
+!       Turbopause                                                      
+      ZH32=PDM(3,4) 
+!      Mixed density at Zlb                                             
+      B32=DENSU(ZH32,DB32,TINF,TLB,32.-XMM,ALPHA(4)-1.,                 &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM32=DENSU(Z,B32,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM32=ZHM28 
+!      Net density at Alt                                               
+      D(4)=DNET(D(4),DM32,ZHM32,XMM,32.) 
+!       Correction to specified mixing ratio at ground                  
+      RL=ALOG(B28*PDM(2,4)/B32) 
+      HC32=PDM(6,4)*PDL(8,2) 
+      ZC32=PDM(5,4)*PDL(7,2) 
+      D(4)=D(4)*CCOR(Z,RL,HC32,ZC32) 
+   38 CONTINUE 
+!      Correction for general departure from diffusive equilibrium above
+      HCC32=PDM(8,4)*PDL(23,2) 
+      HCC232=PDM(8,4)*PDL(23,1) 
+      ZCC32=PDM(7,4)*PDL(22,2) 
+      RC32=PDM(4,4)*PDL(24,2)*(1.+SW(1)*PDL(24,1)*(F107A-150.)) 
+!      Net density corrected at Alt                                     
+      D(4)=D(4)*CCOR2(Z,RC32,HCC32,ZCC32,HCC232) 
+   39 CONTINUE 
+      IF(MASS.NE.48)   GO TO 90 
+   40 CONTINUE 
+!                                                                       
+!       **** AR DENSITY ****                                            
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G40= SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,6)) 
+!      Diffusive density at Zlb                                         
+      DB40 = PDM(1,5)*EXP(G40)*PD(1,6) 
+!       Diffusive density at Alt                                        
+      D(5)=DENSU(Z,DB40,TINF,TLB, 40.,ALPHA(5),T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)
+      DD=D(5) 
+      IF(Z.GT.ALTL(5).OR.SW(15).EQ.0.) GO TO 44 
+!       Turbopause                                                      
+      ZH40=PDM(3,5) 
+!      Mixed density at Zlb                                             
+      B40=DENSU(ZH40,DB40,TINF,TLB,40.-XMM,ALPHA(5)-1.,                 &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM40=DENSU(Z,B40,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM40=ZHM28 
+!      Net density at Alt                                               
+      D(5)=DNET(D(5),DM40,ZHM40,XMM,40.) 
+!       Correction to specified mixing ratio at ground                  
+      RL=ALOG(B28*PDM(2,5)/B40) 
+      HC40=PDM(6,5)*PDL(10,2) 
+      ZC40=PDM(5,5)*PDL(9,2) 
+!      Net density corrected at Alt                                     
+      D(5)=D(5)*CCOR(Z,RL,HC40,ZC40) 
+   44 CONTINUE 
+      IF(MASS.NE.48)   GO TO 90 
+   45 CONTINUE 
+!                                                                       
+!        **** HYDROGEN DENSITY ****                                     
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G1 = SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,7)) 
+!      Diffusive density at Zlb                                         
+      DB01 = PDM(1,6)*EXP(G1)*PD(1,7) 
+!       Diffusive density at Alt                                        
+      D(7)=DENSU(Z,DB01,TINF,TLB,1.,ALPHA(7),T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)
+      DD=D(7) 
+      IF(Z.GT.ALTL(7).OR.SW(15).EQ.0.) GO TO 47 
+!       Turbopause                                                      
+      ZH01=PDM(3,6) 
+!      Mixed density at Zlb                                             
+      B01=DENSU(ZH01,DB01,TINF,TLB,1.-XMM,ALPHA(7)-1.,                  &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM01=DENSU(Z,B01,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM01=ZHM28 
+!      Net density at Alt                                               
+      D(7)=DNET(D(7),DM01,ZHM01,XMM,1.) 
+!       Correction to specified mixing ratio at ground                  
+      RL=ALOG(B28*PDM(2,6)*ABS(PDL(18,2))/B01) 
+      HC01=PDM(6,6)*PDL(12,2) 
+      ZC01=PDM(5,6)*PDL(11,2) 
+      D(7)=D(7)*CCOR(Z,RL,HC01,ZC01) 
+!       Chemistry correction                                            
+      HCC01=PDM(8,6)*PDL(20,2) 
+      ZCC01=PDM(7,6)*PDL(19,2) 
+      RC01=PDM(4,6)*PDL(21,2) 
+!      Net density corrected at Alt                                     
+      D(7)=D(7)*CCOR(Z,RC01,HCC01,ZCC01) 
+   47 CONTINUE 
+      IF(MASS.NE.48)   GO TO 90 
+   48 CONTINUE 
+!                                                                       
+!        **** ATOMIC NITROGEN DENSITY ****                              
+!                                                                       
+!       Density variation factor at Zlb                                 
+      G14 = SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,8)) 
+!      Diffusive density at Zlb                                         
+      DB14 = PDM(1,7)*EXP(G14)*PD(1,8) 
+!       Diffusive density at Alt                                        
+      D(8)=DENSU(Z,DB14,TINF,TLB,14.,ALPHA(8),T(2),PTM(6),S,MN1,        &
+       ZN1,TN1,TGN1)                                                    
+      DD=D(8) 
+      IF(Z.GT.ALTL(8).OR.SW(15).EQ.0.) GO TO 49 
+!       Turbopause                                                      
+      ZH14=PDM(3,7) 
+!      Mixed density at Zlb                                             
+      B14=DENSU(ZH14,DB14,TINF,TLB,14.-XMM,ALPHA(8)-1.,                 &
+        T(2),PTM(6),S,MN1,ZN1,TN1,TGN1)                                 
+!      Mixed density at Alt                                             
+      DM14=DENSU(Z,B14,TINF,TLB,XMM,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+      ZHM14=ZHM28 
+!      Net density at Alt                                               
+      D(8)=DNET(D(8),DM14,ZHM14,XMM,14.) 
+!       Correction to specified mixing ratio at ground                  
+      RL=ALOG(B28*PDM(2,7)*ABS(PDL(3,1))/B14) 
+      HC14=PDM(6,7)*PDL(2,1) 
+      ZC14=PDM(5,7)*PDL(1,1) 
+      D(8)=D(8)*CCOR(Z,RL,HC14,ZC14) 
+!       Chemistry correction                                            
+      HCC14=PDM(8,7)*PDL(5,1) 
+      ZCC14=PDM(7,7)*PDL(4,1) 
+      RC14=PDM(4,7)*PDL(6,1) 
+!      Net density corrected at Alt                                     
+      D(8)=D(8)*CCOR(Z,RC14,HCC14,ZCC14) 
+   49 CONTINUE 
+      IF(MASS.NE.48) GO TO 90 
+   46 CONTINUE 
+!                                                                       
+!        **** Anomalous OXYGEN DENSITY ****                             
+!                                                                       
+      G16H = SW(21)*GLOBE7(YRD,SEC,GLAT,GLONG,STL,F107A,F107,AP,PD(1,9)) 
+      DB16H = PDM(1,8)*EXP(G16H)*PD(1,9) 
+      THO=PDM(10,8)*PDL(7,1) 
+      DD=DENSU(Z,DB16H,THO,THO,16.,ALPHA(9),T2,PTM(6),S,MN1,            &
+       ZN1,TN1,TGN1)                                                    
+      ZSHT=PDM(6,8) 
+      ZMHO=PDM(5,8) 
+      ZSHO=SCALH(ZMHO,16.,THO) 
+      D(9)=DD*EXP(-ZSHT/ZSHO*(EXP(-(Z-ZMHO)/ZSHT)-1.)) 
+      IF(MASS.NE.48) GO TO 90 
+!                                                                       
+!       TOTAL MASS DENSITY                                              
+!                                                                       
+      D(6) = 1.66E-24*(4.*D(1)+16.*D(2)+28.*D(3)+32.*D(4)+40.*D(5)+     &
+             D(7)+14.*D(8))                                             
+      DB48=1.66E-24*(4.*DB04+16.*DB16+28.*DB28+32.*DB32+40.*DB40+DB01+  &
+              14.*DB14)                                                 
+      GO TO 90 
+!       TEMPERATURE AT ALTITUDE                                         
+   50 CONTINUE 
+      Z=ABS(ALT) 
+      DDUM  = DENSU(Z,1., TINF,TLB,0.,0.,T(2),PTM(6),S,MN1,ZN1,TN1,TGN1) 
+   90 CONTINUE 
+!       ADJUST DENSITIES FROM CGS TO KGM                                
+      IF(IMR.EQ.1) THEN 
+        DO 95 I=1,9 
+          D(I)=D(I)*1.E6 
+   95   CONTINUE 
+        D(6)=D(6)/1000. 
+      ENDIF 
+      ALAST=ALT 
+      RETURN 
+  100 FORMAT(1X,'MASS', I5, '  NOT VALID') 
+      END SUBROUTINE GTS7                            
+!-----------------------------------------------------------------------
+      SUBROUTINE METERS(METER) 
+!      Convert outputs to Kg & Meters if METER true                     
+      LOGICAL METER 
+      COMMON/METSEL/IMR 
+      SAVE 
+      IMR=0 
+      IF(METER) IMR=1 
+      END SUBROUTINE METERS                                         
+!-----------------------------------------------------------------------
+      FUNCTION SCALH(ALT,XM,TEMP) 
+!      Calculate scale height (km)                                      
+      COMMON/PARMB/GSURF,RE 
+      SAVE 
+      DATA RGAS/831.4/ 
+      G=GSURF/(1.+ALT/RE)**2 
+      SCALH=RGAS*TEMP/(G*XM) 
+      RETURN 
+      END FUNCTION SCALH                            
+!-----------------------------------------------------------------------
+      FUNCTION GLOBE7(YRD,SEC,LAT,LONG,TLOC,F107A,F107,AP,P) 
+!       CALCULATE G(L) FUNCTION                                         
+!       Upper Thermosphere Parameters                                   
+      REAL LAT, LONG 
+      DIMENSION P(*),SV(25),AP(*) 
+      COMMON/TTEST/TINF,GB,ROUT,T(15) 
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      COMMON/LPOLY/PLG(9,4),CTLOC,STLOC,C2TLOC,S2TLOC,C3TLOC,S3TLOC,    &
+       DAY,DF,DFA,APD,APDF,APT(4),XLONG,IYR                             
+      SAVE 
+      DATA DGTR/1.74533E-2/,DR/1.72142E-2/, XL/1000./,TLL/1000./ 
+      DATA SW9/1./,DAYL/-1./,P14/-1000./,P18/-1000./,P32/-1000./ 
+      DATA HR/.2618/,SR/7.2722E-5/,SV/25*1./,NSW/14/,P39/-1000./ 
+!       3hr Magnetic activity functions                                 
+!      Eq. A24d                                                         
+      G0(A)=(A-4.+(P(26)-1.)*(A-4.+(EXP(-ABS(P(25))*(A-4.))-1.)/ABS(P(25))))
+!       Eq. A24c                                                        
+       SUMEX(EX)=1.+(1.-EX**19)/(1.-EX)*EX**(.5) 
+!       Eq. A24a                                                        
+      SG0(EX)=(G0(AP(2))+(G0(AP(3))*EX+G0(AP(4))*EX*EX+G0(AP(5))*EX**3  &
+       +(G0(AP(6))*EX**4+G0(AP(7))*EX**12)*(1.-EX**8)/(1.-EX))          &
+       )/SUMEX(EX)                                                      
+      IF(ISW.NE.64999) CALL TSELEC(SV) 
+      DO 10 J=1,14 
+       T(J)=0 
+   10 END DO 
+      IF(SW(9).GT.0) SW9=1. 
+      IF(SW(9).LT.0) SW9=-1. 
+      IYR = YRD/1000. 
+      DAY = YRD - IYR*1000. 
+      XLONG=LONG 
+!      Eq. A22 (remainder of code)                                      
+      IF(XL.EQ.LAT)   GO TO 15 
+!          CALCULATE LEGENDRE POLYNOMIALS                               
+      C = SIN(LAT*DGTR) 
+      S = COS(LAT*DGTR) 
+      C2 = C*C 
+      C4 = C2*C2 
+      S2 = S*S 
+      PLG(2,1) = C 
+      PLG(3,1) = 0.5*(3.*C2 -1.) 
+      PLG(4,1) = 0.5*(5.*C*C2-3.*C) 
+      PLG(5,1) = (35.*C4 - 30.*C2 + 3.)/8. 
+      PLG(6,1) = (63.*C2*C2*C - 70.*C2*C + 15.*C)/8. 
+      PLG(7,1) = (11.*C*PLG(6,1) - 5.*PLG(5,1))/6. 
+!     PLG(8,1) = (13.*C*PLG(7,1) - 6.*PLG(6,1))/7.                      
+      PLG(2,2) = S 
+      PLG(3,2) = 3.*C*S 
+      PLG(4,2) = 1.5*(5.*C2-1.)*S 
+      PLG(5,2) = 2.5*(7.*C2*C-3.*C)*S 
+      PLG(6,2) = 1.875*(21.*C4 - 14.*C2 +1.)*S 
+      PLG(7,2) = (11.*C*PLG(6,2)-6.*PLG(5,2))/5. 
+!     PLG(8,2) = (13.*C*PLG(7,2)-7.*PLG(6,2))/6.                        
+!     PLG(9,2) = (15.*C*PLG(8,2)-8.*PLG(7,2))/7.                        
+      PLG(3,3) = 3.*S2 
+      PLG(4,3) = 15.*S2*C 
+      PLG(5,3) = 7.5*(7.*C2 -1.)*S2 
+      PLG(6,3) = 3.*C*PLG(5,3)-2.*PLG(4,3) 
+      PLG(7,3)=(11.*C*PLG(6,3)-7.*PLG(5,3))/4. 
+      PLG(8,3)=(13.*C*PLG(7,3)-8.*PLG(6,3))/5. 
+      PLG(4,4) = 15.*S2*S 
+      PLG(5,4) = 105.*S2*S*C 
+      PLG(6,4)=(9.*C*PLG(5,4)-7.*PLG(4,4))/2. 
+      PLG(7,4)=(11.*C*PLG(6,4)-8.*PLG(5,4))/3. 
+      XL=LAT 
+   15 CONTINUE 
+      IF(TLL.EQ.TLOC)   GO TO 16 
+      IF(SW(7).EQ.0.AND.SW(8).EQ.0.AND.SW(14).EQ.0) GOTO 16 
+      STLOC = SIN(HR*TLOC) 
+      CTLOC = COS(HR*TLOC) 
+      S2TLOC = SIN(2.*HR*TLOC) 
+      C2TLOC = COS(2.*HR*TLOC) 
+      S3TLOC = SIN(3.*HR*TLOC) 
+      C3TLOC = COS(3.*HR*TLOC) 
+      TLL = TLOC 
+   16 CONTINUE 
+      IF(DAY.NE.DAYL.OR.P(14).NE.P14) CD14=COS(DR*(DAY-P(14))) 
+      IF(DAY.NE.DAYL.OR.P(18).NE.P18) CD18=COS(2.*DR*(DAY-P(18))) 
+      IF(DAY.NE.DAYL.OR.P(32).NE.P32) CD32=COS(DR*(DAY-P(32))) 
+      IF(DAY.NE.DAYL.OR.P(39).NE.P39) CD39=COS(2.*DR*(DAY-P(39))) 
+      DAYL = DAY 
+      P14 = P(14) 
+      P18 = P(18) 
+      P32 = P(32) 
+      P39 = P(39) 
+!         F10.7 EFFECT                                                  
+      DF = F107 - F107A 
+      DFA=F107A-150. 
+      T(1) =  P(20)*DF*(1.+P(60)*DFA) + P(21)*DF*DF + P(22)*DFA         &
+       + P(30)*DFA**2                                                   
+      F1 = 1. + (P(48)*DFA +P(20)*DF+P(21)*DF*DF)*SWC(1) 
+      F2 = 1. + (P(50)*DFA+P(20)*DF+P(21)*DF*DF)*SWC(1) 
+!        TIME INDEPENDENT                                               
+      T(2) =                                                            &
+        (P(2)*PLG(3,1) + P(3)*PLG(5,1)+P(23)*PLG(7,1))                  &
+       +(P(15)*PLG(3,1))*DFA*SWC(1)                                     &
+       +P(27)*PLG(2,1)                                                  
+!        SYMMETRICAL ANNUAL                                             
+      T(3) =                                                            &
+       (P(19) )*CD32                                                    
+!        SYMMETRICAL SEMIANNUAL                                         
+      T(4) =                                                            &
+       (P(16)+P(17)*PLG(3,1))*CD18                                      
+!        ASYMMETRICAL ANNUAL                                            
+      T(5) =  F1*                                                       &
+        (P(10)*PLG(2,1)+P(11)*PLG(4,1))*CD14                            
+!         ASYMMETRICAL SEMIANNUAL                                       
+      T(6) =    P(38)*PLG(2,1)*CD39 
+!        DIURNAL                                                        
+      IF(SW(7).EQ.0) GOTO 200 
+      T71 = (P(12)*PLG(3,2))*CD14*SWC(5) 
+      T72 = (P(13)*PLG(3,2))*CD14*SWC(5) 
+      T(7) = F2*                                                        &
+       ((P(4)*PLG(2,2) + P(5)*PLG(4,2) + P(28)*PLG(6,2)                 &
+       + T71)*CTLOC                                                     &
+       + (P(7)*PLG(2,2) + P(8)*PLG(4,2) +P(29)*PLG(6,2)                 &
+       + T72)*STLOC)                                                    
+  200 CONTINUE 
+!        SEMIDIURNAL                                                    
+      IF(SW(8).EQ.0) GOTO 210 
+      T81 = (P(24)*PLG(4,3)+P(36)*PLG(6,3))*CD14*SWC(5) 
+      T82 = (P(34)*PLG(4,3)+P(37)*PLG(6,3))*CD14*SWC(5) 
+      T(8) = F2*                                                        &
+       ((P(6)*PLG(3,3) + P(42)*PLG(5,3) + T81)*C2TLOC                   &
+       +(P(9)*PLG(3,3) + P(43)*PLG(5,3) + T82)*S2TLOC)                  
+  210 CONTINUE 
+!        TERDIURNAL                                                     
+      IF(SW(14).EQ.0) GOTO 220 
+      T(14) = F2*                                                       &
+       ((P(40)*PLG(4,4)+(P(94)*PLG(5,4)+P(47)*PLG(7,4))*CD14*SWC(5))*   &
+       S3TLOC                                                           &
+       +(P(41)*PLG(4,4)+(P(95)*PLG(5,4)+P(49)*PLG(7,4))*CD14*SWC(5))*   &
+       C3TLOC)                                                          
+  220 CONTINUE 
+!          MAGNETIC ACTIVITY BASED ON DAILY AP                          
+                                                                        
+      IF(SW9.EQ.-1.) GO TO 30 
+      APD=(AP(1)-4.) 
+      P44=P(44) 
+      P45=P(45) 
+      IF(P44.LT.0) P44=1.E-5 
+      APDF = APD+(P45-1.)*(APD+(EXP(-P44  *APD)-1.)/P44) 
+      IF(SW(9).EQ.0) GOTO 40 
+      T(9)=APDF*(P(33)+P(46)*PLG(3,1)+P(35)*PLG(5,1)+                   &
+       (P(101)*PLG(2,1)+P(102)*PLG(4,1)+P(103)*PLG(6,1))*CD14*SWC(5)+   &
+       (P(122)*PLG(2,2)+P(123)*PLG(4,2)+P(124)*PLG(6,2))*SWC(7)*        &
+       COS(HR*(TLOC-P(125))))                                           
+      GO TO 40 
+   30 CONTINUE 
+      IF(P(52).EQ.0) GO TO 40 
+      EXP1 = EXP(-10800.*ABS(P(52))/(1.+P(139)*(45.-ABS(LAT)))) 
+      IF(EXP1.GT..99999) EXP1=.99999 
+      IF(P(25).LT.1.E-4) P(25)=1.E-4 
+      APT(1)=SG0(EXP1) 
+!      APT(2)=SG2(EXP1)                                                 
+!      APT(3)=SG0(EXP2)                                                 
+!      APT(4)=SG2(EXP2)                                                 
+      IF(SW(9).EQ.0) GOTO 40 
+      T(9) = APT(1)*(P(51)+P(97)*PLG(3,1)+P(55)*PLG(5,1)+               &
+       (P(126)*PLG(2,1)+P(127)*PLG(4,1)+P(128)*PLG(6,1))*CD14*SWC(5)+   &
+       (P(129)*PLG(2,2)+P(130)*PLG(4,2)+P(131)*PLG(6,2))*SWC(7)*        &
+       COS(HR*(TLOC-P(132))))                                           
+   40 CONTINUE 
+      IF(SW(10).EQ.0.OR.LONG.LE.-1000.) GO TO 49 
+!        LONGITUDINAL                                                   
+      IF(SW(11).EQ.0) GOTO 230 
+      T(11)= (1.+P(81)*DFA*SWC(1))*                                     &
+      ((P(65)*PLG(3,2)+P(66)*PLG(5,2)+P(67)*PLG(7,2)                    &
+       +P(104)*PLG(2,2)+P(105)*PLG(4,2)+P(106)*PLG(6,2)                 &
+       +SWC(5)*(P(110)*PLG(2,2)+P(111)*PLG(4,2)+P(112)*PLG(6,2))*CD14)* &
+           COS(DGTR*LONG)                                               &
+       +(P(91)*PLG(3,2)+P(92)*PLG(5,2)+P(93)*PLG(7,2)                   &
+       +P(107)*PLG(2,2)+P(108)*PLG(4,2)+P(109)*PLG(6,2)                 &
+       +SWC(5)*(P(113)*PLG(2,2)+P(114)*PLG(4,2)+P(115)*PLG(6,2))*CD14)* &
+        SIN(DGTR*LONG))                                                 
+  230 CONTINUE 
+!        UT AND MIXED UT,LONGITUDE                                      
+      IF(SW(12).EQ.0) GOTO 240 
+      T(12)=(1.+P(96)*PLG(2,1))*(1.+P(82)*DFA*SWC(1))*                  &
+      (1.+P(120)*PLG(2,1)*SWC(5)*CD14)*                                 &
+      ((P(69)*PLG(2,1)+P(70)*PLG(4,1)+P(71)*PLG(6,1))*                  &
+           COS(SR*(SEC-P(72))))                                         
+      T(12)=T(12)+SWC(11)*                                              &
+       (P(77)*PLG(4,3)+P(78)*PLG(6,3)+P(79)*PLG(8,3))*                  &
+           COS(SR*(SEC-P(80))+2.*DGTR*LONG)*(1.+P(138)*DFA*SWC(1))      
+  240 CONTINUE 
+!        UT,LONGITUDE MAGNETIC ACTIVITY                                 
+      IF(SW(13).EQ.0) GOTO 48 
+      IF(SW9.EQ.-1.) GO TO 45 
+      T(13)= APDF*SWC(11)*(1.+P(121)*PLG(2,1))*                         &
+      ((P( 61)*PLG(3,2)+P( 62)*PLG(5,2)+P( 63)*PLG(7,2))*               &
+           COS(DGTR*(LONG-P( 64))))                                     &
+       +APDF*SWC(11)*SWC(5)*                                            &
+       (P(116)*PLG(2,2)+P(117)*PLG(4,2)+P(118)*PLG(6,2))*               &
+           CD14*COS(DGTR*(LONG-P(119)))                                 &
+       + APDF*SWC(12)*                                                  &
+       (P( 84)*PLG(2,1)+P( 85)*PLG(4,1)+P( 86)*PLG(6,1))*               &
+           COS(SR*(SEC-P( 76)))                                         
+      GOTO 48 
+   45 CONTINUE 
+      IF(P(52).EQ.0) GOTO 48 
+      T(13)=APT(1)*SWC(11)*(1.+P(133)*PLG(2,1))*                        &
+      ((P(53)*PLG(3,2)+P(99)*PLG(5,2)+P(68)*PLG(7,2))*                  &
+           COS(DGTR*(LONG-P(98))))                                      &
+       +APT(1)*SWC(11)*SWC(5)*                                          &
+       (P(134)*PLG(2,2)+P(135)*PLG(4,2)+P(136)*PLG(6,2))*               &
+           CD14*COS(DGTR*(LONG-P(137)))                                 &
+       +APT(1)*SWC(12)*                                                 &
+       (P(56)*PLG(2,1)+P(57)*PLG(4,1)+P(58)*PLG(6,1))*                  &
+           COS(SR*(SEC-P(59)))                                          
+   48 CONTINUE 
+!  PARMS NOT USED: 83, 90,100,140-150                                   
+   49 CONTINUE 
+      TINF=P(31) 
+      DO 50 I = 1,NSW 
+   50 TINF = TINF + ABS(SW(I))*T(I) 
+      GLOBE7 = TINF 
+      RETURN 
+      END FUNCTION GLOBE7                         
+!-----------------------------------------------------------------------
+      SUBROUTINE TSELEC(SV) 
+!        SET SWITCHES                                                   
+!        Output in  COMMON/CSW/SW(25),ISW,SWC(25)                       
+!        SW FOR MAIN TERMS, SWC FOR CROSS TERMS                         
+!                                                                       
+!        TO TURN ON AND OFF PARTICULAR VARIATIONS CALL TSELEC(SV),      
+!        WHERE SV IS A 25 ELEMENT ARRAY CONTAINING 0. FOR OFF, 1.       
+!        FOR ON, OR 2. FOR MAIN EFFECTS OFF BUT CROSS TERMS ON          
+!                                                                       
+!        To get current values of SW: CALL TRETRV(SW)                   
+!                                                                       
+      DIMENSION SV(*),SAV(25),SVV(*) 
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      SAVE 
+      DO 100 I = 1,25 
+        SAV(I)=SV(I) 
+        SW(I)=AMOD(SV(I),2.) 
+        IF(ABS(SV(I)).EQ.1.OR.ABS(SV(I)).EQ.2.) THEN 
+          SWC(I)=1. 
+        ELSE 
+          SWC(I)=0. 
+        ENDIF 
+  100 END DO 
+      ISW=64999 
+      RETURN 
+      ENTRY TRETRV(SVV) 
+      DO 200 I=1,25 
+        SVV(I)=SAV(I) 
+  200 END DO 
+      END SUBROUTINE TSELEC                         
+!-----------------------------------------------------------------------
+      FUNCTION GLOB7S(P) 
+!      VERSION OF GLOBE FOR LOWER ATMOSPHERE 10/26/99                   
+      REAL LONG 
+      COMMON/LPOLY/PLG(9,4),CTLOC,STLOC,C2TLOC,S2TLOC,C3TLOC,S3TLOC,    &
+       DAY,DF,DFA,APD,APDF,APT(4),LONG,IYR                              
+!     COMMON/CSW/SW(25),ISW,SWC(25)                                     
+      COMMON/CSW/SW(25),SWC(25),ISW 
+      DIMENSION P(*),T(14) 
+      SAVE 
+      DATA DR/1.72142E-2/,DGTR/1.74533E-2/,PSET/2./ 
+      DATA DAYL/-1./,P32,P18,P14,P39/4*-1000./ 
+!       CONFIRM PARAMETER SET                                           
+      IF(P(100).EQ.0) P(100)=PSET 
+      IF(P(100).NE.PSET) THEN 
+        WRITE(6,900) PSET,P(100) 
+  900   FORMAT(1X,'WRONG PARAMETER SET FOR GLOB7S',3F10.1) 
+        STOP 
+      ENDIF 
+      DO 10 J=1,14 
+        T(J)=0. 
+   10 END DO 
+      IF(DAY.NE.DAYL.OR.P32.NE.P(32)) CD32=COS(DR*(DAY-P(32))) 
+      IF(DAY.NE.DAYL.OR.P18.NE.P(18)) CD18=COS(2.*DR*(DAY-P(18))) 
+      IF(DAY.NE.DAYL.OR.P14.NE.P(14)) CD14=COS(DR*(DAY-P(14))) 
+      IF(DAY.NE.DAYL.OR.P39.NE.P(39)) CD39=COS(2.*DR*(DAY-P(39))) 
+      DAYL=DAY 
+      P32=P(32) 
+      P18=P(18) 
+      P14=P(14) 
+      P39=P(39) 
+!                                                                       
+!       F10.7                                                           
+      T(1)=P(22)*DFA 
+!       TIME INDEPENDENT                                                
+      T(2)=P(2)*PLG(3,1)+P(3)*PLG(5,1)+P(23)*PLG(7,1)                   &
+           +P(27)*PLG(2,1)+P(15)*PLG(4,1)+P(60)*PLG(6,1)                
+!       SYMMETRICAL ANNUAL                                              
+      T(3)=(P(19)+P(48)*PLG(3,1)+P(30)*PLG(5,1))*CD32 
+!       SYMMETRICAL SEMIANNUAL                                          
+      T(4)=(P(16)+P(17)*PLG(3,1)+P(31)*PLG(5,1))*CD18 
+!       ASYMMETRICAL ANNUAL                                             
+      T(5)=(P(10)*PLG(2,1)+P(11)*PLG(4,1)+P(21)*PLG(6,1))*CD14 
+!       ASYMMETRICAL SEMIANNUAL                                         
+      T(6)=(P(38)*PLG(2,1))*CD39 
+!        DIURNAL                                                        
+      IF(SW(7).EQ.0) GOTO 200 
+      T71 = P(12)*PLG(3,2)*CD14*SWC(5) 
+      T72 = P(13)*PLG(3,2)*CD14*SWC(5) 
+      T(7) =                                                            &
+       ((P(4)*PLG(2,2) + P(5)*PLG(4,2)                                  &
+       + T71)*CTLOC                                                     &
+       + (P(7)*PLG(2,2) + P(8)*PLG(4,2)                                 &
+       + T72)*STLOC)                                                    
+  200 CONTINUE 
+!        SEMIDIURNAL                                                    
+      IF(SW(8).EQ.0) GOTO 210 
+      T81 = (P(24)*PLG(4,3)+P(36)*PLG(6,3))*CD14*SWC(5) 
+      T82 = (P(34)*PLG(4,3)+P(37)*PLG(6,3))*CD14*SWC(5) 
+      T(8) =                                                            &
+       ((P(6)*PLG(3,3) + P(42)*PLG(5,3) + T81)*C2TLOC                   &
+       +(P(9)*PLG(3,3) + P(43)*PLG(5,3) + T82)*S2TLOC)                  
+  210 CONTINUE 
+!        TERDIURNAL                                                     
+      IF(SW(14).EQ.0) GOTO 220 
+      T(14) = P(40)*PLG(4,4)*S3TLOC +P(41)*PLG(4,4)*C3TLOC
+  220 CONTINUE 
+!       MAGNETIC ACTIVITY                                               
+      IF(SW(9).EQ.0) GOTO 40 
+      IF(SW(9).EQ.1)                                                    &
+       T(9)=APDF*(P(33)+P(46)*PLG(3,1)*SWC(2))                          
+      IF(SW(9).EQ.-1)                                                   &
+       T(9)=(P(51)*APT(1)+P(97)*PLG(3,1)*APT(1)*SWC(2))                 
+   40 CONTINUE 
+      IF(SW(10).EQ.0.OR.SW(11).EQ.0.OR.LONG.LE.-1000.) GO TO 49 
+!        LONGITUDINAL                                                   
+      T(11)= (1.+PLG(2,1)*(P(81)*SWC(5)*COS(DR*(DAY-P(82)))             &
+                 +P(86)*SWC(6)*COS(2.*DR*(DAY-P(87))))                  &
+              +P(84)*SWC(3)*COS(DR*(DAY-P(85)))                         &
+                 +P(88)*SWC(4)*COS(2.*DR*(DAY-P(89))))                  &
+       *((P(65)*PLG(3,2)+P(66)*PLG(5,2)+P(67)*PLG(7,2)                  &
+         +P(75)*PLG(2,2)+P(76)*PLG(4,2)+P(77)*PLG(6,2)                  &
+          )*COS(DGTR*LONG)                                              &
+        +(P(91)*PLG(3,2)+P(92)*PLG(5,2)+P(93)*PLG(7,2)                  &
+         +P(78)*PLG(2,2)+P(79)*PLG(4,2)+P(80)*PLG(6,2)                  &
+          )*SIN(DGTR*LONG))                                             
+   49 CONTINUE 
+      TT=0. 
+      DO 50 I=1,14 
+   50 TT=TT+ABS(SW(I))*T(I) 
+      GLOB7S=TT 
+      RETURN 
+      END FUNCTION GLOB7S                          
+!--------------------------------------------------------------------   
+      FUNCTION DENSU(ALT,DLB,TINF,TLB,XM,ALPHA,TZ,ZLB,S2,               &
+        MN1,ZN1,TN1,TGN1)                                               
+!       Calculate Temperature and Density Profiles for MSIS models      
+!       New lower thermo polynomial 10/30/89                            
+      DIMENSION ZN1(MN1),TN1(MN1),TGN1(2),XS(5),YS(5),Y2OUT(5) 
+      COMMON/PARMB/GSURF,RE 
+      COMMON/LSQV/MP,II,JG,LT,QPB(50),IERR,IFUN,N,J,DV(60) 
+      SAVE 
+      DATA RGAS/831.4/ 
+      ZETA(ZZ,ZL)=(ZZ-ZL)*(RE+ZL)/(RE+ZZ) 
+!CCCCCWRITE(6,*) 'DB',ALT,DLB,TINF,TLB,XM,ALPHA,ZLB,S2,MN1,ZN1,TN1      
+      DENSU=1. 
+!        Joining altitude of Bates and spline                           
+      ZA=ZN1(1) 
+      Z=AMAX1(ALT,ZA) 
+!      Geopotential altitude difference from ZLB                        
+      ZG2=ZETA(Z,ZLB) 
+!      Bates temperature                                                
+      TT=TINF-(TINF-TLB)*EXP(-S2*ZG2) 
+      TA=TT 
+      TZ=TT 
+      DENSU=TZ 
+      IF(ALT.GE.ZA) GO TO 10 
+!                                                                       
+!       CALCULATE TEMPERATURE BELOW ZA                                  
+!      Temperature gradient at ZA from Bates profile                    
+      DTA=(TINF-TA)*S2*((RE+ZLB)/(RE+ZA))**2 
+      TGN1(1)=DTA 
+      TN1(1)=TA 
+      Z=AMAX1(ALT,ZN1(MN1)) 
+      MN=MN1 
+      Z1=ZN1(1) 
+      Z2=ZN1(MN) 
+      T1=TN1(1) 
+      T2=TN1(MN) 
+!      Geopotental difference from Z1                                   
+      ZG=ZETA(Z,Z1) 
+      ZGDIF=ZETA(Z2,Z1) 
+!       Set up spline nodes                                             
+      DO 20 K=1,MN 
+        XS(K)=ZETA(ZN1(K),Z1)/ZGDIF 
+        YS(K)=1./TN1(K) 
+   20 END DO 
+!        End node derivatives                                           
+      YD1=-TGN1(1)/(T1*T1)*ZGDIF 
+      YD2=-TGN1(2)/(T2*T2)*ZGDIF*((RE+Z2)/(RE+Z1))**2 
+!       Calculate spline coefficients                                   
+      CALL SPLINE(XS,YS,MN,YD1,YD2,Y2OUT) 
+      X=ZG/ZGDIF 
+      CALL SPLINT(XS,YS,Y2OUT,MN,X,Y) 
+!       temperature at altitude                                         
+      TZ=1./Y 
+      DENSU=TZ 
+   10 IF(XM.EQ.0.) GO TO 50 
+!                                                                       
+!      CALCULATE DENSITY ABOVE ZA                                       
+      GLB=GSURF/(1.+ZLB/RE)**2 
+      GAMMA=XM*GLB/(S2*RGAS*TINF) 
+      EXPL=EXP(-S2*GAMMA*ZG2) 
+      IF(EXPL.GT.50.OR.TT.LE.0.) THEN 
+        EXPL=50. 
+      ENDIF 
+!       Density at altitude                                             
+      DENSA=DLB*(TLB/TT)**(1.+ALPHA+GAMMA)*EXPL 
+      DENSU=DENSA 
+      IF(ALT.GE.ZA) GO TO 50 
+!                                                                       
+!      CALCULATE DENSITY BELOW ZA                                       
+      GLB=GSURF/(1.+Z1/RE)**2 
+      GAMM=XM*GLB*ZGDIF/RGAS 
+!       integrate spline temperatures                                   
+      CALL SPLINI(XS,YS,Y2OUT,MN,X,YI) 
+      EXPL=GAMM*YI 
+      IF(EXPL.GT.50..OR.TZ.LE.0.) THEN 
+        EXPL=50. 
+      ENDIF 
+!       Density at altitude                                             
+      DENSU=DENSU*(T1/TZ)**(1.+ALPHA)*EXP(-EXPL) 
+   50 CONTINUE 
+      RETURN 
+      END FUNCTION DENSU                                          
+!--------------------------------------------------------------------   
+      FUNCTION DENSM(ALT,D0,XM,TZ,MN3,ZN3,TN3,TGN3,MN2,ZN2,TN2,TGN2) 
+!       Calculate Temperature and Density Profiles for lower atmos.     
+      DIMENSION ZN3(MN3),TN3(MN3),TGN3(2),XS(10),YS(10),Y2OUT(10) 
+      DIMENSION ZN2(MN2),TN2(MN2),TGN2(2) 
+      COMMON/PARMB/GSURF,RE 
+      COMMON/FIT/TAF 
+      COMMON/LSQV/MP,II,JG,LT,QPB(50),IERR,IFUN,N,J,DV(60) 
+      SAVE 
+      DATA RGAS/831.4/ 
+      ZETA(ZZ,ZL)=(ZZ-ZL)*(RE+ZL)/(RE+ZZ) 
+      DENSM=D0 
+      IF(ALT.GT.ZN2(1)) GOTO 50 
+!      STRATOSPHERE/MESOSPHERE TEMPERATURE                              
+      Z=AMAX1(ALT,ZN2(MN2)) 
+      MN=MN2 
+      Z1=ZN2(1) 
+      Z2=ZN2(MN) 
+      T1=TN2(1) 
+      T2=TN2(MN) 
+      ZG=ZETA(Z,Z1) 
+      ZGDIF=ZETA(Z2,Z1) 
+!       Set up spline nodes                                             
+      DO 210 K=1,MN 
+        XS(K)=ZETA(ZN2(K),Z1)/ZGDIF 
+        YS(K)=1./TN2(K) 
+  210 END DO 
+      YD1=-TGN2(1)/(T1*T1)*ZGDIF 
+      YD2=-TGN2(2)/(T2*T2)*ZGDIF*((RE+Z2)/(RE+Z1))**2 
+!       Calculate spline coefficients                                   
+      CALL SPLINE(XS,YS,MN,YD1,YD2,Y2OUT) 
+      X=ZG/ZGDIF 
+      CALL SPLINT(XS,YS,Y2OUT,MN,X,Y) 
+!       Temperature at altitude                                         
+      TZ=1./Y 
+      IF(XM.EQ.0.) GO TO 20 
+!                                                                       
+!      CALCULATE STRATOSPHERE/MESOSPHERE DENSITY                        
+      GLB=GSURF/(1.+Z1/RE)**2 
+      GAMM=XM*GLB*ZGDIF/RGAS 
+!       Integrate temperature profile                                   
+      CALL SPLINI(XS,YS,Y2OUT,MN,X,YI) 
+      EXPL=GAMM*YI 
+      IF(EXPL.GT.50.) EXPL=50. 
+!       Density at altitude                                             
+      DENSM=DENSM*(T1/TZ)*EXP(-EXPL) 
+   20 CONTINUE 
+      IF(ALT.GT.ZN3(1)) GOTO 50 
+!                                                                       
+!      TROPOSPHERE/STRATOSPHERE TEMPERATURE                             
+      Z=ALT 
+      MN=MN3 
+      Z1=ZN3(1) 
+      Z2=ZN3(MN) 
+      T1=TN3(1) 
+      T2=TN3(MN) 
+      ZG=ZETA(Z,Z1) 
+      ZGDIF=ZETA(Z2,Z1) 
+!       Set up spline nodes                                             
+      DO 220 K=1,MN 
+        XS(K)=ZETA(ZN3(K),Z1)/ZGDIF 
+        YS(K)=1./TN3(K) 
+  220 END DO 
+      YD1=-TGN3(1)/(T1*T1)*ZGDIF 
+      YD2=-TGN3(2)/(T2*T2)*ZGDIF*((RE+Z2)/(RE+Z1))**2 
+!       Calculate spline coefficients                                   
+      CALL SPLINE(XS,YS,MN,YD1,YD2,Y2OUT) 
+      X=ZG/ZGDIF 
+      CALL SPLINT(XS,YS,Y2OUT,MN,X,Y) 
+!       temperature at altitude                                         
+      TZ=1./Y 
+      IF(XM.EQ.0.) GO TO 30 
+!                                                                       
+!      CALCULATE TROPOSPHERIC/STRATOSPHERE DENSITY                      
+!                                                                       
+      GLB=GSURF/(1.+Z1/RE)**2 
+      GAMM=XM*GLB*ZGDIF/RGAS 
+!        Integrate temperature profile                                  
+      CALL SPLINI(XS,YS,Y2OUT,MN,X,YI) 
+      EXPL=GAMM*YI 
+      IF(EXPL.GT.50.) EXPL=50. 
+!        Density at altitude                                            
+      DENSM=DENSM*(T1/TZ)*EXP(-EXPL) 
+   30 CONTINUE 
+   50 CONTINUE 
+      IF(XM.EQ.0) DENSM=TZ 
+      RETURN 
+      END FUNCTION DENSM                            
+!-----------------------------------------------------------------------
+      SUBROUTINE SPLINE(X,Y,N,YP1,YPN,Y2) 
+!        CALCULATE 2ND DERIVATIVES OF CUBIC SPLINE INTERP FUNCTION      
+!        ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL                  
+!        X,Y: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X      
+!        N: SIZE OF ARRAYS X,Y                                          
+!        YP1,YPN: SPECIFIED DERIVATIVES AT X(1) AND X(N); VALUES        
+!                 >= 1E30 SIGNAL SIGNAL SECOND DERIVATIVE ZERO          
+!        Y2: OUTPUT ARRAY OF SECOND DERIVATIVES                         
+      PARAMETER (NMAX=100) 
+      DIMENSION X(N),Y(N),Y2(N),U(NMAX) 
+      SAVE 
+      IF(YP1.GT..99E30) THEN 
+        Y2(1)=0 
+        U(1)=0 
+      ELSE 
+        Y2(1)=-.5 
+        U(1)=(3./(X(2)-X(1)))*((Y(2)-Y(1))/(X(2)-X(1))-YP1) 
+      ENDIF 
+      DO 11 I=2,N-1 
+        SIG=(X(I)-X(I-1))/(X(I+1)-X(I-1)) 
+        P=SIG*Y2(I-1)+2. 
+        Y2(I)=(SIG-1.)/P 
+        U(I)=(6.*((Y(I+1)-Y(I))/(X(I+1)-X(I))-(Y(I)-Y(I-1))             &
+          /(X(I)-X(I-1)))/(X(I+1)-X(I-1))-SIG*U(I-1))/P                 
+   11 END DO 
+      IF(YPN.GT..99E30) THEN 
+        QN=0 
+        UN=0 
+      ELSE 
+        QN=.5 
+        UN=(3./(X(N)-X(N-1)))*(YPN-(Y(N)-Y(N-1))/(X(N)-X(N-1))) 
+      ENDIF 
+      Y2(N)=(UN-QN*U(N-1))/(QN*Y2(N-1)+1.) 
+      DO 12 K=N-1,1,-1 
+        Y2(K)=Y2(K)*Y2(K+1)+U(K) 
+   12 END DO 
+      RETURN 
+      END SUBROUTINE SPLINE                         
+!-----------------------------------------------------------------------
+      SUBROUTINE SPLINT(XA,YA,Y2A,N,X,Y) 
+!        CALCULATE CUBIC SPLINE INTERP VALUE                            
+!        ADAPTED FROM NUMERICAL RECIPES BY PRESS ET AL.                 
+!        XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X    
+!        Y2A: ARRAY OF SECOND DERIVATIVES                               
+!        N: SIZE OF ARRAYS XA,YA,Y2A                                    
+!        X: ABSCISSA FOR INTERPOLATION                                  
+!        Y: OUTPUT VALUE                                                
+      DIMENSION XA(N),YA(N),Y2A(N) 
+      SAVE 
+      KLO=1 
+      KHI=N 
+    1 CONTINUE 
+      IF(KHI-KLO.GT.1) THEN 
+        K=(KHI+KLO)/2 
+        IF(XA(K).GT.X) THEN 
+          KHI=K 
+        ELSE 
+          KLO=K 
+        ENDIF 
+        GOTO 1 
+      ENDIF 
+      H=XA(KHI)-XA(KLO) 
+      IF(H.EQ.0) WRITE(6,*) 'BAD XA INPUT TO SPLINT' 
+      A=(XA(KHI)-X)/H 
+      B=(X-XA(KLO))/H 
+      Y=A*YA(KLO)+B*YA(KHI)+                                            &
+        ((A*A*A-A)*Y2A(KLO)+(B*B*B-B)*Y2A(KHI))*H*H/6.                  
+      RETURN 
+      END SUBROUTINE SPLINT                         
+!-----------------------------------------------------------------------
+      SUBROUTINE SPLINI(XA,YA,Y2A,N,X,YI) 
+!       INTEGRATE CUBIC SPLINE FUNCTION FROM XA(1) TO X                 
+!        XA,YA: ARRAYS OF TABULATED FUNCTION IN ASCENDING ORDER BY X    
+!        Y2A: ARRAY OF SECOND DERIVATIVES                               
+!        N: SIZE OF ARRAYS XA,YA,Y2A                                    
+!        X: ABSCISSA ENDPOINT FOR INTEGRATION                           
+!        Y: OUTPUT VALUE                                                
+      DIMENSION XA(N),YA(N),Y2A(N) 
+      SAVE 
+      YI=0 
+      KLO=1 
+      KHI=2 
+    1 CONTINUE 
+      IF(X.GT.XA(KLO).AND.KHI.LE.N) THEN 
+        XX=X 
+        IF(KHI.LT.N) XX=AMIN1(X,XA(KHI)) 
+        H=XA(KHI)-XA(KLO) 
+        A=(XA(KHI)-XX)/H 
+        B=(XX-XA(KLO))/H 
+        A2=A*A 
+        B2=B*B 
+        YI=YI+((1.-A2)*YA(KLO)/2.+B2*YA(KHI)/2.+                        &
+           ((-(1.+A2*A2)/4.+A2/2.)*Y2A(KLO)+                            &
+           (B2*B2/4.-B2/2.)*Y2A(KHI))*H*H/6.)*H                         
+        KLO=KLO+1 
+        KHI=KHI+1 
+        GOTO 1 
+      ENDIF 
+      RETURN 
+      END SUBROUTINE SPLINI                         
+!-----------------------------------------------------------------------
+      FUNCTION DNET(DD,DM,ZHM,XMM,XM) 
+!       TURBOPAUSE CORRECTION FOR MSIS MODELS                           
+!         Root mean density                                             
+!       8/20/80                                                         
+!          DD - diffusive density                                       
+!          DM - full mixed density                                      
+!          ZHM - transition scale length                                
+!          XMM - full mixed molecular weight                            
+!          XM  - species molecular weight                               
+!          DNET - combined density                                      
+      SAVE 
+      A=ZHM/(XMM-XM) 
+      IF(DM.GT.0.AND.DD.GT.0) GOTO 5 
+        WRITE(6,*) 'DNET LOG ERROR',DM,DD,XM 
+        IF(DD.EQ.0.AND.DM.EQ.0) DD=1. 
+        IF(DM.EQ.0) GOTO 10 
+        IF(DD.EQ.0) GOTO 20 
+    5 CONTINUE 
+      YLOG=A*ALOG(DM/DD) 
+      IF(YLOG.LT.-10.) GO TO 10 
+      IF(YLOG.GT.10.)  GO TO 20 
+        DNET=DD*(1.+EXP(YLOG))**(1/A) 
+        GO TO 50 
+   10 CONTINUE 
+        DNET=DD 
+        GO TO 50 
+   20 CONTINUE 
+        DNET=DM 
+        GO TO 50 
+   50 CONTINUE 
+      RETURN 
+      END FUNCTION DNET                             
+!-----------------------------------------------------------------------
+      FUNCTION CCOR(ALT, R,H1,ZH) 
+!        CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS              
+!        ALT - altitude                                                 
+!        R - target ratio                                               
+!        H1 - transition scale length                                   
+!        ZH - altitude of 1/2 R                                         
+      SAVE 
+      E=(ALT-ZH)/H1 
+      IF(E.GT.70.) GO TO 20 
+      IF(E.LT.-70.) GO TO 10 
+        EX=EXP(E) 
+        CCOR=R/(1.+EX) 
+        GO TO 50 
+   10   CCOR=R 
+        GO TO 50 
+   20   CCOR=0. 
+        GO TO 50 
+   50 CONTINUE 
+      CCOR=EXP(CCOR) 
+       RETURN 
+      END FUNCTION CCOR                             
+!-----------------------------------------------------------------------
+      FUNCTION CCOR2(ALT, R,H1,ZH,H2) 
+!       O&O2 CHEMISTRY/DISSOCIATION CORRECTION FOR MSIS MODELS          
+      E1=(ALT-ZH)/H1 
+      E2=(ALT-ZH)/H2 
+      IF(E1.GT.70. .OR. E2.GT.70.) GO TO 20 
+      IF(E1.LT.-70. .AND. E2.LT.-70) GO TO 10 
+        EX1=EXP(E1) 
+        EX2=EXP(E2) 
+        CCOR2=R/(1.+.5*(EX1+EX2)) 
+        GO TO 50 
+   10   CCOR2=R 
+        GO TO 50 
+   20   CCOR2=0. 
+        GO TO 50 
+   50 CONTINUE 
+      CCOR2=EXP(CCOR2) 
+       RETURN 
+      END FUNCTION CCOR2                            
+!-----------------------------------------------------------------------
+      BLOCK DATA GTD7BK 
+!          MSISE-00 01-FEB-02                                           
+      COMMON/PARM7/PT1(50),PT2(50),PT3(50),PA1(50),PA2(50),PA3(50),     &
+       PB1(50),PB2(50),PB3(50),PC1(50),PC2(50),PC3(50),                 &
+       PD1(50),PD2(50),PD3(50),PE1(50),PE2(50),PE3(50),                 &
+       PF1(50),PF2(50),PF3(50),PG1(50),PG2(50),PG3(50),                 &
+       PH1(50),PH2(50),PH3(50),PI1(50),PI2(50),PI3(50),                 &
+       PJ1(50),PJ2(50),PJ3(50),PK1(50),PL1(50),PL2(50),                 &
+       PM1(50),PM2(50),PN1(50),PN2(50),PO1(50),PO2(50),                 &
+       PP1(50),PP2(50),PQ1(50),PQ2(50),PR1(50),PR2(50),                 &
+       PS1(50),PS2(50),PU1(50),PU2(50),PV1(50),PV2(50),                 &
+       PW1(50),PW2(50),PX1(50),PX2(50),PY1(50),PY2(50),                 &
+       PZ1(50),PZ2(50),PAA1(50),PAA2(50)                                
+      COMMON/LOWER7/PTM(10),PDM(10,8) 
+      COMMON/MAVG7/PAVGM(10) 
+!     COMMON/DATIM7/ISDATE(3),ISTIME(2),NAME(2) 
+      COMMON/METSEL/IMR 
+      common/pres/pr65(2,65),pr151(2,151) 
+      DATA IMR/0/ 
+!     DATA ISDATE/'01-F','EB-0','2   '/,ISTIME/'15:4','9:27'/ 
+!     DATA NAME/'MSIS','E-00'/ 
+!         TEMPERATURE                                                   
+      DATA PT1/                                                         &
+        9.86573E-01, 1.62228E-02, 1.55270E-02,-1.04323E-01,-3.75801E-03,&
+       -1.18538E-03,-1.24043E-01, 4.56820E-03, 8.76018E-03,-1.36235E-01,&
+       -3.52427E-02, 8.84181E-03,-5.92127E-03,-8.61650E+00, 0.00000E+00,&
+        1.28492E-02, 0.00000E+00, 1.30096E+02, 1.04567E-02, 1.65686E-03,&
+       -5.53887E-06, 2.97810E-03, 0.00000E+00, 5.13122E-03, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.27026E-06,&
+        0.00000E+00, 6.74494E+00, 4.93933E-03, 2.21656E-03, 2.50802E-03,&
+        0.00000E+00, 0.00000E+00,-2.08841E-02,-1.79873E+00, 1.45103E-03,&
+        2.81769E-04,-1.44703E-03,-5.16394E-05, 8.47001E-02, 1.70147E-01,&
+        5.72562E-03, 5.07493E-05, 4.36148E-03, 1.17863E-04, 4.74364E-03/
+      DATA PT2/                                                         &
+        6.61278E-03, 4.34292E-05, 1.44373E-03, 2.41470E-05, 2.84426E-03,&
+        8.56560E-04, 2.04028E-03, 0.00000E+00,-3.15994E+03,-2.46423E-03,&
+        1.13843E-03, 4.20512E-04, 0.00000E+00,-9.77214E+01, 6.77794E-03,&
+        5.27499E-03, 1.14936E-03, 0.00000E+00,-6.61311E-03,-1.84255E-02,&
+       -1.96259E-02, 2.98618E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        6.44574E+02, 8.84668E-04, 5.05066E-04, 0.00000E+00, 4.02881E+03,&
+       -1.89503E-03, 0.00000E+00, 0.00000E+00, 8.21407E-04, 2.06780E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -1.20410E-02,-3.63963E-03, 9.92070E-05,-1.15284E-04,-6.33059E-05,&
+       -6.05545E-01, 8.34218E-03,-9.13036E+01, 3.71042E-04, 0.00000E+00/
+      DATA PT3/                                                         &
+        4.19000E-04, 2.70928E-03, 3.31507E-03,-4.44508E-03,-4.96334E-03,&
+       -1.60449E-03, 3.95119E-03, 2.48924E-03, 5.09815E-04, 4.05302E-03,&
+        2.24076E-03, 0.00000E+00, 6.84256E-03, 4.66354E-04, 0.00000E+00,&
+       -3.68328E-04, 0.00000E+00, 0.00000E+00,-1.46870E+02, 0.00000E+00,&
+        0.00000E+00, 1.09501E-03, 4.65156E-04, 5.62583E-04, 3.21596E+00,&
+        6.43168E-04, 3.14860E-03, 3.40738E-03, 1.78481E-03, 9.62532E-04,&
+        5.58171E-04, 3.43731E+00,-2.33195E-01, 5.10289E-04, 0.00000E+00,&
+        0.00000E+00,-9.25347E+04, 0.00000E+00,-1.99639E-03, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         HE DENSITY                                                    
+      DATA PA1/                                                         &
+        1.09979E+00,-4.88060E-02,-1.97501E-01,-9.10280E-02,-6.96558E-03,&
+        2.42136E-02, 3.91333E-01,-7.20068E-03,-3.22718E-02, 1.41508E+00,&
+        1.68194E-01, 1.85282E-02, 1.09384E-01,-7.24282E+00, 0.00000E+00,&
+        2.96377E-01,-4.97210E-02, 1.04114E+02,-8.61108E-02,-7.29177E-04,&
+        1.48998E-06, 1.08629E-03, 0.00000E+00, 0.00000E+00, 8.31090E-02,&
+        1.12818E-01,-5.75005E-02,-1.29919E-02,-1.78849E-02,-2.86343E-06,&
+        0.00000E+00,-1.51187E+02,-6.65902E-03, 0.00000E+00,-2.02069E-03,&
+        0.00000E+00, 0.00000E+00, 4.32264E-02,-2.80444E+01,-3.26789E-03,&
+        2.47461E-03, 0.00000E+00, 0.00000E+00, 9.82100E-02, 1.22714E-01,&
+       -3.96450E-02, 0.00000E+00,-2.76489E-03, 0.00000E+00, 1.87723E-03/
+      DATA PA2/                                                         &
+       -8.09813E-03, 4.34428E-05,-7.70932E-03, 0.00000E+00,-2.28894E-03,&
+       -5.69070E-03,-5.22193E-03, 6.00692E-03,-7.80434E+03,-3.48336E-03,&
+       -6.38362E-03,-1.82190E-03, 0.00000E+00,-7.58976E+01,-2.17875E-02,&
+       -1.72524E-02,-9.06287E-03, 0.00000E+00, 2.44725E-02, 8.66040E-02,&
+        1.05712E-01, 3.02543E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -6.01364E+03,-5.64668E-03,-2.54157E-03, 0.00000E+00, 3.15611E+02,&
+       -5.69158E-03, 0.00000E+00, 0.00000E+00,-4.47216E-03,-4.49523E-03,&
+        4.64428E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        4.51236E-02, 2.46520E-02, 6.17794E-03, 0.00000E+00, 0.00000E+00,&
+       -3.62944E-01,-4.80022E-02,-7.57230E+01,-1.99656E-03, 0.00000E+00/
+      DATA PA3/                                                         &
+       -5.18780E-03,-1.73990E-02,-9.03485E-03, 7.48465E-03, 1.53267E-02,&
+        1.06296E-02, 1.18655E-02, 2.55569E-03, 1.69020E-03, 3.51936E-02,&
+       -1.81242E-02, 0.00000E+00,-1.00529E-01,-5.10574E-03, 0.00000E+00,&
+        2.10228E-03, 0.00000E+00, 0.00000E+00,-1.73255E+02, 5.07833E-01,&
+       -2.41408E-01, 8.75414E-03, 2.77527E-03,-8.90353E-05,-5.25148E+00,&
+       -5.83899E-03,-2.09122E-02,-9.63530E-03, 9.77164E-03, 4.07051E-03,&
+        2.53555E-04,-5.52875E+00,-3.55993E-01,-2.49231E-03, 0.00000E+00,&
+        0.00000E+00, 2.86026E+01, 0.00000E+00, 3.42722E-04, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         O DENSITY                                                     
+      DATA PB1/                                                         &
+        1.02315E+00,-1.59710E-01,-1.06630E-01,-1.77074E-02,-4.42726E-03,&
+        3.44803E-02, 4.45613E-02,-3.33751E-02,-5.73598E-02, 3.50360E-01,&
+        6.33053E-02, 2.16221E-02, 5.42577E-02,-5.74193E+00, 0.00000E+00,&
+        1.90891E-01,-1.39194E-02, 1.01102E+02, 8.16363E-02, 1.33717E-04,&
+        6.54403E-06, 3.10295E-03, 0.00000E+00, 0.00000E+00, 5.38205E-02,&
+        1.23910E-01,-1.39831E-02, 0.00000E+00, 0.00000E+00,-3.95915E-06,&
+        0.00000E+00,-7.14651E-01,-5.01027E-03, 0.00000E+00,-3.24756E-03,&
+        0.00000E+00, 0.00000E+00, 4.42173E-02,-1.31598E+01,-3.15626E-03,&
+        1.24574E-03,-1.47626E-03,-1.55461E-03, 6.40682E-02, 1.34898E-01,&
+       -2.42415E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 6.13666E-04/
+      DATA PB2/                                                         &
+       -5.40373E-03, 2.61635E-05,-3.33012E-03, 0.00000E+00,-3.08101E-03,&
+       -2.42679E-03,-3.36086E-03, 0.00000E+00,-1.18979E+03,-5.04738E-02,&
+       -2.61547E-03,-1.03132E-03, 1.91583E-04,-8.38132E+01,-1.40517E-02,&
+       -1.14167E-02,-4.08012E-03, 1.73522E-04,-1.39644E-02,-6.64128E-02,&
+       -6.85152E-02,-1.34414E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        6.07916E+02,-4.12220E-03,-2.20996E-03, 0.00000E+00, 1.70277E+03,&
+       -4.63015E-03, 0.00000E+00, 0.00000E+00,-2.25360E-03,-2.96204E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        3.92786E-02, 1.31186E-02,-1.78086E-03, 0.00000E+00, 0.00000E+00,&
+       -3.90083E-01,-2.84741E-02,-7.78400E+01,-1.02601E-03, 0.00000E+00/
+      DATA PB3/                                                         &
+       -7.26485E-04,-5.42181E-03,-5.59305E-03, 1.22825E-02, 1.23868E-02,&
+        6.68835E-03,-1.03303E-02,-9.51903E-03, 2.70021E-04,-2.57084E-02,&
+       -1.32430E-02, 0.00000E+00,-3.81000E-02,-3.16810E-03, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-9.05762E-04,-2.14590E-03,-1.17824E-03, 3.66732E+00,&
+       -3.79729E-04,-6.13966E-03,-5.09082E-03,-1.96332E-03,-3.08280E-03,&
+       -9.75222E-04, 4.03315E+00,-2.52710E-01, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         N2 DENSITY                                                    
+      DATA PC1/                                                         &
+        1.16112E+00, 0.00000E+00, 0.00000E+00, 3.33725E-02, 0.00000E+00,&
+        3.48637E-02,-5.44368E-03, 0.00000E+00,-6.73940E-02, 1.74754E-01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,&
+        1.26733E-01, 0.00000E+00, 1.03154E+02, 5.52075E-02, 0.00000E+00,&
+        0.00000E+00, 8.13525E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-2.50482E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.48894E-03,&
+        6.16053E-04,-5.79716E-04, 2.95482E-03, 8.47001E-02, 1.70147E-01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PC2/                                                         &
+        0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PC3/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         TLB                                                           
+      DATA PD1/                                                         &
+        9.44846E-01, 0.00000E+00, 0.00000E+00,-3.08617E-02, 0.00000E+00,&
+       -2.44019E-02, 6.48607E-03, 0.00000E+00, 3.08181E-02, 4.59392E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,&
+        2.13260E-02, 0.00000E+00,-3.56958E+02, 0.00000E+00, 1.82278E-04,&
+        0.00000E+00, 3.07472E-04, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 3.83054E-03, 0.00000E+00, 0.00000E+00,&
+       -1.93065E-03,-1.45090E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.23493E-03, 1.36736E-03, 8.47001E-02, 1.70147E-01,&
+        3.71469E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PD2/                                                         &
+        5.10250E-03, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 3.68756E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PD3/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         O2 DENSITY                                                    
+      DATA PE1/                                                         &
+        1.35580E+00, 1.44816E-01, 0.00000E+00, 6.07767E-02, 0.00000E+00,&
+        2.94777E-02, 7.46900E-02, 0.00000E+00,-9.23822E-02, 8.57342E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 2.38636E+01, 0.00000E+00,&
+        7.71653E-02, 0.00000E+00, 8.18751E+01, 1.87736E-02, 0.00000E+00,&
+        0.00000E+00, 1.49667E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-3.67874E+02, 5.48158E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,&
+        1.22631E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PE2/                                                         &
+        8.17187E-03, 3.71617E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.10826E-03,&
+       -3.13640E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -7.35742E-02,-5.00266E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 1.94965E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PE3/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         AR DENSITY                                                    
+      DATA PF1/                                                         &
+        1.04761E+00, 2.00165E-01, 2.37697E-01, 3.68552E-02, 0.00000E+00,&
+        3.57202E-02,-2.14075E-01, 0.00000E+00,-1.08018E-01,-3.73981E-01,&
+        0.00000E+00, 3.10022E-02,-1.16305E-03,-2.07596E+01, 0.00000E+00,&
+        8.64502E-02, 0.00000E+00, 9.74908E+01, 5.16707E-02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 3.46193E+02, 1.34297E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.48509E-03,&
+       -1.54689E-04, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,&
+        1.47753E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PF2/                                                         &
+        1.89320E-02, 3.68181E-05, 1.32570E-02, 0.00000E+00, 0.00000E+00,&
+        3.59719E-03, 7.44328E-03,-1.00023E-03,-6.50528E+03, 0.00000E+00,&
+        1.03485E-02,-1.00983E-03,-4.06916E-03,-6.60864E+01,-1.71533E-02,&
+        1.10605E-02, 1.20300E-02,-5.20034E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -2.62769E+03, 7.13755E-03, 4.17999E-03, 0.00000E+00, 1.25910E+04,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-2.23595E-03, 4.60217E-03,&
+        5.71794E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -3.18353E-02,-2.35526E-02,-1.36189E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.03522E-02,-6.67837E+01,-1.09724E-03, 0.00000E+00/
+      DATA PF3/                                                         &
+       -1.38821E-02, 1.60468E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.51574E-02,&
+       -5.44470E-04, 0.00000E+00, 7.28224E-02, 6.59413E-02, 0.00000E+00,&
+       -5.15692E-03, 0.00000E+00, 0.00000E+00,-3.70367E+03, 0.00000E+00,&
+        0.00000E+00, 1.36131E-02, 5.38153E-03, 0.00000E+00, 4.76285E+00,&
+       -1.75677E-02, 2.26301E-02, 0.00000E+00, 1.76631E-02, 4.77162E-03,&
+        0.00000E+00, 5.39354E+00, 0.00000E+00,-7.51710E-03, 0.00000E+00,&
+        0.00000E+00,-8.82736E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!          H DENSITY                                                    
+      DATA PG1/                                                         &
+        1.26376E+00,-2.14304E-01,-1.49984E-01, 2.30404E-01, 2.98237E-02,&
+        2.68673E-02, 2.96228E-01, 2.21900E-02,-2.07655E-02, 4.52506E-01,&
+        1.20105E-01, 3.24420E-02, 4.24816E-02,-9.14313E+00, 0.00000E+00,&
+        2.47178E-02,-2.88229E-02, 8.12805E+01, 5.10380E-02,-5.80611E-03,&
+        2.51236E-05,-1.24083E-02, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01,-3.48190E-02, 0.00000E+00, 0.00000E+00, 2.89885E-05,&
+        0.00000E+00, 1.53595E+02,-1.68604E-02, 0.00000E+00, 1.01015E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.84552E-04,&
+       -1.22181E-03, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,&
+       -1.04927E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,-5.91313E-03/
+      DATA PG2/                                                         &
+       -2.30501E-02, 3.14758E-05, 0.00000E+00, 0.00000E+00, 1.26956E-02,&
+        8.35489E-03, 3.10513E-04, 0.00000E+00, 3.42119E+03,-2.45017E-03,&
+       -4.27154E-04, 5.45152E-04, 1.89896E-03, 2.89121E+01,-6.49973E-03,&
+       -1.93855E-02,-1.48492E-02, 0.00000E+00,-5.10576E-02, 7.87306E-02,&
+        9.51981E-02,-1.49422E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        2.65503E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 6.37110E-03, 3.24789E-04,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        6.14274E-02, 1.00376E-02,-8.41083E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.27099E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PG3/                                                         &
+       -3.94077E-03,-1.28601E-02,-7.97616E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-6.71465E-03,-1.69799E-03, 1.93772E-03, 3.81140E+00,&
+       -7.79290E-03,-1.82589E-02,-1.25860E-02,-1.04311E-02,-3.02465E-03,&
+        2.43063E-03, 3.63237E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!          N DENSITY                                                    
+      DATA PH1/                                                         &
+        7.09557E+01,-3.26740E-01, 0.00000E+00,-5.16829E-01,-1.71664E-03,&
+        9.09310E-02,-6.71500E-01,-1.47771E-01,-9.27471E-02,-2.30862E-01,&
+       -1.56410E-01, 1.34455E-02,-1.19717E-01, 2.52151E+00, 0.00000E+00,&
+       -2.41582E-01, 5.92939E-02, 4.39756E+00, 9.15280E-02, 4.41292E-03,&
+        0.00000E+00, 8.66807E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 9.74701E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 6.70217E+01,-1.31660E-03, 0.00000E+00,-1.65317E-02,&
+        0.00000E+00, 0.00000E+00, 8.50247E-02, 2.77428E+01, 4.98658E-03,&
+        6.15115E-03, 9.50156E-03,-2.12723E-02, 8.47001E-02, 1.70147E-01,&
+       -2.38645E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.37380E-03/
+      DATA PH2/                                                         &
+       -8.41918E-03, 2.80145E-05, 7.12383E-03, 0.00000E+00,-1.66209E-02,&
+        1.03533E-04,-1.68898E-02, 0.00000E+00, 3.64526E+03, 0.00000E+00,&
+        6.54077E-03, 3.69130E-04, 9.94419E-04, 8.42803E+01,-1.16124E-02,&
+       -7.74414E-03,-1.68844E-03, 1.42809E-03,-1.92955E-03, 1.17225E-01,&
+       -2.41512E-02, 1.50521E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        1.60261E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-3.54403E-04,-1.87270E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        2.76439E-02, 6.43207E-03,-3.54300E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-2.80221E-02, 8.11228E+01,-6.75255E-04, 0.00000E+00/
+      DATA PH3/                                                         &
+       -1.05162E-02,-3.48292E-03,-6.97321E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.45546E-03,-1.31970E-02,-3.57751E-03,-1.09021E+00,&
+       -1.50181E-02,-7.12841E-03,-6.64590E-03,-3.52610E-03,-1.87773E-02,&
+       -2.22432E-03,-3.93895E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!        HOT O DENSITY                                                  
+      DATA PI1/                                                         &
+        6.04050E-02, 1.57034E+00, 2.99387E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.51018E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-8.61650E+00, 1.26454E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 5.50878E-03, 0.00000E+00, 0.00000E+00, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 6.23881E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 8.47001E-02, 1.70147E-01,&
+       -9.45934E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PI2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PI3/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!          S PARAM                                                      
+      DATA PJ1/                                                         &
+        9.56827E-01, 6.20637E-02, 3.18433E-02, 0.00000E+00, 0.00000E+00,&
+        3.94900E-02, 0.00000E+00, 0.00000E+00,-9.24882E-03,-7.94023E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 1.74712E+02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.74677E-03, 0.00000E+00, 1.54951E-02, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-6.99007E-04, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 1.24362E-02,-5.28756E-03, 8.47001E-02, 1.70147E-01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PJ2/                                                         &
+        0.00000E+00, 2.47425E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PJ3/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!          TURBO                                                        
+      DATA PK1/                                                         &
+        1.09930E+00, 3.90631E+00, 3.07165E+00, 9.86161E-01, 1.63536E+01,&
+        4.63830E+00, 1.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 1.28840E+00, 3.10302E-02, 1.18339E-01,&
+        1.00000E+00, 7.00000E-01, 1.15020E+00, 3.44689E+00, 1.28840E+00,&
+        1.00000E+00, 1.08738E+00, 1.22947E+00, 1.10016E+00, 7.34129E-01,&
+        1.15241E+00, 2.22784E+00, 7.95046E-01, 4.01612E+00, 4.47749E+00,&
+        1.23435E+02,-7.60535E-02, 1.68986E-06, 7.44294E-01, 1.03604E+00,&
+        1.72783E+02, 1.15020E+00, 3.44689E+00,-7.46230E-01, 9.49154E-01/
+!         LOWER BOUNDARY                                                
+      DATA PTM/                                                         &
+        1.04130E+03, 3.86000E+02, 1.95000E+02, 1.66728E+01, 2.13000E+02,&
+        1.20000E+02, 2.40000E+02, 1.87000E+02,-2.00000E+00, 0.00000E+00/
+      DATA PDM/                                                         &
+        2.45600E+07, 6.71072E-06, 1.00000E+02, 0.00000E+00, 1.10000E+02,&
+        1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        8.59400E+10, 1.00000E+00, 1.05000E+02,-8.00000E+00, 1.10000E+02,&
+        1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00,&
+        2.81000E+11, 0.00000E+00, 1.05000E+02, 2.80000E+01, 2.89500E+01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        3.30000E+10, 2.68270E-01, 1.05000E+02, 1.00000E+00, 1.10000E+02,&
+        1.00000E+01, 1.10000E+02,-1.00000E+01, 0.00000E+00, 0.00000E+00,&
+        1.33000E+09, 1.19615E-02, 1.05000E+02, 0.00000E+00, 1.10000E+02,&
+        1.00000E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        1.76100E+05, 1.00000E+00, 9.50000E+01,-8.00000E+00, 1.10000E+02,&
+        1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00,&
+        1.00000E+07, 1.00000E+00, 1.05000E+02,-8.00000E+00, 1.10000E+02,&
+        1.00000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 0.00000E+00,&
+        1.00000E+06, 1.00000E+00, 1.05000E+02,-8.00000E+00, 5.50000E+02,&
+        7.60000E+01, 9.00000E+01, 2.00000E+00, 0.00000E+00, 4.00000E+03/
+!         TN1(2)                                                        
+      DATA PL1/                                                         &
+        1.00858E+00, 4.56011E-02,-2.22972E-02,-5.44388E-02, 5.23136E-04,&
+       -1.88849E-02, 5.23707E-02,-9.43646E-03, 6.31707E-03,-7.80460E-02,&
+       -4.88430E-02, 0.00000E+00, 0.00000E+00,-7.60250E+00, 0.00000E+00,&
+       -1.44635E-02,-1.76843E-02,-1.21517E+02, 2.85647E-02, 0.00000E+00,&
+        0.00000E+00, 6.31792E-04, 0.00000E+00, 5.77197E-03, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-8.90272E+03, 3.30611E-03, 3.02172E-03, 0.00000E+00,&
+       -2.13673E-03,-3.20910E-04, 0.00000E+00, 0.00000E+00, 2.76034E-03,&
+        2.82487E-03,-2.97592E-04,-4.21534E-03, 8.47001E-02, 1.70147E-01,&
+        8.96456E-03, 0.00000E+00,-1.08596E-02, 0.00000E+00, 0.00000E+00/
+      DATA PL2/                                                         &
+        5.57917E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 9.65405E-03, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!         TN1(3)                                                        
+      DATA PM1/                                                         &
+        9.39664E-01, 8.56514E-02,-6.79989E-03, 2.65929E-02,-4.74283E-03,&
+        1.21855E-02,-2.14905E-02, 6.49651E-03,-2.05477E-02,-4.24952E-02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 1.19148E+01, 0.00000E+00,&
+        1.18777E-02,-7.28230E-02,-8.15965E+01, 1.73887E-02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-1.44691E-02, 2.80259E-04, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.16584E+02, 3.18713E-03, 7.37479E-03, 0.00000E+00,&
+       -2.55018E-03,-3.92806E-03, 0.00000E+00, 0.00000E+00,-2.89757E-03,&
+       -1.33549E-03, 1.02661E-03, 3.53775E-04, 8.47001E-02, 1.70147E-01,&
+       -9.17497E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PM2/                                                         &
+        3.56082E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.00902E-02, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!         TN1(4)                                                        
+      DATA PN1/                                                         &
+        9.85982E-01,-4.55435E-02, 1.21106E-02, 2.04127E-02,-2.40836E-03,&
+        1.11383E-02,-4.51926E-02, 1.35074E-02,-6.54139E-03, 1.15275E-01,&
+        1.28247E-01, 0.00000E+00, 0.00000E+00,-5.30705E+00, 0.00000E+00,&
+       -3.79332E-02,-6.24741E-02, 7.71062E-01, 2.96315E-02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 6.81051E-03,-4.34767E-03, 8.66784E-02,&
+        1.58727E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 1.07003E+01,-2.76907E-03, 4.32474E-04, 0.00000E+00,&
+        1.31497E-03,-6.47517E-04, 0.00000E+00,-2.20621E+01,-1.10804E-03,&
+       -8.09338E-04, 4.18184E-04, 4.29650E-03, 8.47001E-02, 1.70147E-01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PN2/                                                         &
+       -4.04337E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-9.52550E-04,&
+        8.56253E-04, 4.33114E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.21223E-03,&
+        2.38694E-04, 9.15245E-04, 1.28385E-03, 8.67668E-04,-5.61425E-06,&
+        1.04445E+00, 3.41112E+01, 0.00000E+00,-8.40704E-01,-2.39639E+02,&
+        7.06668E-01,-2.05873E+01,-3.63696E-01, 2.39245E+01, 0.00000E+00,&
+       -1.06657E-03,-7.67292E-04, 1.54534E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!         TN1(5) TN2(1)                                                 
+      DATA PO1/                                                         &
+        1.00320E+00, 3.83501E-02,-2.38983E-03, 2.83950E-03, 4.20956E-03,&
+        5.86619E-04, 2.19054E-02,-1.00946E-02,-3.50259E-03, 4.17392E-02,&
+       -8.44404E-03, 0.00000E+00, 0.00000E+00, 4.96949E+00, 0.00000E+00,&
+       -7.06478E-03,-1.46494E-02, 3.13258E+01,-1.86493E-03, 0.00000E+00,&
+       -1.67499E-02, 0.00000E+00, 0.00000E+00, 5.12686E-04, 8.66784E-02,&
+        1.58727E-01,-4.64167E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        4.37353E-03,-1.99069E+02, 0.00000E+00,-5.34884E-03, 0.00000E+00,&
+        1.62458E-03, 2.93016E-03, 2.67926E-03, 5.90449E+02, 0.00000E+00,&
+        0.00000E+00,-1.17266E-03,-3.58890E-04, 8.47001E-02, 1.70147E-01,&
+        0.00000E+00, 0.00000E+00, 1.38673E-02, 0.00000E+00, 0.00000E+00/
+      DATA PO2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.60571E-03,&
+        6.28078E-04, 5.05469E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.57829E-03,&
+       -4.00855E-04, 5.04077E-05,-1.39001E-03,-2.33406E-03,-4.81197E-04,&
+        1.46758E+00, 6.20332E+00, 0.00000E+00, 3.66476E-01,-6.19760E+01,&
+        3.09198E-01,-1.98999E+01, 0.00000E+00,-3.29933E+02, 0.00000E+00,&
+       -1.10080E-03,-9.39310E-05, 1.39638E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN2(2)                                                       
+      DATA PP1/                                                         &
+        9.81637E-01,-1.41317E-03, 3.87323E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.58707E-02,&
+       -8.63658E-03, 0.00000E+00, 0.00000E+00,-2.02226E+00, 0.00000E+00,&
+       -8.69424E-03,-1.91397E-02, 8.76779E+01, 4.52188E-03, 0.00000E+00,&
+        2.23760E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-7.07572E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+       -4.11210E-03, 3.50060E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-8.36657E-03, 1.61347E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-1.45130E-02, 0.00000E+00, 0.00000E+00/
+      DATA PP2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.24152E-03,&
+        6.43365E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.33255E-03,&
+        2.42657E-03, 1.60666E-03,-1.85728E-03,-1.46874E-03,-4.79163E-06,&
+        1.22464E+00, 3.53510E+01, 0.00000E+00, 4.49223E-01,-4.77466E+01,&
+        4.70681E-01, 8.41861E+00,-2.88198E-01, 1.67854E+02, 0.00000E+00,&
+        7.11493E-04, 6.05601E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN2(3)                                                       
+      DATA PQ1/                                                         &
+        1.00422E+00,-7.11212E-03, 5.24480E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-5.28914E-02,&
+       -2.41301E-02, 0.00000E+00, 0.00000E+00,-2.12219E+01,-1.03830E-02,&
+       -3.28077E-03, 1.65727E-02, 1.68564E+00,-6.68154E-03, 0.00000E+00,&
+        1.45155E-02, 0.00000E+00, 8.42365E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-4.34645E-03, 0.00000E+00, 0.00000E+00, 2.16780E-02,&
+        0.00000E+00,-1.38459E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 7.04573E-03,-4.73204E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 1.08767E-02, 0.00000E+00, 0.00000E+00/
+      DATA PQ2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-8.08279E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.21769E-04,&
+       -2.27387E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.26769E-03,&
+        3.16901E-03, 4.60316E-04,-1.01431E-04, 1.02131E-03, 9.96601E-04,&
+        1.25707E+00, 2.50114E+01, 0.00000E+00, 4.24472E-01,-2.77655E+01,&
+        3.44625E-01, 2.75412E+01, 0.00000E+00, 7.94251E+02, 0.00000E+00,&
+        2.45835E-03, 1.38871E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN2(4) TN3(1)                                                
+      DATA PR1/                                                         &
+        1.01890E+00,-2.46603E-02, 1.00078E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-6.70977E-02,&
+       -4.02286E-02, 0.00000E+00, 0.00000E+00,-2.29466E+01,-7.47019E-03,&
+        2.26580E-03, 2.63931E-02, 3.72625E+01,-6.39041E-03, 0.00000E+00,&
+        9.58383E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.85291E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 1.39717E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 9.19771E-03,-3.69121E+02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-1.57067E-02, 0.00000E+00, 0.00000E+00/
+      DATA PR2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.07265E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.92953E-03,&
+       -2.77739E-03,-4.40092E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.47280E-03,&
+        2.95035E-04,-1.81246E-03, 2.81945E-03, 4.27296E-03, 9.78863E-04,&
+        1.40545E+00,-6.19173E+00, 0.00000E+00, 0.00000E+00,-7.93632E+01,&
+        4.44643E-01,-4.03085E+02, 0.00000E+00, 1.15603E+01, 0.00000E+00,&
+        2.25068E-03, 8.48557E-04,-2.98493E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN3(2)                                                       
+      DATA PS1/                                                         &
+        9.75801E-01, 3.80680E-02,-3.05198E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.85575E-02,&
+        5.04057E-02, 0.00000E+00, 0.00000E+00,-1.76046E+02, 1.44594E-02,&
+       -1.48297E-03,-3.68560E-03, 3.02185E+01,-3.23338E-03, 0.00000E+00,&
+        1.53569E-02, 0.00000E+00,-1.15558E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 4.89620E-03, 0.00000E+00, 0.00000E+00,-1.00616E-02,&
+       -8.21324E-03,-1.57757E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 6.63564E-03, 4.58410E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-2.51280E-02, 0.00000E+00, 0.00000E+00/
+      DATA PS2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 9.91215E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-8.73148E-04,&
+       -1.29648E-03,-7.32026E-05, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-4.68110E-03,&
+       -4.66003E-03,-1.31567E-03,-7.39390E-04, 6.32499E-04,-4.65588E-04,&
+       -1.29785E+00,-1.57139E+02, 0.00000E+00, 2.58350E-01,-3.69453E+01,&
+        4.10672E-01, 9.78196E+00,-1.52064E-01,-3.85084E+03, 0.00000E+00,&
+       -8.52706E-04,-1.40945E-03,-7.26786E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN3(3)                                                       
+      DATA PU1/                                                         &
+        9.60722E-01, 7.03757E-02,-3.00266E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.22671E-02,&
+        4.10423E-02, 0.00000E+00, 0.00000E+00,-1.63070E+02, 1.06073E-02,&
+        5.40747E-04, 7.79481E-03, 1.44908E+02, 1.51484E-04, 0.00000E+00,&
+        1.97547E-02, 0.00000E+00,-1.41844E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 5.77884E-03, 0.00000E+00, 0.00000E+00, 9.74319E-03,&
+        0.00000E+00,-2.88015E+03, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-4.44902E-03,-2.92760E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 2.34419E-02, 0.00000E+00, 0.00000E+00/
+      DATA PU2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.36685E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-4.65325E-04,&
+       -5.50628E-04, 3.31465E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.06179E-03,&
+       -3.08575E-03,-7.93589E-04,-1.08629E-04, 5.95511E-04,-9.05050E-04,&
+        1.18997E+00, 4.15924E+01, 0.00000E+00,-4.72064E-01,-9.47150E+02,&
+        3.98723E-01, 1.98304E+01, 0.00000E+00, 3.73219E+03, 0.00000E+00,&
+       -1.50040E-03,-1.14933E-03,-1.56769E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN3(4)                                                       
+      DATA PV1/                                                         &
+        1.03123E+00,-7.05124E-02, 8.71615E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-3.82621E-02,&
+       -9.80975E-03, 0.00000E+00, 0.00000E+00, 2.89286E+01, 9.57341E-03,&
+        0.00000E+00, 0.00000E+00, 8.66153E+01, 7.91938E-04, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 4.68917E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 7.86638E-03, 0.00000E+00, 0.00000E+00, 9.90827E-03,&
+        0.00000E+00, 6.55573E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-4.00200E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 7.07457E-03, 0.00000E+00, 0.00000E+00/
+      DATA PV2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.72268E-03,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.04970E-04,&
+        1.21560E-03,-8.05579E-06, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.49941E-03,&
+       -4.57256E-04,-1.59311E-04, 2.96481E-04,-1.77318E-03,-6.37918E-04,&
+        1.02395E+00, 1.28172E+01, 0.00000E+00, 1.49903E-01,-2.63818E+01,&
+        0.00000E+00, 4.70628E+01,-2.22139E-01, 4.82292E-02, 0.00000E+00,&
+       -8.67075E-04,-5.86479E-04, 5.32462E-04, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TN3(5) SURFACE TEMP TSL                                      
+      DATA PW1/                                                         &
+        1.00828E+00,-9.10404E-02,-2.26549E-02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-2.32420E-02,&
+       -9.08925E-03, 0.00000E+00, 0.00000E+00, 3.36105E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-1.24957E+01,-5.87939E-03, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.79765E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 2.01237E+03, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-1.75553E-02, 0.00000E+00, 0.00000E+00/
+      DATA PW2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.29699E-03,&
+        1.26659E-03, 2.68402E-04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.17894E-03,&
+        1.48746E-03, 1.06478E-04, 1.34743E-04,-2.20939E-03,-6.23523E-04,&
+        6.36539E-01, 1.13621E+01, 0.00000E+00,-3.93777E-01, 2.38687E+03,&
+        0.00000E+00, 6.61865E+02,-1.21434E-01, 9.27608E+00, 0.00000E+00,&
+        1.68478E-04, 1.24892E-03, 1.71345E-03, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TGN3(2) SURFACE GRAD TSLG                                    
+      DATA PX1/                                                         &
+        1.57293E+00,-6.78400E-01, 6.47500E-01, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-7.62974E-02,&
+       -3.60423E-01, 0.00000E+00, 0.00000E+00, 1.28358E+02, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 4.68038E+01, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.67898E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.90994E+04, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 3.15706E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PX2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TGN2(1) TGN1(2)                                              
+      DATA PY1/                                                         &
+        8.60028E-01, 3.77052E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.17570E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 7.77757E-03, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 1.01024E+02, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 6.54251E+02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+      DATA PY2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,-1.56959E-02,&
+        1.91001E-02, 3.15971E-02, 1.00982E-02,-6.71565E-03, 2.57693E-03,&
+        1.38692E+00, 2.82132E-01, 0.00000E+00, 0.00000E+00, 3.81511E+02,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          TGN3(1) TGN2(2)                                              
+      DATA PZ1/                                                         &
+        1.06029E+00,-5.25231E-02, 3.73034E-01, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.31072E-02,&
+       -3.88409E-01, 0.00000E+00, 0.00000E+00,-1.65295E+02,-2.13801E-01,&
+       -4.38916E-02,-3.22716E-01,-8.82393E+01, 1.18458E-01, 0.00000E+00,&
+       -4.35863E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00,-1.19782E-01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 2.62229E+01, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00,-5.37443E+01, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00,-4.55788E-01, 0.00000E+00, 0.00000E+00/
+      DATA PZ2/                                                         &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 3.84009E-02,&
+        3.96733E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 5.05494E-02,&
+        7.39617E-02, 1.92200E-02,-8.46151E-03,-1.34244E-02, 1.96338E-02,&
+        1.50421E+00, 1.88368E+01, 0.00000E+00, 0.00000E+00,-5.13114E+01,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        5.11923E-02, 3.61225E-02, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00000E+00/
+!          SEMIANNUAL MULT SAM                                          
+      DATA PAA1/                                                        &
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00,&
+        1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00, 1.00000E+00/
+      DATA PAA2/                                                        &
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00,&
+        0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00/
+!         MIDDLE ATMOSPHERE AVERAGES                                    
+      DATA PAVGM/                                                       &
+        2.61000E+02, 2.64000E+02, 2.29000E+02, 2.17000E+02, 2.17000E+02,&
+        2.23000E+02, 2.86760E+02,-2.93940E+00, 2.50000E+00, 0.00000E+00/
+      END                                           
diff --git a/sorc/global_chgres.fd/read_write.f90 b/sorc/global_chgres.fd/read_write.f90
new file mode 100644
index 0000000..6cbb0b5
--- /dev/null
+++ b/sorc/global_chgres.fd/read_write.f90
@@ -0,0 +1,4335 @@
+ SUBROUTINE READ_FV3GFS_ATMS_DATA_NEMSIO(GFILEI, GFSDATAI, GFSHEADI, &
+                                         VCOORD, LEVSP1, NVCOORD)
+
+ USE NEMSIO_MODULE
+ USE NEMSIO_GFS
+
+ IMPLICIT NONE
+
+ TYPE(NEMSIO_GFILE)  :: GFILEI
+ TYPE(NEMSIO_DBTA)   :: GFSDATAI
+ TYPE(NEMSIO_HEAD)   :: GFSHEADI
+
+ INTEGER, INTENT(IN) :: LEVSP1, NVCOORD
+ 
+ REAL, INTENT(IN)    :: VCOORD(LEVSP1, NVCOORD)
+
+ INTEGER             :: I, J, L, IRET
+ INTEGER             :: LONB, LATB, LEVSI
+
+ REAL, ALLOCATABLE   :: TMP(:), P_INTERFACE(:)
+
+ print*,''
+ print*,'READ FV3GFS ATMOSPHERIC NEMSIO FILE'
+
+ LONB = GFSHEADI%DIMX
+ LATB = GFSHEADI%DIMY
+ LEVSI = GFSHEADI%DIMZ
+
+ ALLOCATE(TMP(LONB*LATB))
+
+ PRINT*,'READ HGT'
+ CALL NEMSIO_READRECV(GFILEI, 'hgt', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ GFSDATAI%ZS = RESHAPE(TMP,(/LONB,LATB/))
+
+ PRINT*,'READ U WINDS'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'ugrd', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%U(:,:,L) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ V WINDS'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'vgrd', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%V(:,:,L) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ T'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'tmp', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%T(:,:,L) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ Q'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'spfh', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,1) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ O3'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'o3mr', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,2) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ CLWMR'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'clwmr', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,3) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ RWMR'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'rwmr', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,4) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ ICMR'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'icmr', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,5) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ SNMR'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'snmr', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,6) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ GRLE'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'grle', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%Q(:,:,L,7) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ DZDT'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'dzdt', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%W(:,:,L) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+ PRINT*,'READ DPRES'
+ DO L = 1, LEVSI
+   CALL NEMSIO_READRECV(GFILEI, 'dpres', 'mid layer', L, TMP, IRET=IRET)
+   IF (IRET /= 0) GOTO 99
+   GFSDATAI%DP(:,:,L) = RESHAPE(TMP,(/LONB,LATB/))
+ ENDDO
+
+! COMPUTE SURFACE PRESSURE AND MID-LAYER PRESSURE FROM DELTA P.
+! DO NOT USE THE SURFACE PRESSURE IN THE FILE.  AFTER INTERPOLATION
+! FROM THE MODEL GRID TO THE GAUSSIAN GRID IN THE WRITE COMPONENT,
+! THE SURFACE PRESSURE IS NO LONGER CONSISTENT WITH DELTA P.
+
+ ALLOCATE(P_INTERFACE(LEVSI+1))
+
+ DO J = 1, LATB
+ DO I = 1, LONB
+   P_INTERFACE(LEVSI+1) = VCOORD(LEVSI+1,1) ! MODEL TOP PRESSURE
+   DO L = LEVSI, 1, -1
+     P_INTERFACE(L) = P_INTERFACE(L+1) + GFSDATAI%DP(I,J,L)
+   ENDDO
+   GFSDATAI%PS(I,J) = P_INTERFACE(1)  ! SURFACE PRESSURE
+   DO L = 1, LEVSI
+     GFSDATAI%P(I,J,L) = (P_INTERFACE(L) + P_INTERFACE(L+1)) * 0.5
+   ENDDO
+ ENDDO
+ ENDDO
+
+ DEALLOCATE(P_INTERFACE)
+
+ DEALLOCATE(TMP)
+
+ RETURN
+
+ 99 CONTINUE
+ PRINT*,'FATAL ERROR READING FV3GFS ATMOSPHERIC NEMSIO FILE.'
+ PRINT*,'IRET IS: ', IRET
+ CALL ERREXIT(22)
+
+ END SUBROUTINE READ_FV3GFS_ATMS_DATA_NEMSIO
+
+ SUBROUTINE WRITE_FV3_ATMS_HEADER_NETCDF(LEVS_P1, NTRACM, NVCOORD, VCOORD)
+
+ use netcdf
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN) :: LEVS_P1
+ INTEGER, INTENT(IN) :: NTRACM
+ INTEGER, INTENT(IN) :: NVCOORD
+
+ REAL, INTENT(IN)    :: VCOORD(LEVS_P1, NVCOORD)
+
+ CHARACTER(LEN=13)   :: OUTFILE
+
+ INTEGER             :: ERROR, NCID
+ INTEGER             :: DIM_NVCOORD, DIM_LEVSP
+ INTEGER             :: ID_NTRAC, ID_VCOORD
+ INTEGER             :: FSIZE=65536, INITAL = 0
+ INTEGER             :: HEADER_BUFFER_VAL = 16384
+
+ REAL(KIND=8)        :: TMP(LEVS_P1,NVCOORD)
+
+ OUTFILE = "./gfs_ctrl.nc"
+
+ ERROR = NF90_CREATE(OUTFILE, IOR(NF90_NETCDF4,NF90_CLASSIC_MODEL), &
+                     NCID, INITIALSIZE=INITAL, CHUNKSIZE=FSIZE)
+ CALL NETCDF_ERROR(ERROR, 'Creating file '//TRIM(OUTFILE) )
+
+ ERROR = NF90_DEF_DIM(NCID, 'nvcoord', NVCOORD, DIM_NVCOORD)
+ CALL NETCDF_ERROR(ERROR, 'define dimension nvcoord for file='//TRIM(OUTFILE) )
+
+ ERROR = NF90_DEF_DIM(NCID, 'levsp', LEVS_P1, DIM_LEVSP)
+ CALL NETCDF_ERROR(ERROR, 'define dimension levsp for file='//TRIM(OUTFILE) )
+
+ ERROR = NF90_DEF_VAR(NCID, 'ntrac', NF90_INT, ID_NTRAC)
+ CALL NETCDF_ERROR(ERROR, 'define var ntrac for file='//TRIM(OUTFILE) )
+
+ ERROR = NF90_DEF_VAR(NCID, 'vcoord', NF90_DOUBLE, (/DIM_LEVSP, DIM_NVCOORD/), ID_VCOORD)
+ CALL NETCDF_ERROR(ERROR, 'define var vcoord for file='//TRIM(OUTFILE) )   
+
+ ERROR = NF90_ENDDEF(NCID, HEADER_BUFFER_VAL,4,0,4)
+ CALL NETCDF_ERROR(ERROR, 'end meta define for file='//TRIM(OUTFILE) )
+
+ ERROR = NF90_PUT_VAR( NCID, ID_NTRAC, NTRACM)
+ CALL NETCDF_ERROR(ERROR, 'write var ntrac for file='//TRIM(OUTFILE) )
+
+ TMP(1:LEVS_P1,:) = VCOORD(LEVS_P1:1:-1,:)
+ ERROR = NF90_PUT_VAR( NCID, ID_VCOORD, TMP)
+ CALL NETCDF_ERROR(ERROR, 'write var vcoord for file='//TRIM(OUTFILE) )
+
+ ERROR = NF90_CLOSE(NCID)
+
+ END SUBROUTINE WRITE_FV3_ATMS_HEADER_NETCDF
+
+ subroutine netcdf_error( err, string )
+ use netcdf
+ implicit none
+ integer, intent(in) :: err
+ character(len=*), intent(in) :: string
+ character(len=256) :: errmsg
+
+ if( err.EQ.NF90_NOERR )return
+ errmsg = NF90_STRERROR(err)
+ print*,''
+ print*,'FATAL ERROR: ', trim(string), ': ', trim(errmsg)
+ print*,'STOP.'
+ call errexit(999)
+
+ return
+ end subroutine netcdf_error
+
+ subroutine write_fv3_sfc_data_netcdf(lonb, latb, lsoil, sfcoutput, f10m, &
+                           t2m, q2m, uustar, ffmm, ffhh, tprcp, srflag, tile, &
+                           num_nsst_fields, nsst_output)
+
+ use netcdf
+
+ use surface_chgres, only        : sfc1d
+
+ implicit none
+
+ integer, intent(in)            :: latb, lonb, lsoil, tile
+ integer, intent(in)            :: num_nsst_fields
+ character(len=128)             :: outfile
+
+ integer                        :: fsize=65536, inital = 0
+ integer                        :: header_buffer_val = 16384
+ integer                        :: dim_lon, dim_lat, dim_lsoil
+ integer                        :: error, ncid, i
+ integer                        :: id_lon, id_lat, id_lsoil
+ integer                        :: id_geolon, id_geolat, id_slmsk
+ integer                        :: id_tsea, id_sheleg, id_tg3
+ integer                        :: id_zorl, id_alvsf, id_alvwf
+ integer                        :: id_alnsf, id_alnwf, id_vfrac
+ integer                        :: id_canopy, id_f10m, id_t2m
+ integer                        :: id_q2m, id_vtype, id_stype
+ integer                        :: id_facsf, id_facwf, id_uustar
+ integer                        :: id_ffmm, id_ffhh, id_hice
+ integer                        :: id_fice, id_tisfc, id_tprcp
+ integer                        :: id_srflag, id_snwdph, id_shdmin
+ integer                        :: id_shdmax, id_slope, id_snoalb
+ integer                        :: id_stc, id_smc, id_slc
+ integer                        :: id_tref, id_z_c, id_c_0
+ integer                        :: id_c_d, id_w_0, id_w_d
+ integer                        :: id_xt, id_xs, id_xu, id_xv
+ integer                        :: id_xz, id_zm, id_xtts, id_xzts
+ integer                        :: id_d_conv, id_ifd, id_dt_cool
+ integer                        :: id_qrain
+ 
+ logical                        :: write_nsst
+
+ real, intent(in)               :: f10m(lonb,latb)
+ real, intent(in)               :: q2m(lonb,latb)
+ real, intent(in)               :: t2m(lonb,latb)
+ real, intent(in)               :: uustar(lonb,latb)
+ real, intent(in)               :: ffmm(lonb,latb)
+ real, intent(in)               :: ffhh(lonb,latb)
+ real, intent(in)               :: tprcp(lonb,latb)
+ real, intent(in)               :: srflag(lonb,latb)
+ real, intent(in), optional     :: nsst_output(lonb*latb,num_nsst_fields)
+ real(kind=4)                   :: lsoil_data(lsoil)
+ real(kind=4), allocatable      :: dum2d(:,:), dum3d(:,:,:)
+
+ type(sfc1d)                    :: sfcoutput
+
+ write_nsst = .false.
+ if (present(nsst_output)) write_nsst = .true.
+
+ if (write_nsst) then
+   print*,'- WRITE FV3 SURFACE AND NSST DATA TO NETCDF FILE'
+ else
+   print*,'- WRITE FV3 SURFACE DATA TO NETCDF FILE'
+ endif
+
+ if (tile < 10) then
+   write(outfile, '(A, I1, A)')  'out.sfc.tile', tile, '.nc'
+ else
+   write(outfile, '(A, I2, A)')  'out.sfc.tile', tile, '.nc'
+ endif
+
+!--- open the file
+ error = nf90_create(outfile, ior(nf90_netcdf4,nf90_classic_model), &
+                     ncid, initialsize=inital, chunksize=fsize)
+ call netcdf_error(error, 'CREATING FILE='//trim(outfile) )
+
+!--- define dimension
+ error = nf90_def_dim(ncid, 'lon', lonb, dim_lon)
+ call netcdf_error(error, 'DEFINING LON DIMENSION' )
+ error = nf90_def_dim(ncid, 'lat', latb, dim_lat)
+ call netcdf_error(error, 'DEFINING LAT DIMENSION' )
+ error = nf90_def_dim(ncid, 'lsoil', lsoil, dim_lsoil)
+ call netcdf_error(error, 'DEFINING LSOIL DIMENSION' )
+
+ !--- define field
+ error = nf90_def_var(ncid, 'lon', NF90_FLOAT, (/dim_lon/), id_lon)
+ call netcdf_error(error, 'DEFINING LON FIELD' )
+ error = nf90_put_att(ncid, id_lon, "cartesian_axis", "X")
+ call netcdf_error(error, 'WRITING LON FIELD' )
+ error = nf90_def_var(ncid, 'lat', NF90_FLOAT, (/dim_lat/), id_lat)
+ call netcdf_error(error, 'DEFINING LAT FIELD' )
+ error = nf90_put_att(ncid, id_lat, "cartesian_axis", "Y")
+ call netcdf_error(error, 'WRITING LAT FIELD' )
+ error = nf90_def_var(ncid, 'lsoil', NF90_FLOAT, (/dim_lsoil/), id_lsoil)
+ call netcdf_error(error, 'DEFINING LSOIL FIELD' )
+ error = nf90_put_att(ncid, id_lsoil, "cartesian_axis", "Z")
+ call netcdf_error(error, 'WRITING LSOIL FIELD' )
+ error = nf90_def_var(ncid, 'geolon', NF90_FLOAT, (/dim_lon,dim_lat/), id_geolon)
+ call netcdf_error(error, 'DEFINING GEOLON' )
+ error = nf90_def_var(ncid, 'geolat', NF90_FLOAT, (/dim_lon,dim_lat/), id_geolat)
+ call netcdf_error(error, 'DEFINING GEOLAT' )
+ error = nf90_def_var(ncid, 'slmsk', NF90_FLOAT, (/dim_lon,dim_lat/), id_slmsk)
+ call netcdf_error(error, 'DEFINING SLMSK' )
+ error = nf90_def_var(ncid, 'tsea', NF90_FLOAT, (/dim_lon,dim_lat/), id_tsea)
+ call netcdf_error(error, 'DEFINING TSEA' )
+ error = nf90_def_var(ncid, 'sheleg', NF90_FLOAT, (/dim_lon,dim_lat/), id_sheleg)
+ call netcdf_error(error, 'DEFINING SHELEG' )
+ error = nf90_def_var(ncid, 'tg3', NF90_FLOAT, (/dim_lon,dim_lat/), id_tg3)
+ call netcdf_error(error, 'DEFINING TG3' )
+ error = nf90_def_var(ncid, 'zorl', NF90_FLOAT, (/dim_lon,dim_lat/), id_zorl)
+ call netcdf_error(error, 'DEFINING ZORL' )
+ error = nf90_def_var(ncid, 'alvsf', NF90_FLOAT, (/dim_lon,dim_lat/), id_alvsf)
+ call netcdf_error(error, 'DEFINING ALVSF' )
+ error = nf90_def_var(ncid, 'alvwf', NF90_FLOAT, (/dim_lon,dim_lat/), id_alvwf)
+ call netcdf_error(error, 'DEFINING ALVWF' )
+ error = nf90_def_var(ncid, 'alnsf', NF90_FLOAT, (/dim_lon,dim_lat/), id_alnsf)
+ call netcdf_error(error, 'DEFINING ALNSF' )
+ error = nf90_def_var(ncid, 'alnwf', NF90_FLOAT, (/dim_lon,dim_lat/), id_alnwf)
+ call netcdf_error(error, 'DEFINING ALNWF' )
+ error = nf90_def_var(ncid, 'vfrac', NF90_FLOAT, (/dim_lon,dim_lat/), id_vfrac)
+ call netcdf_error(error, 'DEFINING VFRAC' )
+ error = nf90_def_var(ncid, 'canopy', NF90_FLOAT, (/dim_lon,dim_lat/), id_canopy)
+ call netcdf_error(error, 'DEFINING CANOPY' )
+ error = nf90_def_var(ncid, 'f10m', NF90_FLOAT, (/dim_lon,dim_lat/), id_f10m)
+ call netcdf_error(error, 'DEFINING F10M' )
+ error = nf90_def_var(ncid, 't2m', NF90_FLOAT, (/dim_lon,dim_lat/), id_t2m)
+ call netcdf_error(error, 'DEFINING T2M' )
+ error = nf90_def_var(ncid, 'q2m', NF90_FLOAT, (/dim_lon,dim_lat/), id_q2m)
+ call netcdf_error(error, 'DEFINING Q2M' )
+ error = nf90_def_var(ncid, 'vtype', NF90_FLOAT, (/dim_lon,dim_lat/), id_vtype)
+ call netcdf_error(error, 'DEFINING VTYPE' )
+ error = nf90_def_var(ncid, 'stype', NF90_FLOAT, (/dim_lon,dim_lat/), id_stype)
+ call netcdf_error(error, 'DEFINING STYPE' )
+ error = nf90_def_var(ncid, 'facsf', NF90_FLOAT, (/dim_lon,dim_lat/), id_facsf)
+ call netcdf_error(error, 'DEFINING FACSF' )
+ error = nf90_def_var(ncid, 'facwf', NF90_FLOAT, (/dim_lon,dim_lat/), id_facwf)
+ call netcdf_error(error, 'DEFINING FACWF' )
+ error = nf90_def_var(ncid, 'uustar', NF90_FLOAT, (/dim_lon,dim_lat/), id_uustar)
+ call netcdf_error(error, 'DEFINING UUSTAR' )
+ error = nf90_def_var(ncid, 'ffmm', NF90_FLOAT, (/dim_lon,dim_lat/), id_ffmm)
+ call netcdf_error(error, 'DEFINING FFMM' )
+ error = nf90_def_var(ncid, 'ffhh', NF90_FLOAT, (/dim_lon,dim_lat/), id_ffhh)
+ call netcdf_error(error, 'DEFINING FFHH' )
+ error = nf90_def_var(ncid, 'hice', NF90_FLOAT, (/dim_lon,dim_lat/), id_hice)
+ call netcdf_error(error, 'DEFINING HICE' )
+ error = nf90_def_var(ncid, 'fice', NF90_FLOAT, (/dim_lon,dim_lat/), id_fice)
+ call netcdf_error(error, 'DEFINING FICE' )
+ error = nf90_def_var(ncid, 'tisfc', NF90_FLOAT, (/dim_lon,dim_lat/), id_tisfc)
+ call netcdf_error(error, 'DEFINING TISFC' )
+ error = nf90_def_var(ncid, 'tprcp', NF90_FLOAT, (/dim_lon,dim_lat/), id_tprcp)
+ call netcdf_error(error, 'DEFINING TPRCP' )
+ error = nf90_def_var(ncid, 'srflag', NF90_FLOAT, (/dim_lon,dim_lat/), id_srflag)
+ call netcdf_error(error, 'DEFINING SRFLAG' )
+ error = nf90_def_var(ncid, 'snwdph', NF90_FLOAT, (/dim_lon,dim_lat/), id_snwdph)
+ call netcdf_error(error, 'DEFINING SNWDPH' )
+ error = nf90_def_var(ncid, 'shdmin', NF90_FLOAT, (/dim_lon,dim_lat/), id_shdmin)
+ call netcdf_error(error, 'DEFINING SHDMIN' )
+ error = nf90_def_var(ncid, 'shdmax', NF90_FLOAT, (/dim_lon,dim_lat/), id_shdmax)
+ call netcdf_error(error, 'DEFINING SHDMAX' )
+ error = nf90_def_var(ncid, 'slope', NF90_FLOAT, (/dim_lon,dim_lat/), id_slope)
+ call netcdf_error(error, 'DEFINING SLOPE' )
+ error = nf90_def_var(ncid, 'snoalb', NF90_FLOAT, (/dim_lon,dim_lat/), id_snoalb)
+ call netcdf_error(error, 'DEFINING SNOALB' )
+ error = nf90_def_var(ncid, 'stc', NF90_FLOAT, (/dim_lon,dim_lat,dim_lsoil/), id_stc)
+ call netcdf_error(error, 'DEFINING STC' )
+ error = nf90_def_var(ncid, 'smc', NF90_FLOAT, (/dim_lon,dim_lat,dim_lsoil/), id_smc)
+ call netcdf_error(error, 'DEFINING SMC' )
+ error = nf90_def_var(ncid, 'slc', NF90_FLOAT, (/dim_lon,dim_lat,dim_lsoil/), id_slc)
+ call netcdf_error(error, 'DEFINING SLC' )
+ if (write_nsst) then
+   error = nf90_def_var(ncid, 'tref', NF90_FLOAT, (/dim_lon,dim_lat/), id_tref)
+   call netcdf_error(error, 'DEFINING TREF' )
+   error = nf90_def_var(ncid, 'z_c', NF90_FLOAT, (/dim_lon,dim_lat/), id_z_c)
+   call netcdf_error(error, 'DEFINING Z_C' )
+   error = nf90_def_var(ncid, 'c_0', NF90_FLOAT, (/dim_lon,dim_lat/), id_c_0)
+   call netcdf_error(error, 'DEFINING C_0' )
+   error = nf90_def_var(ncid, 'c_d', NF90_FLOAT, (/dim_lon,dim_lat/), id_c_d)
+   call netcdf_error(error, 'DEFINING C_D' )
+   error = nf90_def_var(ncid, 'w_0', NF90_FLOAT, (/dim_lon,dim_lat/), id_w_0)
+   call netcdf_error(error, 'DEFINING W_0' )
+   error = nf90_def_var(ncid, 'w_d', NF90_FLOAT, (/dim_lon,dim_lat/), id_w_d)
+   call netcdf_error(error, 'DEFINING W_D' )
+   error = nf90_def_var(ncid, 'xt', NF90_FLOAT, (/dim_lon,dim_lat/), id_xt)
+   call netcdf_error(error, 'DEFINING XT' )
+   error = nf90_def_var(ncid, 'xs', NF90_FLOAT, (/dim_lon,dim_lat/), id_xs)
+   call netcdf_error(error, 'DEFINING XS' )
+   error = nf90_def_var(ncid, 'xu', NF90_FLOAT, (/dim_lon,dim_lat/), id_xu)
+   call netcdf_error(error, 'DEFINING XU' )
+   error = nf90_def_var(ncid, 'xv', NF90_FLOAT, (/dim_lon,dim_lat/), id_xv)
+   call netcdf_error(error, 'DEFINING XV' )
+   error = nf90_def_var(ncid, 'xz', NF90_FLOAT, (/dim_lon,dim_lat/), id_xz)
+   call netcdf_error(error, 'DEFINING XZ' )
+   error = nf90_def_var(ncid, 'zm', NF90_FLOAT, (/dim_lon,dim_lat/), id_zm)
+   call netcdf_error(error, 'DEFINING ZM' )
+   error = nf90_def_var(ncid, 'xtts', NF90_FLOAT, (/dim_lon,dim_lat/), id_xtts)
+   call netcdf_error(error, 'DEFINING XTTS' )
+   error = nf90_def_var(ncid, 'xzts', NF90_FLOAT, (/dim_lon,dim_lat/), id_xzts)
+   call netcdf_error(error, 'DEFINING XZTS' )
+   error = nf90_def_var(ncid, 'd_conv', NF90_FLOAT, (/dim_lon,dim_lat/), id_d_conv)
+   call netcdf_error(error, 'DEFINING D_CONV' )
+   error = nf90_def_var(ncid, 'ifd', NF90_FLOAT, (/dim_lon,dim_lat/), id_ifd)
+   call netcdf_error(error, 'DEFINING IFD' )
+   error = nf90_def_var(ncid, 'dt_cool', NF90_FLOAT, (/dim_lon,dim_lat/), id_dt_cool)
+   call netcdf_error(error, 'DEFINING DT_COOL' )
+   error = nf90_def_var(ncid, 'qrain', NF90_FLOAT, (/dim_lon,dim_lat/), id_qrain)
+   call netcdf_error(error, 'DEFINING QRAIN' )
+ endif
+
+ error = nf90_enddef(ncid, header_buffer_val, 4, 0, 4)
+ call netcdf_error(error, 'DEFINING HEADER' )
+
+ allocate(dum2d(lonb,latb))
+
+ dum2d = reshape(sfcoutput%lons, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_lon, dum2d(:,1))
+ call netcdf_error(error, 'WRITING LON HEADER RECORD' )
+
+ dum2d = reshape(sfcoutput%lats, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_lat, dum2d(1,:))
+ call netcdf_error(error, 'WRITING LAT HEADER RECORD' )
+
+ do i = 1, lsoil
+   lsoil_data(i) = float(i)
+ enddo
+ error = nf90_put_var( ncid, id_lsoil, lsoil_data)
+ call netcdf_error(error, 'WRITING LSOIL HEADER' )
+
+ dum2d = reshape(sfcoutput%lons, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_geolon, dum2d)
+ call netcdf_error(error, 'WRITING GEOLON RECORD' )
+
+ dum2d = reshape(sfcoutput%lats, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_geolat, dum2d)
+ call netcdf_error(error, 'WRITING GEOLAT RECORD' )
+
+ dum2d = reshape(sfcoutput%lsmask, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_slmsk, dum2d)
+ call netcdf_error(error, 'WRITING SLMSK RECORD' )
+
+ dum2d = reshape(sfcoutput%skin_temp, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_tsea, dum2d)
+ call netcdf_error(error, 'WRITING TSEA RECORD' )
+
+ dum2d = reshape(sfcoutput%snow_liq_equiv, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_sheleg, dum2d)
+ call netcdf_error(error, 'WRITING SHELEG RECORD' )
+
+ dum2d = reshape(sfcoutput%substrate_temp, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_tg3, dum2d)
+ call netcdf_error(error, 'WRITING TG3 RECORD' )
+
+ dum2d = reshape(sfcoutput%z0, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_zorl, dum2d)
+ call netcdf_error(error, 'WRITING ZORL RECORD' )
+
+ dum2d = reshape(sfcoutput%alvsf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_alvsf, dum2d)
+ call netcdf_error(error, 'WRITING ALVSF RECORD' )
+
+ dum2d = reshape(sfcoutput%alvwf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_alvwf, dum2d)
+ call netcdf_error(error, 'WRITING ALVWF RECORD' )
+
+ dum2d = reshape(sfcoutput%alnsf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_alnsf, dum2d)
+ call netcdf_error(error, 'WRITING ALNSF RECORD' )
+
+ dum2d = reshape(sfcoutput%alnwf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_alnwf, dum2d)
+ call netcdf_error(error, 'WRITING ALNWF RECORD' )
+
+ dum2d = reshape(sfcoutput%greenfrc, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_vfrac, dum2d)
+ call netcdf_error(error, 'WRITING VFRAC RECORD' )
+
+ dum2d = reshape(sfcoutput%canopy_mc, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_canopy, dum2d)
+ call netcdf_error(error, 'WRITING CANOPY RECORD' )
+
+ dum2d = f10m
+ error = nf90_put_var( ncid, id_f10m, dum2d)
+ call netcdf_error(error, 'WRITING F10M RECORD' )
+
+ dum2d = t2m
+ error = nf90_put_var( ncid, id_t2m, dum2d)
+ call netcdf_error(error, 'WRITING T2M RECORD' )
+
+ dum2d = q2m
+ error = nf90_put_var( ncid, id_q2m, dum2d)
+ call netcdf_error(error, 'WRITING Q2M RECORD' )
+
+ dum2d = reshape(float(sfcoutput%veg_type), (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_vtype, dum2d)
+ call netcdf_error(error, 'WRITING VTYPE RECORD' )
+
+ dum2d = reshape(float(sfcoutput%soil_type), (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_stype, dum2d)
+ call netcdf_error(error, 'WRITING STYPE RECORD' )
+
+ dum2d = reshape(sfcoutput%facsf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_facsf, dum2d)
+ call netcdf_error(error, 'WRITING FACSF RECORD' )
+
+ dum2d = reshape(sfcoutput%facwf, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_facwf, dum2d)
+ call netcdf_error(error, 'WRITING FACWF RECORD' )
+
+ dum2d = uustar
+ error = nf90_put_var( ncid, id_uustar, dum2d)
+ call netcdf_error(error, 'WRITING UUSTAR RECORD' )
+
+ dum2d = ffmm
+ error = nf90_put_var( ncid, id_ffmm, dum2d)
+ call netcdf_error(error, 'WRITING FFMM RECORD' )
+
+ dum2d = ffhh
+ error = nf90_put_var( ncid, id_ffhh, dum2d)
+ call netcdf_error(error, 'WRITING FFHH RECORD' )
+
+ dum2d = reshape(sfcoutput%sea_ice_depth, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_hice, dum2d)
+ call netcdf_error(error, 'WRITING HICE RECORD' )
+
+ dum2d = reshape(sfcoutput%sea_ice_fract, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_fice, dum2d)
+ call netcdf_error(error, 'WRITING FICE RECORD' )
+
+ dum2d = reshape(sfcoutput%sea_ice_temp, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_tisfc, dum2d)
+ call netcdf_error(error, 'WRITING TISFC RECORD' )
+
+ dum2d = tprcp
+ error = nf90_put_var( ncid, id_tprcp, dum2d)
+ call netcdf_error(error, 'WRITING TPRCP RECORD' )
+
+ dum2d = srflag
+ error = nf90_put_var( ncid, id_srflag, dum2d)
+ call netcdf_error(error, 'WRITING SRFLAG RECORD' )
+
+ dum2d = reshape(sfcoutput%snow_depth, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_snwdph, dum2d)
+ call netcdf_error(error, 'WRITING SNWDPH RECORD' )
+
+ dum2d = reshape(sfcoutput%greenfrc_min, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_shdmin, dum2d)
+ call netcdf_error(error, 'WRITING SHDMIN RECORD' )
+
+ dum2d = reshape(sfcoutput%greenfrc_max, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_shdmax, dum2d)
+ call netcdf_error(error, 'WRITING SHDMAX RECORD' )
+
+ dum2d = reshape(float(sfcoutput%slope_type), (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_slope, dum2d)
+ call netcdf_error(error, 'WRITING SLOPE RECORD' )
+
+ dum2d = reshape(sfcoutput%mxsnow_alb, (/lonb,latb/) )
+ error = nf90_put_var( ncid, id_snoalb, dum2d)
+ call netcdf_error(error, 'WRITING SNOALB RECORD' )
+
+ deallocate (dum2d)
+
+ allocate(dum3d(lonb,latb,lsoil))
+
+ dum3d = reshape(sfcoutput%soil_temp, (/lonb,latb,lsoil/) )
+ error = nf90_put_var( ncid, id_stc, dum3d)
+ call netcdf_error(error, 'WRITING STC RECORD' )
+
+ dum3d = reshape(sfcoutput%soilm_tot, (/lonb,latb,lsoil/) )
+ error = nf90_put_var( ncid, id_smc, dum3d)
+ call netcdf_error(error, 'WRITING SMC RECORD' )
+
+ dum3d = reshape(sfcoutput%soilm_liq, (/lonb,latb,lsoil/) )
+ error = nf90_put_var( ncid, id_slc, dum3d)
+ call netcdf_error(error, 'WRITING SLC RECORD' )
+
+ deallocate (dum3d)
+
+ if (write_nsst) then
+
+   allocate(dum2d(lonb,latb))
+
+   dum2d = reshape(nsst_output(:,17), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_tref, dum2d)
+   call netcdf_error(error, 'WRITING TREF RECORD' )
+
+   dum2d = reshape(nsst_output(:,10), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_z_c, dum2d)
+   call netcdf_error(error, 'WRITING Z_C RECORD' )
+
+   dum2d = reshape(nsst_output(:,11), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_c_0, dum2d)
+   call netcdf_error(error, 'WRITING C_0 RECORD' )
+
+   dum2d = reshape(nsst_output(:,12), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_c_d, dum2d)
+   call netcdf_error(error, 'WRITING C_D RECORD' )
+
+   dum2d = reshape(nsst_output(:,13), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_w_0, dum2d)
+   call netcdf_error(error, 'WRITING W_0 RECORD' )
+
+   dum2d = reshape(nsst_output(:,14), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_w_d, dum2d)
+   call netcdf_error(error, 'WRITING W_D RECORD' )
+
+   dum2d = reshape(nsst_output(:,1), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xt, dum2d)
+   call netcdf_error(error, 'WRITING XT RECORD' )
+
+   dum2d = reshape(nsst_output(:,2), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xs, dum2d)
+   call netcdf_error(error, 'WRITING XS RECORD' )
+
+   dum2d = reshape(nsst_output(:,3), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xu, dum2d)
+   call netcdf_error(error, 'WRITING XU RECORD' )
+
+   dum2d = reshape(nsst_output(:,4), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xv, dum2d)
+   call netcdf_error(error, 'WRITING XV RECORD' )
+
+   dum2d = reshape(nsst_output(:,5), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xz, dum2d)
+   call netcdf_error(error, 'WRITING XZ RECORD' )
+
+   dum2d = reshape(nsst_output(:,6), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_zm, dum2d)
+   call netcdf_error(error, 'WRITING ZM RECORD' )
+
+   dum2d = reshape(nsst_output(:,7), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xtts, dum2d)
+   call netcdf_error(error, 'WRITING XTTS RECORD' )
+
+   dum2d = reshape(nsst_output(:,8), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_xzts, dum2d)
+   call netcdf_error(error, 'WRITING XZTS RECORD' )
+
+   dum2d = reshape(nsst_output(:,15), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_d_conv, dum2d)
+   call netcdf_error(error, 'WRITING D_CONV RECORD' )
+
+   dum2d = reshape(nsst_output(:,16), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_ifd, dum2d)
+   call netcdf_error(error, 'WRITING IFD RECORD' )
+
+   dum2d = reshape(nsst_output(:,9), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_dt_cool, dum2d)
+   call netcdf_error(error, 'WRITING DT_COOL RECORD' )
+
+   dum2d = reshape(nsst_output(:,18), (/lonb,latb/) )
+   error = nf90_put_var(ncid, id_qrain, dum2d)
+   call netcdf_error(error, 'WRITING QRAIN RECORD' )
+
+   deallocate(dum2d)
+
+ endif
+
+ error = nf90_close(ncid)
+
+ end subroutine write_fv3_sfc_data_netcdf
+
+ SUBROUTINE READ_FV3_LATLON_NETCDF(TILE_NUM, IMO, JMO, GEOLON, GEOLAT)
+
+ use netcdf
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN)     :: TILE_NUM, IMO, JMO
+
+ REAL, INTENT(OUT)       :: GEOLON(IMO,JMO), GEOLAT(IMO,JMO)
+
+ CHARACTER(LEN=256)      :: TILEFILE
+
+ INTEGER                 :: ERROR, ID_DIM, NCID, NX, NY
+ INTEGER                 :: ID_VAR
+
+ REAL, ALLOCATABLE       :: TMPVAR(:,:)
+
+ WRITE(TILEFILE, "(A,I1)") "chgres.fv3.grd.t", TILE_NUM
+
+ ERROR=NF90_OPEN(TRIM(TILEFILE),NF90_NOWRITE,NCID)
+ CALL NETCDF_ERROR(ERROR, 'OPENING FILE: '//TRIM(TILEFILE) )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'nx', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NX)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX' )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'ny', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NY)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY' )
+
+ IF ((NX/2) /= IMO .OR. (NY/2) /= JMO) THEN
+   PRINT*,'FATAL ERROR: DIMENSIONS IN GRID FILE WRONG.'
+   CALL ERREXIT(160)
+ ENDIF
+
+ ALLOCATE(TMPVAR(NX,NY))
+
+ ERROR=NF90_INQ_VARID(NCID, 'x', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, TMPVAR)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X RECORD' )
+
+ GEOLON(1:IMO,1:JMO)     = TMPVAR(2:NX:2,2:NY:2)
+
+ ERROR=NF90_INQ_VARID(NCID, 'y', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, TMPVAR)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y RECORD' )
+
+ GEOLAT(1:IMO,1:JMO)     = TMPVAR(2:NX:2,2:NY:2)
+
+ DEALLOCATE(TMPVAR)
+
+ ERROR = NF90_CLOSE(NCID)
+
+ END SUBROUTINE READ_FV3_LATLON_NETCDF
+
+ SUBROUTINE READ_FV3_GRID_DIMS_NETCDF(TILE_NUM,IMO,JMO)
+   
+ use netcdf
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN)   :: TILE_NUM
+ INTEGER, INTENT(OUT)  :: IMO, JMO
+
+ CHARACTER(LEN=256)    :: TILEFILE
+
+ INTEGER               :: ERROR, NCID, ID_DIM
+  
+ IF (TILE_NUM < 10) THEN
+   WRITE(TILEFILE, "(A,I1)") "chgres.fv3.orog.t", TILE_NUM
+ ELSE
+   WRITE(TILEFILE, "(A,I2)") "chgres.fv3.orog.t", TILE_NUM
+ ENDIF
+
+ PRINT*,'WILL READ GRID DIMENSIONS FROM: ', TRIM(TILEFILE)
+
+ ERROR=NF90_OPEN(TRIM(TILEFILE),NF90_NOWRITE,NCID)
+ CALL NETCDF_ERROR(ERROR, 'OPENING: '//TRIM(TILEFILE) )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'lon', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'READING LON ID' )
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=IMO)
+ CALL NETCDF_ERROR(ERROR, 'READING LON VALUE' )
+
+ PRINT*,'I-DIRECTION GRID DIM: ',IMO
+
+ ERROR=NF90_INQ_DIMID(NCID, 'lat', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'READING LAT ID' )
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=JMO)
+ CALL NETCDF_ERROR(ERROR, 'READING LAT VALUE' )
+
+ PRINT*,'J-DIRECTION GRID DIM: ',JMO
+
+ ERROR = NF90_CLOSE(NCID)
+
+ END SUBROUTINE READ_FV3_GRID_DIMS_NETCDF
+
+ SUBROUTINE READ_FV3_GRID_DATA_NETCDF(FIELD,TILE_NUM,IMO,JMO,SFCDATA)
+   
+ use netcdf
+
+ IMPLICIT NONE
+
+ CHARACTER(LEN=*)      :: FIELD
+
+ INTEGER, INTENT(IN)   :: IMO, JMO, TILE_NUM
+
+ REAL, INTENT(OUT)     :: SFCDATA(IMO,JMO)
+
+ CHARACTER(LEN=256)    :: TILEFILE
+
+ INTEGER               :: ERROR, NCID, LAT, LON, ID_DIM
+ INTEGER               :: ID_VAR
+  
+ IF (TILE_NUM < 10) THEN
+   WRITE(TILEFILE, "(A,I1)") "chgres.fv3.orog.t", TILE_NUM
+ ELSE
+   WRITE(TILEFILE, "(A,I2)") "chgres.fv3.orog.t", TILE_NUM
+ ENDIF
+
+ PRINT*,'WILL READ ',TRIM(FIELD), ' FROM: ', TRIM(TILEFILE)
+
+ ERROR=NF90_OPEN(TRIM(TILEFILE),NF90_NOWRITE,NCID)
+ CALL NETCDF_ERROR(ERROR, 'OPENING: '//TRIM(TILEFILE) )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'lon', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'READING LON ID' )
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=LON)
+ CALL NETCDF_ERROR(ERROR, 'READING LON VALUE' )
+
+ PRINT*,'LON IS ',LON
+ IF(LON/=IMO) THEN
+   PRINT*,'FATAL ERROR: I-DIMENSIONS DO NOT MATCH ',LON,IMO
+   CALL ERREXIT(101)
+ ENDIF
+
+ ERROR=NF90_INQ_DIMID(NCID, 'lat', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'READING LAT ID' )
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=LAT)
+ CALL NETCDF_ERROR(ERROR, 'READING LAT VALUE' )
+
+ PRINT*,'LAT IS ',LAT
+ IF(LAT/=JMO) THEN
+   PRINT*,'FATAL ERROR: J-DIMENSIONS DO NOT MATCH ',LAT,JMO
+   CALL ERREXIT(102)
+ ENDIF
+
+ ERROR=NF90_INQ_VARID(NCID, FIELD, ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'READING FIELD ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, SFCDATA)
+ CALL NETCDF_ERROR(ERROR, 'READING FIELD' )
+
+ ERROR = NF90_CLOSE(NCID)
+
+ END SUBROUTINE READ_FV3_GRID_DATA_NETCDF
+
+ SUBROUTINE WRITE_FV3_ATMS_BNDY_NETCDF(ZS,PS,T,W,U,V,Q,VCOORD,LONB,LATB,&
+                                  LEVSO,NTRACM,NVCOORD,HALO,INPTYP, &
+                                  MODELNAME)
+
+!---------------------------------------------------------------------------
+!
+! Output data along the four halo boundaries.  The naming convention is
+! based on point (1,1) being in the lower left corner of the grid:
+!
+!          --------------- TOP ---------------
+!          |                                 |
+!          |                                 |
+!     LEFT |                                 | RIGHT
+!          |                                 |
+!          |PT(1,1)                          |
+!          ------------- BOTTOM --------------
+!
+!---------------------------------------------------------------------------
+
+ use netcdf
+
+ IMPLICIT NONE
+
+ CHARACTER(LEN=8), INTENT(IN) :: MODELNAME
+
+ INTEGER,  INTENT(IN)  :: LONB, LATB, LEVSO, NTRACM
+ INTEGER,  INTENT(IN)  :: NVCOORD, HALO, INPTYP
+
+ REAL, INTENT(IN)      :: PS(LONB,LATB), ZS(LONB,LATB)
+ REAL, INTENT(IN)      :: T(LONB,LATB,LEVSO), W(LONB,LATB,LEVSO)
+ REAL, INTENT(IN)      :: U(LONB,LATB,LEVSO), V(LONB,LATB,LEVSO)
+ REAL, INTENT(IN)      :: Q(LONB,LATB,LEVSO,NTRACM)
+ REAL, INTENT(IN)      :: VCOORD(LEVSO+1,NVCOORD)
+
+ CHARACTER(LEN=256)    :: OUTFILE, TILEFILE
+
+ INTEGER               :: I, II, J, JJ, IHALO, JHALO, K
+ INTEGER               :: HALO_P1, IM, JM, JM2, ID_VAR
+ INTEGER               :: ID_I_BOTTOM, ID_J_BOTTOM
+ INTEGER               :: ID_I_TOP, ID_J_TOP
+ INTEGER               :: ID_I_RIGHT, ID_J_RIGHT
+ INTEGER               :: ID_I_LEFT, ID_J_LEFT
+ INTEGER               :: ID_I_W_BOTTOM, ID_J_W_BOTTOM
+ INTEGER               :: ID_I_W_TOP, ID_J_W_TOP
+ INTEGER               :: ID_I_W_RIGHT, ID_J_W_RIGHT
+ INTEGER               :: ID_I_W_LEFT, ID_J_W_LEFT
+ INTEGER               :: ID_I_S_BOTTOM, ID_J_S_BOTTOM
+ INTEGER               :: ID_I_S_TOP, ID_J_S_TOP
+ INTEGER               :: ID_I_S_RIGHT, ID_J_S_RIGHT
+ INTEGER               :: ID_I_S_LEFT, ID_J_S_LEFT
+ INTEGER               :: ID_PS_TOP, ID_PS_BOTTOM
+ INTEGER               :: ID_PS_RIGHT, ID_PS_LEFT
+ INTEGER               :: ID_T_TOP, ID_T_BOTTOM
+ INTEGER               :: ID_T_RIGHT, ID_T_LEFT
+ INTEGER               :: ID_SPHUM_TOP, ID_SPHUM_BOTTOM
+ INTEGER               :: ID_SPHUM_RIGHT, ID_SPHUM_LEFT
+ INTEGER               :: ID_CLWMR_TOP, ID_CLWMR_BOTTOM
+ INTEGER               :: ID_CLWMR_RIGHT, ID_CLWMR_LEFT
+ INTEGER               :: ID_O3MR_TOP, ID_O3MR_BOTTOM
+ INTEGER               :: ID_O3MR_RIGHT, ID_O3MR_LEFT
+ INTEGER               :: ID_RWMR_TOP, ID_RWMR_BOTTOM
+ INTEGER               :: ID_RWMR_RIGHT, ID_RWMR_LEFT
+ INTEGER               :: ID_ICMR_TOP, ID_ICMR_BOTTOM
+ INTEGER               :: ID_ICMR_RIGHT, ID_ICMR_LEFT
+ INTEGER               :: ID_SNMR_TOP, ID_SNMR_BOTTOM
+ INTEGER               :: ID_SNMR_RIGHT, ID_SNMR_LEFT
+ INTEGER               :: ID_GRLE_TOP, ID_GRLE_BOTTOM
+ INTEGER               :: ID_GRLE_RIGHT, ID_GRLE_LEFT
+ INTEGER               :: ID_W_TOP, ID_W_BOTTOM
+ INTEGER               :: ID_W_RIGHT, ID_W_LEFT
+ INTEGER               :: ID_ZH_TOP, ID_ZH_BOTTOM
+ INTEGER               :: ID_ZH_RIGHT, ID_ZH_LEFT
+ INTEGER               :: ID_U_S_TOP, ID_U_S_BOTTOM
+ INTEGER               :: ID_U_S_RIGHT, ID_U_S_LEFT
+ INTEGER               :: ID_U_W_TOP, ID_U_W_BOTTOM
+ INTEGER               :: ID_U_W_RIGHT, ID_U_W_LEFT
+ INTEGER               :: ID_V_S_TOP, ID_V_S_BOTTOM
+ INTEGER               :: ID_V_S_RIGHT, ID_V_S_LEFT
+ INTEGER               :: ID_V_W_TOP, ID_V_W_BOTTOM
+ INTEGER               :: ID_V_W_RIGHT, ID_V_W_LEFT
+ INTEGER               :: ERROR, ID_DIM, NX, NY, NCID, NCID2
+ INTEGER               :: DIM_HALO, DIM_HALOP, DIM_LON, DIM_LAT
+ INTEGER               :: DIM_LATM, DIM_LONP
+ INTEGER               :: DIM_LEV, DIM_LEVP
+ INTEGER               :: ISTART, IEND, JSTART, JEND
+ INTEGER               :: LEVSO_P1
+ INTEGER               :: INITAL=0, FSIZE=65536
+ INTEGER               :: HEADER_BUFFER_VAL = 16384
+ INTEGER, ALLOCATABLE  :: IDUM(:)
+
+ REAL, ALLOCATABLE     :: GEOLAT(:,:), GEOLON(:,:)
+ REAL, ALLOCATABLE     :: GEOLAT_HALO(:,:), GEOLON_HALO(:,:)
+ REAL, ALLOCATABLE     :: HALO_2D(:,:), HALO_3D(:,:,:), HALO_3D2(:,:,:)
+ REAL, ALLOCATABLE     :: AK(:), BK(:), ZH(:,:,:)
+
+ REAL(KIND=4), ALLOCATABLE  :: HALO_2D_4BYTE(:,:)
+ REAL(KIND=4), ALLOCATABLE  :: HALO_3D_4BYTE(:,:,:)
+
+ print*,''
+ print*,'- COMPUTE AND OUTPUT LATERAL BOUNDARY DATA.'
+
+ HALO_P1 = HALO + 1
+
+ LEVSO_P1 = LEVSO + 1
+
+ ALLOCATE(AK(LEVSO_P1))
+ ALLOCATE(BK(LEVSO_P1))
+ ALLOCATE(ZH(LONB,LATB,LEVSO_P1))
+
+ AK = VCOORD(:,1)
+ BK = VCOORD(:,2)
+
+ CALL COMPUTE_ZH(LONB,LATB,LEVSO,AK,BK,PS,ZS,T,Q,ZH)
+    
+ DEALLOCATE(AK, BK)
+
+!----------------------------------------------------------------------------------
+! Read FV3 grid file.  This routine only works for a regional domain
+! and assumes that domain is tile number 7.
+!----------------------------------------------------------------------------------
+
+ TILEFILE="chgres.fv3.grd.t7"
+
+ PRINT*, "READ FV3 GRID INFO FROM: "//TRIM(TILEFILE)
+
+ ERROR=NF90_OPEN(TRIM(TILEFILE),NF90_NOWRITE,NCID)
+ CALL NETCDF_ERROR(ERROR, 'OPENING FILE: '//TRIM(TILEFILE) )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'nx', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NX)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX' )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'ny', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NY)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY' )
+
+ IF (MOD(NX,2) /= 0) THEN
+   PRINT*,'FATAL ERROR: NX IS NOT EVEN'
+   CALL ERREXIT(130)
+ ENDIF
+
+ IF (MOD(NY,2) /= 0) THEN
+   PRINT*,'FATAL ERROR: NY IS NOT EVEN'
+   CALL ERREXIT(131)
+ ENDIF
+
+ IM = NX/2
+ JM = NY/2
+
+ ALLOCATE(GEOLON(NX+1,NY+1))
+ ALLOCATE(GEOLAT(NX+1,NY+1))
+
+ ERROR=NF90_INQ_VARID(NCID, 'x', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, GEOLON)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X RECORD' )
+
+ ERROR=NF90_INQ_VARID(NCID, 'y', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, GEOLAT)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y RECORD' )
+
+ ERROR = NF90_CLOSE(NCID2)
+
+!----------------------------------------------------------------------------------
+! Create output file header.
+!----------------------------------------------------------------------------------
+
+ WRITE(OUTFILE, '(A, I1, A)')  'gfs_bndy.tile', 7, '.nc'
+ ERROR = NF90_CREATE(OUTFILE, IOR(NF90_NETCDF4,NF90_CLASSIC_MODEL), &
+                     NCID2, INITIALSIZE=INITAL, CHUNKSIZE=FSIZE)
+ CALL NETCDF_ERROR(ERROR, 'CREATING FILE: '//TRIM(OUTFILE) )
+
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'FV3GFS GAUSSIAN NEMSIO FILE')
+ ELSEIF (INPTYP == 1) THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'GFS NEMSIO FILE')
+ ELSEIF (INPTYP == 2) THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'GFS SIGIO FILE')
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING GLOBAL SOURCE ATTRIBUTE')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lon', IM, DIM_LON)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LON DIMENSION')
+
+ JM2 = JM - (2*HALO)
+ ERROR = NF90_DEF_DIM(NCID2, 'lat', JM2, DIM_LAT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LAT DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lonp', (IM+1), DIM_LONP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LONP DIMENSION')
+
+ JM2 = (JM + 1) - (2*HALO_P1)
+ ERROR = NF90_DEF_DIM(NCID2, 'latm', JM2, DIM_LATM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LATM DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'halo', HALO, DIM_HALO)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING HALO DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'halop', HALO_P1, DIM_HALOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING HALOP DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lev', LEVSO, DIM_LEV)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LEV DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'levp', LEVSO_P1, DIM_LEVP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LEVP DIMENSION')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_bottom', NF90_INT, &
+                             (/DIM_LON/), ID_I_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_BOTTOM, "long_name", "i-indices bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_bottom', NF90_INT, &
+                             (/DIM_HALO/), ID_J_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_BOTTOM, "long_name", "j-indices bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_top', NF90_INT, &
+                             (/DIM_LON/), ID_I_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_TOP, "long_name", "i-indices top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_top', NF90_INT, &
+                             (/DIM_HALO/), ID_J_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_TOP, "long_name", "j-indices top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_right', NF90_INT, &
+                             (/DIM_HALO/), ID_I_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_RIGHT, "long_name", "i-indices right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_right', NF90_INT, &
+                             (/DIM_LAT/), ID_J_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_RIGHT, "long_name", "j-indices right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_left', NF90_INT, &
+                             (/DIM_HALO/), ID_I_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_LEFT, "long_name", "i-indices left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_left', NF90_INT, &
+                             (/DIM_LAT/), ID_J_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_LEFT, "long_name", "j-indices left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'ps_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO/), ID_PS_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_BOTTOM, "long_name", "surface pressure bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_BOTTOM, "units", "Pa")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'ps_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO/), ID_PS_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_TOP, "long_name", "surface pressure top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_TOP, "units", "Pa")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'ps_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT/), ID_PS_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_RIGHT, "long_name", "surface pressure right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_RIGHT, "units", "Pa")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'ps_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT/), ID_PS_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_LEFT, "long_name", "surface pressure left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS_LEFT, "units", "Pa")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'w_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_W_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_BOTTOM')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_BOTTOM, "long_name", "vertical velocity bottom bndy")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_BOTTOM, "long_name", "omega bottom bndy")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_BOTTOM ATTRIBUTE')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_BOTTOM, "units", "m/s")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_BOTTOM, "units", "Pa/s")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'w_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_W_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_TOP')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_TOP, "long_name", "vertical velocity top bndy")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_TOP, "long_name", "omega top bndy")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_TOP ATTRIBUTE')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_TOP, "units", "m/s")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_TOP, "units", "Pa/s")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'w_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_W_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_RIGHT')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_RIGHT, "long_name", "vertical velocity right bndy")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_RIGHT, "long_name", "omega right bndy")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_RIGHT ATTRIBUTE')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_RIGHT, "units", "m/s")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_RIGHT, "units", "Pa/s")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'w_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_W_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_LEFT')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_LEFT, "long_name", "vertical velocity left bndy")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_LEFT, "long_name", "omega left bndy")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_LEFT ATTRIBUTE')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_LEFT, "units", "m/s")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W_LEFT, "units", "Pa/s")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'zh_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEVP/), ID_ZH_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_BOTTOM, "long_name", "height bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_BOTTOM, "units", "m")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'zh_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEVP/), ID_ZH_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_TOP, "long_name", "height top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_TOP, "units", "m")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'zh_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEVP/), ID_ZH_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_RIGHT, "long_name", "height right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_RIGHT, "units", "m")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'zh_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEVP/), ID_ZH_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_LEFT, "long_name", "height left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH_LEFT, "units", "m")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 't_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_T_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_BOTTOM, "long_name", "temperature bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_BOTTOM, "units", "kelvin")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 't_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_T_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_TOP, "long_name", "temperature top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_TOP, "units", "kelvin")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 't_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_T_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_RIGHT, "long_name", "temperature right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_RIGHT, "units", "kelvin")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 't_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_T_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_LEFT, "long_name", "temperature left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T_LEFT, "units", "kelvin")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'sphum_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_SPHUM_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_BOTTOM, "long_name", "specific humidity bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_BOTTOM, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'sphum_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_SPHUM_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_TOP, "long_name", "specific humidity top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_TOP, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'sphum_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_SPHUM_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_RIGHT, "long_name", "specific humidity right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_RIGHT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'sphum_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_SPHUM_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_LEFT, "long_name", "specific humidity left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM_LEFT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'o3mr_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_O3MR_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_BOTTOM, "long_name", "ozone bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_BOTTOM, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'o3mr_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_O3MR_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_TOP, "long_name", "ozone top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_TOP, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'o3mr_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_O3MR_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_RIGHT, "long_name", "ozone right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_RIGHT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'o3mr_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_O3MR_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_LEFT, "long_name", "ozone left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR_LEFT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'liq_wat_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_CLWMR_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LIQ_WAT_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_BOTTOM, "long_name", "cloud liq water mixing ratio bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_BOTTOM, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'liq_wat_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_CLWMR_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LIQ_WAT_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_TOP, "long_name", "cloud liq water mixing ratio top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_TOP, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'liq_wat_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_CLWMR_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LIQ_WAT_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_RIGHT, "long_name", "cloud liq water mixing ratio right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_RIGHT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'liq_wat_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_CLWMR_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LIQ_WAT_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_LEFT, "long_name", "cloud liq water mixing ratio left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR_LEFT, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR_LEFT UNITS')
+
+ IF (NTRACM > 3) THEN
+
+   ERROR = NF90_DEF_VAR(NCID2, 'rainwat_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_RWMR_BOTTOM)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_BOTTOM')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_BOTTOM, "long_name", "rain water mixing ratio bottom bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_BOTTOM ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_BOTTOM, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_BOTTOM UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'rainwat_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_RWMR_TOP)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_TOP')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_TOP, "long_name", "rain water mixing ratio top bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_TOP ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_TOP, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_TOP UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'rainwat_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_RWMR_RIGHT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_RIGHT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_RIGHT, "long_name", "rain water mixing ratio right bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_RIGHT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_RIGHT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_RIGHT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'rainwat_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_RWMR_LEFT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_LEFT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_LEFT, "long_name", "rain water mixing ratio left bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_LEFT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR_LEFT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR_LEFT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'ice_wat_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_ICMR_BOTTOM)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_BOTTOM')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_BOTTOM, "long_name", "ice water mixing ratio bottom bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_BOTTOM ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_BOTTOM, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_BOTTOM UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'ice_wat_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_ICMR_TOP)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_TOP')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_TOP, "long_name", "ice water mixing ratio top bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_TOP ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_TOP, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_TOP UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'ice_wat_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_ICMR_RIGHT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_RIGHT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_RIGHT, "long_name", "ice water mixing ratio right bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_RIGHT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_RIGHT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_RIGHT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'ice_wat_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_ICMR_LEFT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_LEFT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_LEFT, "long_name", "ice water mixing ratio left bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_LEFT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR_LEFT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR_LEFT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'snowwat_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_SNMR_BOTTOM)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_BOTTOM')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_BOTTOM, "long_name", "snow water mixing ratio bottom bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_BOTTOM ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_BOTTOM, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_BOTTOM UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'snowwat_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_SNMR_TOP)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_TOP')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_TOP, "long_name", "snow water mixing ratio top bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_TOP ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_TOP, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_TOP UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'snowwat_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_SNMR_RIGHT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_RIGHT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_RIGHT, "long_name", "snow water mixing ratio right bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_RIGHT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_RIGHT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_RIGHT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'snowwat_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_SNMR_LEFT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_LEFT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_LEFT, "long_name", "snow water mixing ratio left bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_LEFT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR_LEFT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR_LEFT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'graupel_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_GRLE_BOTTOM)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_BOTTOM')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_BOTTOM, "long_name", "graupel mixing ratio bottom bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_BOTTOM ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_BOTTOM, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_BOTTOM UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'graupel_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALO, DIM_LEV/), ID_GRLE_TOP)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_TOP')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_TOP, "long_name", "graupel mixing ratio top bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_TOP ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_TOP, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_TOP UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'graupel_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_GRLE_RIGHT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_RIGHT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_RIGHT, "long_name", "graupel mixing ratio right bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_RIGHT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_RIGHT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_RIGHT UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'graupel_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LAT, DIM_LEV/), ID_GRLE_LEFT)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_LEFT')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_LEFT, "long_name", "graupel mixing ratio left bndy")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_LEFT ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE_LEFT, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE_LEFT UNITS')
+
+ ENDIF
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_w_bottom', NF90_INT, &
+                             (/DIM_LONP/), ID_I_W_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_W_BOTTOM, "long_name", "i-indices west edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_w_bottom', NF90_INT, &
+                             (/DIM_HALO/), ID_J_W_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_W_BOTTOM, "long_name", "j-indices west edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_w_top', NF90_INT, &
+                             (/DIM_LONP/), ID_I_W_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_W_TOP, "long_name", "i-indices west edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_w_top', NF90_INT, &
+                             (/DIM_HALO/), ID_J_W_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_W_TOP, "long_name", "j-indices west edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_w_right', NF90_INT, &
+                             (/DIM_HALOP/), ID_I_W_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_W_RIGHT, "long_name", "i-indices west edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_w_right', NF90_INT, &
+                             (/DIM_LAT/), ID_J_W_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_W_RIGHT, "long_name", "j-indices west edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_w_left', NF90_INT, &
+                             (/DIM_HALOP/), ID_I_W_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_W_LEFT, "long_name", "i-indices west edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_W_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_w_left', NF90_INT, &
+                             (/DIM_LAT/), ID_J_W_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_W_LEFT, "long_name", "j-indices west edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_W_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_w_bottom', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_HALO, DIM_LEV/), ID_U_W_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_BOTTOM, "long_name", "u-component wind west edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_BOTTOM, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_w_top', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_HALO, DIM_LEV/), ID_U_W_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_TOP, "long_name", "u-component wind west edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_TOP, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_w_right', NF90_FLOAT, &
+                             (/DIM_HALOP, DIM_LAT, DIM_LEV/), ID_U_W_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_RIGHT, "long_name", "u-component wind west edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_RIGHT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_w_left', NF90_FLOAT, &
+                             (/DIM_HALOP, DIM_LAT, DIM_LEV/), ID_U_W_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_LEFT, "long_name", "u-component wind west edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W_LEFT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_w_bottom', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_HALO, DIM_LEV/), ID_V_W_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_BOTTOM, "long_name", "v-component wind west edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_BOTTOM, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_w_top', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_HALO, DIM_LEV/), ID_V_W_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_TOP, "long_name", "v-component wind west edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_TOP, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_w_right', NF90_FLOAT, &
+                             (/DIM_HALOP, DIM_LAT, DIM_LEV/), ID_V_W_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_RIGHT, "long_name", "v-component wind west edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_RIGHT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_w_left', NF90_FLOAT, &
+                             (/DIM_HALOP, DIM_LAT, DIM_LEV/), ID_V_W_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_LEFT, "long_name", "v-component wind west edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W_LEFT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_s_bottom', NF90_INT, &
+                             (/DIM_LON/), ID_I_S_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_S_BOTTOM, "long_name", "i-indices south edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_s_bottom', NF90_INT, &
+                             (/DIM_HALOP/), ID_J_S_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_S_BOTTOM, "long_name", "j-indices south edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_BOTTOM ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_s_top', NF90_INT, &
+                             (/DIM_LON/), ID_I_S_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_S_TOP, "long_name", "i-indices south edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_s_top', NF90_INT, &
+                             (/DIM_HALOP/), ID_J_S_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_S_TOP, "long_name", "j-indices south edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_TOP ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_s_right', NF90_INT, &
+                             (/DIM_HALO/), ID_I_S_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_S_RIGHT, "long_name", "i-indices south edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_s_right', NF90_INT, &
+                             (/DIM_LATM/), ID_J_S_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_S_RIGHT, "long_name", "j-indices south edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_RIGHT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'i_s_left', NF90_INT, &
+                             (/DIM_HALO/), ID_I_S_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_I_S_LEFT, "long_name", "i-indices south edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING I_S_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'j_s_left', NF90_INT, &
+                             (/DIM_LATM/), ID_J_S_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_J_S_LEFT, "long_name", "j-indices south edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING J_S_LEFT ATTRIBUTE')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_s_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALOP, DIM_LEV/), ID_U_S_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_BOTTOM, "long_name", "u-component wind south edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_BOTTOM, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_s_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALOP, DIM_LEV/), ID_U_S_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_TOP, "long_name", "u-component wind south edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_TOP, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_s_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LATM, DIM_LEV/), ID_U_S_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_RIGHT, "long_name", "u-component wind south edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_RIGHT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_s_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LATM, DIM_LEV/), ID_U_S_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_LEFT, "long_name", "u-component wind south edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S_LEFT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S_LEFT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_s_bottom', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALOP, DIM_LEV/), ID_V_S_BOTTOM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_BOTTOM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_BOTTOM, "long_name", "v-component wind south edge bottom bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_BOTTOM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_BOTTOM, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_BOTTOM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_s_top', NF90_FLOAT, &
+                             (/DIM_LON, DIM_HALOP, DIM_LEV/), ID_V_S_TOP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_TOP')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_TOP, "long_name", "v-component wind south edge top bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_TOP ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_TOP, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_TOP UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_s_right', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LATM, DIM_LEV/), ID_V_S_RIGHT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_RIGHT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_RIGHT, "long_name", "v-component wind south edge right bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_RIGHT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_RIGHT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_RIGHT UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_s_left', NF90_FLOAT, &
+                             (/DIM_HALO, DIM_LATM, DIM_LEV/), ID_V_S_LEFT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_LEFT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_LEFT, "long_name", "v-component wind south edge left bndy")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_LEFT ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S_LEFT, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S_LEFT UNITS')
+
+ ERROR = NF90_ENDDEF(NCID2, HEADER_BUFFER_VAL, 4, 0, 4)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING END OF HEADER')
+
+!----------------------------------------------------------------------------------
+! "Bottom" boundary.
+!----------------------------------------------------------------------------------
+
+ ISTART = 1
+ IEND   = IM
+ JSTART = 1
+ JEND   = HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+ 
+ ALLOCATE(HALO_2D(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(HALO_2D_4BYTE(ISTART:IEND,JSTART:JEND))
+
+ CALL GL2ANY(0, 1, PS, LONB, LATB, HALO_2D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ HALO_2D_4BYTE = REAL(HALO_2D,4)
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_PS_BOTTOM, HALO_2D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING PS_BOTTOM')
+
+ DEALLOCATE(HALO_2D, HALO_2D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,1), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_SPHUM_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING SPHUM_BOTTOM')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,2), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_O3MR_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING O3MR_BOTTOM')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,3), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_CLWMR_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING LIQ_WAT_BOTTOM')
+
+ IF (NTRACM > 3) THEN
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,4), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_RWMR_BOTTOM, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING RWMR_BOTTOM')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,5), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_ICMR_BOTTOM, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING ICMR_BOTTOM')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,6), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_SNMR_BOTTOM, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING SNMR_BOTTOM')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,7), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_GRLE_BOTTOM, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING GRLE_BOTTOM')
+
+ ENDIF
+
+ CALL GL2ANY(0, LEVSO, T, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_T_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING T_BOTTOM')
+
+ CALL GL2ANY(0, LEVSO, W, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_W_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING W_BOTTOM')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+
+ CALL GL2ANY(0, LEVSO_P1, ZH, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO_P1
+   HALO_3D_4BYTE(:,:,LEVSO_P1-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_ZH_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING ZH_BOTTOM')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = IM+1
+ JSTART = 1
+ JEND   = HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_W_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_W_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_W_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_W_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = (2*I)-1
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_W_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_W_BOTTOM')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_W_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_W_BOTTOM')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = IM
+ JSTART = 1
+ JEND   = HALO + 1
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_S_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_S_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_S_BOTTOM, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_S_BOTTOM')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = (2*J) - 1
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_S_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_S_BOTTOM')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_S_BOTTOM, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_S_BOTTOM')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+!----------------------------------------------------------------------------------
+! "Top" boundary.
+!----------------------------------------------------------------------------------
+
+ ISTART = 1
+ IEND   = IM
+ JSTART = JM - HALO + 1
+ JEND   = JM
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_TOP')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_TOP')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_2D(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(HALO_2D_4BYTE(ISTART:IEND,JSTART:JEND))
+
+ CALL GL2ANY(0, 1, PS, LONB, LATB, HALO_2D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ HALO_2D_4BYTE = REAL(HALO_2D,4)
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_PS_TOP, HALO_2D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING PS_TOP')
+
+ DEALLOCATE(HALO_2D, HALO_2D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,1), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_SPHUM_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING SPHUM_TOP')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,2), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_O3MR_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING O3MR_TOP')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,3), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_CLWMR_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING CLWMR_TOP')
+
+ IF (NTRACM > 3) THEN
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,4), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_RWMR_TOP, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING RWMR_TOP')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,5), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_ICMR_TOP, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING ICMR_TOP')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,6), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_SNMR_TOP, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING SNMR_TOP')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,7), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_GRLE_TOP, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING GRLE_TOP')
+
+ ENDIF
+
+ CALL GL2ANY(0, LEVSO, T, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_T_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING T_TOP')
+
+ CALL GL2ANY(0, LEVSO, W, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_W_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING W_TOP')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+
+ CALL GL2ANY(0, LEVSO_P1, ZH, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO_P1
+   HALO_3D_4BYTE(:,:,LEVSO_P1-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_ZH_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING ZH_TOP')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = IM+1
+ JSTART = JM - HALO + 1
+ JEND   = JM
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_W_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_W_TOP')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_W_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_W_TOP')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = (2*I)-1
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_W_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_W_TOP')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_W_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_W_TOP')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = IM
+ JSTART = JM - HALO + 1
+ JEND   = JM + 1
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_S_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_S_TOP')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_S_TOP, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_S_TOP')
+
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = (2*J) - 1
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_S_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_S_TOP')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_S_TOP, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_S_TOP')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+!----------------------------------------------------------------------------------
+! "Left" boundary.
+!----------------------------------------------------------------------------------
+
+ ISTART = 1
+ IEND   = HALO
+ JSTART = HALO + 1
+ JEND   = JM - HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_2D(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(HALO_2D_4BYTE(ISTART:IEND,JSTART:JEND))
+
+ CALL GL2ANY(0, 1, PS, LONB, LATB, HALO_2D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ HALO_2D_4BYTE = REAL(HALO_2D,4)
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_PS_LEFT, HALO_2D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING PS_LEFT')
+
+ DEALLOCATE(HALO_2D, HALO_2D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,1), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_SPHUM_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING SPHUM_LEFT')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,2), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_O3MR_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING O3MR_LEFT')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,3), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_CLWMR_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING CLWMR_LEFT')
+
+ IF (NTRACM > 3) THEN
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,4), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_RWMR_LEFT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING RWMR_LEFT')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,5), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_ICMR_LEFT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING ICMR_LEFT')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,6), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_SNMR_LEFT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING SNMR_LEFT')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,7), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_GRLE_LEFT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING GRLE_LEFT')
+
+ ENDIF
+
+ CALL GL2ANY(0, LEVSO, T, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_T_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING T_LEFT')
+
+ CALL GL2ANY(0, LEVSO, W, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_W_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING W_LEFT')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+
+ CALL GL2ANY(0, LEVSO_P1, ZH, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO_P1
+   HALO_3D_4BYTE(:,:,LEVSO_P1-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_ZH_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING ZH_LEFT')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = HALO + 1
+ JSTART = HALO + 1
+ JEND   = JM - HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_W_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_W_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_W_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_W_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = (2*I)-1
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_W_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_W_LEFT')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_W_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_W_LEFT')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = 1
+ IEND   = HALO
+ JSTART = HALO_P1 + 1
+ JEND   = JM + 1 - HALO_P1
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_S_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_S_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_S_LEFT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_S_LEFT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = (2*J) - 1
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_S_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_S_LEFT')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_S_LEFT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_S_LEFT')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+!----------------------------------------------------------------------------------
+! "Right" boundary.
+!----------------------------------------------------------------------------------
+
+ ISTART = IM - HALO + 1
+ IEND   = IM
+ JSTART = HALO + 1
+ JEND   = JM - HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_2D(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(HALO_2D_4BYTE(ISTART:IEND,JSTART:JEND))
+
+ CALL GL2ANY(0, 1, PS, LONB, LATB, HALO_2D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ HALO_2D_4BYTE = REAL(HALO_2D,4)
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_PS_RIGHT, HALO_2D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING PS_RIGHT')
+
+ DEALLOCATE(HALO_2D, HALO_2D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,1), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_SPHUM_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING SPHUM_RIGHT')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,2), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_O3MR_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING O3MR_RIGHT')
+
+ CALL GL2ANY(0, LEVSO, Q(:,:,:,3), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_CLWMR_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING CLWMR_RIGHT')
+
+ IF (NTRACM > 3) THEN
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,4), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_RWMR_RIGHT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING RWMR_RIGHT')
+   
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,5), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_ICMR_RIGHT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING ICMR_RIGHT')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,6), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_SNMR_RIGHT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING SNMR_RIGHT')
+
+   CALL GL2ANY(0, LEVSO, Q(:,:,:,7), LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+   DO K = 1, LEVSO
+     HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_GRLE_RIGHT, HALO_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING GRLE_RIGHT')
+
+ ENDIF
+
+ CALL GL2ANY(0, LEVSO, T, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_T_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING T_RIGHT')
+
+ CALL GL2ANY(0, LEVSO, W, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_W_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING W_RIGHT')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+
+ CALL GL2ANY(0, LEVSO_P1, ZH, LONB, LATB, HALO_3D, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+ DO K = 1, LEVSO_P1
+   HALO_3D_4BYTE(:,:,LEVSO_P1-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_ZH_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING ZH_RIGHT')
+
+ DEALLOCATE(HALO_3D, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = IM - HALO + 1
+ IEND   = IM + 1
+ JSTART = HALO + 1
+ JEND   = JM - HALO
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_W_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_W_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_W_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_W_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = (2*I)-1
+     JJ = 2*J
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_W_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_W_RIGHT')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_W_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_W_RIGHT')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+ ISTART = IM - HALO + 1
+ IEND   = IM
+ JSTART = HALO_P1 + 1
+ JEND   = JM + 1 - HALO_P1
+
+ IHALO = IEND - ISTART + 1
+ JHALO = JEND - JSTART + 1
+
+ ALLOCATE(IDUM(ISTART:IEND))
+ DO I = ISTART, IEND
+   IDUM(I) = I
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_I_S_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING I_S_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(IDUM(JSTART:JEND))
+ DO J = JSTART, JEND
+   IDUM(J) = J
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_J_S_RIGHT, IDUM)
+ CALL NETCDF_ERROR(ERROR, 'WRITING J_S_RIGHT')
+ DEALLOCATE(IDUM)
+
+ ALLOCATE(GEOLAT_HALO(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_HALO(ISTART:IEND,JSTART:JEND))
+
+ DO J = JSTART, JEND
+   DO I = ISTART, IEND
+     II = 2*I
+     JJ = (2*J) - 1
+     GEOLON_HALO(I,J) = GEOLON(II,JJ)
+     GEOLAT_HALO(I,J) = GEOLAT(II,JJ)
+   ENDDO
+ ENDDO
+
+ ALLOCATE(HALO_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(HALO_3D2(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0, LEVSO, U, V, LONB, LATB, HALO_3D, HALO_3D2, IHALO, JHALO, GEOLON_HALO, GEOLAT_HALO)
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_S_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_S_RIGHT')
+
+ DO K = 1, LEVSO
+   HALO_3D_4BYTE(:,:,LEVSO-K+1) = REAL(HALO_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_S_RIGHT, HALO_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_S_RIGHT')
+
+ DEALLOCATE(HALO_3D, HALO_3D2, HALO_3D_4BYTE)
+ DEALLOCATE(GEOLAT_HALO, GEOLON_HALO)
+
+!----------------------------------------------------------------------------------
+! Cleanup and close file.
+!----------------------------------------------------------------------------------
+
+ DEALLOCATE(GEOLAT)
+ DEALLOCATE(GEOLON)
+
+ ERROR = NF90_CLOSE(NCID2)
+
+ END SUBROUTINE WRITE_FV3_ATMS_BNDY_NETCDF
+
+ SUBROUTINE WRITE_FV3_ATMS_NETCDF(ZS,PS,T,W,U,V,Q,VCOORD,LONB,LATB,&
+                                  LEVSO,NTRACM,NVCOORD,NTILES,HALO,&
+                                  INPTYP,MODELNAME)
+
+ use netcdf
+
+ IMPLICIT NONE
+
+ CHARACTER(LEN=8), INTENT(IN) :: MODELNAME
+
+ INTEGER,  INTENT(IN)  :: NTILES, LONB, LATB, LEVSO, NTRACM
+ INTEGER,  INTENT(IN)  :: NVCOORD, HALO, INPTYP
+
+ REAL, INTENT(IN)      :: PS(LONB,LATB), ZS(LONB,LATB)
+ REAL, INTENT(IN)      :: T(LONB,LATB,LEVSO), W(LONB,LATB,LEVSO)
+ REAL, INTENT(IN)      :: U(LONB,LATB,LEVSO), V(LONB,LATB,LEVSO)
+ REAL, INTENT(IN)      :: Q(LONB,LATB,LEVSO,NTRACM)
+ REAL, INTENT(IN)      :: VCOORD(LEVSO+1,NVCOORD)
+
+ CHARACTER(LEN=256)    :: TILEFILE, OUTFILE
+
+ INTEGER               :: ID_DIM, ID_VAR, IM, JM
+ INTEGER               :: ERROR, N, NCID, NCID2, NX, NY
+ INTEGER               :: INITAL=0, FSIZE=65536
+ INTEGER               :: HEADER_BUFFER_VAL = 16384
+ INTEGER               :: DIM_LON, DIM_LAT, DIM_LONP, DIM_LATP
+ INTEGER               :: DIM_LEV, DIM_LEVP, DIM_TRACER
+ INTEGER               :: ID_LON, ID_LAT, ID_PS, ID_T
+ INTEGER               :: ID_W, ID_ZH, ID_SPHUM, ID_O3MR
+ INTEGER               :: ID_CLWMR, ID_U_W, ID_V_W
+ INTEGER               :: ID_RWMR, ID_ICMR, ID_SNMR, ID_GRLE
+ INTEGER               :: ID_U_S, ID_V_S, K, LEVSO_P1
+ INTEGER               :: I, J, II, JJ
+ INTEGER               :: ISTART, IEND, JSTART, JEND, IM_OUT, JM_OUT
+ INTEGER               :: START_TILE, END_TILE
+
+ REAL, ALLOCATABLE     :: CUBE_2D(:,:), CUBE_3D(:,:,:), CUBE_3D2(:,:,:)
+ REAL, ALLOCATABLE     :: AK(:), BK(:), ZH(:,:,:)
+ REAL, ALLOCATABLE     :: GEOLAT(:,:), GEOLAT_W(:,:), GEOLAT_S(:,:)
+ REAL, ALLOCATABLE     :: GEOLON(:,:), GEOLON_W(:,:)
+ REAL, ALLOCATABLE     :: GEOLON_S(:,:), TMPVAR(:,:)
+
+ REAL(KIND=4), ALLOCATABLE  :: CUBE_2D_4BYTE(:,:)
+ REAL(KIND=4), ALLOCATABLE  :: CUBE_3D_4BYTE(:,:,:)
+
+ LEVSO_P1 = LEVSO + 1
+
+ CALL WRITE_FV3_ATMS_HEADER_NETCDF(LEVSO_P1, NTRACM, NVCOORD, VCOORD)
+
+ ALLOCATE(AK(LEVSO_P1))
+ ALLOCATE(BK(LEVSO_P1))
+ ALLOCATE(ZH(LONB,LATB,(LEVSO_P1)))
+
+ AK = VCOORD(:,1)
+ BK = VCOORD(:,2)
+
+ CALL COMPUTE_ZH(LONB,LATB,LEVSO,AK,BK,PS,ZS,T,Q,ZH)
+    
+ DEALLOCATE(AK, BK)
+
+ PRINT*,''
+
+ IF (HALO == 0) THEN  ! NOT A REGIONAL GRID
+   START_TILE = 1
+   END_TILE   = NTILES
+ ELSE                 ! A REGIONAL GRID.  ASSUME IT IS TILE 7.
+   START_TILE = 7
+   END_TILE   = 7
+ ENDIF
+
+ TILE_LOOP : DO N = START_TILE, END_TILE
+
+ PRINT*,'WRITE FV3 ATMOSPHERIC DATA FOR TILE ',N
+
+ IF (N < 10) THEN
+   WRITE(TILEFILE, "(A,I1)") "chgres.fv3.grd.t", N
+ ELSE
+   WRITE(TILEFILE, "(A,I2)") "chgres.fv3.grd.t", N
+ ENDIF
+
+ ERROR=NF90_OPEN(TRIM(TILEFILE),NF90_NOWRITE,NCID)
+ CALL NETCDF_ERROR(ERROR, 'OPENING FILE: '//TRIM(TILEFILE) )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'nx', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NX)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NX' )
+
+ ERROR=NF90_INQ_DIMID(NCID, 'ny', ID_DIM)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY ID' )
+
+ ERROR=NF90_INQUIRE_DIMENSION(NCID,ID_DIM,LEN=NY)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING NY' )
+
+ IF (MOD(NX,2) /= 0) THEN
+   PRINT*,'FATAL ERROR: NX IS NOT EVEN'
+   CALL ERREXIT(103)
+ ENDIF
+
+ IF (MOD(NY,2) /= 0) THEN
+   PRINT*,'FATAL ERROR: NY IS NOT EVEN'
+   CALL ERREXIT(104)
+ ENDIF
+
+ IM = NX/2
+ JM = NY/2
+
+ IF (HALO > 0) THEN
+   ISTART     = 1 + HALO
+   IEND       = IM - HALO
+   JSTART     = 1+ HALO
+   JEND       = JM - HALO
+   PRINT*,''
+   PRINT*,"WILL NOT PROCESS HALO REGION."
+   PRINT*,"HALO IS ", HALO, " ROWS/COLUMNS"
+   PRINT*,"WILL PROCESS I= ", ISTART, " TO ", IEND
+   PRINT*,"WILL PROCESS J= ", JSTART, " TO ", JEND
+   PRINT*,''
+ ELSE
+   ISTART = 1
+   IEND   = IM
+   JSTART = 1
+   JEND   = JM
+ ENDIF
+
+ IM_OUT = IEND - ISTART + 1
+ JM_OUT = JEND - JSTART +1
+
+ PRINT*, "READ FV3 GRID INFO FROM: "//TRIM(TILEFILE)
+
+ ALLOCATE(TMPVAR(NX+1,NY+1))
+ ALLOCATE(GEOLON(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLON_W(ISTART:IEND+1,JSTART:JEND))
+ ALLOCATE(GEOLON_S(ISTART:IEND,JSTART:JEND+1))
+
+ ERROR=NF90_INQ_VARID(NCID, 'x', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, TMPVAR)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING X RECORD' )
+
+ DO J = JSTART, JEND
+ DO I = ISTART, IEND
+   II = 2*I
+   JJ = 2*J
+   GEOLON(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+
+ DO J = JSTART, JEND
+ DO I = ISTART, IEND+1
+   II = (2*I) - 1
+   JJ = 2*J
+   GEOLON_W(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+
+ DO J = JSTART, JEND+1
+ DO I = ISTART, IEND
+   II = 2*I
+   JJ = (2*J) - 1
+   GEOLON_S(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+
+ ERROR=NF90_INQ_VARID(NCID, 'y', ID_VAR) 
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y ID' )
+ ERROR=NF90_GET_VAR(NCID, ID_VAR, TMPVAR)
+ CALL NETCDF_ERROR(ERROR, 'ERROR READING Y RECORD' )
+
+ ERROR = NF90_CLOSE(NCID)
+
+ ALLOCATE(GEOLAT(ISTART:IEND,JSTART:JEND))
+ ALLOCATE(GEOLAT_W(ISTART:IEND+1,JSTART:JEND))
+ ALLOCATE(GEOLAT_S(ISTART:IEND,JSTART:JEND+1))
+
+ DO J = JSTART, JEND
+ DO I = ISTART, IEND
+   II = 2*I
+   JJ = 2*J
+   GEOLAT(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+
+ DO J = JSTART, JEND
+ DO I = ISTART, IEND+1
+   II = (2*I) - 1
+   JJ = 2*J
+   GEOLAT_W(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+
+ DO J = JSTART, JEND+1
+ DO I = ISTART, IEND
+   II = 2*I
+   JJ = (2*J) - 1
+   GEOLAT_S(I,J) = TMPVAR(II,JJ)
+ ENDDO
+ ENDDO
+ 
+ DEALLOCATE(TMPVAR)
+
+ IF (N < 10) THEN
+   WRITE(OUTFILE, "(A,I1,A)") 'gfs_data.tile', N, '.nc' 
+ ELSE
+   WRITE(OUTFILE, "(A,I2,A)") 'gfs_data.tile', N, '.nc'
+ ENDIF
+
+ ERROR = NF90_CREATE(OUTFILE, IOR(NF90_NETCDF4,NF90_CLASSIC_MODEL), &
+                     NCID2, INITIALSIZE=INITAL, CHUNKSIZE=FSIZE)
+ CALL NETCDF_ERROR(ERROR, 'CREATING FILE: '//TRIM(OUTFILE) )
+
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'FV3GFS GAUSSIAN NEMSIO FILE')
+ ELSEIF (INPTYP == 1) THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'GFS NEMSIO FILE')
+ ELSEIF (INPTYP == 2) THEN
+   ERROR = NF90_PUT_ATT(NCID2, NF90_GLOBAL, 'source', 'GFS SIGIO FILE')
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING GLOBAL SOURCE ATTRIBUTE')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lon', IM_OUT, DIM_LON)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LON DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lat', JM_OUT, DIM_LAT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LAT DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lonp', (IM_OUT+1), DIM_LONP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LONP DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'latp', (JM_OUT+1), DIM_LATP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LATP DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'lev', LEVSO, DIM_LEV)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LEV DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'levp', LEVSO_P1, DIM_LEVP)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LEVP DIMENSION')
+
+ ERROR = NF90_DEF_DIM(NCID2, 'ntracer', NTRACM, DIM_TRACER)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING NTRACER DIMENSION')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'lon', NF90_FLOAT, DIM_LON, ID_LON)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LON VARIABLE')
+
+ ERROR = NF90_PUT_ATT(NCID2, ID_LON, "cartesian_axis", "X")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING X-AXIS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'lat', NF90_FLOAT, DIM_LAT, ID_LAT)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LAT VARIABLE')
+
+ ERROR = NF90_PUT_ATT(NCID2, ID_LAT, "cartesian_axis", "Y")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING Y-AXIS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'ps', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT/), ID_PS)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PS')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS, "long_name", "surface pressure")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PRESSURE ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_PS, "units", "Pa")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING PRESSURE UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'w', NF90_FLOAT,  &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_W)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W, "long_name", "vertical velocity")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W, "long_name", "omega")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W ATTRIBUTE')
+ IF (TRIM(MODELNAME) == "FV3GFS") THEN
+   ERROR = NF90_PUT_ATT(NCID2, ID_W, "units", "m/s")
+ ELSE
+   ERROR = NF90_PUT_ATT(NCID2, ID_W, "units", "Pa/s")
+ ENDIF
+ CALL NETCDF_ERROR(ERROR, 'DEFINING W UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'zh', NF90_FLOAT,  &
+                             (/DIM_LON, DIM_LAT, DIM_LEVP/), ID_ZH)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH, "long_name", "height")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_ZH, "units", "m")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING ZH UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 't', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_T)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING t')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T, "long_name", "temperature")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_T, "units", "kelvin")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING T UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'sphum', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_SPHUM)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM, "long_name", "specific humidity")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_SPHUM, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING SPHUM UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'o3mr', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_O3MR)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR, "long_name", "ozone")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_O3MR, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING O3MR UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'liq_wat', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_CLWMR)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING LIQ_WAT')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR, "long_name", "cloud liquid water mixing ratio")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_CLWMR, "units", "kg/kg")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING CLWMR UNITS')
+
+ IF (NTRACM > 3) THEN
+
+   ERROR = NF90_DEF_VAR(NCID2, 'rainwat', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_RWMR)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR, "long_name", "rain water mixing ratio")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_RWMR, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING RWMR UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'ice_wat', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_ICMR)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR, "long_name", "ice water mixing ratio")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_ICMR, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING ICMR UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'snowwat', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_SNMR)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR, "long_name", "snow water mixing ratio")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_SNMR, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING SNMR UNITS')
+
+   ERROR = NF90_DEF_VAR(NCID2, 'graupel', NF90_FLOAT, &
+                             (/DIM_LON, DIM_LAT, DIM_LEV/), ID_GRLE)
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE, "long_name", "graupel mixing ratio")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE ATTRIBUTE')
+   ERROR = NF90_PUT_ATT(NCID2, ID_GRLE, "units", "kg/kg")
+   CALL NETCDF_ERROR(ERROR, 'DEFINING GRLE UNITS')
+
+ ENDIF
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_w', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_LAT, DIM_LEV/), ID_U_W)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W, "long_name", "u-component wind on d grid")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_W, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_W UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_w', NF90_FLOAT, &
+                             (/DIM_LONP, DIM_LAT, DIM_LEV/), ID_V_W)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W, "long_name", "v-component wind on c grid")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_W, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_W UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'u_s', NF90_FLOAT,  &
+                             (/DIM_LON, DIM_LATP, DIM_LEV/), ID_U_S)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S, "long_name", "u-component wind on c grid")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_U_S, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING U_S UNITS')
+
+ ERROR = NF90_DEF_VAR(NCID2, 'v_s', NF90_FLOAT,  &
+                             (/DIM_LON, DIM_LATP, DIM_LEV/), ID_V_S)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S, "long_name", "v-component wind on d grid")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S ATTRIBUTE')
+ ERROR = NF90_PUT_ATT(NCID2, ID_V_S, "units", "m/s")
+ CALL NETCDF_ERROR(ERROR, 'DEFINING V_S UNITS')
+
+ ERROR = NF90_ENDDEF(NCID2, HEADER_BUFFER_VAL, 4, 0, 4)
+ CALL NETCDF_ERROR(ERROR, 'DEFINING END OF HEADER')
+
+!------------------------------------------------------------------
+! Write out data.  fv3 convention: lowest model level is levso.
+! top model layer is 1.  this is opposite the gfs convention.
+!------------------------------------------------------------------
+
+ ALLOCATE(CUBE_2D(ISTART:IEND,JSTART:JEND), CUBE_2D_4BYTE(ISTART:IEND,JSTART:JEND))
+
+ CUBE_2D_4BYTE = REAL(GEOLON,4)
+ ERROR = NF90_PUT_VAR(NCID2, ID_LON, CUBE_2D_4BYTE(:,JSTART))
+ CALL NETCDF_ERROR(ERROR, 'WRITING LON')
+
+ CUBE_2D_4BYTE = REAL(GEOLAT,4)
+ ERROR = NF90_PUT_VAR(NCID2, ID_LAT, CUBE_2D_4BYTE(ISTART,:))
+ CALL NETCDF_ERROR(ERROR, 'WRITING LAT')
+
+ CALL GL2ANY(0,1,PS,LONB,LATB,CUBE_2D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ CUBE_2D_4BYTE = REAL(CUBE_2D,4)
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_PS, CUBE_2D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING PS')
+    
+ DEALLOCATE(CUBE_2D_4BYTE, CUBE_2D)
+
+ ALLOCATE(CUBE_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+ ALLOCATE(CUBE_3D(ISTART:IEND,JSTART:JEND,LEVSO_P1))
+
+ CALL GL2ANY(0,LEVSO_P1,ZH,LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ DO K = 1, LEVSO_P1
+   CUBE_3D_4BYTE(:,:,LEVSO_P1-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_ZH, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING ZH')
+
+ DEALLOCATE(CUBE_3D, CUBE_3D_4BYTE)
+
+ ALLOCATE(CUBE_3D_4BYTE(ISTART:IEND,JSTART:JEND,LEVSO))
+ ALLOCATE(CUBE_3D(ISTART:IEND,JSTART:JEND,LEVSO))
+
+ CALL GL2ANY(0,LEVSO,W,LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_W, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING W')
+
+ CALL GL2ANY(0,LEVSO,T,LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON,GEOLAT)
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_T, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING T')
+
+ CALL GL2ANY(0,LEVSO,Q(:,:,:,1),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_SPHUM, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING SPHUM')
+
+ CALL GL2ANY(0,LEVSO,Q(:,:,:,2),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_O3MR, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING O3MR')
+
+ CALL GL2ANY(0,LEVSO,Q(:,:,:,3),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_CLWMR, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING CLWMR')
+
+ IF (NTRACM > 3) THEN
+
+   CALL GL2ANY(0,LEVSO,Q(:,:,:,4),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+   DO K = 1, LEVSO
+     CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_RWMR, CUBE_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING RWMR')
+ 
+   CALL GL2ANY(0,LEVSO,Q(:,:,:,5),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+   DO K = 1, LEVSO
+     CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_ICMR, CUBE_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING ICMR')
+
+   CALL GL2ANY(0,LEVSO,Q(:,:,:,6),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+   DO K = 1, LEVSO
+     CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_SNMR, CUBE_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING SNMR')
+
+   CALL GL2ANY(0,LEVSO,Q(:,:,:,7),LONB,LATB,CUBE_3D,IM_OUT,JM_OUT,GEOLON, GEOLAT)
+   DO K = 1, LEVSO
+     CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+   ENDDO
+
+   ERROR = NF90_PUT_VAR(NCID2, ID_GRLE, CUBE_3D_4BYTE)
+   CALL NETCDF_ERROR(ERROR, 'WRITING GRLE')
+
+ ENDIF
+
+ DEALLOCATE (CUBE_3D, CUBE_3D_4BYTE)
+
+ ALLOCATE(CUBE_3D_4BYTE(ISTART:IEND+1,JSTART:JEND,LEVSO))
+ ALLOCATE(CUBE_3D(ISTART:IEND+1,JSTART:JEND,LEVSO))
+ ALLOCATE(CUBE_3D2(ISTART:IEND+1,JSTART:JEND,LEVSO))
+
+ CALL GL2ANYV(0,LEVSO,U,V,LONB,LATB,CUBE_3D,CUBE_3D2,(IM_OUT+1),JM_OUT,GEOLON_W, GEOLAT_W)
+
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_W, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_W')
+
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_W, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_W')
+
+ DEALLOCATE (CUBE_3D, CUBE_3D2, CUBE_3D_4BYTE)
+
+ ALLOCATE(CUBE_3D_4BYTE(ISTART:IEND,JSTART:JEND+1,LEVSO))
+ ALLOCATE(CUBE_3D(ISTART:IEND,JSTART:JEND+1,LEVSO))
+ ALLOCATE(CUBE_3D2(ISTART:IEND,JSTART:JEND+1,LEVSO))
+
+ CALL GL2ANYV(0,LEVSO,U,V,LONB,LATB,CUBE_3D,CUBE_3D2,IM_OUT,(JM_OUT+1),GEOLON_S, GEOLAT_S)
+
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_U_S, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING U_S')
+
+ DO K = 1, LEVSO
+   CUBE_3D_4BYTE(:,:,LEVSO-K+1) = REAL(CUBE_3D2(:,:,K),4)
+ ENDDO
+
+ ERROR = NF90_PUT_VAR(NCID2, ID_V_S, CUBE_3D_4BYTE)
+ CALL NETCDF_ERROR(ERROR, 'WRITING V_S')
+
+ ERROR = NF90_CLOSE(NCID2)
+
+ DEALLOCATE(CUBE_3D, CUBE_3D2, CUBE_3D_4BYTE)
+ DEALLOCATE(GEOLON, GEOLON_W, GEOLON_S)
+ DEALLOCATE(GEOLAT, GEOLAT_W, GEOLAT_S)
+
+ ENDDO TILE_LOOP
+
+ DEALLOCATE(ZH)
+
+ END SUBROUTINE WRITE_FV3_ATMS_NETCDF
+
+ SUBROUTINE READ_GFS_NSST_DATA_NSTIO(IMI,JMI,NUM_NSST_FIELDS,     &
+                                     NSST_INPUT, MASK_INPUT, &
+                                     NSST_YEAR, NSST_MON,    &
+                                     NSST_DAY, NSST_HOUR,    &
+                                     NSST_FHOUR)
+
+ USE NSTIO_MODULE
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN)  :: IMI, JMI, NUM_NSST_FIELDS
+ INTEGER, INTENT(OUT) :: NSST_YEAR, NSST_MON
+ INTEGER, INTENT(OUT) :: NSST_DAY, NSST_HOUR
+
+ REAL, INTENT(OUT)   :: NSST_FHOUR
+ REAL, INTENT(OUT)   :: MASK_INPUT(IMI,JMI)
+ REAL, INTENT(OUT)   :: NSST_INPUT(IMI,JMI,NUM_NSST_FIELDS)
+
+ INTEGER(NSTIO_INTKIND) :: NSSTI, IRET
+
+ TYPE(NSTIO_HEAD)        :: NSST_IN_HEAD
+ TYPE(NSTIO_DATA)        :: NSST_IN_DATA
+
+ PRINT*,'- READ NSST FILE chgres.inp.nst.'
+!  OPEN NSST FILES
+ NSSTI=31
+ CALL NSTIO_SROPEN(NSSTI,'chgres.inp.nst',IRET)
+ IF(IRET/=0)THEN
+   PRINT*,'FATAL ERROR OPENING chgres.inp.nst ', IRET
+   CALL ERREXIT(105)
+ ENDIF
+ CALL NSTIO_SRHEAD(NSSTI,NSST_IN_HEAD,IRET)
+ IF(IRET/=0)THEN
+   PRINT*,'FATAL ERROR READING chgres.inp.nst ', IRET
+   CALL ERREXIT(106)
+ ENDIF
+ CALL NSTIO_ALDATA(NSST_IN_HEAD,NSST_IN_DATA,IRET)
+ CALL NSTIO_SRDATA(NSSTI,NSST_IN_HEAD,NSST_IN_DATA,IRET)
+ IF(IRET/=0)THEN
+   PRINT*,'FATAL ERROR READING chgres.inp.nst ', IRET
+   CALL ERREXIT(107)
+ ENDIF
+ NSST_YEAR=NSST_IN_HEAD%IDATE(4)
+ NSST_MON=NSST_IN_HEAD%IDATE(2)
+ NSST_DAY=NSST_IN_HEAD%IDATE(3)
+ NSST_HOUR=NSST_IN_HEAD%IDATE(1)
+ NSST_FHOUR=NSST_IN_HEAD%FHOUR
+ NSST_INPUT(:,:,1)=NSST_IN_DATA%XT
+ NSST_INPUT(:,:,2)=NSST_IN_DATA%XS
+ NSST_INPUT(:,:,3)=NSST_IN_DATA%XU
+ NSST_INPUT(:,:,4)=NSST_IN_DATA%XV
+ NSST_INPUT(:,:,5)=NSST_IN_DATA%XZ
+ NSST_INPUT(:,:,6)=NSST_IN_DATA%ZM
+ NSST_INPUT(:,:,7)=NSST_IN_DATA%XTTS
+ NSST_INPUT(:,:,8)=NSST_IN_DATA%XZTS
+ NSST_INPUT(:,:,9)=NSST_IN_DATA%DT_COOL
+ NSST_INPUT(:,:,10)=NSST_IN_DATA%Z_C
+ NSST_INPUT(:,:,11)=NSST_IN_DATA%C_0
+ NSST_INPUT(:,:,12)=NSST_IN_DATA%C_D
+ NSST_INPUT(:,:,13)=NSST_IN_DATA%W_0
+ NSST_INPUT(:,:,14)=NSST_IN_DATA%W_D
+ NSST_INPUT(:,:,15)=NSST_IN_DATA%D_CONV
+ NSST_INPUT(:,:,16)=NSST_IN_DATA%IFD
+ NSST_INPUT(:,:,17)=NSST_IN_DATA%TREF
+ NSST_INPUT(:,:,18)=NSST_IN_DATA%QRAIN
+ MASK_INPUT=NSST_IN_DATA%SLMSK
+ CALL NSTIO_AXDATA(NSST_IN_DATA,IRET)
+ CALL NSTIO_SRCLOSE(NSSTI,IRET)
+
+ END SUBROUTINE READ_GFS_NSST_DATA_NSTIO
+
+ SUBROUTINE READ_FV3GFS_NSST_DATA_NEMSIO (MASK_INPUT,NSST_INPUT,IMI,JMI, &
+                 NUM_NSST_FIELDS,NSST_YEAR,NSST_MON,NSST_DAY,    & 
+                 NSST_HOUR,NSST_FHOUR)
+
+!-----------------------------------------------------------------------
+! Subroutine: read nsst data from a fv3gfs nemsio file
+!
+! Author: George Gayno/EMC
+!
+! Abstract: Reads an fv3gfs nsst file in nemsio format.  Places data
+!           in the "nsst_input" array in the order expected by routine
+!           nsst_chgres.
+!
+! Input files: 
+!    "chgres.inp.sfc" - input nsst nemsio file.  note: fv3gfs sfc
+!                       and nsst fields are in the same file.
+!
+! Output files:  none
+!
+! History:
+!   2018-05-31   Gayno - Initial version
+!
+! Condition codes:  all non-zero codes are fatal
+!   109 - bad open of nst file "chgres.inp.sfc"
+!   110 - bad read of "chgres.inp.sfc" header
+!   112 - wrong number of nsst records
+!   113 - bad read of landmask record.
+!   114 - bad read of an nst file record.
+!-----------------------------------------------------------------------
+
+ use nemsio_module
+
+ implicit none
+
+ integer, parameter      :: nrec=18
+
+ character(len=3)        :: levtyp
+ character(len=8)        :: recname(nrec)
+
+ integer, intent(in)     :: imi, jmi, num_nsst_fields
+ integer, intent(out)    :: nsst_year, nsst_mon
+ integer, intent(out)    :: nsst_day, nsst_hour
+
+ real,    intent(out)    :: mask_input(imi,jmi)
+ real,    intent(out)    :: nsst_input(imi,jmi,num_nsst_fields)
+ real,    intent(out)    :: nsst_fhour
+
+ integer(nemsio_intkind) :: iret, lev, nframe
+ integer(nemsio_intkind) :: idate(7), nfhour
+
+ integer                 :: j
+
+ real(nemsio_realkind),allocatable :: dummy(:)
+
+ type(nemsio_gfile)      :: gfile
+
+ data recname   /"xt      ", "xs      ", "xu      ", &
+                 "xv      ", "xz      ", "zm      ", &
+                 "xtts    ", "xzts    ", "dtcool  ", &
+                 "zc      ", "c0      ", "cd      ", &
+                 "w0      ", "wd      ", "dconv   ", &
+                 "ifd     ", "tref    ", "qrain   " /
+
+ print*,"- READ INPUT NSST DATA IN NEMSIO FORMAT"
+
+ if (nrec /= num_nsst_fields) then
+   print*,"- FATAL ERROR: bad number of nsst records."
+   call errexit(112)
+ endif
+
+! note: fv3gfs surface and nsst fields are in a single file.
+  
+ call nemsio_open(gfile, "chgres.inp.sfc", "read", iret=iret)
+ if (iret /= 0) then
+   print*,"- FATAL ERROR: bad open of chgres.inp.sfc."
+   print*,"- IRET IS ", iret
+   call errexit(109)
+ endif
+
+ print*,"- READ FILE HEADER"
+ call nemsio_getfilehead(gfile,iret=iret, &
+           idate=idate,nfhour=nfhour)
+ if (iret /= 0) then
+   print*,"- FATAL ERROR: bad read of chgres.inp.sfc header."
+   print*,"- IRET IS ", iret
+   call errexit(110)
+ endif
+
+ nsst_year=idate(1)
+ nsst_mon=idate(2)
+ nsst_day=idate(3)
+ nsst_hour=idate(4)
+ nsst_fhour=float(nfhour)
+
+ levtyp='sfc'
+ lev=1
+ nframe=0
+
+ allocate(dummy(imi*jmi))
+
+!-----------------------------------------------------------------------
+! Read land mask into its own variable
+!-----------------------------------------------------------------------
+
+ call nemsio_readrecv(gfile,"land",levtyp,lev, &
+           dummy,nframe,iret)
+
+ if (iret /= 0) then
+   print*,"- FATAL ERROR: bad read of landmask record."
+   print*,"- IRET IS ", iret
+   call errexit(113)
+ endif
+
+ mask_input = reshape (dummy, (/imi,jmi/))
+
+!-----------------------------------------------------------------------
+! Read remaining records into nsst_input data structure.
+! Note: fv3gfs files do not contain 'ifd' or 'zm' records.  Set
+! to default values per recommendation of nsst developer.
+!-----------------------------------------------------------------------
+
+ print*,"- READ DATA RECORDS"
+
+ do j = 1, nrec
+   if (trim(recname(j)) == 'zm') then  
+     nsst_input(:,:,j) = 0.0
+     cycle
+   endif
+   if (trim(recname(j)) == 'ifd') then
+     nsst_input(:,:,j) = 1.0
+     cycle
+   endif
+   call nemsio_readrecv(gfile,recname(j),levtyp,lev, &
+             dummy,nframe,iret)
+   if (iret /= 0) then
+     print*,"- FATAL ERROR: bad read of chgres.inp.sfc."
+     print*,"- IRET IS ", iret
+     call errexit(114)
+   endif
+   nsst_input(:,:,j) = reshape (dummy, (/imi,jmi/))
+ enddo
+
+ deallocate(dummy)
+
+ call nemsio_close(gfile,iret=iret)
+
+ END SUBROUTINE READ_FV3GFS_NSST_DATA_NEMSIO
+
+ SUBROUTINE READ_GFS_NSST_DATA_NEMSIO (MASK_INPUT,NSST_INPUT,IMI,JMI, &
+                 NUM_NSST_FIELDS,NSST_YEAR,NSST_MON,NSST_DAY,    & 
+                 NSST_HOUR,NSST_FHOUR)
+
+!-----------------------------------------------------------------------
+! Subroutine: read nsst data from a gfs nemsio file
+!
+! Author: George Gayno/EMC
+!
+! Abstract: Reads an nsst file in nemsio format.  Places data
+!           in the "nsst_input" array as expected by routine
+!           nsst_chgres.
+!
+! Input files: 
+!    "chgres.inp.nst" - input nsst nemsio file
+!
+! Output files:  none
+!
+! History:
+!   2016-04-05   Gayno - Initial version
+!
+! Condition codes:  all non-zero codes are fatal
+!   109 - bad open of nst file "chgres.inp.nst"
+!   110 - bad read of "chgres.inp.nst" header
+!   111 - the program assumes that the resolution of the
+!         nst grid matches the input surface grid.  if
+!         they are not the same, stop procoessing.
+!   112 - the nst file does not have the 19 required records.
+!   113 - bad read of landmask record.
+!   114 - bad read of an nst file record.
+!-----------------------------------------------------------------------
+
+ use nemsio_module
+
+ implicit none
+
+ character(len=3)        :: levtyp
+ character(len=8)        :: recname(19)
+
+ integer, intent(in)     :: imi, jmi, num_nsst_fields
+ integer, intent(out)    :: nsst_year, nsst_mon
+ integer, intent(out)    :: nsst_day, nsst_hour
+
+ real,    intent(out)    :: mask_input(imi,jmi)
+ real,    intent(out)    :: nsst_input(imi,jmi,num_nsst_fields)
+ real,    intent(out)    :: nsst_fhour
+
+ integer(nemsio_intkind) :: iret, nrec, dimx, dimy, lev, nframe
+ integer(nemsio_intkind) :: idate(7), nfhour
+
+ integer                 :: j
+
+ real(nemsio_realkind),allocatable :: dummy(:)
+
+ type(nemsio_gfile)      :: gfile
+
+ data recname   /"land    ", "xt      ", "xs      ", &
+                 "xu      ", "xv      ", "xz      ", &
+                 "zm      ", "xtts    ", "xzts    ", &
+                 "dtcool  ", "zc      ", "c0      ", &
+                 "cd      ", "w0      ", "wd      ", &
+                 "dconv   ", "ifd     ", "tref    ", &
+                 "qrain   " /
+
+ print*,"- READ INPUT NSST DATA IN NEMSIO FORMAT"
+
+ call nemsio_open(gfile, "chgres.inp.nst", "read", iret=iret)
+ if (iret /= 0) then
+   print*,"- FATAL ERROR: bad open of chgres.inp.nst."
+   print*,"- IRET IS ", iret
+   call errexit(109)
+ endif
+
+ print*,"- READ FILE HEADER"
+ call nemsio_getfilehead(gfile,iret=iret,nrec=nrec,dimx=dimx, &
+           dimy=dimy,idate=idate,nfhour=nfhour)
+ if (iret /= 0) then
+   print*,"- FATAL ERROR: bad read of chgres.inp.nst header."
+   print*,"- IRET IS ", iret
+   call errexit(110)
+ endif
+
+ if (dimx /= imi .or. dimy /= jmi) then
+   print*,"- FATAL ERROR: nst and sfc file resolution"
+   print*,"- must be the same."
+   call errexit(111)
+ endif
+
+ if (nrec /= 19) then
+   print*,"- FATAL ERROR: nst file has wrong number of records."
+   call errexit(112)
+ endif
+
+ nsst_year=idate(1)
+ nsst_mon=idate(2)
+ nsst_day=idate(3)
+ nsst_hour=idate(4)
+ nsst_fhour=float(nfhour)
+
+ levtyp='sfc'
+ lev=1
+ nframe=0
+
+ allocate(dummy(imi*jmi))
+
+!-----------------------------------------------------------------------
+! Read land mask.  Note: older file versions use 'slmsk'
+! as the header id.
+!-----------------------------------------------------------------------
+
+ call nemsio_readrecv(gfile,recname(1),levtyp,lev, &
+           dummy,nframe,iret)
+ if (iret /= 0) then
+   call nemsio_readrecv(gfile,"slmsk",levtyp,lev, &
+             dummy,nframe,iret)
+   if (iret /= 0) then
+     print*,"- FATAL ERROR: bad read of landmask record."
+     print*,"- IRET IS ", iret
+     call errexit(113)
+   endif
+ endif
+ mask_input = reshape (dummy, (/imi,jmi/))
+
+ print*,"- READ DATA RECORDS"
+ do j = 2, nrec
+   call nemsio_readrecv(gfile,recname(j),levtyp,lev, &
+             dummy,nframe,iret)
+   if (iret /= 0) then
+     print*,"- FATAL ERROR: bad read of chgres.inp.nst."
+     print*,"- IRET IS ", iret
+     call errexit(114)
+   endif
+   nsst_input(:,:,j-1) = reshape (dummy, (/imi,jmi/))
+ enddo
+
+ deallocate(dummy)
+
+ call nemsio_close(gfile,iret=iret)
+
+ END SUBROUTINE READ_GFS_NSST_DATA_NEMSIO
+
+ SUBROUTINE READ_GFS_SFC_HEADER_NEMSIO (IMI,JMI,IVSI,LSOILI, &
+                 FCSTHOUR,IDATE4O,KGDS_INPUT)
+
+ USE NEMSIO_MODULE
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(OUT)     :: IMI,JMI,IVSI,LSOILI,IDATE4O(4)
+ INTEGER, INTENT(OUT)     :: KGDS_INPUT(200)
+
+ REAL, INTENT(OUT)        :: FCSTHOUR
+
+ CHARACTER(LEN=8)         :: FILETYPE
+
+ INTEGER(NEMSIO_INTKIND)  :: DIMX, DIMY, IRET, VERSION
+ INTEGER(NEMSIO_INTKIND)  :: NSOIL, IDATE(7), NFHOUR
+
+ TYPE(NEMSIO_GFILE)       :: GFILEISFC
+
+ CALL NEMSIO_OPEN(GFILEISFC,'chgres.inp.sfc','read',IRET=IRET)
+ IF (IRET /= 0) THEN
+   PRINT*,"FATAL ERROR OPENING chgres.inp.sfc"
+   PRINT*,"IRET IS: ",IRET
+   CALL ERREXIT(119)
+ ENDIF
+
+ CALL NEMSIO_GETFILEHEAD(GFILEISFC,GTYPE=FILETYPE,IRET=IRET, &
+           VERSION=VERSION, DIMX=DIMX, DIMY=DIMY, NSOIL=NSOIL, &
+           IDATE=IDATE, NFHOUR=NFHOUR)
+ IF (IRET /= 0) THEN
+   PRINT*,"FATAL ERROR READING chgres.inp.sfc FILE HEADER."
+   PRINT*,"IRET IS: ",IRET
+   CALL ERREXIT(120)
+ ENDIF
+
+! check bad status
+
+ CALL NEMSIO_CLOSE(GFILEISFC,IRET=IRET)
+
+ IMI        = DIMX
+ JMI        = DIMY
+ LSOILI     = NSOIL
+ IVSI       = VERSION
+ FCSTHOUR   = FLOAT(NFHOUR)
+ IDATE4O(1) = IDATE(4)  ! HOUR
+ IDATE4O(2) = IDATE(2)  ! MONTH
+ IDATE4O(3) = IDATE(3)  ! DAY
+ IDATE4O(4) = IDATE(1)  ! YEAR
+     
+ KGDS_INPUT = 0
+ KGDS_INPUT(1) = 4          ! OCT 6 - TYPE OF GRID (GAUSSIAN)
+ KGDS_INPUT(2) = IMI        ! OCT 7-8 - # PTS ON LATITUDE CIRCLE
+ KGDS_INPUT(3) = JMI        ! OCT 9-10 - # PTS ON LONGITUDE CIRCLE
+ KGDS_INPUT(4) = 90000      ! OCT 11-13 - LAT OF ORIGIN
+ KGDS_INPUT(5) = 0          ! OCT 14-16 - LON OF ORIGIN
+ KGDS_INPUT(6) = 128        ! OCT 17 - RESOLUTION FLAG
+ KGDS_INPUT(7) = -90000     ! OCT 18-20 - LAT OF EXTREME POINT
+ KGDS_INPUT(8) = NINT(-360000./IMI)  ! OCT 21-23 - LON OF EXTREME POINT
+ KGDS_INPUT(9)  = NINT((360.0 / FLOAT(IMI))*1000.0)
+                            ! OCT 24-25 - LONGITUDE DIRECTION INCR.
+ KGDS_INPUT(10) = JMI /2    ! OCT 26-27 - NUMBER OF CIRCLES POLE TO EQUATOR
+ KGDS_INPUT(12) = 255       ! OCT 29 - RESERVED
+ KGDS_INPUT(20) = 255       ! OCT 5  - NOT USED, SET TO 255
+
+ END SUBROUTINE READ_GFS_SFC_HEADER_NEMSIO
+
+ SUBROUTINE READ_GFS_SFC_HEADER_SFCIO (NSFCI,IMI,JMI,IVSI,LSOILI, &
+                 FCSTHOUR,IDATE4O,KGDS_INPUT)
+
+ USE SFCIO_MODULE
+
+ INTEGER, INTENT(IN)  :: NSFCI
+ INTEGER, INTENT(OUT) :: IMI,JMI,IVSI,LSOILI,IDATE4O(4)
+ INTEGER, INTENT(OUT) :: KGDS_INPUT(200)
+ INTEGER              :: IRET
+
+ REAL, INTENT(OUT)    :: FCSTHOUR
+
+ TYPE(SFCIO_HEAD)     :: SFCHEADI
+
+ CALL SFCIO_SROPEN(NSFCI,'chgres.inp.sfc',IRET)
+ IF (IRET /= 0) THEN
+   PRINT*,"FATAL ERROR OPENING chgres.inp.sfc"
+   PRINT*,"IRET IS: ", IRET
+   CALL ERREXIT(121)
+ ENDIF
+
+ CALL SFCIO_SRHEAD(NSFCI,SFCHEADI,IRET)
+ IF (IRET /= 0) THEN
+   PRINT*,"FATAL ERROR READING chgres.inp.sfc HEADER"
+   PRINT*,"IRET IS: ", IRET
+   CALL ERREXIT(122)
+ ENDIF
+
+ CALL SFCIO_SCLOSE(NSFCI,IRET)
+
+ IMI = SFCHEADI%LONB
+ JMI = SFCHEADI%LATB
+ IVSI = SFCHEADI%IVS
+ LSOILI = SFCHEADI%LSOIL
+ FCSTHOUR = SFCHEADI%FHOUR
+ IDATE4O = SFCHEADI%IDATE
+
+ KGDS_INPUT = 0
+ KGDS_INPUT(1) = 4          ! OCT 6 - TYPE OF GRID (GAUSSIAN)
+ KGDS_INPUT(2) = IMI        ! OCT 7-8 - # PTS ON LATITUDE CIRCLE
+ KGDS_INPUT(3) = JMI        ! OCT 9-10 - # PTS ON LONGITUDE CIRCLE
+ KGDS_INPUT(4) = 90000      ! OCT 11-13 - LAT OF ORIGIN
+ KGDS_INPUT(5) = 0          ! OCT 14-16 - LON OF ORIGIN
+ KGDS_INPUT(6) = 128        ! OCT 17 - RESOLUTION FLAG
+ KGDS_INPUT(7) = -90000     ! OCT 18-20 - LAT OF EXTREME POINT
+ KGDS_INPUT(8) = NINT(-360000./IMI)  ! OCT 21-23 - LON OF EXTREME POINT
+ KGDS_INPUT(9)  = NINT((360.0 / FLOAT(IMI))*1000.0)
+                            ! OCT 24-25 - LONGITUDE DIRECTION INCR.
+ KGDS_INPUT(10) = JMI /2    ! OCT 26-27 - NUMBER OF CIRCLES POLE TO EQUATOR
+ KGDS_INPUT(12) = 255       ! OCT 29 - RESERVED
+ KGDS_INPUT(20) = 255       ! OCT 5  - NOT USED, SET TO 255
+
+ END SUBROUTINE READ_GFS_SFC_HEADER_SFCIO
+
+ SUBROUTINE READ_FV3GFS_SFC_DATA_NEMSIO (IMI, JMI, LSOILI, SFCINPUT, &
+                                 F10MI, T2MI, Q2MI,  &
+                                 UUSTARI, FFMMI, FFHHI, SRFLAGI, &
+                                 TPRCPI)
+
+ USE NEMSIO_MODULE
+ USE SURFACE_CHGRES
+
+ INTEGER, INTENT(IN)  :: IMI, JMI, LSOILI
+
+ REAL, INTENT(OUT)    :: F10MI(IMI,JMI), T2MI(IMI,JMI)
+ REAL, INTENT(OUT)    :: Q2MI(IMI,JMI), UUSTARI(IMI,JMI)
+ REAL, INTENT(OUT)    :: FFMMI(IMI,JMI), FFHHI(IMI,JMI)
+ REAL, INTENT(OUT)    :: SRFLAGI(IMI,JMI), TPRCPI(IMI,JMI)
+
+ TYPE(SFC2D)              :: SFCINPUT
+ TYPE(NEMSIO_GFILE)       :: GFILEISFC
+
+ INTEGER(NEMSIO_INTKIND)  :: IRET
+
+ REAL(NEMSIO_REALKIND)    :: TMP(IMI*JMI)
+
+ CALL NEMSIO_OPEN(GFILEISFC,'chgres.inp.sfc','read',IRET=IRET)
+ IF(IRET /= 0)THEN
+   PRINT*,"FATAL ERROR OPENING chgres.inp.sfc"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(244)
+ ENDIF
+
+ SRFLAGI = 0.0  ! NOT IN FILE.  SET TO ZERO.
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'ffhh', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ FFHHI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'ffmm', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ FFMMI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'f10m', '10 m above gnd', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ F10MI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', '2 m above gnd', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ T2MI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'spfh', '2 m above gnd', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ Q2MI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'fricv', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ UUSTARI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'tprcp', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ TPRCPI = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'alnsf', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%ALNSF = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'alnwf', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%ALNWF = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'alvsf', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%ALVSF = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'cnwat', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%CANOPY_MC = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'veg', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%GREENFRC = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'facsf', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%FACSF = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'facwf', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%FACWF = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SKIN_TEMP = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'land', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%LSMASK = RESHAPE(TMP, (/IMI,JMI/) )
+
+ DO J = 1, JMI
+ DO I = 1, IMI
+   SFCINPUT%SEA_ICE_FLAG(I,J) = 0
+   IF(NINT(SFCINPUT%LSMASK(I,J))==2) THEN
+     SFCINPUT%LSMASK(I,J)=0.
+     SFCINPUT%SEA_ICE_FLAG(I,J) = 1
+   ENDIF
+ ENDDO
+ ENDDO
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'sfcr', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%Z0 = RESHAPE(TMP, (/IMI,JMI/) )
+ SFCINPUT%Z0 = SFCINPUT%Z0 * 100.0  ! convert to cm
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'orog', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%OROG = RESHAPE(TMP, (/IMI,JMI/) )
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'vtype', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%VEG_TYPE = NINT(RESHAPE(TMP, (/IMI,JMI/) ))
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'sotyp', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOIL_TYPE = NINT(RESHAPE(TMP, (/IMI,JMI/) ))
+ 
+ CALL NEMSIO_READRECV(GFILEISFC, 'weasd', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SNOW_LIQ_EQUIV = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'icec', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SEA_ICE_FRACT = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'icetk', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SEA_ICE_DEPTH = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'snoalb', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%MXSNOW_ALB = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'snod', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SNOW_DEPTH = RESHAPE(TMP, (/IMI,JMI/) )
+ SFCINPUT%SNOW_DEPTH = SFCINPUT%SNOW_DEPTH * 1000.0 ! convert to mm
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'sltyp', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SLOPE_TYPE = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'shdmin', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%GREENFRC_MIN = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'shdmax', 'sfc', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%GREENFRC_MAX = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soilw', '0-10 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_TOT(:,:,1) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soilw', '10-40 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_TOT(:,:,2) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soilw', '40-100 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_TOT(:,:,3) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soilw', '100-200 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_TOT(:,:,4) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soill', '0-10 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_LIQ(:,:,1) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soill', '10-40 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_LIQ(:,:,2) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soill', '40-100 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_LIQ(:,:,3) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'soill', '100-200 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOILM_LIQ(:,:,4) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', '0-10 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOIL_TEMP(:,:,1) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', '10-40 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOIL_TEMP(:,:,2) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', '40-100 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOIL_TEMP(:,:,3) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_READRECV(GFILEISFC, 'tmp', '100-200 cm down', 1, TMP, IRET=IRET)
+ IF (IRET /= 0) GOTO 99
+ SFCINPUT%SOIL_TEMP(:,:,4) = RESHAPE(TMP, (/IMI,JMI/) )
+
+ CALL NEMSIO_CLOSE(GFILEISFC, IRET=IRET)
+
+ RETURN
+
+ 99 CONTINUE
+ PRINT*,"FATAL ERROR READING DATA FROM chgres.inp.sfc"
+ PRINT*,"IRET IS ", IRET
+ CALL ERREXIT(245)
+
+ END SUBROUTINE READ_FV3GFS_SFC_DATA_NEMSIO
+
+ SUBROUTINE READ_GFS_SFC_DATA_NEMSIO (IMI, JMI, LSOILI, IVSI, SFCINPUT, &
+                                 F10MI, T2MI, Q2MI,  &
+                                 UUSTARI, FFMMI, FFHHI, SRFLAGI, &
+                                 TPRCPI)
+
+ USE NEMSIO_MODULE
+ USE NEMSIO_GFS
+ USE SURFACE_CHGRES
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN)  :: IMI, JMI, LSOILI, IVSI
+
+ REAL, INTENT(OUT)    :: F10MI(IMI,JMI), T2MI(IMI,JMI)
+ REAL, INTENT(OUT)    :: Q2MI(IMI,JMI), UUSTARI(IMI,JMI)
+ REAL, INTENT(OUT)    :: FFMMI(IMI,JMI), FFHHI(IMI,JMI)
+ REAL, INTENT(OUT)    :: SRFLAGI(IMI,JMI), TPRCPI(IMI,JMI)
+
+ INTEGER(NEMSIO_INTKIND)  :: IRET
+ INTEGER                  :: I, J, L
+
+ TYPE(SFC2D)          :: SFCINPUT
+ TYPE(NEMSIO_GFILE)   :: GFILEISFC
+ TYPE(NEMSIO_DBTA)    :: GFSDATAI
+
+ CALL NEMSIO_OPEN(GFILEISFC,'chgres.inp.sfc','read',IRET=IRET)
+ IF(IRET /= 0)THEN
+   PRINT*,"FATAL ERROR OPENING chgres.inp.sfc"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(144)
+ ENDIF
+
+ CALL NEMSIO_GFS_ALSFC(IMI, JMI, LSOILI, GFSDATAI)
+
+ CALL NEMSIO_GFS_RDSFC(GFILEISFC,GFSDATAI,IRET)
+ IF(IRET /= 0)THEN
+   PRINT*,"FATAL ERROR READING DATA FROM chgres.inp.sfc"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(145)
+ ENDIF
+
+ CALL NEMSIO_CLOSE(GFILEISFC, IRET=IRET)
+
+!$OMP PARALLEL DO PRIVATE(I,J)
+ DO J = 1, JMI
+   DO I = 1, IMI
+
+     SFCINPUT%ALNSF(I,J) = GFSDATAI%ALNSF(I,J)
+     SFCINPUT%ALNWF(I,J) = GFSDATAI%ALNWF(I,J)
+     SFCINPUT%ALVSF(I,J) = GFSDATAI%ALVSF(I,J)
+     SFCINPUT%ALVWF(I,J) = GFSDATAI%ALVWF(I,J)
+     SFCINPUT%CANOPY_MC(I,J) = GFSDATAI%CANOPY(I,J)
+     SFCINPUT%GREENFRC(I,J) = GFSDATAI%VFRAC(I,J)
+     SFCINPUT%FACSF(I,J) = GFSDATAI%FACSF(I,J)
+     SFCINPUT%FACWF(I,J) = GFSDATAI%FACWF(I,J)
+     SFCINPUT%SKIN_TEMP(I,J) = GFSDATAI%TSEA(I,J)
+     SFCINPUT%LSMASK(I,J) = GFSDATAI%SLMSK(I,J)
+     SFCINPUT%SEA_ICE_FLAG(I,J) = 0
+     IF(NINT(SFCINPUT%LSMASK(I,J))==2) THEN
+       SFCINPUT%LSMASK(I,J)=0.
+       SFCINPUT%SEA_ICE_FLAG(I,J) = 1
+      ENDIF
+     SFCINPUT%Z0(I,J) = GFSDATAI%ZORL(I,J)
+     SFCINPUT%OROG(I,J)         = GFSDATAI%OROG(I,J)
+     SFCINPUT%VEG_TYPE(I,J)     = NINT(GFSDATAI%VTYPE(I,J))
+     SFCINPUT%SOIL_TYPE(I,J)    = NINT(GFSDATAI%STYPE(I,J))
+     SFCINPUT%SNOW_LIQ_EQUIV(I,J) = GFSDATAI%SHELEG(I,J)
+
+   ENDDO
+ ENDDO
+!$OMP END PARALLEL DO
+ 
+ DO L = 1, LSOILI
+!$OMP PARALLEL DO PRIVATE(I,J)
+   DO J = 1, JMI
+     DO I = 1, IMI
+       SFCINPUT%SOILM_TOT(I,J,L) = GFSDATAI%SMC(I,J,L)
+       SFCINPUT%SOIL_TEMP(I,J,L) = GFSDATAI%STC(I,J,L)
+     ENDDO
+   ENDDO
+!$OMP END PARALLEL DO
+ ENDDO
+
+ SRFLAGI = 0.0
+ TPRCPI  = 0.0
+
+ IF (IVSI >= 200501) THEN
+!$OMP PARALLEL DO PRIVATE(I,J)
+   DO J = 1, JMI
+     DO I = 1, IMI
+       SFCINPUT%SEA_ICE_FRACT(I,J) = GFSDATAI%FICE(I,J)
+       SFCINPUT%SEA_ICE_DEPTH(I,J) = GFSDATAI%HICE(I,J)
+       SFCINPUT%MXSNOW_ALB(I,J)    = GFSDATAI%SNOALB(I,J)
+       SFCINPUT%SNOW_DEPTH(I,J)    = GFSDATAI%SNWDPH(I,J)
+       SFCINPUT%SLOPE_TYPE(I,J)    = NINT(GFSDATAI%SLOPE(I,J))
+       SFCINPUT%GREENFRC_MAX(I,J)  = GFSDATAI%SHDMAX(I,J)
+       SFCINPUT%GREENFRC_MIN(I,J)  = GFSDATAI%SHDMIN(I,J)
+       SRFLAGI(I,J)                = GFSDATAI%SRFLAG(I,J)
+       TPRCPI(I,J)                 = GFSDATAI%TPRCP(I,J)
+     ENDDO
+   ENDDO
+!$OMP END PARALLEL DO
+
+   DO L=1,LSOILI
+!$OMP PARALLEL DO PRIVATE(I,J)
+     DO J = 1, JMI
+       DO I = 1, IMI
+         SFCINPUT%SOILM_LIQ(I,J,L) = GFSDATAI%SLC(I,J,L)
+       ENDDO
+     ENDDO
+   ENDDO
+
+ END IF  ! IVS >= 200501
+
+!$OMP PARALLEL DO PRIVATE(I,J)
+ DO J = 1, JMI
+   DO I = 1, IMI
+     F10MI(I,J) = GFSDATAI%F10M(I,J)
+     T2MI(I,J) = GFSDATAI%T2M(I,J)
+     Q2MI(I,J) = GFSDATAI%Q2M(I,J)
+     UUSTARI(I,J) = GFSDATAI%UUSTAR(I,J)
+     FFMMI(I,J) = GFSDATAI%FFMM(I,J)
+     FFHHI(I,J) = GFSDATAI%FFHH(I,J)
+   ENDDO
+ ENDDO
+!$OMP END PARALLEL DO
+
+ END SUBROUTINE READ_GFS_SFC_DATA_NEMSIO
+
+ SUBROUTINE READ_GFS_SFC_DATA_SFCIO (NSFCI, IMI, JMI, SFCINPUT,  &
+                              F10MI, T2MI, Q2MI, &
+                              UUSTARI, FFMMI, FFHHI, SRFLAGI, &
+                              TPRCPI)
+
+ USE SFCIO_MODULE
+ USE SURFACE_CHGRES
+
+ IMPLICIT NONE
+
+ INTEGER, INTENT(IN)  :: NSFCI, IMI, JMI
+ INTEGER              :: I,J,L, IRET
+
+ REAL, INTENT(OUT)    :: F10MI(IMI,JMI), T2MI(IMI,JMI)
+ REAL, INTENT(OUT)    :: Q2MI(IMI,JMI), UUSTARI(IMI,JMI)
+ REAL, INTENT(OUT)    :: FFMMI(IMI,JMI), FFHHI(IMI,JMI)
+ REAL, INTENT(OUT)    :: SRFLAGI(IMI,JMI), TPRCPI(IMI,JMI)
+
+ TYPE(SFC2D)          :: SFCINPUT
+ TYPE(SFCIO_HEAD)     :: SFCHEADI
+ TYPE(SFCIO_DBTA)     :: SFCDATAI
+
+ CALL SFCIO_SROPEN(NSFCI,'chgres.inp.sfc',IRET)
+ IF(IRET /=0) THEN
+   PRINT*,"FATAL ERROR OPENING chgres.inp.sfc"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(155)
+ ENDIF
+
+ CALL SFCIO_SRHEAD(NSFCI,SFCHEADI,IRET)
+ IF(IRET /=0) THEN
+   PRINT*,"FATAL ERROR READING chgres.inp.sfc HEADER"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(156)
+ ENDIF
+
+ CALL SFCIO_ALDBTA(SFCHEADI,SFCDATAI,IRET)
+ IF(IRET.NE.0) THEN
+   PRINT*,"FATAL ERROR ALLOCATING SFC DATA STRUCTURE"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(158)
+ ENDIF
+
+ CALL SFCIO_SRDBTA(NSFCI,SFCHEADI,SFCDATAI,IRET)
+ IF(IRET /=0) THEN
+   PRINT*,"FATAL ERROR READING chgres.inp.sfc DATA"
+   PRINT*,"IRET IS ", IRET
+   CALL ERREXIT(157)
+ ENDIF
+
+ CALL SFCIO_SCLOSE(NSFCI,IRET)
+
+!$OMP PARALLEL DO PRIVATE(I,J)
+
+ DO J = 1, SFCHEADI%LATB
+ DO I = 1, SFCHEADI%LONB
+
+   SFCINPUT%ALNSF(I,J) = SFCDATAI%ALNSF(I,J)
+   SFCINPUT%ALNWF(I,J) = SFCDATAI%ALNWF(I,J)
+   SFCINPUT%ALVSF(I,J) = SFCDATAI%ALVSF(I,J)
+   SFCINPUT%ALVWF(I,J) = SFCDATAI%ALVWF(I,J)
+   SFCINPUT%CANOPY_MC(I,J) = SFCDATAI%CANOPY(I,J)
+   SFCINPUT%GREENFRC(I,J) = SFCDATAI%VFRAC(I,J)
+   SFCINPUT%FACSF(I,J) = SFCDATAI%FACSF(I,J)
+   SFCINPUT%FACWF(I,J) = SFCDATAI%FACWF(I,J)
+   SFCINPUT%SKIN_TEMP(I,J) = SFCDATAI%TSEA(I,J)
+   SFCINPUT%LSMASK(I,J) = SFCDATAI%SLMSK(I,J)
+   SFCINPUT%SEA_ICE_FLAG(I,J) = 0
+   IF(NINT(SFCINPUT%LSMASK(I,J))==2) THEN
+     SFCINPUT%LSMASK(I,J)=0.
+     SFCINPUT%SEA_ICE_FLAG(I,J) = 1
+   ENDIF
+   SFCINPUT%Z0(I,J) = SFCDATAI%ZORL(I,J)
+   SFCINPUT%OROG(I,J)         = SFCDATAI%OROG(I,J)
+   SFCINPUT%VEG_TYPE(I,J)     = NINT(SFCDATAI%VTYPE(I,J))
+   SFCINPUT%SOIL_TYPE(I,J)    = NINT(SFCDATAI%STYPE(I,J))
+   SFCINPUT%SNOW_LIQ_EQUIV(I,J) = SFCDATAI%SHELEG(I,J)
+
+ ENDDO
+ ENDDO
+
+!$OMP END PARALLEL DO
+
+ DO L = 1, SFCHEADI%LSOIL
+!$OMP PARALLEL DO PRIVATE(I,J)
+   DO J = 1, SFCHEADI%LATB
+     DO I = 1, SFCHEADI%LONB
+       SFCINPUT%SOILM_TOT(I,J,L) = SFCDATAI%SMC(I,J,L)
+       SFCINPUT%SOIL_TEMP(I,J,L) = SFCDATAI%STC(I,J,L)
+     ENDDO
+   ENDDO
+!$OMP END PARALLEL DO
+ ENDDO
+
+ SRFLAGI = 0.0
+ TPRCPI  = 0.0
+
+ IF (SFCHEADI%IVS >= 200501) THEN
+!$OMP PARALLEL DO PRIVATE(I,J)
+   DO J = 1, SFCHEADI%LATB
+     DO I = 1, SFCHEADI%LONB
+       SFCINPUT%SEA_ICE_FRACT(I,J) = SFCDATAI%FICE(I,J)
+       SFCINPUT%SEA_ICE_DEPTH(I,J) = SFCDATAI%HICE(I,J)
+       SFCINPUT%MXSNOW_ALB(I,J)    = SFCDATAI%SNOALB(I,J)
+       SFCINPUT%SNOW_DEPTH(I,J)    = SFCDATAI%SNWDPH(I,J)
+       SFCINPUT%SLOPE_TYPE(I,J)    = NINT(SFCDATAI%SLOPE(I,J))
+       SFCINPUT%GREENFRC_MAX(I,J)  = SFCDATAI%SHDMAX(I,J)
+       SFCINPUT%GREENFRC_MIN(I,J)  = SFCDATAI%SHDMIN(I,J)
+       SRFLAGI(I,J)                = SFCDATAI%SRFLAG(I,J)
+       TPRCPI(I,J)                 = SFCDATAI%TPRCP(I,J)
+     ENDDO
+   ENDDO
+!$OMP END PARALLEL DO
+
+   DO L=1,SFCHEADI%LSOIL
+!$OMP PARALLEL DO PRIVATE(I,J)
+     DO J = 1, SFCHEADI%LATB
+       DO I = 1, SFCHEADI%LONB
+         SFCINPUT%SOILM_LIQ(I,J,L) = SFCDATAI%SLC(I,J,L)
+       ENDDO
+     ENDDO
+   ENDDO
+
+ END IF  ! IVS >= 200501
+
+!$OMP PARALLEL DO PRIVATE(I,J)
+ DO J = 1, SFCHEADI%LATB
+   DO I = 1, SFCHEADI%LONB
+     F10MI(I,J) = SFCDATAI%F10M(I,J)
+     T2MI(I,J) = SFCDATAI%T2M(I,J)
+     Q2MI(I,J) = SFCDATAI%Q2M(I,J)
+     UUSTARI(I,J) = SFCDATAI%UUSTAR(I,J)
+     FFMMI(I,J) = SFCDATAI%FFMM(I,J)
+     FFHHI(I,J) = SFCDATAI%FFHH(I,J)
+   ENDDO
+ ENDDO
+!$OMP END PARALLEL DO
+
+ CALL SFCIO_AXDBTA(SFCDATAI,IRET)
+
+ END SUBROUTINE READ_GFS_SFC_DATA_SFCIO
diff --git a/sorc/global_cycle.fd/CMakeLists.txt b/sorc/global_cycle.fd/CMakeLists.txt
new file mode 100644
index 0000000..94d44e1
--- /dev/null
+++ b/sorc/global_cycle.fd/CMakeLists.txt
@@ -0,0 +1,26 @@
+set(fortran_src
+    cycle.f90     
+    machine.f90
+    num_parthds.f90
+    sfcsub.F
+    read_write_data.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -convert big_endian")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fdefault-real-8 -fconvert=big-endian")
+endif()
+
+set(exe_name global_cycle)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  w3nco_d
+  bacio_4
+  ip_d
+  sp_d
+  MPI::MPI_Fortran
+  NetCDF::NetCDF_Fortran
+  OpenMP::OpenMP_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/machine-setup.sh b/sorc/machine-setup.sh
index 48b2ee1..8389f2b 100644
--- a/sorc/machine-setup.sh
+++ b/sorc/machine-setup.sh
@@ -27,7 +27,6 @@ if [[ -d /lfs3 ]] ; then
     fi
     target=jet
     module purge
-    module use /lfs3/projects/hfv3gfs/nwprod/NCEPLIBS/modulefiles
 elif [[ -d /scratch1 ]] ; then
     # We are on NOAA Hera
     if ( ! eval module help > /dev/null 2>&1 ) ; then
@@ -36,7 +35,6 @@ elif [[ -d /scratch1 ]] ; then
     fi
     target=hera
     module purge
-    MOD_PATH=/scratch2/NCEPDEV/nwprod/NCEPLIBS/modulefiles
 elif [[ -d /gpfs/hps && -e /etc/SuSE-release ]] ; then
     # We are on NOAA Luna or Surge
     if ( ! eval module help > /dev/null 2>&1 ) ; then
@@ -109,6 +107,9 @@ elif [[ -d /lustre && -d /ncrc ]] ; then
     fi
     target=gaea
     module purge
+elif [[ "$(hostname)" =~ "Orion" ]]; then
+    target="orion"
+    module purge
 elif [[ "$(hostname)" =~ "odin" ]]; then
     target="odin"
 else
diff --git a/sorc/mkgfsnemsioctl.fd/CMakeLists.txt b/sorc/mkgfsnemsioctl.fd/CMakeLists.txt
new file mode 100644
index 0000000..7002cf3
--- /dev/null
+++ b/sorc/mkgfsnemsioctl.fd/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(fortran_src
+    mkgfsnemsioctl.f90)
+
+set(exe_name mkgfsnemsioctl)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  nemsio
+  bacio_4
+  w3nco_d)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/mkgfsnemsioctl.fd/mkgfsnemsioctl.f90 b/sorc/mkgfsnemsioctl.fd/mkgfsnemsioctl.f90
new file mode 100644
index 0000000..cdc9efc
--- /dev/null
+++ b/sorc/mkgfsnemsioctl.fd/mkgfsnemsioctl.f90
@@ -0,0 +1,535 @@
+!- - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+! the program create NEMS GFS  sfc ctl file
+!
+!   Mar 12, 2015   Jun Wang
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+!
+  program main
+  use nemsio_module
+  implicit none
+!
+!---------------------------------------------------------------------------
+  type(nemsio_gfile) :: gfile
+  character(255) cin,cindx
+  real,allocatable  :: data(:,:)
+!---------------------------------------------------------------------------
+!--- nemsio meta data
+  integer nrec,im,jm,lm,idate(7),nfhour,tlmeta,nsoil,fieldsize
+  real(4),allocatable    :: lat1(:),lat(:),lon1(:)
+  real(8),allocatable    :: slat(:)
+  character(16),allocatable:: recname(:),reclevtyp(:)
+  integer,allocatable:: reclev(:)
+!---------------------------------------------------------------------------
+!--- local vars
+  character(3) cmon
+  character(16) reclevtyp_sht
+  character(32) ctldate,varname
+  character(35) sweep_blanks
+  real(8) radi
+  real lon_stt,lat_stt,lon_intl,lat_intl
+  integer i,n,j,krec,iret,io_unit,idrt,nmeta
+!---------------------------------------------------------------------------
+!---------------------------------------------------------------------------
+!
+  call nemsio_init(iret=iret)
+  if(iret/=0) print *,'ERROR: nemsio_init '
+!
+!---------------------------------------------------------------------------
+!***  read nemsio grd header info
+!---------------------------------------------------------------------------
+!--- open gfile for reading
+  call getarg(1,cin)
+  print *,'filename is cin=',trim(cin)
+  if(trim(cin)=='') then
+    print *,'usage: mknemsioctl input_nemsio_file_name'
+    stop
+  endif
+  call getarg(2,cindx)
+  if(trim(cindx)=='') then
+    cindx=trim(cin)//'.ctl'
+  endif
+  
+  call nemsio_open(gfile,trim(cin),'READ',iret=iret)
+  if(iret/=0) print *,'Error: open nemsio file,',trim(cin),' iret=',iret
+
+  call nemsio_getfilehead(gfile,iret=iret,nrec=nrec,dimx=im,dimy=jm, &
+    dimz=lm,idate=idate,nfhour=nfhour,nmeta=nmeta,                   &
+    nsoil=nsoil,idrt=idrt,tlmeta=tlmeta)
+!
+   fieldsize=im*jm
+   allocate(recname(nrec),reclevtyp(nrec),reclev(nrec))
+   allocate(lat1(fieldsize),lat(jm),lon1(fieldsize))
+   call nemsio_getfilehead(gfile,iret=iret,recname=recname,          &
+       reclevtyp=reclevtyp,reclev=reclev,lat=lat1,lon=lon1) 
+!
+   call nemsio_close(gfile,iret=iret)
+!
+   call nemsio_finalize()
+!
+!---------------------------------------------------------------------------
+!****** write .ctl file
+!---------------------------------------------------------------------------
+!
+!-- get date
+   call cmonth(idate(2),cmon)
+   write(ctldate,'(i2.2,a,i2.2,a3,i4.4)')idate(4),'Z',idate(3)       &
+        ,cmon,idate(1)
+!-- get Gaussian grid
+   if(idrt==4) then
+!-- data has lat/lon info
+     if (nmeta>=8) then
+       lon_stt=lon1(1)
+       lon_intl=lon1(2)-lon1(1)
+       do  j=1,jm
+         lat(j) = lat1(1+(j-1)*im)
+       enddo
+     else
+       call splat8(idrt,jm,slat)
+       radi=180.0/(4.*atan(1.0))
+       do  j=1,jm
+         lat(j) = asin(slat(j)) * radi
+       enddo
+       lon_stt=0.
+       lon_intl=360./real(jm)
+     endif
+   elseif(idrt==0) then
+     if(nmeta>=8) then
+       lon_stt=lon1(1)
+       lon_intl=lon1(2)-lon1(1)
+       lat_stt=-abs(lat1(1))
+       lat_intl=abs(lat1(1+im)-lat1(1))
+!!     print*, "im=",im,' jm=',jm
+!!     print*, "lon1=",lon1
+!!     print*, "lat_intl=",lat_intl
+!!     print*, "lat1=",lat1
+     else
+       if (mod(jm,2) == 0) then
+         lat_intl=180.0/real(jm)
+         lat_stt=-90.0+0.5*lat_intl
+       else
+         lat_intl=180.0/real(jm-1)
+         lat_stt=-90.0
+       endif
+       lon_intl=360./real(im)
+       lon_stt=0.5*lon_intl
+     endif
+   endif
+
+   io_unit=650
+   open(io_unit,file=trim(cindx),form='formatted')
+!
+   write(io_unit,105)trim(cin)
+   write(io_unit,106)
+
+   if (idrt == 4 )then
+      write(io_unit,107)
+   elseif(idrt==0) then
+    if(nmeta>=8) then
+     if (lat1(1)>lat1(im+1)) then
+       write(io_unit,107)
+     else
+       write(io_unit,1077)
+     endif
+    else
+     write(io_unit,1077)
+    endif
+   endif
+
+   write(io_unit,108)tlmeta
+   write(io_unit,109)
+   write(io_unit,111)im,lon_stt,lon_intl
+   if (idrt==4) then
+     write(io_unit,112)jm
+     write(io_unit,113)(lat(i),i=jm,1,-1)
+   else
+     write(io_unit,120)jm,lat_stt,lat_intl
+   endif
+   write(io_unit,114)lm
+   if(nfhour/=0) then
+     write(io_unit,115)1,trim(ctldate),nfhour
+   else
+     write(io_unit,116)1,trim(ctldate)
+   endif
+
+!
+ 105  FORMAT('dset ^',A)
+ 106  FORMAT('undef 9.99E+20')
+ 107  FORMAT('options big_endian sequential yrev')
+ 1077 FORMAT('options big_endian sequential')
+ 108  FORMAT('fileheader',I12.0)
+ 109  FORMAT('title gfs nemsioi file')
+
+ 111  FORMAT('xdef  ',I6,' linear  ',f9.6,' ',f9.6)
+ 112  FORMAT('ydef  ',I6,' levels')
+ 113  FORMAT(10f11.6)
+
+ 114  FORMAT('zdef ',I6,' linear 1 1')
+ 115  FORMAT('tdef ',I6,' linear ',A12,' ',I6,'hr')
+ 116  FORMAT('tdef ',I6,' linear ',A12,'  1yr')
+!
+ 120  FORMAT('ydef  ',I6,' linear  ',f13.6,' ',f9.6)
+!
+   krec=0
+   do n=1,nrec
+     if(reclev(n)==1) then
+       krec=krec+1
+     endif
+   enddo
+      
+   WRITE(IO_UNIT,'(A,I6)')'VARS ',krec
+
+   n=1
+   do while (n<=nrec)
+     reclevtyp_sht=reclevtyp(n)
+     if(trim(reclevtyp_sht) == "convect-cld bot") then
+       reclevtyp_sht="cvb"
+     elseif (trim(reclevtyp_sht) == "convect-cld top") then
+       reclevtyp_sht="cvt"
+     elseif (trim(reclevtyp_sht) == "high cld bot") then
+       reclevtyp_sht="hcb"
+     elseif (trim(reclevtyp_sht) == "high cld top") then
+       reclevtyp_sht="hct"
+     elseif (trim(reclevtyp_sht) == "mid cld bot") then
+       reclevtyp_sht="mcb"
+     elseif (trim(reclevtyp_sht) == "mid cld top") then
+       reclevtyp_sht="mct"
+     elseif (trim(reclevtyp_sht) == "low cld bot") then
+       reclevtyp_sht="lcb"
+     elseif (trim(reclevtyp_sht) == "low cld top") then
+       reclevtyp_sht="lct"
+     elseif (trim(reclevtyp_sht) == "convect-cld laye") then
+       reclevtyp_sht="cvcl"
+     elseif (trim(reclevtyp_sht) == "bndary-layer cld") then
+       reclevtyp_sht="bdrlc"
+     elseif (trim(reclevtyp_sht) == "atmos col") then
+       reclevtyp_sht="acol"
+     elseif (trim(reclevtyp_sht) == "high cld lay") then
+       reclevtyp_sht="hcl"
+     elseif (trim(reclevtyp_sht) == "mid cld lay") then
+       reclevtyp_sht="mcl"
+     elseif (trim(reclevtyp_sht) == "low cld lay") then
+       reclevtyp_sht="lcl"
+     elseif (trim(reclevtyp_sht) == "2 m above gnd") then
+       reclevtyp_sht="2m"
+     elseif (trim(reclevtyp_sht) == "10 m above gnd") then
+       reclevtyp_sht="10m"
+     endif
+     varname=sweep_blanks(trim(recname(n))//trim(reclevtyp_sht))
+     if(trim(reclevtyp(n))=='mid layer') then
+       write(io_unit,'(a16,i3,a)')varname,lm,' 99 model layer'
+       n=n+lm
+     elseif(trim(reclevtyp(n))=='soil layer') then
+        write(io_unit,'(a16,i3,a)')varname,nsoil,' 99 soil layer'
+        n=n+nsoil
+     elseif(trim(reclevtyp(n))=='2 m above gnd') then
+       recname(n)=trim(recname(n))//'2m'
+       write(io_unit,'(a16,a7,a)')varname,'  0 99 ',trim(reclevtyp(n))
+       n=n+1
+     elseif(trim(reclevtyp(n))=='10 m above gnd') then
+       recname(n)=trim(recname(n))//'10m'
+       write(io_unit,'(a16,a7,a)')varname,'  0 99 ',trim(reclevtyp(n))
+       n=n+1
+     else
+       write(io_unit,'(a16,a7,a)')varname,'  0 99 ',trim(reclevtyp(n))
+       n=n+1
+     endif
+   enddo
+
+   write(io_unit,'(A8)')'endvars'
+   close(io_unit)
+
+!---------------------------------------------------------------------------
+!****** clean up
+!---------------------------------------------------------------------------
+  deallocate(recname,reclevtyp,reclev,lat,lat1,lon1)
+!---------------------------------------------------------------------------
+!
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+  stop
+
+ end program
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+      SUBROUTINE CMONTH(IMON,CMON)
+!
+!-----------------------------------------------------------------------
+!***  Convert month
+!-----------------------------------------------------------------------
+!
+      INTEGER,INTENT(IN) :: IMON
+      CHARACTER(LEN=3)   :: CMON
+!
+!-----------------------------------------------------------------------
+!
+      SELECT CASE (IMON)
+        CASE(1)
+            CMON='Jan'
+        CASE(2)
+            CMON='Feb'
+        CASE(3)
+            CMON='Mar'
+        CASE(4)
+            CMON='Apr'
+        CASE(5)
+            CMON='May'
+        CASE(6)
+            CMON='Jun'
+        CASE(7)
+            CMON='Jul'
+        CASE(8)
+            CMON='Aug'
+        CASE(9)
+            CMON='Sep'
+        CASE(10)
+            CMON='Oct'
+        CASE(11)
+            CMON='Nov'
+        CASE(12)
+            CMON='Dec'
+      END SELECT
+!
+!-----------------------------------------------------------------------
+!
+      END SUBROUTINE CMONTH
+
+!
+      sUBROUTINE splat4(IDRT,JMAX,ASLAT)
+!
+      implicit none
+      integer,intent(in) :: idrt,jmax
+      real(4),intent(out) :: ASLAT(JMAX)
+      INTEGER,PARAMETER:: KD=SELECTED_REAL_KIND(15,45)
+      REAL(KIND=KD):: PK(JMAX/2),PKM1(JMAX/2),PKM2(JMAX/2)
+      REAL(KIND=KD):: ASLATD(JMAX/2),SP,SPMAX,EPS=10.d0*EPSILON(SP)
+      integer,PARAMETER:: JZ=50
+      REAL(8) BZ(JZ)
+      DATA BZ        / 2.4048255577d0,  5.5200781103d0, &
+       8.6537279129d0, 11.7915344391d0, 14.9309177086d0, 18.0710639679d0, &
+      21.2116366299d0, 24.3524715308d0, 27.4934791320d0, 30.6346064684d0, &
+      33.7758202136d0, 36.9170983537d0, 40.0584257646d0, 43.1997917132d0, &
+      46.3411883717d0, 49.4826098974d0, 52.6240518411d0, 55.7655107550d0, &
+      58.9069839261d0, 62.0484691902d0, 65.1899648002d0, 68.3314693299d0, &
+      71.4729816036d0, 74.6145006437d0, 77.7560256304d0, 80.8975558711d0, &
+      84.0390907769d0, 87.1806298436d0, 90.3221726372d0, 93.4637187819d0, &
+      96.6052679510d0, 99.7468198587d0, 102.888374254d0, 106.029930916d0, &
+      109.171489649d0, 112.313050280d0, 115.454612653d0, 118.596176630d0, &
+      121.737742088d0, 124.879308913d0, 128.020877005d0, 131.162446275d0, &
+      134.304016638d0, 137.445588020d0, 140.587160352d0, 143.728733573d0, &
+      146.870307625d0, 150.011882457d0, 153.153458019d0, 156.295034268d0 /
+      REAL(8):: DLT,D1=1.d0
+      INTEGER(4):: JHE,JHO,J0=0
+      real(8),PARAMETER :: PI=3.14159265358979d0,C=(1.d0-(2.d0/PI)**2)*0.25d0
+      real(8) r
+      integer jh,js,n,j
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  GAUSSIAN LATITUDES
+      IF(IDRT.EQ.4) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        R=1.d0/SQRT((JMAX+0.5d0)**2+C)
+        DO J=1,MIN(JH,JZ)
+          ASLATD(J)=COS(BZ(J)*R)
+        ENDDO
+        DO J=JZ+1,JH
+          ASLATD(J)=COS((BZ(JZ)+(J-JZ)*PI)*R)
+        ENDDO
+        SPMAX=1.d0
+        DO WHILE(SPMAX.GT.EPS)
+          SPMAX=0.d0
+          DO J=1,JH
+            PKM1(J)=1.d0
+            PK(J)=ASLATD(J)
+          ENDDO
+          DO N=2,JMAX
+            DO J=1,JH
+              PKM2(J)=PKM1(J)
+              PKM1(J)=PK(J)
+              PK(J)=((2*N-1)*ASLATD(J)*PKM1(J)-(N-1)*PKM2(J))/N
+            ENDDO
+          ENDDO
+          DO J=1,JH
+            SP=PK(J)*(1.d0-ASLATD(J)**2)/(JMAX*(PKM1(J)-ASLATD(J)*PK(J)))
+            ASLATD(J)=ASLATD(J)-SP
+            SPMAX=MAX(SPMAX,ABS(SP))
+          ENDDO
+        ENDDO
+!CDIR$ IVDEP
+        DO J=1,JH
+          ASLAT(J)=ASLATD(J)
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  EQUALLY-SPACED LATITUDES INCLUDING POLES
+      ELSEIF(IDRT.EQ.0) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        JHO=JHE-1
+        DLT=PI/(JMAX-1)
+        ASLAT(1)=1.d0
+        DO J=2,JH
+          ASLAT(J)=COS((J-1)*DLT)
+        ENDDO
+!CDIR$ IVDEP
+        DO J=1,JH
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  EQUALLY-SPACED LATITUDES EXCLUDING POLES
+      ELSEIF(IDRT.EQ.256) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        JHO=JHE
+        DLT=PI/JMAX
+        ASLAT(1)=1.d0
+        DO J=1,JH
+          ASLAT(J)=COS((J-0.5)*DLT)
+        ENDDO
+!CDIR$ IVDEP
+        DO J=1,JH
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+      ENDIF
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+     end subroutine splat4
+!
+!----------------------------------------------------------------------
+     SUBROUTINE splat8(IDRT,JMAX,ASLAT)
+!$$$
+      implicit none
+      integer,intent(in) :: idrt,jmax
+      real(8),intent(out) :: ASLAT(JMAX)
+      INTEGER,PARAMETER:: KD=SELECTED_REAL_KIND(15,45)
+      REAL(KIND=KD):: PK(JMAX/2),PKM1(JMAX/2),PKM2(JMAX/2)
+      REAL(KIND=KD):: ASLATD(JMAX/2),SP,SPMAX,EPS=10.d0*EPSILON(SP)
+      integer,PARAMETER:: JZ=50
+      REAL(8) BZ(JZ)
+      DATA BZ        / 2.4048255577d0,  5.5200781103d0, &
+       8.6537279129d0, 11.7915344391d0, 14.9309177086d0, 18.0710639679d0, &
+      21.2116366299d0, 24.3524715308d0, 27.4934791320d0, 30.6346064684d0, &
+      33.7758202136d0, 36.9170983537d0, 40.0584257646d0, 43.1997917132d0, &
+      46.3411883717d0, 49.4826098974d0, 52.6240518411d0, 55.7655107550d0, &
+      58.9069839261d0, 62.0484691902d0, 65.1899648002d0, 68.3314693299d0, &
+      71.4729816036d0, 74.6145006437d0, 77.7560256304d0, 80.8975558711d0, &
+      84.0390907769d0, 87.1806298436d0, 90.3221726372d0, 93.4637187819d0, &
+      96.6052679510d0, 99.7468198587d0, 102.888374254d0, 106.029930916d0, &
+      109.171489649d0, 112.313050280d0, 115.454612653d0, 118.596176630d0, &
+      121.737742088d0, 124.879308913d0, 128.020877005d0, 131.162446275d0, &
+      134.304016638d0, 137.445588020d0, 140.587160352d0, 143.728733573d0, &
+      146.870307625d0, 150.011882457d0, 153.153458019d0, 156.295034268d0 /
+      REAL(8):: DLT,D1=1.d0
+      INTEGER(4):: JHE,JHO,J0=0
+      real(8),PARAMETER :: PI=3.14159265358979d0,C=(1.d0-(2.d0/PI)**2)*0.25d0
+      real(8) r
+      integer jh,js,n,j
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  GAUSSIAN LATITUDES
+      IF(IDRT.EQ.4) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        R=1.d0/SQRT((JMAX+0.5d0)**2+C)
+        DO J=1,MIN(JH,JZ)
+          ASLATD(J)=COS(BZ(J)*R)
+        ENDDO
+        DO J=JZ+1,JH
+          ASLATD(J)=COS((BZ(JZ)+(J-JZ)*PI)*R)
+        ENDDO
+        SPMAX=1.d0
+        DO WHILE(SPMAX.GT.EPS)
+          SPMAX=0.d0
+          DO J=1,JH
+            PKM1(J)=1.d0
+            PK(J)=ASLATD(J)
+          ENDDO
+          DO N=2,JMAX
+            DO J=1,JH
+              PKM2(J)=PKM1(J)
+              PKM1(J)=PK(J)
+              PK(J)=((2*N-1)*ASLATD(J)*PKM1(J)-(N-1)*PKM2(J))/N
+            ENDDO
+          ENDDO
+          DO J=1,JH
+            SP=PK(J)*(1.d0-ASLATD(J)**2)/(JMAX*(PKM1(J)-ASLATD(J)*PK(J)))
+            ASLATD(J)=ASLATD(J)-SP
+            SPMAX=MAX(SPMAX,ABS(SP))
+          ENDDO
+        ENDDO
+!CDIR$ IVDEP
+        DO J=1,JH
+          ASLAT(J)=ASLATD(J)
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  EQUALLY-SPACED LATITUDES INCLUDING POLES
+      ELSEIF(IDRT.EQ.0) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        JHO=JHE-1
+        DLT=PI/(JMAX-1)
+        ASLAT(1)=1.d0
+        DO J=2,JH
+          ASLAT(J)=COS((J-1)*DLT)
+        ENDDO
+!CDIR$ IVDEP
+        DO J=1,JH
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+!C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+!C  EQUALLY-SPACED LATITUDES EXCLUDING POLES
+      ELSEIF(IDRT.EQ.256) THEN
+        JH=JMAX/2
+        JHE=(JMAX+1)/2
+        JHO=JHE
+        DLT=PI/JMAX
+        ASLAT(1)=1.d0
+        DO J=1,JH
+          ASLAT(J)=COS((J-0.5d0)*DLT)
+        ENDDO
+!DIR$ IVDEP
+        DO J=1,JH
+          ASLAT(JMAX+1-J)=-ASLAT(J)
+        ENDDO
+        IF(JHE.GT.JH) THEN
+          ASLAT(JHE)=0.d0
+        ENDIF
+      ENDIF
+! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+     end subroutine splat8
+!-----------------------------------------------------------------------
+
+   character(35) function sweep_blanks(in_str)
+
+!
+   implicit none
+!
+   character(*), intent(in) :: in_str
+   character(35) :: out_str
+   character :: ch
+   integer :: j
+
+   out_str = " "
+   do j=1, len_trim(in_str)
+     ! get j-th char
+     ch = in_str(j:j)
+     if (ch .eq. "-") then
+       out_str = trim(out_str) // "_"
+     else if (ch .ne. " ") then
+       out_str = trim(out_str) // ch
+     endif
+     sweep_blanks = out_str
+   end do
+ end function sweep_blanks
+
diff --git a/sorc/nemsio_chgdate.fd/CMakeLists.txt b/sorc/nemsio_chgdate.fd/CMakeLists.txt
new file mode 100644
index 0000000..bb04b6c
--- /dev/null
+++ b/sorc/nemsio_chgdate.fd/CMakeLists.txt
@@ -0,0 +1,17 @@
+set(fortran_src
+    nemsio_chgdate.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -convert big_endian")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fconvert=big-endian")
+endif()
+
+set(exe_name nemsio_chgdate)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  nemsio
+  bacio_4)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/nemsio_chgdate.fd/nemsio_chgdate.f90 b/sorc/nemsio_chgdate.fd/nemsio_chgdate.f90
new file mode 100644
index 0000000..a75ad36
--- /dev/null
+++ b/sorc/nemsio_chgdate.fd/nemsio_chgdate.f90
@@ -0,0 +1,103 @@
+program nemsio_chgdate
+!$$$  main program documentation block
+!
+! program:  nemsio_chgdate
+!
+! prgmmr: mahajan          org: ncep/emc               date: 2018-02-14
+!
+! abstract:  Replace the date and forecast hour from NCEP/EMC nemsio file
+!            with a date and hour provided from input
+!
+! program history log:
+!   2018-02-14  Initial version.
+!
+! usage:
+!   nemsio_chgdate.x filename.nemsio new_idate_YYYYMMDDHH new_nfhour_HH
+!
+! attributes:
+!   language: f95
+!
+!$$$
+
+use nemsio_module, only:  nemsio_init, nemsio_open, nemsio_close
+use nemsio_module, only:  nemsio_intkind
+use nemsio_module, only:  nemsio_gfile, nemsio_getfilehead, &
+                          nemsio_setheadvar
+
+implicit none
+
+character(len=50) :: filename
+character(len=10) :: idatestr, nfhourstr
+integer(nemsio_intkind) :: iret
+integer(nemsio_intkind) :: idate(7), nfhour
+
+type(nemsio_gfile) :: gfile
+
+! replace idate and nfhour in this file
+call getarg(1, filename)
+
+! read idate to replace
+call getarg(2, idatestr)
+
+! read nfhour to replace
+call getarg(3, nfhourstr)
+
+write(6,'(A)')'NEMSIO_CHGDATE:'
+write(6,'(2(A))')'   filename = ',trim(filename)
+write(6,'(2(A))')'  new idate = ',trim(idatestr)
+write(6,'(2(A))')' new nfhour = ',trim(nfhourstr)
+
+call nemsio_init(iret=iret)
+call nemsio_error(iret, 'open to initialize nemsio')
+
+call nemsio_open(gfile, trim(filename), 'RDWR', iret=iret)
+call nemsio_error(iret, 'open to READ and WRITE' // trim(filename))
+
+call nemsio_getfilehead(gfile, idate=idate, nfhour=nfhour, iret=iret)
+call nemsio_error(iret, 'getfilehead (idate) from ' // trim(filename))
+
+write(6,'(A,7(1X,I6))') 'OLD idate  = ', idate
+write(6,'(A,I4)') 'OLD nfhour = ', nfhour
+
+! Replace old date with new dates
+read(idatestr(1:4), '(I4)') idate(1)
+read(idatestr(5:6), '(I2)') idate(2)
+read(idatestr(7:8), '(I2)') idate(3)
+read(idatestr(9:10), '(I2)')idate(4)
+read(nfhourstr, '(I10)') nfhour
+
+write(6,'(A,7(1X,I6))') 'NEW idate  = ', idate
+write(6,'(A,I4)') 'NEW nfhour = ', nfhour
+
+call nemsio_setheadvar(gfile, 'idate', idate, iret=iret)
+call nemsio_error(iret, 'setfilehead (idate) in ' // trim(filename))
+call nemsio_setheadvar(gfile, 'nfhour', nfhour, iret=iret)
+call nemsio_error(iret, 'setfilehead (nfhour) in ' // trim(filename))
+
+call nemsio_close(gfile, iret=iret)
+call nemsio_error(iret, 'close file ' // trim(filename))
+
+stop
+
+contains
+
+subroutine nemsio_error(iret, msg)
+
+implicit none
+
+integer(nemsio_intkind), intent(in) :: iret
+character(len=*), intent(in) :: msg
+
+character(len=500) :: msgout
+
+if ( iret /= 0 ) then
+
+    msgout = '***ERROR*** Unable to ' // trim(msg) // ' ABORT!'
+    write(6,*) trim(msgout)
+    stop 99
+
+endif
+
+end subroutine nemsio_error
+
+END program nemsio_chgdate
diff --git a/sorc/nemsio_get.fd/CMakeLists.txt b/sorc/nemsio_get.fd/CMakeLists.txt
new file mode 100644
index 0000000..435602e
--- /dev/null
+++ b/sorc/nemsio_get.fd/CMakeLists.txt
@@ -0,0 +1,18 @@
+set(fortran_src
+    nemsio_get.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -convert big_endian")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fconvert=big-endian")
+endif()
+
+set(exe_name nemsio_get)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  nemsio
+  bacio_4
+  w3nco_d)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/nemsio_get.fd/nemsio_get.f90 b/sorc/nemsio_get.fd/nemsio_get.f90
new file mode 100644
index 0000000..cc265e0
--- /dev/null
+++ b/sorc/nemsio_get.fd/nemsio_get.f90
@@ -0,0 +1,408 @@
+!- - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+! the program provide value for a variable/field in a nemsio file
+! revision history:
+!  Jan 2010:  Jun Wang  Initial code
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+!
+  program main
+!
+  use nemsio_module
+  implicit none
+!
+  type(nemsio_gfile) :: gfile
+!
+  character(255) cin,filenm
+  character(16) varname
+  character(16) varlevtyp
+  character(3) cvarlev
+  integer varlev
+  real,allocatable  :: data(:)
+!---------------------------------------------------------------------------
+!--- nemsio meta data
+  integer nrec,im,jm,nframe,nmetaaryi,nmetaaryr,nmetaaryl,nmetaaryc,        &
+          nmetaaryr8,i,j,fieldsize,iret,idate(7),levs,ntrac, tlmeta
+  integer  ivar
+  real(4)  rvar
+  real(8)  r8var
+  logical  lvar
+  character(10)  odate
+  character(16)  cvar, file_endian
+  character(35) mystr,sweep_blanks
+  character(4) gdatatype
+  character(16),allocatable:: recname(:)
+  character(16),allocatable  :: reclevtyp(:)
+  integer,allocatable:: reclev(:)
+  real(4),allocatable ::vcoord(:,:,:),lat(:),lon(:),cpi(:),ri(:),dx(:),dy(:)
+!---------------------------------------------------------------------------
+!
+  character(16),allocatable :: aryiname(:),aryrname(:),arylname(:),arycname(:),&
+      aryr8name(:)
+  integer,allocatable :: aryilen(:),aryrlen(:),aryllen(:),aryclen(:),aryr8len(:)
+  integer,allocatable :: iary(:)
+  real(4),allocatable :: rary(:)
+  real(8),allocatable :: r8ary(:)
+  logical,allocatable :: lary(:)
+  character(16),allocatable :: cary(:)
+!
+!-------------set up nemsio write--------------------------
+  call nemsio_init(iret=iret)
+!
+!---------------------------------------------------------------------------
+!******Example 2:  read full history file
+!---------------------------------------------------------------------------
+!--- open gfile for reading
+  call getarg(1,cin)
+  call nemsio_open(gfile,trim(cin),'READ',iret=iret)
+  if (iret .ne.0 ) then
+    print *,'ERROR: can not open file ',trim(cin)
+    stop
+  endif
+!
+  call nemsio_getfilehead(gfile,iret=iret,gdatatype=gdatatype,dimx=im,dimy=jm, &
+    nframe=nframe,dimz=levs,nrec=nrec,ntrac=ntrac,tlmeta=tlmeta,               &
+    file_endian=file_endian,nmetaaryi=nmetaaryi,nmetaaryr=nmetaaryr,           &
+    nmetaaryl=nmetaaryl,nmetaaryc=nmetaaryc)
+!
+   fieldsize=(im+2*nframe)*(jm+2*nframe)
+!
+   call getarg(2,varname)
+   call getarg(3,varlevtyp)
+   call getarg(4,cvarlev)
+   read(cvarlev,'(I3)')varlev
+!
+!*** 1: test for var:
+    call nemsio_getheadvar(gfile,trim(varname),ivar,iret=iret)
+    if(iret/=0) then
+      call nemsio_getheadvar(gfile,trim(varname),rvar,iret=iret)
+      if(iret/=0) then
+        call nemsio_getheadvar(gfile,trim(varname),lvar,iret=iret)
+        if(iret/=0) then
+          call nemsio_getheadvar(gfile,trim(varname),cvar,iret=iret)
+          if(iret/=0) then
+            call nemsio_getheadvar(gfile,trim(varname),r8var,iret=iret)
+            if(iret==0) then
+              print *,trim(varname),'=',r8var
+              stop
+            endif
+          else
+            print *,trim(varname),'=',trim(cvar)
+            stop
+          endif
+        else
+           print *,trim(varname),'=',lvar
+            stop
+        endif
+      else
+        print *,trim(varname),'=',rvar
+        stop
+      endif
+    else
+      print *,trim(varname),'=',ivar
+      stop
+    endif
+
+!*** 5: test for array:
+! *** integer  
+!idate
+   if( trim(varname)=='idate') then
+     call nemsio_getfilehead(gfile,idate=idate,iret=iret)
+     if(iret==0) then
+       print *,'idate=',idate
+       write(odate,'(I4.4,I2.2,I2.2,I2.2)')idate(1),idate(2),idate(3),idate(4)
+       print *,'idate_ymdh=',odate
+       stop
+     endif
+   endif
+!vcoord
+   if(equal_str_nocase(trim(varname),'vcoord')) then
+     allocate(vcoord(levs+1,3,2))
+     call nemsio_getfilehead(gfile,vcoord=vcoord,iret=iret)
+     if(iret==0) then
+       print *,'levs=',levs,'vcoord(1:levs+1,1,1)=',vcoord(:,1,1)
+       print *,'levs=',levs,'vcoord(1:levs+1,2,1)=',vcoord(:,2,1)
+       print *,'levs=',levs,'vcoord(1:levs+1,3,1)=',vcoord(:,3,1)
+       print *,'levs=',levs,'vcoord(1:levs+1,1,2)=',vcoord(:,1,2)
+       print *,'levs=',levs,'vcoord(1:levs+1,2,2)=',vcoord(:,2,2)
+       print *,'levs=',levs,'vcoord(1:levs+1,3,2)=',vcoord(:,3,2)
+       deallocate(vcoord)
+       stop
+     endif
+     deallocate(vcoord)
+    endif
+!
+!recname
+   if(equal_str_nocase(trim(varname),'recname')) then
+     allocate(recname(nrec))
+     call nemsio_getfilehead(gfile,recname=recname,iret=iret)
+     if(iret==0) then
+       print *,'nrec=',nrec,'recname(1:nrec)=',recname
+       deallocate(recname)
+       stop
+     endif
+     deallocate(recname)
+    endif
+!
+!reclevtyp
+   if(equal_str_nocase(trim(varname),'reclevtyp')) then
+     allocate(reclevtyp(nrec))
+     call nemsio_getfilehead(gfile,reclevtyp=reclevtyp,iret=iret)
+     if(iret==0) then
+       print *,'nrec=',nrec,'reclevtyp(1:nrec)=',reclevtyp
+       deallocate(reclevtyp)
+       stop
+     endif
+     deallocate(reclevtyp)
+    endif
+!
+!reclev
+   if(equal_str_nocase(trim(varname),'reclev')) then
+     allocate(reclev(nrec))
+     call nemsio_getfilehead(gfile,reclev=reclev,iret=iret)
+     if(iret==0) then
+       print *,'nrec=',nrec,'reclev(1:nrec)=',reclev
+       deallocate(reclev)
+       stop
+     endif
+     deallocate(reclev)
+    endif
+!
+!lat
+   if(equal_str_nocase(trim(varname),'lat')) then
+     allocate(lat((im+2*nframe)*(jm+2*nframe)))
+     call nemsio_getfilehead(gfile,lat=lat,iret=iret)
+     if(iret==0) then
+       print *,'domainsize=',(im+2*nframe)*(jm+2*nframe),'lat(1:domainsize)=',lat
+       deallocate(lat)
+       stop
+     endif
+     deallocate(lat)
+    endif
+!
+!lon
+   if(equal_str_nocase(trim(varname),'lon')) then
+     allocate(lon((im+2*nframe)*(jm+2*nframe)))
+     call nemsio_getfilehead(gfile,lon=lon,iret=iret)
+     if(iret==0) then
+       print *,'domainsize=',(im+2*nframe)*(jm+2*nframe),'lon(1:domainsize)=',lon
+       deallocate(lon)
+       stop
+     endif
+     deallocate(lon)
+    endif
+!
+!dx
+   if(equal_str_nocase(trim(varname),'dx')) then
+     allocate(dx((im+2*nframe)*(jm+2*nframe)))
+     call nemsio_getfilehead(gfile,dx=dx,iret=iret)
+     if(iret==0) then
+       print *,'domainsize=',(im+2*nframe)*(jm+2*nframe),'dx(1:domainsize)=',dx
+       deallocate(dx)
+       stop
+     endif
+     deallocate(dx)
+    endif
+!
+!dy
+   if(equal_str_nocase(trim(varname),'dy')) then
+     allocate(dy((im+2*nframe)*(jm+2*nframe)))
+     call nemsio_getfilehead(gfile,dy=dy,iret=iret)
+     if(iret==0) then
+       print *,'domainsize=',(im+2*nframe)*(jm+2*nframe),'dy(1:domainsize)=',dy
+       deallocate(dy)
+       stop
+     endif
+     deallocate(dy)
+    endif
+!
+!cpi
+   if(equal_str_nocase(trim(varname),'cpi')) then
+     allocate(cpi(ntrac+1))
+     call nemsio_getfilehead(gfile,cpi=cpi,iret=iret)
+     if(iret==0) then
+       print *,'ntrac+1=',ntrac+1,'cpi(1:ntrac+1)=',cpi
+       deallocate(cpi)
+       stop
+     endif
+     deallocate(cpi)
+    endif
+!
+!ri
+   if(equal_str_nocase(trim(varname),'ri')) then
+     allocate(ri(ntrac+1))
+     call nemsio_getfilehead(gfile,ri=ri,iret=iret)
+     if(iret==0) then
+       print *,'ntrac+1=',ntrac+1,'ri(1:ntrac+1)=',ri
+       deallocate(ri)
+       stop
+     endif
+     deallocate(ri)
+    endif
+!
+!tlmeta
+    if(equal_str_nocase(trim(varname),'tlmeta')) then
+       print *,'tlmeta=',tlmeta
+       stop
+    endif
+!
+!file_endian
+    if(equal_str_nocase(trim(varname),'file_endian')) then
+       print *,'file_endian=',file_endian
+       stop
+    endif
+
+!int array
+   if(nmetaaryi>0) then
+     allocate(aryiname(nmetaaryi),aryilen(nmetaaryi))
+     call nemsio_getfilehead(gfile,iret=iret,aryiname=aryiname,aryilen=aryilen)
+     Do i=1,nmetaaryi
+!       if(trim(varname)==aryiname(i)) then
+       if(equal_str_nocase(trim(varname),trim(aryiname(i)))) then
+         j=i
+         call nemsio_getfilehead(gfile, aryilen=aryilen)
+         allocate(iary(aryilen(j)))
+         call nemsio_getheadvar(gfile,trim(varname),iary,iret=iret)
+         if(iret==0) then
+           print *,trim(varname),'(1:',aryilen(j),')=',iary
+           if(equal_str_nocase(trim(varname),"fcstdate")) then
+             write(odate,'(I4.4,I2.2,I2.2,I2.2)')iary(1),iary(2),iary(3),iary(4)
+             print *,'fcstdate_ymdh=',odate
+           endif
+           call nemsio_close(gfile)
+           call nemsio_finalize()
+           stop
+         endif
+       endif
+     enddo
+   endif
+!
+! *** real4
+   if(nmetaaryr>0) then
+     allocate(aryrname(nmetaaryr),aryrlen(nmetaaryr))
+     call nemsio_getfilehead(gfile,iret=iret,aryrname=aryrname,aryrlen=aryrlen)
+     Do i=1,nmetaaryr
+       if(equal_str_nocase(trim(varname),trim(aryrname(i)))) then
+         j=i
+         call nemsio_getfilehead(gfile, aryrlen=aryrlen)
+         allocate(rary(aryrlen(j)))
+         call nemsio_getheadvar(gfile,trim(varname),rary,iret=iret)
+         if(iret==0) then
+           print *,trim(varname),'(1:',aryrlen(j),')=',rary
+           call nemsio_close(gfile)
+           call nemsio_finalize()
+           stop
+         endif
+       endif
+     enddo
+   endif
+!
+! *** real8
+   if(nmetaaryr8>0) then
+     allocate(aryr8name(nmetaaryr8),aryr8len(nmetaaryr8))
+     call nemsio_getfilehead(gfile,iret=iret,aryr8name=aryr8name,aryr8len=aryr8len)
+     Do i=1,nmetaaryr8
+       if(equal_str_nocase(trim(varname),trim(aryr8name(i)))) then
+         j=i
+         call nemsio_getfilehead(gfile, aryr8len=aryr8len)
+         allocate(rary(aryr8len(j)))
+         call nemsio_getheadvar(gfile,trim(varname),rary,iret=iret)
+         if(iret==0) then
+           print *,trim(varname),'(1:',aryr8len(j),')=',rary
+           call nemsio_close(gfile)
+           call nemsio_finalize()
+           stop
+         endif
+       endif
+     enddo
+   endif
+!
+   if(nmetaaryl>0) then
+     allocate(arylname(nmetaaryl),aryllen(nmetaaryl))
+     call nemsio_getfilehead(gfile,iret=iret,arylname=arylname,aryllen=aryllen)
+     Do i=1,nmetaaryl
+       if(equal_str_nocase(trim(varname),trim(arylname(i)))) then
+         j=i
+         allocate(lary(aryllen(j)))
+         call nemsio_getheadvar(gfile,trim(varname),lary,iret=iret)
+         if(iret==0) then
+           print *,trim(varname),'(1:',aryllen(j),')=',lary
+           call nemsio_close(gfile)
+           call nemsio_finalize()
+           stop
+         endif
+       endif
+     enddo
+   endif
+!
+   if(nmetaaryc>0) then
+     allocate(arycname(nmetaaryc),aryclen(nmetaaryc))
+     call nemsio_getfilehead(gfile,iret=iret,arycname=arycname,aryclen=aryclen)
+     Do i=1,nmetaaryc
+       if(equal_str_nocase(trim(varname),trim(arycname(i)))) then
+         j=i
+         allocate(cary(aryclen(j)))
+         call nemsio_getheadvar(gfile,trim(varname),cary,iret=iret)
+         if(iret==0) then
+           print *,trim(varname),'(1:',aryclen(j),')=',cary
+           call nemsio_close(gfile)
+           call nemsio_finalize()
+           stop
+         endif
+       endif
+     enddo
+   endif
+!
+!   
+!*** 6: test for 2D array:
+   allocate(data(fieldsize))
+   call nemsio_readrecv(gfile,varname,varlevtyp,varlev,data=data,iret=iret)
+   if(iret==0)  then
+      print *,'fieldsize=',(im+2*nframe)*(jm+2*nframe),'i=',im+2*nframe
+      do j=1,jm+2*nframe
+        print *,'j=',j,trim(varname),'=',data(1+(j-1)*(im+2*nframe):j*(im+2*nframe))
+      enddo
+!-- output pure binary file for 1 2D array
+      mystr=trim(varname)//trim(varlevtyp)//trim(cvarlev)
+      filenm=sweep_blanks(mystr)
+      open(991,file=trim(filenm),form='unformatted')
+      write(991) ((data(i+(j-1)*(im+2*nframe)),i=1,im+2*nframe),j=1,jm+2*nframe)
+      close(991)
+!
+      deallocate(data)
+      call nemsio_close(gfile)
+      call nemsio_finalize()
+      stop
+   endif
+!
+   call nemsio_close(gfile)
+   call nemsio_finalize()
+!
+   print *,'no ',trim(varname), ' in the nemsio file!'
+!   
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+  stop
+
+!-----------------------------------------------------------------------
+!
+ end program
+
+!-----------------------------------------------------------------------
+!
+ character(35) function sweep_blanks(in_str)
+!
+   implicit none
+!
+   character(*), intent(in) :: in_str
+   character(35) :: out_str
+   character :: ch
+   integer :: j
+
+   out_str = " "
+   do j=1, len_trim(in_str)
+     ! get j-th char
+     ch = in_str(j:j)
+     if (ch .ne. " ") then
+       out_str = trim(out_str) // ch
+     endif
+     sweep_blanks = out_str 
+   end do
+ end function sweep_blanks
diff --git a/sorc/nemsio_read.fd/CMakeLists.txt b/sorc/nemsio_read.fd/CMakeLists.txt
new file mode 100644
index 0000000..9e19204
--- /dev/null
+++ b/sorc/nemsio_read.fd/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(fortran_src
+    nemsio_read.f90)
+
+set(exe_name nemsio_read)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  nemsio
+  bacio_4
+  w3nco_d)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/nemsio_read.fd/nemsio_read.f90 b/sorc/nemsio_read.fd/nemsio_read.f90
new file mode 100644
index 0000000..af51e7b
--- /dev/null
+++ b/sorc/nemsio_read.fd/nemsio_read.f90
@@ -0,0 +1,197 @@
+!- - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- - --
+! the program reads and list the contents in a nemsio file
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- -
+!  Revision history
+!   Sep 2008:  Jun Wang Initial code
+! --
+  program main
+!
+  use nemsio_module
+  implicit none
+!
+  integer, parameter:: double=selected_real_kind(p=13,r=200)
+  type(nemsio_gfile) :: gfile,gfilem2,gfilem3,gfiled2
+!
+  real (kind=8) timef
+  character(255) cin
+  character(8) gdatatype,modelname
+  character(2) level
+  real,allocatable  :: tmp(:)
+!---------------------------------------------------------------------------
+!--- nemsio meta data
+  real  isecond,stime,etime,dummy
+  integer nrec,im,jm,lm,l,idate(7),version, im2,jm2, nframe, &
+          ntrac,irealf,nrec1,version1,nmeta1,nfhour,nfminute,nfsecond, &
+          nfsecondn,nfsecondd,nmeta,tlmeta
+  integer nsoil,jcap,ncld,idsl,idvc,idvm,idrt,rlon_min,rlon_max, &
+          rlat_min,rlat_max
+  integer nmetavari,nmetavarr,nmetavarl,nmetavarc,nmetavarr8,    &
+          nmetaaryi,nmetaaryr,nmetaaryl,nmetaaryc,nmetaaryr8
+  integer ihrst,idat(3),mp_physics,sf_surface_physics,icycle,fieldsize
+  logical global, run,extrameta
+  character(16),allocatable :: recname(:),reclevtyp(:)
+  integer,allocatable       :: reclev(:)
+  real,allocatable          :: cpi(:),ri(:)
+!---------------------------------------------------------------------------
+!--- local vars
+  character(16) vname
+  character(32) gtype
+  character(16) vlevtyp
+  integer i,ii,j,jj,jrec,krec,vlev,iret,lev,ista,iend,jsta,jend
+!---------------------------------------------------------------------------
+!
+  character(16),allocatable :: variname(:),varrname(:),varlname(:),varcname(:),varr8name(:), &
+                               aryiname(:),aryrname(:),arylname(:),arycname(:),aryr8name(:)
+  integer,allocatable :: varival(:),aryilen(:),aryrlen(:),aryllen(:),aryclen(:),aryr8len(:)
+  integer,allocatable :: aryival(:,:)
+  real,allocatable :: varrval(:),aryrval(:,:)
+  real(8),allocatable :: varr8val(:),aryr8val(:,:)
+  logical,allocatable :: varlval(:),arylval(:,:)
+  character(16),allocatable :: varcval(:),arycval(:,:)
+!
+!---------------------------------------------------------------------------
+!
+!-------------set up nemsio write--------------------------
+  call nemsio_init(iret=iret)
+  print *,'nemsio_init, iret=',iret
+!
+!+++++++++++++++++ read nemsil file with 2 meta data
+!+++++++++++++++++++++++++++
+!
+!--- open gfile for reading
+  print *,'3b:: start reading nemsio file '
+!  cin='nemsio_2meta_big'
+  call getarg(1,cin)
+  call nemsio_open(gfile,trim(cin),'read',iret=iret)
+  if(iret/=0) print *,'3b:: after open read, ',trim(cin), ' iret=',iret
+!
+!--- get dimension
+  im=0;jm=0;lm=0;nframe=0;nrec=0
+  call nemsio_getfilehead(gfile,dimx=im,dimy=jm,dimz=lm,nframe=nframe,nrec=nrec,&
+       gdatatype=gdatatype,modelname=modelname,nmeta=nmeta,ntrac=ntrac,tlmeta=tlmeta,iret=iret)
+  print *,'3b:: gfilem2,im=',im,'jm=',jm,'lm=',lm,'nframe=',nframe,'nrec=',nrec, &
+       'gdatatype=',gdatatype,' modelname=',modelname,' nmeta=',nmeta,'ntrac=',ntrac, &
+       'tlmeta=',tlmeta,'iret=',iret
+!--- meta data info
+  call nemsio_getfilehead(gfile,nfhour=nfhour,nfminute=nfminute,nsoil=nsoil,ncldt=ncld,&
+       idsl=idsl,idvc=idvc,idvm=idvm,idrt=idrt,iret=iret)
+  print *,'3b:: gfilem2,nfhour=',nfhour,'jcap=',jcap,'ncld=',ncld,'idvc=',idvc,'idrt=',idrt
+!
+! call nemsio_getheadvar(gfile,'nfhour',nfhour,iret=iret)
+! print *,'nfhour=',nfhour
+! call nemsio_getheadvar(gfile,'latf', latf,iret=iret)
+! print *,'latf=',latf
+!
+  call nemsio_getfilehead(gfile,nmetavari=nmetavari,nmetavarr=nmetavarr,nmetavarl=nmetavarl, &
+       nmetavarc=nmetavarc,nmetavarr8=nmetavarr8,nmetaaryi=nmetaaryi,nmetaaryr=nmetaaryr,    &
+       nmetaaryr8=nmetaaryr8,nmetaaryl=nmetaaryl, nmetaaryc=nmetaaryc)
+  print *,'nmetavari=',nmetavari,'nmetavarr=',nmetavarr,'nmetavarl=',nmetavarl,            &
+          'nmetavarc=',nmetavarc,'nmetavarr8=',nmetavarr8
+  print *,'nmetaaryi=',nmetaaryi,'nmetaaryr=',nmetaaryr,'nmetaaryl=',nmetaaryl,            &
+          'nmetaaryc=',nmetaaryc,'nmetaaryr8=',nmetaaryr8
+  if(nmetavari>0) then
+    allocate(variname(nmetavari),varival(nmetavari))
+    call nemsio_getfilehead(gfile,variname=variname,varival=varival)
+    print *,'variname=',variname,'varival=',varival
+  endif
+  if(nmetavarr>0) then
+    allocate(varrname(nmetavarr),varrval(nmetavarr))
+    call nemsio_getfilehead(gfile,varrname=varrname,varrval=varrval)
+    print *,'varrname=',varrname,'varrval=',varrval
+  endif
+  if(nmetavarr8>0) then
+    allocate(varr8name(nmetavarr8),varr8val(nmetavarr8))
+    call nemsio_getfilehead(gfile,varr8name=varr8name,varr8val=varr8val)
+    print *,'varr8name=',varr8name,'varr8val=',varr8val
+  endif
+  if(nmetavarl>0) then
+    allocate(varlname(nmetavarl),varlval(nmetavarl))
+    call nemsio_getfilehead(gfile,varlname=varlname,varlval=varlval)
+    print *,'varlname=',varlname,'varlval=',varlval
+  endif
+  if(nmetavarc>0) then
+    allocate(varcname(nmetavarc),varcval(nmetavarc))
+    call nemsio_getfilehead(gfile,varcname=varcname,varcval=varcval)
+    print *,'varcname=',varcname,'varcval=',varcval
+  endif
+
+  if(nmetaaryi>0) then
+    allocate(aryiname(nmetaaryi),aryilen(nmetaaryi))
+    call nemsio_getfilehead(gfile,aryiname=aryiname,aryilen=aryilen)
+    print *,'aryiname=',aryiname,'aryilen=',aryilen
+    allocate(aryival(maxval(aryilen),nmetaaryi))
+    call nemsio_getfilehead(gfile,aryival=aryival)
+    do i=1,nmetaaryi
+      print *,'aryiname=',aryiname(i),aryilen(i),aryival(1:aryilen(i),i)
+    enddo
+  endif
+  if(nmetaaryr>0) then
+    allocate(aryrname(nmetaaryr),aryrlen(nmetaaryr))
+    call nemsio_getfilehead(gfile,aryrname=aryrname,aryrlen=aryrlen)
+    print *,'aryrname=',aryrname,'aryrlen=',aryrlen
+    allocate(aryrval(maxval(aryrlen),nmetaaryr))
+    call nemsio_getfilehead(gfile,aryrval=aryrval)
+    do i=1,nmetaaryr
+      print *,'aryrname=',aryrname(i),aryrlen(i),aryrval(1:aryrlen(i),i)
+    enddo
+  endif
+  if(nmetaaryr8>0) then
+    allocate(aryr8name(nmetaaryr8),aryr8len(nmetaaryr8))
+    call nemsio_getfilehead(gfile,aryr8name=aryr8name,aryr8len=aryr8len)
+    print *,'aryr8name=',aryr8name,'aryr8len=',aryr8len
+    allocate(aryr8val(maxval(aryr8len),nmetaaryr8))
+    call nemsio_getfilehead(gfile,aryr8val=aryr8val)
+    do i=1,nmetaaryr8
+      print *,'aryr8name=',aryr8name(i),aryr8len(i),aryr8val(1:aryr8len(i),i)
+    enddo
+  endif
+  if(nmetaaryl>0) then
+    allocate(arylname(nmetaaryl),aryllen(nmetaaryl))
+    call nemsio_getfilehead(gfile,arylname=arylname,aryllen=aryllen)
+    print *,'arylname=',arylname,'aryllen=',aryllen
+    allocate(arylval(maxval(aryllen),nmetaaryl))
+    call nemsio_getfilehead(gfile,arylval=arylval)
+    do i=1,nmetaaryl
+      print *,'arylname=',arylname(i),aryllen(i),arylval(1:aryllen(i),i)
+    enddo
+  endif
+  if(nmetaaryc>0) then
+    allocate(arycname(nmetaaryc),aryclen(nmetaaryc))
+    call nemsio_getfilehead(gfile,arycname=arycname,aryclen=aryclen)
+    print *,'arycname=',arycname,'aryclen=',aryclen
+    allocate(arycval(maxval(aryclen),nmetaaryc))
+    call nemsio_getfilehead(gfile,arycval=arycval)
+    do i=1,nmetaaryc
+      print *,'arycname=',arycname(i),aryclen(i),arycval(1:aryclen(i),i)
+    enddo
+  endif
+
+
+!
+!---read fields
+!
+  fieldsize=(im+2*nframe)*(jm+2*nframe)
+  allocate(tmp(fieldsize))
+  do jrec=1,nrec
+    call nemsio_getrechead(gfile,jrec,vname,vlevtyp,vlev,iret)
+    call nemsio_readrec(gfile,jrec,tmp,iret=iret)
+    print *,'3b:: read,jrec=',jrec,'iret=',iret,' vname=',trim(vname), &
+       ' vlevtyp=',trim(vlevtyp),' vlev=',vlev,'data=',maxval(tmp),minval(tmp)
+   enddo
+!
+!--- close nemsio file
+  call nemsio_close(gfile,iret=iret)
+  if ( iret .ne.0) print *,'iret=',iret
+
+!!---------------------------------------------------------------------------
+  deallocate(tmp)
+!
+!---------------------------------------------------------------------------
+!
+  call nemsio_finalize()
+! - - - - -- - -- - -- - -- - - -- - --  -- - -- - -- - - -- - - - -- -
+! --
+  stop
+
+ end program
+
diff --git a/sorc/nst_tf_chg.fd/CMakeLists.txt b/sorc/nst_tf_chg.fd/CMakeLists.txt
new file mode 100644
index 0000000..43cd322
--- /dev/null
+++ b/sorc/nst_tf_chg.fd/CMakeLists.txt
@@ -0,0 +1,24 @@
+set(fortran_src
+    nc_check.f90
+    nst_tf_chg.f90
+    read_tfs_nc.f90
+    read_tfs_nc_2d.f90
+    setup.f90
+    smth9_msk.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fdefault-real-8")
+endif()
+
+set(exe_name nst_tf_chg)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  nemsio
+  w3nco_d
+  bacio_4
+  NetCDF::NetCDF_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/nst_tf_chg.fd/read_tfs_nc_2d.f90 b/sorc/nst_tf_chg.fd/read_tfs_nc_2d.f90
new file mode 100644
index 0000000..85ea789
--- /dev/null
+++ b/sorc/nst_tf_chg.fd/read_tfs_nc_2d.f90
@@ -0,0 +1,91 @@
+subroutine read_tfs_nc_2d(filename,tf,mask,nlon,nlat)
+!
+! abstract : read Tf at GFS Gaussin grids in netCDF 
+!
+  use netcdf
+  implicit none
+  
+  ! This is the name of the data file we will read.
+  character (len=6),            intent(in)  :: filename
+  integer,                      intent(in)  :: nlat,nlon
+  real, dimension(nlon,nlat),   intent(out) :: tf
+  integer, dimension(nlon,nlat),   intent(in) :: mask
+! Local variables
+  real, dimension(nlon,nlat) :: tf_tmp
+
+  integer :: ncid
+
+  integer, parameter :: ndims = 2
+  real, parameter :: xoffset = 273.15, scale_factor = 0.01
+  character (len = *), parameter :: lat_name = "latitude"
+  character (len = *), parameter :: lon_name = "longitude"
+  character (len = *), parameter :: tf_name="tf"
+  character (len = *), parameter :: mask_name="slmsk"
+  integer :: no_fill,fill_value
+  integer :: lon_varid, lat_varid, tf_varid, mask_varid
+
+  ! The start and count arrays will tell the netCDF library where to read our data.
+  integer, dimension(ndims) :: start, count
+  real, dimension(nlat) :: xlats
+  real, dimension(nlon) :: xlons
+
+  character (len = *), parameter :: units = "units"
+  character (len = *), parameter :: tf_units = "kelvin", mask_units = "none"
+  character (len = *), parameter :: lat_units = "degrees_north"
+  character (len = *), parameter :: lon_units = "degrees_east"
+
+  integer :: missv
+! Loop indices
+  integer :: rec, i,j
+
+! To check the units attributes.
+  character*80 tf_units_in, mask_units_in
+  character*80 lat_units_in, lon_units_in
+
+  write(*,*) 'filename, nlon, nlat : ',filename, nlon, nlat
+
+! Open the file. 
+! call nc_check( nf90_open(filename, nf90_netcdf4, ncid) )
+  call nc_check( nf90_open(filename, nf90_nowrite, ncid) )
+
+! Get the varids of the latitude and longitude coordinate variables.
+! call nc_check( nf90_inq_varid(ncid, lat_name, lat_varid) )
+! call nc_check( nf90_inq_varid(ncid, lon_name, lon_varid) )
+
+! Read the time, latitude and longitude data.
+! call nc_check( nf90_get_var(ncid, lat_varid, xlats) )
+! call nc_check( nf90_get_var(ncid, lon_varid, xlons) )
+
+! Get the varids of the tf & mask netCDF variables.
+  call nc_check( nf90_inq_varid(ncid, tf_name, tf_varid) )
+! call nc_check( nf90_inq_varid(ncid, mask_name, mask_varid) )
+
+! Get the missing value of analysed_sst
+! call nc_check( nf90_get_att(ncid, tf_varid, '_FillValue', missv) )
+! write(*,*) 'ostia Tf fill_value, missing_value : ',missv,missing_value
+
+! Read 1 record of nlat*nlon values, starting at the beginning 
+! of the record (the (1, 1, rec) element in the netCDF file).
+  start = (/ 1, 1 /)
+  count = (/ nlon, nlat /)
+
+! Read the tf & mask data from the file, one record at a time.
+  call nc_check( nf90_get_var(ncid, tf_varid,   tf_tmp, start, count) )
+! call nc_check( nf90_get_var(ncid, mask_varid, mask,   start, count) )
+
+  do j = 1, nlat
+     do i = 1, nlon
+        if ( mask(i,j) == 0 ) then
+           tf(i,j) = real(tf_tmp(i,nlat+1-j))*scale_factor + xoffset
+        endif
+     enddo
+  enddo
+
+! Close the file. This frees up any internal netCDF resources
+! associated with the file.
+  call nc_check( nf90_close(ncid) )
+
+! If we got this far, everything worked as expected. Yipee! 
+  print *,"*** SUCCESS reading file ", filename, "!"
+
+end subroutine read_tfs_nc_2d
diff --git a/sorc/orog.fd/CMakeLists.txt b/sorc/orog.fd/CMakeLists.txt
new file mode 100644
index 0000000..28a5793
--- /dev/null
+++ b/sorc/orog.fd/CMakeLists.txt
@@ -0,0 +1,24 @@
+set(fortran_src
+    mtnlm7_oclsm.f
+    netcdf_io.F90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -convert big_endian -assume byterecl")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fdefault-real-8 -fconvert=big-endian -fno-range-check")
+endif()
+
+set(exe_name orog)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  bacio_4
+  w3nco_d
+  ip_d
+  sp_d
+  NetCDF::NetCDF_Fortran)
+if(OpenMP_Fortran_FOUND)
+  target_link_libraries(${exe_name} OpenMP::OpenMP_Fortran)
+endif()
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/orog.fd/mtnlm7_oclsm.f b/sorc/orog.fd/mtnlm7_oclsm.f
new file mode 100755
index 0000000..46cd166
--- /dev/null
+++ b/sorc/orog.fd/mtnlm7_oclsm.f
@@ -0,0 +1,4456 @@
+C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
+C
+C MAIN PROGRAM:  TERRAIN  TERRAIN MAKER FOR GLOBAL SPECTRAL MODEL
+C   PRGMMR: IREDELL       ORG: W/NMC23       DATE: 92-04-16
+C
+C ABSTRACT: THIS PROGRAM CREATES 7 TERRAIN-RELATED FILES
+C   COMPUTED FROM THE NAVY 10-MINUTE TERRAIN DATASET.
+C   THE MODEL PHYSICS GRID PARAMETERS AND SPECTRAL TRUNCATION
+C   AND FILTER PARAMETERS ARE READ BY THIS PROGRAM AS INPUT.
+C   THE 7 FILES PRODUCED ARE RESPECTIVELY:
+C     1) SEA-LAND MASK ON MODEL PHYSICS GRID
+C     2) GRIDDED OROGRAPHY ON MODEL PHYSICS GRID
+C     3) MOUNTAIN STD DEV ON MODEL PHYSICS GRID
+C     4) SPECTRAL OROGRAPHY IN SPECTRAL DOMAIN
+C     5) UNFILTERED GRIDDED OROGRAPHY ON MODEL PHYSICS GRID
+C     6) GRIB SEA-LAND MASK ON MODEL PHYSICS GRID
+C     7) GRIB GRIDDED OROGRAPHY ON MODEL PHYSICS GRID
+C   THE OROGRAPHY IS ONLY FILTERED FOR WAVENUMBERS GREATER THAN NF0.
+C   FOR WAVENUMBERS N BETWEEN NF0 AND NF1, THE OROGRAPHY IS FILTERED
+C   BY THE FACTOR 1-((N-NF0)/(NF1-NF0))**2.  THE FILTERED OROGRAPHY
+C   WILL NOT HAVE INFORMATION BEYOND WAVENUMBER NF1.
+C
+C PROGRAM HISTORY LOG:
+C   92-04-16  IREDELL
+C   98-02-02  IREDELL  FILTER
+C   98-05-31  HONG Modified for subgrid orography used in Kim's scheme
+C   98-12-31  HONG Modified for high-resolution GTOPO orography
+C   99-05-31  HONG Modified for getting OL4 (mountain fraction)
+!   00-02-10  Moorthi's modifications
+C   00-04-11  HONG Modified for reduced grids
+C   00-04-12  Iredell Modified for reduced grids
+C   02-01-07  (*j*) modified for principal axes of orography
+!             There are now 14 files, 4 additional for lm mb
+!   04-04-04  (*j*) re-Test on IST/ilen calc for sea-land mask(*j*)
+!   04-09-04   minus sign here in MAKEOA IST and IEN as in MAKEMT!
+!   05-09-05   if test on HK and HLPRIM for GAMMA SQRT
+!   07-08-07   replace 8' with 30" incl GICE, conintue w/ S-Y. lake slm
+!   08-08-07  All input 30", UMD option, and filter as described below
+! --- Quadratic filter applied by default.
+! --- NF0 is normally set to an even value beyond the previous truncation, 
+! --- for example, for jcap=382, NF0=254+2
+! --- NF1 is set as jcap+2 (and/or nearest even), eg., for t382, NF1=382+2=384
+! --- if no filter is desired then NF1=NF0=0 and ORF=ORO
+! --- but if no filter but spectral to grid (with gibbs) then NF1=jcap+2, and NF1=jcap+1
+C       
+C
+C USAGE:
+C
+C   INPUT FILES:
+C     UNIT5      - PHYSICS LONGITUDES (IM), PHYSICS LATITUDES (JM),
+C                  SPECTRAL TRUNCATION (NM), RHOMBOIDAL FLAG (NR),
+C                  AND FIRST AND SECOND FILTER PARAMETERS (NF0,NF1).
+C                  RESPECTIVELY READ IN FREE FORMAT.
+C     UNIT235    - GTOPO 30" AVR for ZAVG elevation
+C     UNIT10     - 30" UMD land (lake) cover mask  see MSKSRC switch
+C    XUNIT11     - GTOPO AVR
+C    XUNIT12     - GTOPO STD DEV
+C    XUNIT13     - GTOPO MAX
+C     UNIT14     - GTOPO SLM (10' NAVY if switched to get lakes 
+C     UNIT15     - GICE Grumbine 30" RAMP Antarctica orog IMNx3616
+C     UNIT25     - Ocean land-sea mask on gaussian grid         
+C
+C   OUTPUT FILES:
+C     UNIT51     - SEA-LAND MASK (IM,JM)
+C     UNIT52     - GRIDDED OROGRAPHY (IM,JM)
+C     UNIT54     - SPECTRAL OROGRAPHY ((NM+1)*((NR+1)*NM+2))
+C     UNIT55     - UNFILTERED GRIDDED OROGRAPHY (IM,JM)
+C     UNIT57     - GRIB GRIDDED OROGRAPHY (IM,JM)
+C
+C   SUBPROGRAMS CALLED:
+C     UNIQUE:
+C     TERSUB     - MAIN SUBPROGRAM
+C     SPLAT      - COMPUTE GAUSSIAN LATITUDES OR EQUALLY-SPACED LATITUDES
+C     LIBRARY:
+C     SPTEZ      - SPHERICAL TRANSFORM
+C     GBYTES     - UNPACK BITS
+C
+C   REMARKS: FORTRAN 9X EXTENSIONS ARE USED.
+C           
+C ATTRIBUTES:
+C   CRAY YMP & IBM AIX 3 5 00C88D5D4C00.
+C
+C$$$
+CFPP$ NOCONCUR F
+      include 'netcdf.inc'
+      logical fexist, opened
+      integer fsize, ncid, error, id_dim, nx, ny
+      character(len=256) :: OUTGRID = "none"
+      character(len=256) :: INPUTOROG = "none"
+      logical            :: do_oa = .true. ! create oa and ol data.
+      logical            :: grid_from_file = .true.
+      integer :: MTNRES,IM,JM,NM,NR,NF0,NF1,EFAC,BLAT,NW
+      fsize=65536
+      READ(5,*) MTNRES,IM,JM,NM,NR,NF0,NF1,EFAC,BLAT
+      READ(5,*) OUTGRID
+      READ(5,*) INPUTOROG
+!      MTNRES=1
+!      IM=48
+!      JM=48
+!      NM=46
+!      NF0=0             
+!      NF1=0              
+!      efac=0
+!      blat=0
+!      NR=0
+!      OUTGRID = "C48_grid.tile1.nc"
+!      INPUTOROG = "oro.288x144.nc"
+      print*, "INPUTOROG=", trim(INPUTOROG)
+      print*, "IM,JM=", IM, JM
+! --- MTNRES defines the input (highest) elev resolution
+! --- =1 is topo30 30" in units of 1/2 minute.
+!     so MTNRES for old values must be *2.
+!     =16 is now Song Yu's 8' orog the old ops standard
+! --- other possibilities are =8 for 4' and =4 for 2' see
+!     HJ for T1000 test. Must set to 1 for now.
+      MTNRES=1
+      print*, MTNRES,IM,JM,NM,NR,NF0,NF1,EFAC,BLAT
+      NW=(NM+1)*((NR+1)*NM+2)
+      IMN = 360*120/MTNRES
+      JMN = 180*120/MTNRES
+      print *, ' Starting terr12 mtnlm7_slm30.f  IMN,JMN:',IMN,JMN
+
+! --- read the grid resolution if the OUTGRID exists.
+      if( trim(OUTGRID) .NE. "none" ) then
+         inquire(file=trim(OUTGRID), exist=fexist)
+         if(.not. fexist) then
+            print*, "file "//trim(OUTGRID)//" does not exist"
+            CALL ERREXIT(4)
+         endif
+         do ncid = 103, 512
+           inquire( ncid,OPENED=opened )
+           if( .NOT.opened )exit
+         end do
+
+         print*, "outgrid=", trim(outgrid)
+         error=NF__OPEN(trim(OUTGRID),NF_NOWRITE,fsize,ncid)
+         call netcdf_err(error, 'Open file '//trim(OUTGRID) )
+         error=nf_inq_dimid(ncid, 'nx', id_dim)
+         call netcdf_err(error, 'inquire dimension nx from file '//
+     &                   trim(OUTGRID) )
+         error=nf_inq_dimlen(ncid,id_dim,nx)
+         call netcdf_err(error, 'inquire dimension nx length '//
+     &       'from file '//trim(OUTGRID) )
+         
+         error=nf_inq_dimid(ncid, 'ny', id_dim)
+         call netcdf_err(error, 'inquire dimension ny from file '//
+     &                   trim(OUTGRID) )
+         error=nf_inq_dimlen(ncid,id_dim,ny)
+         call netcdf_err(error, 'inquire dimension ny length '//
+     &       'from file '//trim(OUTGRID) )
+         print*, "nx = ", nx
+         if(IM .ne. nx/2) then
+            print*, "IM=",IM, " /= grid file nx/2=",nx/2
+            print*, "Set IM = ", nx/2
+            IM = nx/2
+         endif
+         if(JM .ne. ny/2) then
+            print*, "JM=",JM, " /= grid file ny/2=",ny/2
+            print*, "Set JM = ", ny/2
+            JM = ny/2
+         endif
+         error=nf_close(ncid)
+         call netcdf_err(error, 'close file '//trim(OUTGRID) )
+         
+      endif         
+         
+      
+      CALL TERSUB(IMN,JMN,IM,JM,NM,NR,NF0,NF1,NW,EFAC,BLAT,
+     &            OUTGRID,INPUTOROG)
+      STOP
+      END
+      SUBROUTINE TERSUB(IMN,JMN,IM,JM,NM,NR,NF0,NF1,NW,EFAC,BLAT,
+     &     OUTGRID,INPUTOROG)
+!jaa      use ipfort
+      implicit none
+      include 'machine.h'
+      include 'netcdf.inc'
+C
+      integer                      :: IMN,JMN,IM,JM,NW
+      character(len=*), intent(in) :: OUTGRID
+      character(len=*), intent(in) :: INPUTOROG
+      integer :: NR,NF0,NF1
+      real, parameter :: MISSING_VALUE=-9999.
+      real, PARAMETER :: PI=3.1415926535897931
+      integer :: efac, blat
+      integer, PARAMETER :: NMT=14
+      INTEGER ZSLMX(2700,1350)
+      integer NM
+      logical LATLONGRID
+      INTEGER,allocatable::  ZAVG(:,:),ZSLM(:,:)
+      REAL(4),allocatable::  GICE(:,:),OCLSM(:,:)
+      real :: DEGRAD
+      integer*1,allocatable:: UMD(:,:)
+      integer*1 i3save
+      integer*2 glob(IMN,JMN), i2save
+      logical grid_from_file
+      INTEGER KPDS(200),KGDS(200), zsave1,zsave2,itopo,kount
+      INTEGER kount2,islmx,jslmx,oldslm,msksrc,mskocn,notocn
+      REAL COSCLT(JM),WGTCLT(JM),RCLT(JM),XLAT(JM),DIFFX(JM/2)
+      REAL XLON(IM)
+      LOGICAL is_south_pole(IM,JM), is_north_pole(IM,JM)
+      REAL GEOLON(IM,JM),GEOLAT(IM,JM)
+      REAL, allocatable :: tmpvar(:,:)
+      REAL GEOLON_C(IM+1,JM+1),GEOLAT_C(IM+1,JM+1)
+      REAL DX(IM,JM),DY(IM,JM)
+      REAL SLM(IM,JM),ORO(IM,JM),VAR(IM,JM),ORS(NW),ORF(IM,JM)
+      REAL land_frac(IM,JM)
+      REAL THETA(IM,JM),GAMMA(IM,JM),SIGMA(IM,JM),ELVMAX(IM,JM)
+      REAL WZ4(IM,JM),VAR4(IM,JM),OA(IM,JM,4),OL(IM,JM,4),SLMI(IM,JM)
+      integer IST(IM,jm),IEN(IM,jm),JST(JM),JEN(JM)
+      integer IWORK(IM,JM,4)
+      real    WORK1(IM,JM),WORK2(IM,JM),WORK3(IM,JM),WORK4(IM,JM)
+      real    WORK5(IM,JM),WORK6(IM,JM),GLAT(JMN)
+      LOGICAL SPECTR, REVLAT, FILTER
+      logical fexist
+      real HPRIME(IM,JM,14)
+      real oaa(4),ola(4),sumdif,avedif,alon,alat
+      real, allocatable :: oa_in(:,:,:), ol_in(:,:,:)
+      real, allocatable :: slm_in(:,:), lon_in(:,:), lat_in(:,:)
+      integer numi(jm),ios,iosg,latg2,istat
+      integer  maxc3,maxc4,maxc5,maxc6,maxc7,maxc8
+      integer lonsperlat(jm/2),itest,jtest
+      integer i, j, nx, ny, ncid, js, jn, iw, ie, k
+      integer it,jt,i1,error,id_dim,id_var,nx_in,ny_in
+      integer i_south_pole,j_south_pole,i_north_pole,j_north_pole
+      real    maxlat, minlat
+      logical opened
+      logical LB(IM*JM)
+      integer fsize,wgta,IN,INW,INE,IS,ISW,ISE,M,N,IMT,IRET
+      complex ffj(im/2+1)
+      real    dlat,PHI,DELXN,RS,RN,slma,oroa,vara,var4a,xn,XS,FFF
+      real    WWW
+      real :: timef,tbeg,tend,tbeg1
+      logical :: output_binary
+      output_binary = .false.
+      tbeg1=timef()
+      tbeg=timef()
+      fsize = 65536
+
+       allocate (ZAVG(IMN,JMN))
+       allocate (ZSLM(IMN,JMN))
+       allocate (GICE(IMN+1,3601))
+       allocate (UMD(IMN,JMN))
+       allocate (OCLSM(IM,JM))
+
+!
+!  SET CONSTANTS AND ZERO FIELDS
+!
+      DEGRAD = 180./PI
+      SPECTR = NM .GT. 0     ! if NM <=0 grid is assumed lat/lon
+      FILTER = .TRUE.        ! Spectr Filter defaults true and set by NF1 & NF0
+!     MSKSRC = 0             ! MSKSRC=0 navy 10 lake msk, 1 UMD 30, -1 no lakes
+      MSKSRC = 1             ! MSKSRC=0 navy 10 lake msk, 1 UMD 30, -1 no lakes
+      REVLAT = BLAT .LT. 0   ! Reverse latitude/longitude for output
+      ITOPO  = 1             ! topo 30" read, otherwise tiles (opt offline)
+      MSKOCN = 1             ! Ocean land sea mask =1, =0 if not present
+      NOTOCN = 1             ! =1 Ocean lsm input reverse: Ocean=1, land=0 
+! --- The LSM Gaussian file from the ocean model sometimes arrives with 
+! --- 0=Ocean and 1=Land or it arrives with 1=Ocean and 0=land without 
+! --- metadata to distinguish its disposition.  The AI below mitigates this.
+
+      print *,' In TERSUB, ITOPO=',itopo
+                      if (mskocn .eq. 1)then
+      print *,' Ocean Model LSM Present and '
+      print *, ' Overrides OCEAN POINTS in LSM: mskocn=',mskocn
+                    if (notocn .eq. 1)then
+      print *,' Ocean LSM Reversed:  NOTOCN=',notocn
+                    endif
+                      endif
+C
+C --- old S-Y. files
+C- OPEN(UNIT=11,FORM='FORMATTED',ERR=900) ! average
+C- OPEN(UNIT=12,FORM='FORMATTED',ERR=900) ! Std Dev
+C- OPEN(UNIT=13,FORM='FORMATTED',ERR=900) ! maximum
+C- OPEN(UNIT=14,FORM='FORMATTED',ERR=900) ! sea-land-lake-mask
+C
+! ---      READ(11,11) ZAVG
+! ---      READ(12,11) ZVAR
+! ---      READ(13,11) ZMAX
+! --- 11    FORMAT(20I4)
+!
+! ---  MSKSRC 0 navy 10' lake mask, =1 for 30" UMD lake mask, 
+! ---  MSKSRC internally set if above fails at -1 for no lakes
+! ---
+           IF (MSKSRC .eq. 0 ) then 
+              READ(14,12,iostat=ios) ZSLMX
+   12    FORMAT(80I1)
+      if (ios.ne.0) then 
+            MSKSRC=-1
+          print *,' navy10 lake mask rd fail -- ios,MSKSRC:',ios,MSKSRC
+      endif
+           ELSE
+      print *,' Attempt to open/read UMD 30" slmsk MSKSRC=',MSKSRC
+! --- not 0 so MSKSRC=1 and attempt to open/read UMD 30" slmsk
+!     open(10,file=
+!    &"/scratch2/portfolios/NCEPDEV/global/noscrub/Jordan.Alpert/wx23ja
+!    &/terrain30/landcover30.fixed", 
+!    & recl=43200*21600, access='direct',iostat=istat)
+       open(10,file="landcover30.fixed",
+     & recl=43200*21600, access='direct',iostat=istat)
+
+                  IF (istat.ne.0) then
+                   MSKSRC=-1
+      print *,' UMD lake mask open failed -- ios,MSKSRC:',istat,MSKSRC
+                  ELSE 
+!
+              read(10, rec=1,iostat=istat) UMD
+      print *,' UMD lake mask opened OK   -- ios,MSKSRC:',istat,MSKSRC
+!
+                  ENDIF
+! --------------
+              IF (istat.ne.0) then
+! --- When UMD read fails attempt to read navy 10'
+      print *,' UMD lake mask rd err -- trying navy 10',istat
+                MSKSRC=0
+          print *,' ***** MSKSRC set to 0 MSKSRC=',MSKSRC
+               if (MSKSRC .eq. 0 ) then 
+                   READ(14,12,iostat=ios) ZSLMX
+                  if (ios.ne.0)  then
+                   MSKSRC=-1
+           print *,' navy10 lake mask rd fail - ios,MSKSRC:',ios,MSKSRC
+                  endif
+               endif
+              ELSE
+           print *,' UMD lake, UMD(50,50)=',UMD(50,50),MSKSRC
+              ENDIF
+! --------------
+! ---      good UMD land cover read and MSKSRC=1
+           ENDIF        
+C
+C- READ_G for global 30" terrain 
+C
+       print *,' About to call read_g, ITOPO=',ITOPO
+          if ( ITOPO .ne. 0 ) call read_g(glob,ITOPO)
+! --- transpose even though glob 30" is from S to N and NCEP std is N to S
+       do j=1,jmn/2
+       do I=1,imn
+        jt=jmn - j + 1
+        i2save = glob(I,j)
+        glob(I,j)=glob(I,jt)
+        glob(I,jt) = i2save
+       enddo
+       enddo 
+! --- transpose glob as USGS 30" is from dateline and NCEP std is 0
+       do j=1,jmn
+       do I=1,imn/2
+        it=imn/2 + i 
+        i2save = glob(i,J)
+        glob(i,J)=glob(it,J)
+        glob(it,J) = i2save
+       enddo
+       enddo 
+       print *,' After read_g, glob(500,500)=',glob(500,500)
+!
+
+!  --- IMN,JMN
+      print*, ' IM, JM, NM, NR, NF0, NF1, EFAC, BLAT'
+      print*, IM,JM,NM,NR,NF0,NF1,EFAC,BLAT
+       print *,'  imn,jmn,glob(imn,jmn)=',imn,jmn,glob(imn,jmn)
+       print *,' UBOUND ZAVG=',UBOUND(ZAVG)
+       print *,' UBOUND glob=',UBOUND(glob)
+       print *,' UBOUND ZSLM=',UBOUND(ZSLM)
+       print *,' UBOUND GICE=',UBOUND(GICE)
+       print *,' UBOUND OCLSM=',UBOUND(OCLSM)
+!
+! ---  0 is ocean and 1 is land for slm
+!
+C
+! --- ZSLM initialize with all land 1, ocean 0
+!     ZSLM=1
+      do j=1,jmn
+      do i=1,imn
+      zslm(i,j)=1
+      enddo
+      enddo
+
+           SELECTCASE(MSKSRC)
+C----  30" sea land mask. 0 are water (lake or ocean)
+              CASE(1)
+! --- transpose even though glob 30" is from S to N and NCEP std is N to S
+       do j=1,jmn/2
+       do I=1,imn
+        jt=jmn - j + 1
+        i3save = UMD(I,j)
+        UMD(I,j)=UMD(I,jt)
+        UMD(I,jt) = i3save
+       enddo
+       enddo 
+! --- transpose UMD as USGS 30" is from dateline and NCEP std is 0
+       do j=1,jmn
+       do i=1,imn/2
+        it=imn/2 + i 
+        i3save = UMD(i,J)
+        UMD(i,J)=UMD(it,J)
+        UMD(it,J) = i3save
+       enddo
+       enddo
+! ---   UMD slmsk with 30" lakes  and set ZAVG from glob
+          do j=1,jmn
+          do i=1,imn
+           if ( UMD(i,j) .eq. 0 ) ZSLM(i,j) = 0
+           ZAVG(i,j) = glob(i,j)
+          enddo
+          enddo
+! --- Global land in slm plus lakes on 30" grid and elev set over globe
+! ---
+! ---   When navy 10' mask is set MSKSRC=0
+              CASE(0)
+! ---  MSKSRC 0 navy 10' lake mask, =1 for 30" UMD lake mask, -1 no lakes
+       print *,' NAVY 10 (8) slmsk for lakes, MSKSRC=',MSKSRC 
+         kount = 0
+         kount2 = 0
+       do j=1,jmn
+          oldslm = ZSLM(IMN,j)
+        do i=1,imn
+          i1 = i + 1
+! ---    slmsk with 10' lakes  and set ZAVG from 30" glob
+        ZAVG(i,j) = glob(i,j)
+            if ( glob(i,j) .eq. -9999 ) then 
+               ZSLM(i,j) = 0
+               kount = kount + 1
+            endif
+           islmx=(i-1)/16 + 1
+           jslmx=(j-1)/16 + 1
+          if ( ZSLMX(islmx,jslmx) .eq. 0 ) then
+       if ( j .gt. 8 .and. j .lt. JMN-8 ) then
+              if (i1 .gt. IMN ) i1 = i1 - IMN
+! -----
+      if(ZSLM(i,j).eq.1 .and. oldslm .eq. 1 .and. ZSLM(i1,j).eq.1)then  
+       if (i .ne. 1) oldslm = ZSLM(i,j)
+       ZSLM(i,j) = 0
+       kount2 = kount2 + 1
+      endif 
+! -----
+       endif
+          endif
+        enddo
+       enddo
+! ---
+              CASE(-1)
+      print *,' ***** set ZAVG and slm from 30" glob, MSKSRC=',MSKSRC
+         kount = 0
+         kount2 = 0
+       do j=1,jmn
+        do i=1,imn
+          i1 = i + 1
+! ---   UMD slmsk with 10' lakes  and set ZAVG from 30" glob
+        ZAVG(i,j) = glob(i,j)
+            if ( glob(i,j) .eq. -9999 ) then 
+               ZSLM(i,j) = 0
+               kount = kount + 1
+            endif
+        enddo
+       enddo
+           END SELECT
+! ---
+! ---  Fixing an error in the topo 30" data set at pole (-9999).  
+            do i=1,imn
+            ZSLM(i,1)=0
+            ZSLM(i,JMN)=1
+            enddo
+!
+!      print *,' kount1,2,ZAVG(1,1),ZAVG(imn,jmn),ZAVG(500,500)',
+!     & kount,kount2,ZAVG(1,1),ZAVG(imn,jmn),ZAVG(500,500)
+! --- The center of pixel (1,1) is 89.9958333N/179.9958333W with dx/dy 
+! --- spacing of 1/120 degrees. 
+!
+!  READ REDUCED GRID EXTENTS IF GIVEN
+!
+      read(20,*,iostat=ios) latg2,lonsperlat
+      if(ios.ne.0.or.2*latg2.ne.jm) then
+        do j=1,jm
+          numi(j)=im
+        enddo
+        print *,ios,latg2,'COMPUTE TERRAIN ON A FULL GAUSSIAN GRID'
+      else
+        do j=1,jm/2
+          numi(j)=lonsperlat(j)
+        enddo
+        do j=jm/2+1,jm
+          numi(j)=lonsperlat(jm+1-j)
+        enddo
+        print *,ios,latg2,'COMPUTE TERRAIN ON A REDUCED GAUSSIAN GRID',
+     &          numi
+C       print *,ios,latg2,'COMPUTE TERRAIN ON A REDUCED GAUSSIAN GRID'
+      endif
+!       print *,ios,latg2,'TERRAIN ON GAUSSIAN GRID',numi
+      
+!
+!    This code assumes that lat runs from north to south for gg!
+!
+      print *,' SPECTR=',SPECTR,' REVLAT=',REVLAT,' ** with GICE-07 **'
+      IF (SPECTR) THEN
+        CALL SPLAT(4,JM,COSCLT,WGTCLT)
+        DO J=1,JM/2
+          RCLT(J)      = ACOS(COSCLT(J))
+        ENDDO
+        DO J = 1,JM/2
+           PHI = RCLT(J) * DEGRAD
+           XLAT(J) = 90. - PHI
+           XLAT(JM-J+1) =  PHI - 90.
+        ENDDO
+      ELSE
+        CALL SPLAT(0,JM,COSCLT,WGTCLT)
+        DO J=1,JM
+          RCLT(J) = ACOS(COSCLT(J))
+          XLAT(J) = 90.0 - RCLT(J) * DEGRAD
+        ENDDO
+      ENDIF
+!
+c      print *,' cosclt=',cosclt
+!       print *,' RCLT(1)=',RCLT(1)
+       sumdif = 0.
+       DO J = JM/2,2,-1
+       DIFFX(J) = xlat(J) - XLAT(j-1)
+       sumdif = sumdif + DIFFX(J)
+       ENDDO
+       avedif=sumdif/(float(JM/2))
+!      print *,' XLAT= avedif: ',avedif
+!      write (6,107) (xlat(J)-xlat(j-1),J=JM,2,-1)
+       print *,' XLAT='
+       write (6,106) (xlat(J),J=JM,1,-1)
+  106 format( 10(f7.3,1x))   
+  107 format( 10(f9.5,1x))   
+C
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+      print *,
+     & ' Before GICE ZAVG(1,2)=',ZAVG(1,2),ZSLM(1,2)
+      print *,
+     & ' Before GICE ZAVG(1,12)=',ZAVG(1,12),ZSLM(1,12)
+      print *,
+     & ' Before GICE ZAVG(1,52)=',ZAVG(1,52),ZSLM(1,52)
+      print *,
+     & ' Before GICE ZAVG(1,112)=',ZAVG(1,JMN-112),ZSLM(1,112)
+! GICE: Grumbine 30" Antarctica orog IMNx3616 from S to N & wraped E-W.
+! NB: Zfields are S to N and W-E!
+       iosg = 0
+       READ(15,iostat=iosg) GICE
+       if(iosg .ne. 0 ) then
+        print *,' *** Err on reading GICE record, iosg=',iosg
+        print *,' exec continues but NO GICE correction done '
+!       stop
+       else
+        print *,' GICE 30" Antarctica RAMP orog 43200x3616 read OK'
+        print *,' Processing! '
+        print *,' Processing! '
+        print *,' Processing! '
+         do j = 1, 3601 
+         do i = 1, IMN
+           zsave1 = ZAVG(i,j)
+           zsave2 = ZSLM(i,j)
+         if( GICE(i,j) .ne. -99. .and.  GICE(i,j) .ne. -1.0 ) then
+           if ( GICE(i,j) .gt. 0.) then 
+                ZAVG(i,j) = int( GICE(i,j) + 0.5 )
+!! --- for GICE values less than or equal to 0 (0, -1, or -99) then
+!! --- radar-sat (RAMP) values are not valid and revert back to old orog 
+                ZSLM(i,j) = 1
+           endif
+         endif
+!jaa           ALON = float(i-1) * 360./float(IMN)
+!jaa           ALAT = glat(j)
+!           if(  ZAVG(i,j) .ne. zsave1 .and. i .lt. 3 )
+!    & print *,' antarctica change to ZAVG(i=',i,'j=',j,')=',
+!    &    ZAVG(i,j),ZSLM(i,j),' from originally:',zsave1,zsave2
+!     &write(6,151)i,j,ZAVG(i,j),ZSLM(i,j),zsave1,zsave2,ALAT,ALON
+!  151 format(1x,'antarctica ZAVG(i=',i3,' j=',i3,')=',i5,i3,
+!     &' orig:',i5,i3,' Lat=',f8.3,f9.3,'E')
+!jaa            if(  ZAVG(i,j) .ne. zsave1 ) then 
+!jaa          if ( i .le. 1201 .and. i .gt. 1200 )then
+!jaa      write(6,152)i,j,ZAVG(i,j),ZSLM(i,j),zsave1,zsave2,ALAT,ALON,
+!jaa     &      GICE(i,j)
+!jaa          endif
+!jaa            endif
+  152 format(1x,' ZAVG(i=',i4,' j=',i4,')=',i5,i3,
+     &' orig:',i5,i4,' Lat=',f7.3,f8.2,'E',' GICE=',f8.1)
+         enddo
+         enddo
+       endif
+!      print *,
+!     & ' After GICE ZAVG(1,2)=',ZAVG(1,2),ZSLM(1,2)
+!      print *,
+!     & ' After GICE ZAVG(1,12)=',ZAVG(1,12),ZSLM(1,12)
+!      print *,
+!     & ' After GICE ZAVG(1,52)=',ZAVG(1,52),ZSLM(1,52)
+!      print *,
+!     & ' After GICE ZAVG(1,112)=',ZAVG(1,112),ZSLM(1,112)
+!C
+C     COMPUTE MOUNTAIN DATA : ORO SLM VAR (Std Dev) OC
+C
+! --- The coupled ocean model is already on a Guasian grid if (IM,JM)
+! --- Attempt to Open the file if mskocn=1
+      istat=0
+          if (mskocn .eq. 1) then
+!     open(25,form='unformatted',iostat=istat)
+!     open(25,form='binary',iostat=istat)
+! --- open to fort.25 with link to file in script
+      open(25,form='formatted',iostat=istat)
+                  if (istat.ne.0) then
+                  mskocn = 0
+      print *,' Ocean lsm file Open failure: mskocn,istat=',mskocn,istat
+                  else
+                  mskocn = 1
+      print *,' Ocean lsm file Opened OK: mskocn,istat=',mskocn,istat
+                  endif
+! --- Read it in
+      ios=0
+      OCLSM=0.
+!      read(25,iostat=ios)OCLSM
+       read(25,*,iostat=ios)OCLSM
+         if (ios.ne.0) then 
+         mskocn = 0
+! --- did not properly read Gaussian grid ocean land-sea mask, but
+!     continue using ZSLMX 
+      print *,' Rd fail: Ocean lsm - continue, mskocn,ios=',mskocn,ios
+         else
+         mskocn = 1
+      print *,' Rd OK: ocean lsm:  mskocn,ios=',mskocn,ios
+! --- LSM initialized to ocean mask especially for case where Ocean
+! --- changed by ocean model to land to cope with its problems
+! --- remember, that lake mask is in zslm to be assigned in MAKEMT.
+          if ( mskocn .eq. 1 ) then
+      DO J = 1,JM
+      DO I = 1,numi(j)
+            if ( notocn .eq. 0 ) then
+            slmi(i,j) = float(NINT(OCLSM(i,j)))
+            else
+                     if ( NINT(OCLSM(i,j)) .eq. 0) then
+                     slmi(i,j) = 1
+                     else 
+                     slmi(i,j) = 0
+                     endif
+            endif
+      enddo
+      enddo
+      print *,' OCLSM',OCLSM(1,1),OCLSM(50,50),OCLSM(75,75),OCLSM(IM,JM)
+      print *,' SLMI:',SLMI(1,1),SLMI(50,50),SLMI(75,75),SLMI(IM,JM)
+! --- Diag
+!        WRITE(27,iostat=ios) REAL(SLMI,4)
+!        print *,' write SLMI/OCLSM diag input:',ios
+          endif
+         endif
+
+          else
+          print *,' Not using Ocean model land sea mask'
+          endif
+
+      if (mskocn .eq. 1)then
+      print *,' LSM:',OCLSM(1,1),OCLSM(50,50),OCLSM(75,75),OCLSM(IM,JM)
+      endif
+
+!--- reading grid file.
+      grid_from_file = .false.
+      is_south_pole = .false.
+      is_north_pole = .false.
+      i_south_pole = 0
+      j_south_pole = 0
+      i_north_pole = 0
+      j_north_pole = 0
+      if( trim(OUTGRID) .NE. "none" ) then
+         grid_from_file = .true.
+         inquire(file=trim(OUTGRID), exist=fexist)
+         if(.not. fexist) then
+            print*, "file "//trim(OUTGRID)//" does not exist"
+            CALL ERREXIT(4)
+         endif
+         do ncid = 103, 512
+           inquire( ncid,OPENED=opened )
+           if( .NOT.opened )exit
+         end do
+
+         print*, "outgrid=", trim(outgrid)
+         error=NF__OPEN(trim(OUTGRID),NF_NOWRITE,fsize,ncid)
+         call netcdf_err(error, 'Open file '//trim(OUTGRID) )
+         error=nf_inq_dimid(ncid, 'nx', id_dim)
+         call netcdf_err(error, 'inquire dimension nx from file '//
+     &                   trim(OUTGRID) )
+         nx = 2*IM
+         ny = 2*JM
+!         error=nf_inq_dimlen(ncid,id_dim,nx)
+!         print*, "nx = ", nx, id_dim
+!         call netcdf_err(error, 'inquire dimension nx length '//
+!     &       'from file '//trim(OUTGRID) )
+!         error=nf_inq_dimid(ncid, 'ny', id_dim)
+!         call netcdf_err(error, 'inquire dimension ny from file '//
+!     &                   trim(OUTGRID) )
+!         error=nf_inq_dimlen(ncid,id_dim,ny)
+!         call netcdf_err(error, 'inquire dimension ny length '//
+!     &       'from file '//trim(OUTGRID) )
+!        IM should equal nx/2 and JM should equal ny/2
+!         if(IM .ne. nx/2) then
+!            print*, "IM=",IM, " /= grid file nx/2=",nx/2
+!            CALL ERREXIT(4)
+!         endif
+!         if(JM .ne. ny/2) then
+!            print*, "JM=",JM, " /= grid file ny/2=",ny/2
+!            CALL ERREXIT(4)
+!         endif
+         print*, "Read the grid from file "//trim(OUTGRID)
+
+         allocate(tmpvar(nx+1,ny+1))
+
+         error=nf_inq_varid(ncid, 'x', id_var)
+         call netcdf_err(error, 'inquire varid of x from file '
+     &                   //trim(OUTGRID) )
+         error=nf_get_var_double(ncid, id_var, tmpvar)
+         call netcdf_err(error, 'inquire data of x from file '
+     &                   //trim(OUTGRID) )
+         !--- adjust lontitude to be between 0 and 360.
+         do j = 1,ny+1; do i = 1,nx+1
+            if(tmpvar(i,j) .NE. MISSING_VALUE) then
+              if(tmpvar(i,j) .GT. 360) tmpvar(i,j) = tmpvar(i,j) - 360
+              if(tmpvar(i,j) .LT. 0) tmpvar(i,j) = tmpvar(i,j) + 360
+            endif
+         enddo; enddo
+
+         geolon(1:IM,1:JM) = tmpvar(2:nx:2,2:ny:2)
+         geolon_c(1:IM+1,1:JM+1) = tmpvar(1:nx+1:2,1:ny+1:2)
+         
+         error=nf_inq_varid(ncid, 'y', id_var)
+         call netcdf_err(error, 'inquire varid of y from file '
+     &                   //trim(OUTGRID) )
+         error=nf_get_var_double(ncid, id_var, tmpvar)
+         call netcdf_err(error, 'inquire data of y from file '
+     &                   //trim(OUTGRID) )
+         geolat(1:IM,1:JM) = tmpvar(2:nx:2,2:ny:2)
+         geolat_c(1:IM+1,1:JM+1) = tmpvar(1:nx+1:2,1:ny+1:2)
+
+         !--- figure out pole location.
+         maxlat = -90
+         minlat = 90
+         i_north_pole = 0
+         j_north_pole = 0
+         i_south_pole = 0
+         j_south_pole = 0
+         do j = 1, ny+1; do i = 1, nx+1
+            if( tmpvar(i,j) > maxlat ) then
+               i_north_pole=i
+               j_north_pole=j
+               maxlat = tmpvar(i,j)
+            endif
+            if( tmpvar(i,j) < minlat ) then
+               i_south_pole=i
+               j_south_pole=j
+               minlat = tmpvar(i,j)
+            endif
+         enddo ; enddo
+         !--- only when maxlat is close to 90. the point is north pole
+         if(maxlat < 89.9 ) then
+            i_north_pole = 0
+            j_north_pole = 0
+         endif
+         if(minlat > -89.9 ) then
+            i_south_pole = 0
+            j_south_pole = 0
+         endif
+         print*, "minlat=", minlat, "maxlat=", maxlat
+         print*, "north pole supergrid index is ",
+     &           i_north_pole, j_north_pole
+         print*, "south pole supergrid index is ",
+     &           i_south_pole, j_south_pole
+         deallocate(tmpvar)
+
+         if(i_south_pole >0 .and. j_south_pole > 0) then
+           if(mod(i_south_pole,2)==0) then ! stretched grid
+             do j = 1, JM; do i = 1, IM
+               if(i==i_south_pole/2 .and. (j==j_south_pole/2 
+     &              .or. j==j_south_pole/2+1) ) then
+                 is_south_pole(i,j) = .true.
+                 print*, "south pole at i,j=", i, j
+               endif
+             enddo; enddo      
+            else
+               do j = 1, JM; do i = 1, IM
+                  if((i==i_south_pole/2 .or. i==i_south_pole/2+1)
+     &             .and. (j==j_south_pole/2 .or.
+     &                j==j_south_pole/2+1) ) then
+                    is_south_pole(i,j) = .true.
+                    print*, "south pole at i,j=", i, j
+                  endif
+               enddo; enddo
+            endif            
+         endif
+         if(i_north_pole >0 .and. j_north_pole > 0) then
+            if(mod(i_north_pole,2)==0) then ! stretched grid
+               do j = 1, JM; do i = 1, IM
+                  if(i==i_north_pole/2 .and. (j==j_north_pole/2 .or.
+     &                j==j_north_pole/2+1) ) then
+                    is_north_pole(i,j) = .true.
+                    print*, "north pole at i,j=", i, j
+                  endif
+               enddo; enddo      
+            else
+               do j = 1, JM; do i = 1, IM
+                  if((i==i_north_pole/2 .or. i==i_north_pole/2+1)
+     &             .and. (j==j_north_pole/2 .or.
+     &                j==j_north_pole/2+1) ) then
+                    is_north_pole(i,j) = .true.
+                    print*, "north pole at i,j=", i, j
+                  endif
+               enddo; enddo
+            endif            
+         endif
+         
+         
+         allocate(tmpvar(nx,ny))
+         error=nf_inq_varid(ncid, 'area', id_var)
+         call netcdf_err(error, 'inquire varid of area from file '
+     &                   //trim(OUTGRID) )
+         error=nf_get_var_double(ncid, id_var, tmpvar)
+         call netcdf_err(error, 'inquire data of area from file '
+     &                   //trim(OUTGRID) )
+
+         do j = 1, jm
+            do i = 1, im
+               dx(i,j) = sqrt(tmpvar(2*i-1,2*j-1)+tmpvar(2*i,2*j-1)
+     &                       +tmpvar(2*i-1,2*j  )+tmpvar(2*i,2*j  ))
+               dy(i,j) = dx(i,j)
+            enddo
+         enddo
+!         allocate(tmpvar(nx,ny+1))
+
+!         error=nf_inq_varid(ncid, 'dx', id_var)
+!         call netcdf_err(error, 'inquire varid of dx from file '
+!     &                   //trim(OUTGRID) )
+!         error=nf_get_var_double(ncid, id_var, tmpvar)
+!         call netcdf_err(error, 'inquire data of dx from file '
+!     &                   //trim(OUTGRID) )
+!         dx(1:IM,1:JM+1) = tmpvar(2:nx:2,1:ny+1:2)
+!         deallocate(tmpvar)
+
+!          allocate(tmpvar(nx+1,ny))
+!         error=nf_inq_varid(ncid, 'dy', id_var)
+!         call netcdf_err(error, 'inquire varid of dy from file '
+!     &                   //trim(OUTGRID) )
+!         error=nf_get_var_double(ncid, id_var, tmpvar)
+!         call netcdf_err(error, 'inquire data of dy from file '
+!     &                   //trim(OUTGRID) )
+!         dy(1:IM+1,1:JM) = tmpvar(1:nx+1:2,2:ny:2)
+!         deallocate(tmpvar)         
+      endif
+      tend=timef()
+      write(6,*)' Timer 1 time= ',tend-tbeg
+                                !
+! --- CALL MAKEMT(ZAVG,ZSLM,ORO,OCLSM,mskocn,SLM,VAR,VAR4,GLAT,
+      if(grid_from_file) then
+       tbeg=timef()
+         CALL MAKEMT2(ZAVG,ZSLM,ORO,SLM,land_frac,VAR,VAR4,GLAT,
+     & IM,JM,IMN,JMN,geolon_c,geolat_c)
+      tend=timef()
+      write(6,*)' MAKEMT2 time= ',tend-tbeg
+      else
+
+        CALL MAKEMT(ZAVG,ZSLM,ORO,SLM,VAR,VAR4,GLAT,
+     &   IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+      endif
+       call minmxj(IM,JM,ORO,'     ORO')
+       call minmxj(IM,JM,SLM,'     SLM')
+       call minmxj(IM,JM,VAR,'     VAR')
+       call minmxj(IM,JM,VAR4,'    VAR4')
+C --- check for nands in above
+!      call nanc(ORO,IM*JM,"MAKEMT_ORO")
+!      call nanc(SLM,IM*JM,"MAKEMT_SLM")
+!      call nanc(VAR,IM*JM,"MAKEMT_VAR")
+!      call nanc(VAR4,IM*JM,"MAKEMT_VAR4")
+!
+C   check antarctic pole 
+!     DO J = 1,JM
+!     DO I = 1,numi(j)
+!        if ( i .le. 100 .and. i .ge. 1 )then
+!           if (j .ge. JM-1 )then
+!      if (height .eq. 0.) print *,'I,J,SLM:',I,J,SLM(I,J)
+!      write(6,153)i,j,ORO(i,j),HEIGHT,SLM(i,j)
+!             endif
+!        endif    
+!     ENDDO
+!     ENDDO
+C
+C ===  Compute mtn principal coord HTENSR: THETA,GAMMA,SIGMA
+C
+       if(grid_from_file) then       
+      tbeg=timef()
+         CALL MAKEPC2(ZAVG,ZSLM,THETA,GAMMA,SIGMA,GLAT,
+     1            IM,JM,IMN,JMN,geolon_c,geolat_c)
+      tend=timef()
+      write(6,*)' MAKEPC2 time= ',tend-tbeg
+       else
+         CALL MAKEPC(ZAVG,ZSLM,THETA,GAMMA,SIGMA,GLAT,
+     1            IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+       endif
+        
+       call minmxj(IM,JM,THETA,'   THETA')
+       call minmxj(IM,JM,GAMMA,'   GAMMA')
+       call minmxj(IM,JM,SIGMA,'   SIGMA')
+
+C --- check for nands in above
+!      call nanc(THETA,IM*JM,"MAKEPC_THETA")
+!      call nanc(GAMMA,IM*JM,"MAKEPC_GAMMA")
+!      call nanc(SIGMA,IM*JM,"MAKEPC_SIGMA")
+C
+C     COMPUTE MOUNTAIN DATA : OA OL
+C
+       call minmxj(IM,JM,ORO,'     ORO')
+       print*, "inputorog=", trim(INPUTOROG)
+       if(grid_from_file) then
+         if(trim(INPUTOROG) == "none") then
+           print*, "calling MAKEOA2 to compute OA, OL"
+      tbeg=timef()
+           CALL MAKEOA2(ZAVG,zslm,VAR,GLAT,OA,OL,IWORK,ELVMAX,ORO,
+     1            WORK1,WORK2,WORK3,WORK4,WORK5,WORK6,
+     2            IM,JM,IMN,JMN,geolon_c,geolat_c,
+     3            geolon,geolat,dx,dy,is_south_pole,is_north_pole)
+      tend=timef()
+      write(6,*)' MAKEOA2 time= ',tend-tbeg
+         else
+           !-- read the data from INPUTOROG file.
+           error=NF__OPEN(trim(INPUTOROG),NF_NOWRITE,fsize,ncid)
+           call netcdf_err(error, 'Open file '//trim(INPUTOROG) )
+           error=nf_inq_dimid(ncid, 'lon', id_dim)
+           call netcdf_err(error, 'inquire dimension lon from file '//
+     &                   trim(INPUTOROG) )
+           error=nf_inq_dimlen(ncid,id_dim,nx_in)
+           call netcdf_err(error, 'inquire dimension lon length '//
+     &       'from file '//trim(INPUTOROG) )
+           error=nf_inq_dimid(ncid, 'lat', id_dim)
+           call netcdf_err(error, 'inquire dimension lat from file '//
+     &                   trim(INPUTOROG) )
+           error=nf_inq_dimlen(ncid,id_dim,ny_in)
+           call netcdf_err(error, 'inquire dimension lat length '//
+     &       'from file '//trim(INPUTOROG) )
+           
+           print*, "extrapolate OA, OL from Gaussian grid with nx=",
+     &              nx_in, ", ny=", ny_in
+           allocate(oa_in(nx_in,ny_in,4), ol_in(nx_in,ny_in,4))
+           allocate(slm_in(nx_in,ny_in) )
+           allocate(lon_in(nx_in,ny_in), lat_in(nx_in,ny_in) )
+           
+           error=nf_inq_varid(ncid, 'oa1', id_var)
+           call netcdf_err(error, 'inquire varid of oa1 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, oa_in(:,:,1))
+           call netcdf_err(error, 'inquire data of oa1 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_inq_varid(ncid, 'oa2', id_var)
+           call netcdf_err(error, 'inquire varid of oa2 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, oa_in(:,:,2))
+           call netcdf_err(error, 'inquire data of oa2 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_inq_varid(ncid, 'oa3', id_var)
+           call netcdf_err(error, 'inquire varid of oa3 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, oa_in(:,:,3))
+           call netcdf_err(error, 'inquire data of oa3 from file '
+     &                   //trim(INPUTOROG) )           
+           error=nf_inq_varid(ncid, 'oa4', id_var)
+           call netcdf_err(error, 'inquire varid of oa4 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, oa_in(:,:,4))
+           call netcdf_err(error, 'inquire data of oa4 from file '
+     &                   //trim(INPUTOROG) )
+
+           error=nf_inq_varid(ncid, 'ol1', id_var)
+           call netcdf_err(error, 'inquire varid of ol1 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, ol_in(:,:,1))
+           call netcdf_err(error, 'inquire data of ol1 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_inq_varid(ncid, 'ol2', id_var)
+           call netcdf_err(error, 'inquire varid of ol2 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, ol_in(:,:,2))
+           call netcdf_err(error, 'inquire data of ol2 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_inq_varid(ncid, 'ol3', id_var)
+           call netcdf_err(error, 'inquire varid of ol3 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, ol_in(:,:,3))
+           call netcdf_err(error, 'inquire data of ol3 from file '
+     &                   //trim(INPUTOROG) )           
+           error=nf_inq_varid(ncid, 'ol4', id_var)
+           call netcdf_err(error, 'inquire varid of ol4 from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, ol_in(:,:,4))
+           call netcdf_err(error, 'inquire data of ol4 from file '
+     &                   //trim(INPUTOROG) )
+
+           error=nf_inq_varid(ncid, 'slmsk', id_var)
+           call netcdf_err(error, 'inquire varid of slmsk from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, slm_in)
+           call netcdf_err(error, 'inquire data of slmsk from file '
+     &                   //trim(INPUTOROG) )
+
+           error=nf_inq_varid(ncid, 'geolon', id_var)
+           call netcdf_err(error, 'inquire varid of geolon from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, lon_in)
+           call netcdf_err(error, 'inquire data of geolon from file '
+     &                   //trim(INPUTOROG) )
+
+           error=nf_inq_varid(ncid, 'geolat', id_var)
+           call netcdf_err(error, 'inquire varid of geolat from file '
+     &                   //trim(INPUTOROG) )
+           error=nf_get_var_double(ncid, id_var, lat_in)
+           call netcdf_err(error, 'inquire data of geolat from file '
+     &                   //trim(INPUTOROG) )
+           
+           ! set slmsk=2 to be ocean (0)
+           do j=1,ny_in; do i=1,nx_in
+              if(slm_in(i,j) == 2) slm_in(i,j) = 0
+           enddo; enddo
+           
+           error=nf_close(ncid)
+           call netcdf_err(error, 'close file '
+     &                   //trim(INPUTOROG) )
+           
+           print*, "calling MAKEOA3 to compute OA, OL"
+           CALL MAKEOA3(ZAVG,zslm,VAR,GLAT,OA,OL,IWORK,ELVMAX,ORO,SLM,
+     1            WORK1,WORK2,WORK3,WORK4,WORK5,WORK6,
+     2            IM,JM,IMN,JMN,geolon_c,geolat_c,
+     3            geolon,geolat,is_south_pole,is_north_pole,nx_in,ny_in,
+     4            oa_in,ol_in,slm_in,lon_in,lat_in)
+         endif  
+       else
+         CALL MAKEOA(ZAVG,VAR,GLAT,OA,OL,IWORK,ELVMAX,ORO,
+     1            WORK1,WORK2,WORK3,WORK4,
+     2            WORK5,WORK6,
+     3            IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+       endif
+       tbeg=timef()
+       call minmxj(IM,JM,OA,'      OA')
+       call minmxj(IM,JM,OL,'      OL')
+       call minmxj(IM,JM,ELVMAX,'  ELVMAX')
+       call minmxj(IM,JM,ORO,'     ORO')
+C --- check for nands in above
+!      call nanc(OA(1,1,1), IM*JM,"MAKEOA_OA(1,1,1)")
+!      call nanc(OA(1,1,2), IM*JM,"MAKEOA_OA(1,1,2)")
+!      call nanc(OA(1,1,3), IM*JM,"MAKEOA_OA(1,1,3)")
+!      call nanc(OA(1,1,4), IM*JM,"MAKEOA_OA(1,1,4)")
+!      call nanc(OL(1,1,1), IM*JM,"MAKEOA_OL(1,1,1)")
+!      call nanc(OL(1,1,2), IM*JM,"MAKEOA_OL(1,1,2)")
+!      call nanc(OL(1,1,3), IM*JM,"MAKEOA_OL(1,1,3)")
+!      call nanc(OL(1,1,4), IM*JM,"MAKEOA_OL(1,1,4)")
+!      call nanc(ELVMAX, IM*JM,"MAKEPC_ELVMAX")
+
+        maxc3 = 0
+        maxc4 = 0
+        maxc5 = 0
+        maxc6 = 0
+        maxc7 = 0
+        maxc8 = 0
+      DO J = 1,JM
+      DO I = 1,numi(j)
+         if (ELVMAX(I,J) .gt. 3000.) maxc3 = maxc3 +1
+         if (ELVMAX(I,J) .gt. 4000.) maxc4 = maxc4 +1
+         if (ELVMAX(I,J) .gt. 5000.) maxc5 = maxc5 +1
+         if (ELVMAX(I,J) .gt. 6000.) maxc6 = maxc6 +1
+         if (ELVMAX(I,J) .gt. 7000.) maxc7 = maxc7 +1
+         if (ELVMAX(I,J) .gt. 8000.) maxc8 = maxc8 +1
+      ENDDO
+      ENDDO
+      print *,' MAXC3:',maxc3,maxc4,maxc5,maxc6,maxc7,maxc8
+!
+c      itest=151
+c      jtest=56
+C      
+       print *,' ===> Replacing ELVMAX with ELVMAX-ORO <=== ' 
+       print *,' ===> if ELVMAX<=ORO replace with proxy <=== ' 
+       print *,' ===> the sum of mean orog (ORO) and std dev <=== ' 
+      DO J = 1,JM
+      DO I = 1,numi(j)
+        if (ELVMAX(I,J) .lt. ORO(I,J) ) then
+C---  subtracting off ORO leaves std dev (this should never happen)
+       ELVMAX(I,J) = MAX(  3. * VAR(I,J),0.)
+        else
+       ELVMAX(I,J) = MAX( ELVMAX(I,J) - ORO(I,J),0.)
+        endif
+      ENDDO
+      ENDDO
+        maxc3 = 0
+        maxc4 = 0
+        maxc5 = 0
+        maxc6 = 0
+        maxc7 = 0
+        maxc8 = 0
+      DO J = 1,JM
+      DO I = 1,numi(j)
+         if (ELVMAX(I,J) .gt. 3000.) maxc3 = maxc3 +1
+         if (ELVMAX(I,J) .gt. 4000.) maxc4 = maxc4 +1
+         if (ELVMAX(I,J) .gt. 5000.) maxc5 = maxc5 +1
+         if (ELVMAX(I,J) .gt. 6000.) maxc6 = maxc6 +1
+         if (ELVMAX(I,J) .gt. 7000.) maxc7 = maxc7 +1
+         if (ELVMAX(I,J) .gt. 8000.) maxc8 = maxc8 +1
+      ENDDO
+      ENDDO
+      print *,' after MAXC 3-6 km:',maxc3,maxc4,maxc5,maxc6
+c
+       call mnmxja(IM,JM,ELVMAX,itest,jtest,'  ELVMAX')
+!     if (JM .gt. 0) stop
+C
+C     ZERO OVER OCEAN
+C
+      print *,' Testing at point (itest,jtest)=',itest,jtest
+      print *,' SLM(itest,jtest)=',slm(itest,jtest),itest,jtest
+      print *,' ORO(itest,jtest)=',oro(itest,jtest),itest,jtest
+      DO J = 1,JM
+        DO I = 1,numi(j)
+          IF(SLM(I,J).EQ.0.) THEN
+C           VAR(I,J) = 0.
+            VAR4(I,J) = 0.
+            OA(I,J,1) = 0.
+            OA(I,J,2) = 0.
+            OA(I,J,3) = 0.
+            OA(I,J,4) = 0.
+            OL(I,J,1) = 0.
+            OL(I,J,2) = 0.
+            OL(I,J,3) = 0.
+            OL(I,J,4) = 0.
+C           THETA(I,J) =0.
+C           GAMMA(I,J) =0.
+C           SIGMA(I,J) =0.
+C           ELVMAX(I,J)=0.
+! --- the sub-grid scale parameters for mtn blocking and gwd retain 
+! --- properties even if over ocean but there is elevation within the 
+! --- gaussian grid box.
+          ENDIF
+       ENDDO
+      ENDDO
+C
+! --- if mskocn=1 ocean land sea mask given, =0 if not present
+! ---  OCLSM is real(*4)  array with fractional values possible
+! ---  0 is ocean and 1 is land for slm
+! ---  Step 1: Only change SLM after GFS SLM is applied
+! ---  SLM is only field that will be altered by OCLSM
+! ---  Ocean land sea mask ocean points made ocean in atm model
+! ---  Land and Lakes and all other atm elv moments remain unchanged.  
+            if ( mskocn .eq. 1 ) then
+
+      DO j = 1,jm
+        DO i = 1,numi(j)
+              if (abs (oro(i,j)) .lt. 1. ) then 
+              slm(i,j) = slmi(i,j)
+              else
+      if ( slmi(i,j) .eq. 1. .and. slm(i,j) .eq. 1) slm(i,j) = 1
+      if ( slmi(i,j) .eq. 0. .and. slm(i,j) .eq. 0) slm(i,j) = 0
+      if ( slmi(i,j) .eq. 0. .and. slm(i,j) .eq. 1) slm(i,j) = 0
+      if ( slmi(i,j) .eq. 0. .and. slm(i,j) .eq. 0) slm(i,j) = 0
+              endif
+        enddo
+      enddo
+            endif
+      print *,' SLM(itest,jtest)=',slm(itest,jtest),itest,jtest
+      print *,' ORO(itest,jtest)=',oro(itest,jtest),itest,jtest
+
+C  REMOVE ISOLATED POINTS
+      DO J=2,JM-1
+        JN=J-1
+        JS=J+1
+        RN=REAL(NUMI(JN))/REAL(NUMI(J))
+        RS=REAL(NUMI(JS))/REAL(NUMI(J))
+        DO I=1,NUMI(J)
+          IW=MOD(I+IM-2,IM)+1
+          IE=MOD(I,IM)+1
+          SLMA=SLM(IW,J)+SLM(IE,J)
+          OROA=ORO(IW,J)+ORO(IE,J)
+          VARA=VAR(IW,J)+VAR(IE,J)
+          VAR4A=VAR4(IW,J)+VAR4(IE,J)
+          DO K=1,4
+            OAA(K)=OA(IW,J,K)+OA(IE,J,K)
+! --- (*j*) fix typo:
+            OLA(K)=OL(IW,J,K)+OL(IE,J,K)
+          ENDDO
+          WGTA=2
+          XN=RN*(I-1)+1
+          IF(ABS(XN-NINT(XN)).LT.1.E-2) THEN
+            IN=MOD(NINT(XN)-1,NUMI(JN))+1
+            INW=MOD(IN+NUMI(JN)-2,NUMI(JN))+1
+            INE=MOD(IN,NUMI(JN))+1
+            SLMA=SLMA+SLM(INW,JN)+SLM(IN,JN)+SLM(INE,JN)
+            OROA=OROA+ORO(INW,JN)+ORO(IN,JN)+ORO(INE,JN)
+            VARA=VARA+VAR(INW,JN)+VAR(IN,JN)+VAR(INE,JN)
+            VAR4A=VAR4A+VAR4(INW,JN)+VAR4(IN,JN)+VAR4(INE,JN)
+            DO K=1,4
+              OAA(K)=OAA(K)+OA(INW,JN,K)+OA(IN,JN,K)+OA(INE,JN,K)
+              OLA(K)=OLA(K)+OL(INW,JN,K)+OL(IN,JN,K)+OL(INE,JN,K)
+            ENDDO
+            WGTA=WGTA+3
+          ELSE
+            INW=INT(XN)
+            INE=MOD(INW,NUMI(JN))+1
+            SLMA=SLMA+SLM(INW,JN)+SLM(INE,JN)
+            OROA=OROA+ORO(INW,JN)+ORO(INE,JN)
+            VARA=VARA+VAR(INW,JN)+VAR(INE,JN)
+            VAR4A=VAR4A+VAR4(INW,JN)+VAR4(INE,JN)
+            DO K=1,4
+              OAA(K)=OAA(K)+OA(INW,JN,K)+OA(INE,JN,K)
+              OLA(K)=OLA(K)+OL(INW,JN,K)+OL(INE,JN,K)
+            ENDDO
+            WGTA=WGTA+2
+          ENDIF
+          XS=RS*(I-1)+1
+          IF(ABS(XS-NINT(XS)).LT.1.E-2) THEN
+            IS=MOD(NINT(XS)-1,NUMI(JS))+1
+            ISW=MOD(IS+NUMI(JS)-2,NUMI(JS))+1
+            ISE=MOD(IS,NUMI(JS))+1
+            SLMA=SLMA+SLM(ISW,JS)+SLM(IS,JS)+SLM(ISE,JS)
+            OROA=OROA+ORO(ISW,JS)+ORO(IS,JS)+ORO(ISE,JS)
+            VARA=VARA+VAR(ISW,JS)+VAR(IS,JS)+VAR(ISE,JS)
+            VAR4A=VAR4A+VAR4(ISW,JS)+VAR4(IS,JS)+VAR4(ISE,JS)
+            DO K=1,4
+              OAA(K)=OAA(K)+OA(ISW,JS,K)+OA(IS,JS,K)+OA(ISE,JS,K)
+              OLA(K)=OLA(K)+OL(ISW,JS,K)+OL(IS,JS,K)+OL(ISE,JS,K)
+            ENDDO
+            WGTA=WGTA+3
+          ELSE
+            ISW=INT(XS)
+            ISE=MOD(ISW,NUMI(JS))+1
+            SLMA=SLMA+SLM(ISW,JS)+SLM(ISE,JS)
+            OROA=OROA+ORO(ISW,JS)+ORO(ISE,JS)
+            VARA=VARA+VAR(ISW,JS)+VAR(ISE,JS)
+            VAR4A=VAR4A+VAR4(ISW,JS)+VAR4(ISE,JS)
+            DO K=1,4
+              OAA(K)=OAA(K)+OA(ISW,JS,K)+OA(ISE,JS,K)
+              OLA(K)=OLA(K)+OL(ISW,JS,K)+OL(ISE,JS,K)
+            ENDDO
+            WGTA=WGTA+2
+          ENDIF
+          OROA=OROA/WGTA
+          VARA=VARA/WGTA
+          VAR4A=VAR4A/WGTA
+          DO K=1,4
+            OAA(K)=OAA(K)/WGTA
+            OLA(K)=OLA(K)/WGTA
+          ENDDO
+          IF(SLM(I,J).EQ.0..AND.SLMA.EQ.WGTA) THEN
+            PRINT '("SEA ",2F8.0," MODIFIED TO LAND",2F8.0," AT ",2I8)',
+     &       ORO(I,J),VAR(I,J),OROA,VARA,I,J
+            SLM(I,J)=1.
+            ORO(I,J)=OROA
+            VAR(I,J)=VARA
+            VAR4(I,J)=VAR4A
+            DO K=1,4
+              OA(I,J,K)=OAA(K)
+              OL(I,J,K)=OLA(K)
+            ENDDO
+          ELSEIF(SLM(I,J).EQ.1..AND.SLMA.EQ.0.) THEN
+            PRINT '("LAND",2F8.0," MODIFIED TO SEA ",2F8.0," AT ",2I8)',
+     &       ORO(I,J),VAR(I,J),OROA,VARA,I,J
+            SLM(I,J)=0.
+            ORO(I,J)=OROA
+            VAR(I,J)=VARA
+            VAR4(I,J)=VAR4A
+            DO K=1,4
+              OA(I,J,K)=OAA(K)
+              OL(I,J,K)=OLA(K)
+            ENDDO
+          ENDIF
+        ENDDO
+      ENDDO
+C--- print for testing after isolated points removed
+      print *,' after isolated points removed'
+       call minmxj(IM,JM,ORO,'     ORO')
+C     print *,' JM=',JM,' numi=',numi
+      print *,' ORO(itest,jtest)=',oro(itest,jtest)
+      print *,' VAR(itest,jtest)=',var(itest,jtest)
+      print *,' VAR4(itest,jtest)=',var4(itest,jtest)
+      print *,' OA(itest,jtest,1)=',oa(itest,jtest,1)
+      print *,' OA(itest,jtest,2)=',oa(itest,jtest,2)
+      print *,' OA(itest,jtest,3)=',oa(itest,jtest,3)
+      print *,' OA(itest,jtest,4)=',oa(itest,jtest,4)
+      print *,' OL(itest,jtest,1)=',ol(itest,jtest,1)
+      print *,' OL(itest,jtest,2)=',ol(itest,jtest,2)
+      print *,' OL(itest,jtest,3)=',ol(itest,jtest,3)
+      print *,' OL(itest,jtest,4)=',ol(itest,jtest,4)
+      print *,' Testing at point (itest,jtest)=',itest,jtest
+      print *,' THETA(itest,jtest)=',theta(itest,jtest)
+      print *,' GAMMA(itest,jtest)=',GAMMA(itest,jtest)
+      print *,' SIGMA(itest,jtest)=',SIGMA(itest,jtest)
+      print *,' ELVMAX(itest,jtest)=',ELVMAX(itest,jtest)
+      print *,' EFAC=',EFAC
+C
+      DO J=1,JM
+        DO I=1,numi(j)
+          ORO(I,J) = ORO(I,J) + EFAC*VAR(I,J)
+          HPRIME(I,J,1) = VAR(I,J)
+          HPRIME(I,J,2) = VAR4(I,J)
+          HPRIME(I,J,3) = oa(I,J,1)
+          HPRIME(I,J,4) = oa(I,J,2)
+          HPRIME(I,J,5) = oa(I,J,3)
+          HPRIME(I,J,6) = oa(I,J,4)
+          HPRIME(I,J,7) = ol(I,J,1)
+          HPRIME(I,J,8) = ol(I,J,2)
+          HPRIME(I,J,9) = ol(I,J,3)
+          HPRIME(I,J,10)= ol(I,J,4)
+          HPRIME(I,J,11)= THETA(I,J)
+          HPRIME(I,J,12)= GAMMA(I,J)
+          HPRIME(I,J,13)= SIGMA(I,J)
+          HPRIME(I,J,14)= ELVMAX(I,J)
+        ENDDO
+      ENDDO
+!
+       call mnmxja(IM,JM,ELVMAX,itest,jtest,'  ELVMAX')
+! --- Quadratic filter applied by default.
+! --- NF0 is normally set to an even value beyond the previous truncation, 
+! --- for example, for jcap=382, NF0=254+2
+! --- NF1 is set as jcap+2 (and/or nearest even), eg., for t382, NF1=382+2=384
+! --- if no filter is desired then NF1=NF0=0 and ORF=ORO
+! --- if no filter but spectral to grid (with gibbs) then NF1=jcap+2, and NF1=jcap+1
+!
+      IF ( NF1 - NF0 .eq. 0 ) FILTER=.FALSE.
+      print *,' NF1, NF0, FILTER=',NF1,NF0,FILTER
+      IF (FILTER) THEN
+C       SPECTRALLY TRUNCATE AND FILTER OROGRAPHY
+        do j=1,jm
+          if(numi(j).lt.im) then
+            ffj=cmplx(0.,0.)
+            call spfft1(numi(j),im/2+1,numi(j),1,ffj,oro(1,j),-1)
+            call spfft1(im,im/2+1,im,1,ffj,oro(1,j),+1)
+          endif
+        enddo
+        CALL SPTEZ(NR,NM,4,IM,JM,ORS,ORO,-1)
+!
+      print *,' about to apply spectral filter '
+        FFF=1./(NF1-NF0)**2
+        I=0
+        DO M=0,NM
+        DO N=M,NM+NR*M
+          IF(N.GT.NF0) THEN
+            WWW=MAX(1.-FFF*(N-NF0)**2,0.)
+            ORS(I+1)=ORS(I+1)*WWW
+            ORS(I+2)=ORS(I+2)*WWW
+          ENDIF
+        I=I+2
+        ENDDO
+        ENDDO
+!
+        CALL SPTEZ(NR,NM,4,IM,JM,ORS,ORF,+1)
+        do j=1,jm
+          if(numi(j).lt.im) then
+            call spfft1(im,im/2+1,im,1,ffj,orf(1,j),-1)
+            call spfft1(numi(j),im/2+1,numi(j),1,ffj,orf(1,j),+1)
+          endif
+        enddo
+
+      ELSE
+        IF (REVLAT) THEN
+          CALL REVERS(IM, JM, numi, SLM, WORK1)
+          CALL REVERS(IM, JM, numi, ORO, WORK1)
+          DO IMT=1,NMT
+            CALL REVERS(IM, JM, numi, HPRIME(1,1,IMT), WORK1)
+          ENDDO
+        ENDIF
+        ORS=0.
+        ORF=ORO
+      ENDIF
+       call mnmxja(IM,JM,ELVMAX,itest,jtest,'  ELVMAX')
+      print *,' ELVMAX(',itest,jtest,')=',ELVMAX(itest,jtest)
+      print *,' after spectral filter is applied'
+       call minmxj(IM,JM,ORO,'     ORO')
+       call minmxj(IM,JM,ORF,'     ORF')
+C
+C  USE NEAREST NEIGHBOR INTERPOLATION TO FILL FULL GRIDS
+      call rg2gg(im,jm,numi,slm)
+      call rg2gg(im,jm,numi,oro)
+      call rg2gg(im,jm,numi,orf)
+C ---   not apply to new prin coord and ELVMAX (*j*)
+      do imt=1,10 
+        call rg2gg(im,jm,numi,hprime(1,1,imt))
+      enddo
+C 
+      print *,' after nearest neighbor interpolation applied '
+       call minmxj(IM,JM,ORO,'     ORO')
+       call minmxj(IM,JM,ORF,'     ORF')
+       call mnmxja(IM,JM,ELVMAX,itest,jtest,'  ELVMAX')
+       print *,' ORO,ORF(itest,jtest),itest,jtest:',
+     &          ORO(itest,jtest),ORF(itest,jtest),itest,jtest
+      print *,' ELVMAX(',itest,jtest,')=',ELVMAX(itest,jtest)
+
+
+C   check antarctic pole 
+      DO J = 1,JM
+      DO I = 1,numi(j)
+         if ( i .le. 21 .and. i .ge. 1 )then
+         if (j .eq. JM )write(6,153)i,j,ORO(i,j),ELVMAX(i,j),SLM(i,j)
+  153 format(1x,' ORO,ELVMAX(i=',i4,' j=',i4,')=',2E14.5,f5.1)
+         endif
+      ENDDO
+      ENDDO
+      tend=timef()
+      write(6,*)' Timer 5 time= ',tend-tbeg
+      if (output_binary) then
+      tbeg=timef()
+C       OUTPUT BINARY FIELDS
+        print *,' OUTPUT BINARY FIELDS'
+        WRITE(51) REAL(SLM,4)
+        WRITE(52) REAL(ORF,4)
+        WRITE(53) REAL(HPRIME,4)
+        WRITE(54) REAL(ORS,4)
+        WRITE(55) REAL(ORO,4)
+        WRITE(66) REAL(THETA,4)
+        WRITE(67) REAL(GAMMA,4)
+        WRITE(68) REAL(SIGMA,4)
+! --- OCLSM is real(4) write only if ocean mask is present
+            if ( mskocn .eq. 1 ) then
+        ios=0
+         WRITE(27,iostat=ios) OCLSM
+         print *,' write OCLSM input:',ios
+!      print *,' LSM:',OCLSM(1,1),OCLSM(50,50),OCLSM(75,75),OCLSM(IM,JM)
+            endif
+C
+       call minmxj(IM,JM,ORO,'     ORO')
+      print *,' IM=',IM,' JM=',JM,' SPECTR=',SPECTR
+C---    Test binary file output:
+      WRITE(71) REAL(SLM,4)
+      DO IMT=1,NMT
+        WRITE(71) REAL(HPRIME(:,:,IMT),4)
+        print *,' HPRIME(',itest,jtest,imt,')=',HPRIME(itest,jtest,imt)
+      ENDDO
+      WRITE(71) REAL(ORO,4)
+      IF (SPECTR) THEN
+        WRITE(71) REAL(ORF,4)   ! smoothed spectral orography!
+      ENDIF
+C  OUTPUT GRIB FIELDS
+      KPDS=0
+      KPDS(1)=7
+      KPDS(2)=78
+      KPDS(3)=255
+      KPDS(4)=128
+      KPDS(5)=81
+      KPDS(6)=1
+      kpds(8)=2004
+      KPDS(9)=1
+      KPDS(10)=1
+      KPDS(13)=4
+      KPDS(15)=1
+      KPDS(16)=51
+      KPDS(17)=1
+      KPDS(18)=1
+      KPDS(19)=1
+      KPDS(21)=20
+      KPDS(22)=0
+      KGDS=0
+      KGDS(1)=4
+      KGDS(2)=IM
+      KGDS(3)=JM
+      KGDS(4)=90000-180000/PI*RCLT(1)
+      KGDS(6)=128
+      KGDS(7)=180000/PI*RCLT(1)-90000
+      KGDS(8)=-NINT(360000./IM)
+      KGDS(9)=NINT(360000./IM)
+      KGDS(10)=JM/2
+      KGDS(20)=255
+! --- SLM
+      CALL BAOPEN(56,'fort.56',IRET)
+      if (iret .ne. 0) print *,' BAOPEN ERROR UNIT 56: IRET=',IRET
+      CALL PUTGB(56,IM*JM,KPDS,KGDS,LB,SLM,IRET)
+      print *,' SLM: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+      if (iret .ne. 0) print *,' SLM PUTGB ERROR:  UNIT 56: IRET=',IRET
+      print *,' SLM: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+! --- OCLSM if present
+!           if ( mskocn .eq. 1 ) then
+!     CALL BAOPEN(27,'fort.27',IRET)
+!     if (iret .ne. 0) print *,' OCLSM BAOPEN ERROR UNIT 27:IRET=',IRET
+!     CALL PUTGB(27,IM*JM,KPDS,KGDS,LB,OCLSM,IRET)
+!     if (iret .ne. 0) print *,' OCLSM PUTGB ERROR: UNIT 27:IRET=',IRET
+!     print *,' OCLSM: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+!           endif
+
+      KPDS(5)=8
+      IF (SPECTR) THEN
+        CALL BAOPEN(57,'fort.57',IRET)
+        CALL PUTGB(57,IM*JM,KPDS,KGDS,LB,ORF,IRET)
+      print *,' ORF (ORO): putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+      ENDIF
+C
+C ===  write out theta (angle of land to East) using #101 (wave dir)
+C ===  [radians] and since < 1 scale adjust kpds(22)
+C
+      KPDS(5)=101
+        CALL BAOPEN(58,'fort.58',IRET)
+        CALL PUTGB(58,IM*JM,KPDS,KGDS,LB,THETA,IRET)
+      print *,' THETA: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+C
+C ===  write out (land aspect ratio or anisotropy)  using #102 
+C ===  (as in wind wave hgt)
+C
+      KPDS(22)=2
+      KPDS(5)=102
+        CALL BAOPEN(60,'fort.60',IRET)
+        CALL PUTGB(60,IM*JM,KPDS,KGDS,LB,SIGMA,IRET)
+      print *,' SIGMA: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+C
+C ===  write out (slope parameter sigma)  using #9 
+C ===  (as in std hgt)
+C
+      KPDS(22)=1
+      KPDS(5)=103
+        CALL BAOPEN(59,'fort.59',IRET)
+        CALL PUTGB(59,IM*JM,KPDS,KGDS,LB,GAMMA,IRET)
+      print *,' GAMMA: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+C
+      KPDS(22)=1
+      KPDS(5)=9
+        CALL BAOPEN(61,'fort.61',IRET)
+        CALL PUTGB(61,IM*JM,KPDS,KGDS,LB,HPRIME,IRET)
+      print *,' HPRIME: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+C
+C
+      KPDS(22)=0
+      KPDS(5)=8
+        CALL BAOPEN(62,'fort.62',IRET)
+        CALL PUTGB(62,IM*JM,KPDS,KGDS,LB,ELVMAX,IRET)
+      print *,' ELVMAX: putgb-KPDS(22,5),iret:',KPDS(22),KPDS(5),IRET
+      endif ! output_binary
+C
+      DELXN = 360./IM
+      do i=1,im
+        xlon(i) = DELXN*(i-1)
+      enddo
+      IF(trim(OUTGRID) == "none") THEN
+        do j=1,jm
+         do i=1,im
+           geolon(i,j) = xlon(i)
+           geolat(i,j) = xlat(j)
+         enddo
+        enddo
+      else
+        do j = 1, jm
+           xlat(j) = geolat(1,j)
+        enddo
+        do i = 1, im
+           xlon(i) = geolon(i,1)
+        enddo
+      endif
+      tend=timef()
+      write(6,*)' Binary output time= ',tend-tbeg
+      tbeg=timef()
+      CALL WRITE_NETCDF(IM,JM,SLM,land_frac,ORO,ORF,HPRIME,1,1,
+     1                  GEOLON(1:IM,1:JM),GEOLAT(1:IM,1:JM), XLON,XLAT)
+      tend=timef()
+      write(6,*)' WRITE_NETCDF time= ',tend-tbeg
+      print *,' wrote netcdf file out.oro.tile?.nc'
+
+      print *,' ===== Deallocate Arrays and ENDING MTN VAR OROG program'
+      deallocate (ZAVG)
+      deallocate (ZSLM)
+      deallocate (UMD)
+      deallocate (GICE)
+      tend=timef()
+      write(6,*)' Total runtime time= ',tend-tbeg1
+      RETURN
+      END
+      SUBROUTINE MAKEMT(ZAVG,ZSLM,ORO,SLM,VAR,VAR4,
+!     SUBROUTINE MAKEMT(ZAVG,ZSLM,ORO,OCLSM,mskocn,SLM,VAR,VAR4,
+     1 GLAT,IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+      DIMENSION GLAT(JMN),XLAT(JM)
+!     REAL*4 OCLSM
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      DIMENSION ORO(IM,JM),SLM(IM,JM),VAR(IM,JM),VAR4(IM,JM)
+      DIMENSION IST(IM,jm),IEN(IM,jm),JST(JM),JEN(JM),numi(jm)
+      INTEGER mskocn,isave
+      LOGICAL FLAG, DEBUG
+C==== DATA DEBUG/.TRUE./
+      DATA DEBUG/.FALSE./
+C
+! ---- OCLSM holds the ocean (im,jm) grid
+! ---  mskocn=1 Use ocean model sea land mask, OK and present,
+! ---  mskocn=0 dont use Ocean model sea land mask, not OK, not present
+      print *,' _____ SUBROUTINE MAKEMT '
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      JM1 = JM - 1
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+C  (*j*)  for hard wired zero offset (lambda s =0) for terr05 
+      DO J=1,JM
+       DO I=1,numi(j)
+         IM1 = numi(j) - 1
+         DELX  = 360./numi(j)       ! GAUSSIAN GRID RESOLUTION
+         FACLON  = DELX / DELXN
+         IST(I,j) = FACLON * FLOAT(I-1) - FACLON * 0.5 + 1
+         IEN(I,j) = FACLON * FLOAT(I) - FACLON * 0.5 + 1
+!        IST(I,j) = FACLON * FLOAT(I-1) + 1.0001
+!        IEN(I,j) = FACLON * FLOAT(I)   + 0.0001
+C
+         IF (IST(I,j) .LE. 0)      IST(I,j) = IST(I,j) + IMN
+         IF (IEN(I,j) .LT. IST(I,j)) IEN(I,j) = IEN(I,j) + IMN
+!
+!          if ( I .lt. 10  .and. J .ge. JM-1 )
+!    1   PRINT*,' MAKEMT: I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+       ENDDO
+!          if ( J .ge. JM-1 ) then
+!     print *,' *** FACLON=',FACLON, 'numi(j=',j,')=',numi(j)
+!          endif
+      ENDDO
+      print *,' DELX=',DELX,' DELXN=',DELXN
+      DO J=1,JM-1
+         FLAG=.TRUE.
+         DO J1=1,JMN
+            XXLAT = (XLAT(J)+XLAT(J+1))/2.
+            IF(FLAG.AND.GLAT(J1).GT.XXLAT) THEN
+              JST(J) = J1
+              JEN(J+1) = J1 - 1
+              FLAG = .FALSE.
+            ENDIF
+         ENDDO
+CX     PRINT*, ' J JST JEN ',J,JST(J),JEN(J),XLAT(J),GLAT(J1)
+      ENDDO
+      JST(JM) = MAX(JST(JM-1) - (JEN(JM-1)-JST(JM-1)),1)
+      JEN(1)  = MIN(JEN(2) + (JEN(2)-JST(2)),JMN)      
+!      PRINT*, ' JM JST JEN=',JST(JM),JEN(JM),XLAT(JM),GLAT(JMN)
+C
+C...FIRST, AVERAGED HEIGHT
+C
+      DO J=1,JM
+        DO I=1,numi(j)
+            ORO(I,J)  = 0.0
+            VAR(I,J)  = 0.0
+            VAR4(I,J) = 0.0
+            XNSUM = 0.0
+            XLAND = 0.0
+            XWATR = 0.0
+            XL1 = 0.0
+            XS1 = 0.0
+            XW1 = 0.0
+            XW2 = 0.0
+            XW4 = 0.0
+            DO II1 = 1, IEN(I,J) - IST(I,J) + 1
+               I1 = IST(I,J) + II1 - 1
+               IF(I1.LE.0.)  I1 = I1 + IMN
+               IF(I1.GT.IMN) I1 = I1 - IMN
+!        if ( i .le. 10 .and. i .ge. 1 ) then 
+!             if (j .eq. JM )
+!    &print *,' J,JST,JEN,IST,IEN,I1=',
+!    &J,JST(j),JEN(J),IST(I,j),IEN(I,j),I1
+!        endif
+               DO J1=JST(J),JEN(J)
+                  XLAND = XLAND + FLOAT(ZSLM(I1,J1))
+                  XWATR = XWATR + FLOAT(1-ZSLM(I1,J1))
+                  XNSUM = XNSUM + 1.
+                  HEIGHT = FLOAT(ZAVG(I1,J1)) 
+C.........
+                  IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                  XL1 = XL1 + HEIGHT * FLOAT(ZSLM(I1,J1))
+                  XS1 = XS1 + HEIGHT * FLOAT(1-ZSLM(I1,J1))
+                  XW1 = XW1 + HEIGHT
+                  XW2 = XW2 + HEIGHT ** 2
+C   check antarctic pole 
+!        if ( i .le. 10 .and. i .ge. 1 )then
+!           if (j .ge. JM-1 )then
+C=== degub testing
+!     print *," I,J,I1,J1,XL1,XS1,XW1,XW2:",I,J,I1,J1,XL1,XS1,XW1,XW2
+! 153 format(1x,' ORO,ELVMAX(i=',i4,' j=',i4,')=',2E14.5,3f5.1)
+!          endif
+!        endif
+               ENDDO
+            ENDDO
+            IF(XNSUM.GT.1.) THEN
+! --- SLM initialized with OCLSM calc from all land points except ....
+! ---  0 is ocean and 1 is land for slm
+! ---  Step 1 is to only change SLM after GFS SLM is applied
+                 
+               SLM(I,J) = FLOAT(NINT(XLAND/XNSUM))
+               IF(SLM(I,J).NE.0.) THEN
+                  ORO(I,J)= XL1 / XLAND
+               ELSE
+                  ORO(I,J)= XS1 / XWATR
+               ENDIF
+               VAR(I,J)=SQRT(MAX(XW2/XNSUM-(XW1/XNSUM)**2,0.))
+            DO II1 = 1, IEN(I,j) - IST(I,J) + 1
+               I1 = IST(I,J) + II1 - 1
+                  IF(I1.LE.0.) I1 = I1 + IMN
+                  IF(I1.GT.IMN) I1 = I1 - IMN
+                  DO J1=JST(J),JEN(J)
+                     HEIGHT = FLOAT(ZAVG(I1,J1)) 
+                     IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                     XW4 = XW4 + (HEIGHT-ORO(I,J)) ** 4
+                  ENDDO
+               ENDDO
+               IF(VAR(I,J).GT.1.) THEN
+!          if ( I .lt. 20  .and. J .ge. JM-19 ) then
+!     print *,'I,J,XW4,XNSUM,VAR(I,J)',I,J,XW4,XNSUM,VAR(I,J)
+!          endif
+                  VAR4(I,J) = MIN(XW4/XNSUM/VAR(I,J) **4,10.)
+               ENDIF
+            ENDIF
+         ENDDO
+      ENDDO
+      WRITE(6,*) "! MAKEMT ORO SLM VAR VAR4 DONE"
+C
+
+      RETURN
+      END
+
+      SUBROUTINE get_index(IMN,JMN,npts,lonO,latO,DELXN,
+     &           jst,jen,ilist,numx)
+        implicit none
+        integer, intent(in)  :: IMN,JMN
+        integer              :: npts
+        real,    intent(in)  :: LONO(npts), LATO(npts)
+        real,    intent(in)  :: DELXN
+        integer, intent(out) :: jst,jen
+        integer, intent(out) :: ilist(IMN)
+        integer, intent(out) :: numx
+        real    minlat,maxlat,minlon,maxlon
+        integer i2, ii, ist, ien
+        
+         minlat = minval(LATO)
+         maxlat = maxval(LATO)
+         minlon = minval(LONO)
+         maxlon = maxval(LONO)
+         ist = minlon/DELXN+1
+         ien = maxlon/DELXN+1
+         jst = (minlat+90)/DELXN+1 
+         jen = (maxlat+90)/DELXN 
+         !--- add a few points to both ends of j-direction
+         jst = jst - 5
+         if(jst<1) jst = 1
+         jen = jen + 5
+         if(jen>JMN) jen = JMN
+
+         !--- when around the pole, just search through all the points.
+         if((jst == 1 .OR. jen == JMN) .and. 
+     &            (ien-ist+1 > IMN/2) )then
+            numx = IMN
+            do i2 = 1, IMN
+               ilist(i2) = i2
+            enddo
+         else if( ien-ist+1 > IMN/2 ) then  ! cross longitude = 0
+            !--- find the minimum that greater than IMN/2 
+            !--- and maximum that less than IMN/2
+            ist = 0
+            ien = IMN+1
+            do i2 = 1, npts
+               ii = LONO(i2)/DELXN+1
+               if(ii <0 .or. ii>IMN) print*,"ii=",ii,IMN,LONO(i2),DELXN
+               if( ii < IMN/2 ) then
+                  ist = max(ist,ii)
+               else if( ii > IMN/2 ) then
+                  ien = min(ien,ii)
+               endif
+            enddo 
+            if(ist<1 .OR. ist>IMN) then
+               print*, "ist<1 .or. ist>IMN"
+               call ABORT()
+            endif
+           if(ien<1 .OR. ien>IMN) then
+               print*, "iend<1 .or. iend>IMN"
+               call ABORT()
+            endif
+
+            numx = IMN - ien + 1
+            do i2 = 1, numx
+               ilist(i2) = ien + (i2-1)           
+            enddo
+            do i2 = 1, ist
+               ilist(numx+i2) = i2
+            enddo
+            numx = numx+ist
+         else
+            numx = ien-ist+1
+            do i2 = 1, numx
+               ilist(i2) = ist + (i2-1)
+            enddo
+         endif
+
+      END   
+      
+      SUBROUTINE MAKEMT2(ZAVG,ZSLM,ORO,SLM,land_frac,VAR,VAR4,
+     1 GLAT,IM,JM,IMN,JMN,lon_c,lat_c)
+      implicit none
+      real, parameter :: D2R = 3.14159265358979/180.
+      integer, parameter :: MAXSUM=20000000
+      real  hgt_1d(MAXSUM)     
+      integer IM, JM, IMN, JMN
+      real GLAT(JMN), GLON(IMN)
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      real land_frac(IM,JM)
+      real ORO(IM,JM),SLM(IM,JM),VAR(IM,JM),VAR4(IM,JM)
+      integer IST,IEN,JST, JEN
+      real lon_c(IM+1,JM+1), lat_c(IM+1,JM+1)
+      INTEGER mskocn,isave
+      LOGICAL FLAG, DEBUG
+      real    LONO(4),LATO(4),LONI,LATI
+      real    HEIGHT
+      integer JM1,i,j,nsum,ii,jj,i1,numx,i2
+      integer ilist(IMN)
+      real    DELXN,XNSUM,XLAND,XWATR,XL1,XS1,XW1,XW2,XW4
+!jaa
+      real :: xnsum_j,xland_j,xwatr_j
+      logical inside_a_polygon
+C==== DATA DEBUG/.TRUE./
+      DATA DEBUG/.FALSE./
+C
+! ---- OCLSM holds the ocean (im,jm) grid
+! ---  mskocn=1 Use ocean model sea land mask, OK and present,
+! ---  mskocn=0 dont use Ocean model sea land mask, not OK, not present
+      print *,' _____ SUBROUTINE MAKEMT2 '
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      JM1 = JM - 1
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+      DO I=1,IMN
+         GLON(I) = 0. + (I-1) * DELXN + DELXN * 0.5
+      ENDDO
+ 
+      land_frac(:,:) = 0.0     
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+C  (*j*)  for hard wired zero offset (lambda s =0) for terr05 
+!$omp parallel do
+!$omp* private (j,i,xnsum,xland,xwatr,nsum,xl1,xs1,xw1,xw2,xw4,lono,
+!$omp*          lato,jst,jen,ilist,numx,jj,i2,ii,loni,lati,height,
+!$omp*          hgt_1d)
+      DO J=1,JM
+!       print*, "J=", J
+       DO I=1,IM
+         ORO(I,J)  = 0.0
+         VAR(I,J)  = 0.0
+         VAR4(I,J) = 0.0
+         XNSUM = 0.0
+         XLAND = 0.0
+         XWATR = 0.0
+         nsum = 0
+         XL1 = 0.0
+         XS1 = 0.0
+         XW1 = 0.0
+         XW2 = 0.0
+         XW4 = 0.0
+         
+         LONO(1) = lon_c(i,j) 
+         LONO(2) = lon_c(i+1,j) 
+         LONO(3) = lon_c(i+1,j+1) 
+         LONO(4) = lon_c(i,j+1) 
+         LATO(1) = lat_c(i,j) 
+         LATO(2) = lat_c(i+1,j) 
+         LATO(3) = lat_c(i+1,j+1) 
+         LATO(4) = lat_c(i,j+1) 
+         call get_index(IMN,JMN,4,LONO,LATO,DELXN,jst,jen,ilist,numx)
+         do jj = jst, jen; do i2 = 1, numx
+            ii = ilist(i2)
+            LONI = ii*DELXN
+            LATI = -90 + jj*DELXN
+            if(inside_a_polygon(LONI*D2R,LATI*D2R,4,
+     &          LONO*D2R,LATO*D2R))then
+
+               XLAND = XLAND + FLOAT(ZSLM(ii,jj))
+               XWATR = XWATR + FLOAT(1-ZSLM(ii,jj))
+               XNSUM = XNSUM + 1.
+               HEIGHT = FLOAT(ZAVG(ii,jj)) 
+               nsum = nsum+1
+               if(nsum > MAXSUM) then
+                 print*, "nsum is greater than MAXSUM, increase MAXSUM"
+                 call ABORT()
+               endif
+               hgt_1d(nsum) = HEIGHT
+               IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+               XL1 = XL1 + HEIGHT * FLOAT(ZSLM(ii,jj))
+               XS1 = XS1 + HEIGHT * FLOAT(1-ZSLM(ii,jj))
+               XW1 = XW1 + HEIGHT
+               XW2 = XW2 + HEIGHT ** 2
+            endif
+         enddo ; enddo
+
+         
+         IF(XNSUM.GT.1.) THEN
+! --- SLM initialized with OCLSM calc from all land points except ....
+! ---  0 is ocean and 1 is land for slm
+! ---  Step 1 is to only change SLM after GFS SLM is applied
+               land_frac(i,j) = XLAND/XNSUM  
+               SLM(I,J) = FLOAT(NINT(XLAND/XNSUM))
+               IF(SLM(I,J).NE.0.) THEN
+                  ORO(I,J)= XL1 / XLAND
+               ELSE
+                  ORO(I,J)= XS1 / XWATR
+               ENDIF
+               VAR(I,J)=SQRT(MAX(XW2/XNSUM-(XW1/XNSUM)**2,0.))
+               do I1 = 1, NSUM
+                  XW4 = XW4 + (hgt_1d(I1) - ORO(i,j)) ** 4
+               enddo   
+
+               IF(VAR(I,J).GT.1.) THEN
+                  VAR4(I,J) = MIN(XW4/XNSUM/VAR(I,J) **4,10.)
+               ENDIF
+            ENDIF
+         ENDDO
+      ENDDO
+!$omp end parallel do
+      WRITE(6,*) "! MAKEMT ORO SLM VAR VAR4 DONE"
+C
+
+      RETURN
+      END
+
+      
+      SUBROUTINE MAKEPC(ZAVG,ZSLM,THETA,GAMMA,SIGMA,
+     1           GLAT,IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+C
+C===  PC: principal coordinates of each Z avg orog box for L&M
+C
+      parameter(REARTH=6.3712E+6)
+      DIMENSION GLAT(JMN),XLAT(JM),DELTAX(JMN)
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      DIMENSION ORO(IM,JM),SLM(IM,JM),HL(IM,JM),HK(IM,JM)
+      DIMENSION HX2(IM,JM),HY2(IM,JM),HXY(IM,JM),HLPRIM(IM,JM)
+      DIMENSION THETA(IM,JM),GAMMA(IM,JM),SIGMA2(IM,JM),SIGMA(IM,JM)
+      DIMENSION IST(IM,jm),IEN(IM,jm),JST(JM),JEN(JM),numi(jm)
+      LOGICAL FLAG, DEBUG
+C===  DATA DEBUG/.TRUE./
+      DATA DEBUG/.FALSE./
+C
+      PI = 4.0 * ATAN(1.0)
+      CERTH = PI * REARTH
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      JM1 = JM - 1
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+      DELTAY =  CERTH / FLOAT(JMN)
+      print *, 'MAKEPC: DELTAY=',DELTAY
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+         DELTAX(J) = DELTAY * COS(GLAT(J)*PI/180.0)
+      ENDDO
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+      DO J=1,JM
+      DO I=1,numi(j)
+C        IM1 = numi(j) - 1
+         DELX  = 360./numi(j)       ! GAUSSIAN GRID RESOLUTION
+         FACLON  = DELX / DELXN
+         IST(I,j) = FACLON * FLOAT(I-1) - FACLON * 0.5
+         IST(I,j) = IST(I,j) + 1
+         IEN(I,j) = FACLON * FLOAT(I) - FACLON * 0.5
+C              if (debug) then
+C          if ( I .lt. 10 .and. J .lt. 10 )
+C    1     PRINT*, ' I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+C              endif
+!        IST(I,j) = FACLON * FLOAT(I-1) + 1.0001
+!        IEN(I,j) = FACLON * FLOAT(I)   + 0.0001
+         IF (IST(I,j) .LE. 0)      IST(I,j) = IST(I,j) + IMN
+         IF (IEN(I,j) .LT. IST(I,j)) IEN(I,j) = IEN(I,j) + IMN
+               if (debug) then
+           if ( I .lt. 10 .and. J .lt. 10 )
+     1     PRINT*, ' I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+               endif
+         IF (IEN(I,j) .LT. IST(I,j)) 
+     1 print *,' MAKEPC: IEN < IST: I,J,IST(I,J),IEN(I,J)',
+     2 I,J,IST(I,J),IEN(I,J)
+      ENDDO
+      ENDDO
+      DO J=1,JM-1
+         FLAG=.TRUE.
+         DO J1=1,JMN
+            XXLAT = (XLAT(J)+XLAT(J+1))/2.
+            IF(FLAG.AND.GLAT(J1).GT.XXLAT) THEN
+              JST(J) = J1
+              JEN(J+1) = J1 - 1
+              FLAG = .FALSE.
+            ENDIF
+         ENDDO
+      ENDDO
+      JST(JM) = MAX(JST(JM-1) - (JEN(JM-1)-JST(JM-1)),1)
+      JEN(1)  = MIN(JEN(2) + (JEN(2)-JST(2)),JMN)
+               if (debug) then
+        PRINT*, ' IST,IEN(1,1-numi(1,JM))',IST(1,1),IEN(1,1), 
+     1  IST(numi(JM),JM),IEN(numi(JM),JM), numi(JM)
+        PRINT*, ' JST,JEN(1,JM) ',JST(1),JEN(1),JST(JM),JEN(JM) 
+                endif
+C
+C... DERIVITIVE TENSOR OF HEIGHT
+C
+      DO J=1,JM
+        DO I=1,numi(j)
+            ORO(I,J)  = 0.0
+            HX2(I,J) = 0.0
+            HY2(I,J) = 0.0
+            HXY(I,J) = 0.0
+            XNSUM = 0.0
+            XLAND = 0.0
+            XWATR = 0.0
+            XL1 = 0.0
+            XS1 = 0.0
+            xfp = 0.0
+            yfp = 0.0
+            xfpyfp = 0.0
+            xfp2 = 0.0
+            yfp2 = 0.0
+            HL(I,J) = 0.0
+            HK(I,J) = 0.0
+            HLPRIM(I,J) = 0.0
+            THETA(I,J) = 0.0 
+            GAMMA(I,J) = 0.
+            SIGMA2(I,J) = 0.
+            SIGMA(I,J) = 0.
+C
+            DO II1 = 1, IEN(I,J) - IST(I,J) + 1
+               I1 = IST(I,J) + II1 - 1
+               IF(I1.LE.0.)  I1 = I1 + IMN
+               IF(I1.GT.IMN) I1 = I1 - IMN
+C
+C===  set the rest of the indexs for ave: 2pt staggered derivitive
+C
+                i0 = i1 - 1
+                if (i1 - 1 .le. 0 )   i0 = i0 + imn
+                if (i1 - 1 .gt. imn)  i0 = i0 - imn
+C
+                ip1 = i1 + 1
+                if (i1 + 1 .le. 0 )   ip1 = ip1 + imn
+                if (i1 + 1 .gt. imn)  ip1 = ip1 - imn
+C
+               DO J1=JST(J),JEN(J)
+                if (debug) then
+                   if ( I1 .eq. IST(I,J) .and. J1 .eq. JST(J) ) 
+     1   PRINT*, ' J, J1,IST,JST,DELTAX,GLAT ',
+     2             J,J1,IST(I,J),JST(J),DELTAX(J1),GLAT(J1)  
+                   if ( I1 .eq. IEN(I,J) .and. J1 .eq. JEN(J) ) 
+     1   PRINT*, ' J, J1,IEN,JEN,DELTAX,GLAT ',
+     2             J,J1,IEN(I,J),JEN(J),DELTAX(J1),GLAT(J1)  
+                endif
+                  XLAND = XLAND + FLOAT(ZSLM(I1,J1))
+                  XWATR = XWATR + FLOAT(1-ZSLM(I1,J1))
+                  XNSUM = XNSUM + 1.
+C
+                  HEIGHT = FLOAT(ZAVG(I1,J1))
+                  hi0 =  float(zavg(i0,j1))
+                  hip1 =  float(zavg(ip1,j1))
+C
+                  IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                  if(hi0 .lt. -990.)  hi0 = 0.0
+                  if(hip1 .lt. -990.)  hip1 = 0.0
+C........           xfp = xfp + 0.5 * ( hip1 - hi0 ) / DELTAX(J1)
+           xfp = 0.5 * ( hip1 - hi0 ) / DELTAX(J1)
+          xfp2 = xfp2 + 0.25 * ( ( hip1 - hi0 )/DELTAX(J1) )** 2 
+C
+! --- not at boundaries
+!RAB                 if ( J1 .ne. JST(1)  .and. J1 .ne. JEN(JM) ) then
+                 if ( J1 .ne. JST(JM)  .and. J1 .ne. JEN(1) ) then
+                  hj0 =  float(zavg(i1,j1-1))
+                  hjp1 =  float(zavg(i1,j1+1))
+                  if(hj0 .lt. -990.)  hj0 = 0.0
+                  if(hjp1 .lt. -990.)  hjp1 = 0.0
+C.......          yfp = yfp + 0.5 * ( hjp1 - hj0 ) / DELTAY
+                  yfp = 0.5 * ( hjp1 - hj0 ) / DELTAY
+                  yfp2 = yfp2 + 0.25 * ( ( hjp1 - hj0 )/DELTAY )**2   
+C
+C..............elseif ( J1 .eq. JST(J) .or. J1 .eq. JEN(JM) ) then
+C ===     the NH pole: NB J1 goes from High at NP to Low toward SP
+C
+!RAB                 elseif ( J1 .eq. JST(1) ) then
+                 elseif ( J1 .eq. JST(JM) ) then
+		 ijax = i1 + imn/2 
+               if (ijax .le. 0 )   ijax = ijax + imn
+               if (ijax .gt. imn)  ijax = ijax - imn
+C..... at N pole we stay at the same latitude j1 but cross to opp side
+                 hijax = float(zavg(ijax,j1))
+                 hi1j1 = float(zavg(i1,j1))
+                  if(hijax .lt. -990.)  hijax = 0.0
+                  if(hi1j1 .lt. -990.)  hi1j1 = 0.0
+C.......        yfp = yfp + 0.5 * ( ( 0.5 * ( hijax + hi1j1) ) - hi1j1 )/DELTAY
+        yfp = 0.5 * ( ( 0.5 * ( hijax - hi1j1 ) ) )/DELTAY
+        yfp2 = yfp2 + 0.25 * ( ( 0.5 *  ( hijax - hi1j1) ) 
+     1                                              / DELTAY )**2
+C
+C ===     the SH pole: NB J1 goes from High at NP to Low toward SP
+C
+!RAB                 elseif ( J1 .eq. JEN(JM) ) then
+                 elseif ( J1 .eq. JEN(1) ) then
+		 ijax = i1 + imn/2 
+               if (ijax .le. 0 )   ijax = ijax + imn
+               if (ijax .gt. imn)  ijax = ijax - imn
+                 hijax = float(zavg(ijax,j1))
+                 hi1j1 = float(zavg(i1,j1))
+                  if(hijax  .lt. -990.)  hijax = 0.0
+                  if(hi1j1  .lt. -990.)  hi1j1 = 0.0
+             if ( i1 .lt. 5 )print *,' S.Pole i1,j1 :',i1,j1,hijax,hi1j1
+C.....        yfp = yfp + 0.5 *  (0.5 * ( hijax - hi1j1) )/DELTAY  
+        yfp = 0.5 *  (0.5 * ( hijax - hi1j1) )/DELTAY  
+        yfp2 = yfp2 + 0.25 * (  (0.5 * (hijax - hi1j1) )
+     1                                                 / DELTAY )**2  
+                 endif
+C
+C ===    The above does an average across the pole for the bndry in j.
+C23456789012345678901234567890123456789012345678901234567890123456789012......
+C
+                  xfpyfp = xfpyfp + xfp * yfp
+                  XL1 = XL1 + HEIGHT * FLOAT(ZSLM(I1,J1))
+                  XS1 = XS1 + HEIGHT * FLOAT(1-ZSLM(I1,J1))
+C
+C === average the HX2, HY2 and HXY
+C === This will be done over all land
+C
+               ENDDO
+            ENDDO
+C
+C ===  HTENSR 
+C
+           IF(XNSUM.GT.1.) THEN
+               SLM(I,J) = FLOAT(NINT(XLAND/XNSUM))
+               IF(SLM(I,J).NE.0.) THEN
+                  ORO(I,J)= XL1 / XLAND
+                  HX2(I,J) =  xfp2  / XLAND
+                  HY2(I,J) =  yfp2  / XLAND
+		  HXY(I,J) =  xfpyfp / XLAND
+               ELSE
+                  ORO(I,J)= XS1 / XWATR
+               ENDIF
+C=== degub testing
+      if (debug) then
+          print *," I,J,i1,j1,HEIGHT:", I,J,i1,j1,HEIGHT,
+     1         XLAND,SLM(i,j)
+          print *," xfpyfp,xfp2,yfp2:",xfpyfp,xfp2,yfp2
+          print *," HX2,HY2,HXY:",HX2(I,J),HY2(I,J),HXY(I,J)
+      ENDIF
+C
+C === make the principal axes, theta, and the degree of anisotropy, 
+C === and sigma2, the slope parameter
+C
+               HK(I,J) = 0.5 * ( HX2(I,J) + HY2(I,J) )
+               HL(I,J) = 0.5 * ( HX2(I,J) - HY2(I,J) )
+               HLPRIM(I,J) = SQRT(HL(I,J)*HL(I,J) + HXY(I,J)*HXY(I,J))
+           IF( HL(I,J).NE. 0. .AND. SLM(I,J) .NE. 0. ) THEN
+C
+             THETA(I,J) = 0.5 * ATAN2(HXY(I,J),HL(I,J)) * 180.0 / PI
+C ===   for testing print out in degrees
+C            THETA(I,J) = 0.5 * ATAN2(HXY(I,J),HL(I,J))
+            ENDIF
+             SIGMA2(I,J) =  ( HK(I,J) + HLPRIM(I,J) )
+        if ( SIGMA2(I,J) .GE. 0. ) then 
+             SIGMA(I,J) =  SQRT(SIGMA2(I,J) )
+             if (sigma2(i,j) .ne. 0. .and. 
+     &        HK(I,J) .GE. HLPRIM(I,J) ) 
+     1       GAMMA(I,J) = sqrt( (HK(I,J) - HLPRIM(I,J)) / SIGMA2(I,J) )
+        else
+             SIGMA(I,J)=0.
+        endif
+           ENDIF
+                  if (debug) then
+       print *," I,J,THETA,SIGMA,GAMMA,",I,J,THETA(I,J),
+     1                                       SIGMA(I,J),GAMMA(I,J)
+       print *," HK,HL,HLPRIM:",HK(I,J),HL(I,J),HLPRIM(I,J)
+                  endif
+        ENDDO
+      ENDDO
+      WRITE(6,*) "! MAKE Principal Coord  DONE"
+C
+      RETURN
+      END
+
+      SUBROUTINE MAKEPC2(ZAVG,ZSLM,THETA,GAMMA,SIGMA,
+     1           GLAT,IM,JM,IMN,JMN,lon_c,lat_c)
+C
+C===  PC: principal coordinates of each Z avg orog box for L&M
+C
+      implicit none
+      real, parameter :: REARTH=6.3712E+6
+      real, parameter :: D2R = 3.14159265358979/180. 
+      integer :: IM,JM,IMN,JMN
+      real  :: GLAT(JMN),DELTAX(JMN)
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      real lon_c(IM+1,JM+1), lat_c(IM+1,JM+1)
+      real ORO(IM,JM),SLM(IM,JM),HL(IM,JM),HK(IM,JM)
+      real HX2(IM,JM),HY2(IM,JM),HXY(IM,JM),HLPRIM(IM,JM)
+      real THETA(IM,JM),GAMMA(IM,JM),SIGMA2(IM,JM),SIGMA(IM,JM)
+      real PI,CERTH,DELXN,DELTAY,XNSUM,XLAND,XWATR,XL1,XS1
+      real xfp,yfp,xfpyfp,xfp2,yfp2,HEIGHT
+      real hi0,hip1,hj0,hjp1,hijax,hi1j1
+      real LONO(4),LATO(4),LONI,LATI
+      integer i,j,i1,j1,i2,jst,jen,numx,i0,ip1,ijax
+      integer ilist(IMN)
+      logical inside_a_polygon
+      LOGICAL FLAG, DEBUG
+C===  DATA DEBUG/.TRUE./
+      DATA DEBUG/.FALSE./
+C
+      PI = 4.0 * ATAN(1.0)
+      CERTH = PI * REARTH
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+      DELTAY =  CERTH / FLOAT(JMN)
+      print *, 'MAKEPC2: DELTAY=',DELTAY
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+         DELTAX(J) = DELTAY * COS(GLAT(J)*D2R)
+      ENDDO
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+
+C... DERIVITIVE TENSOR OF HEIGHT
+C
+!$omp parallel do
+!$omp* private (j,i,xnsum,xland,xwatr,xl1,xs1,xfp,yfp,xfpyfp,
+!$omp*          xfp2,yfp2,lono,lato,jst,jen,ilist,numx,j1,i2,i1,
+!$omp*          loni,lati,i0,ip1,height,hi0,hip1,hj0,hjp1,ijax,
+!$omp*          hijax,hi1j1)
+      DO J=1,JM
+!        print*, "J=", J
+        DO I=1,IM
+          ORO(I,J)  = 0.0
+          HX2(I,J) = 0.0
+          HY2(I,J) = 0.0
+          HXY(I,J) = 0.0
+          XNSUM = 0.0
+          XLAND = 0.0
+          XWATR = 0.0
+          XL1 = 0.0
+            XS1 = 0.0
+            xfp = 0.0
+            yfp = 0.0
+            xfpyfp = 0.0
+            xfp2 = 0.0
+            yfp2 = 0.0
+            HL(I,J) = 0.0
+            HK(I,J) = 0.0
+            HLPRIM(I,J) = 0.0
+            THETA(I,J) = 0.0 
+            GAMMA(I,J) = 0.
+            SIGMA2(I,J) = 0.
+            SIGMA(I,J) = 0.
+
+            LONO(1) = lon_c(i,j) 
+            LONO(2) = lon_c(i+1,j) 
+            LONO(3) = lon_c(i+1,j+1) 
+            LONO(4) = lon_c(i,j+1) 
+            LATO(1) = lat_c(i,j) 
+            LATO(2) = lat_c(i+1,j) 
+            LATO(3) = lat_c(i+1,j+1) 
+            LATO(4) = lat_c(i,j+1) 
+            call get_index(IMN,JMN,4,LONO,LATO,DELXN,jst,jen,ilist,numx)
+
+            do j1 = jst, jen; do i2 = 1, numx
+              i1 = ilist(i2)         
+              LONI = i1*DELXN
+              LATI = -90 + j1*DELXN
+              if(inside_a_polygon(LONI*D2R,LATI*D2R,4,
+     &           LONO*D2R,LATO*D2R))then
+
+C===  set the rest of the indexs for ave: 2pt staggered derivitive
+C
+                i0 = i1 - 1
+                if (i1 - 1 .le. 0 )   i0 = i0 + imn
+                if (i1 - 1 .gt. imn)  i0 = i0 - imn
+C
+                ip1 = i1 + 1
+                if (i1 + 1 .le. 0 )   ip1 = ip1 + imn
+                if (i1 + 1 .gt. imn)  ip1 = ip1 - imn
+
+                  XLAND = XLAND + FLOAT(ZSLM(I1,J1))
+                  XWATR = XWATR + FLOAT(1-ZSLM(I1,J1))
+                  XNSUM = XNSUM + 1.
+C
+                  HEIGHT = FLOAT(ZAVG(I1,J1))
+                  hi0 =  float(zavg(i0,j1))
+                  hip1 =  float(zavg(ip1,j1))
+C
+                  IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                  if(hi0 .lt. -990.)  hi0 = 0.0
+                  if(hip1 .lt. -990.)  hip1 = 0.0
+C........           xfp = xfp + 0.5 * ( hip1 - hi0 ) / DELTAX(J1)
+                  xfp = 0.5 * ( hip1 - hi0 ) / DELTAX(J1)
+                  xfp2 = xfp2 + 0.25 * ( ( hip1 - hi0 )/DELTAX(J1) )** 2 
+C
+! --- not at boundaries
+!RAB                 if ( J1 .ne. JST(1)  .and. J1 .ne. JEN(JM) ) then
+                 if ( J1 .ne. 1  .and. J1 .ne. JMN ) then
+                  hj0 =  float(zavg(i1,j1-1))
+                  hjp1 =  float(zavg(i1,j1+1))
+                  if(hj0 .lt. -990.)  hj0 = 0.0
+                  if(hjp1 .lt. -990.)  hjp1 = 0.0
+C.......          yfp = yfp + 0.5 * ( hjp1 - hj0 ) / DELTAY
+                  yfp = 0.5 * ( hjp1 - hj0 ) / DELTAY
+                  yfp2 = yfp2 + 0.25 * ( ( hjp1 - hj0 )/DELTAY )**2   
+C
+C..............elseif ( J1 .eq. JST(J) .or. J1 .eq. JEN(JM) ) then
+C ===     the NH pole: NB J1 goes from High at NP to Low toward SP
+C
+!RAB                 elseif ( J1 .eq. JST(1) ) then
+                 elseif ( J1 .eq. 1 ) then
+		   ijax = i1 + imn/2 
+                   if (ijax .le. 0 )   ijax = ijax + imn
+                   if (ijax .gt. imn)  ijax = ijax - imn
+C..... at N pole we stay at the same latitude j1 but cross to opp side
+                   hijax = float(zavg(ijax,j1))
+                   hi1j1 = float(zavg(i1,j1))
+                   if(hijax .lt. -990.)  hijax = 0.0
+                   if(hi1j1 .lt. -990.)  hi1j1 = 0.0
+C.......        yfp = yfp + 0.5 * ( ( 0.5 * ( hijax + hi1j1) ) - hi1j1 )/DELTAY
+                   yfp = 0.5 * ( ( 0.5 * ( hijax - hi1j1 ) ) )/DELTAY
+                   yfp2 = yfp2 + 0.25 * ( ( 0.5 *  ( hijax - hi1j1) ) 
+     1                                              / DELTAY )**2
+C
+C ===     the SH pole: NB J1 goes from High at NP to Low toward SP
+C
+!RAB                 elseif ( J1 .eq. JEN(JM) ) then
+                 elseif ( J1 .eq. JMN ) then
+		  ijax = i1 + imn/2 
+                  if (ijax .le. 0 )   ijax = ijax + imn
+                  if (ijax .gt. imn)  ijax = ijax - imn
+                  hijax = float(zavg(ijax,j1))
+                  hi1j1 = float(zavg(i1,j1))
+                  if(hijax  .lt. -990.)  hijax = 0.0
+                  if(hi1j1  .lt. -990.)  hi1j1 = 0.0
+                  if ( i1 .lt. 5 )print *,' S.Pole i1,j1 :',i1,j1,
+     &                      hijax,hi1j1
+C.....        yfp = yfp + 0.5 *  (0.5 * ( hijax - hi1j1) )/DELTAY  
+        yfp = 0.5 *  (0.5 * ( hijax - hi1j1) )/DELTAY  
+        yfp2 = yfp2 + 0.25 * (  (0.5 * (hijax - hi1j1) )
+     1                                                 / DELTAY )**2  
+                 endif
+C
+C ===    The above does an average across the pole for the bndry in j.
+C23456789012345678901234567890123456789012345678901234567890123456789012......
+C
+                  xfpyfp = xfpyfp + xfp * yfp
+                  XL1 = XL1 + HEIGHT * FLOAT(ZSLM(I1,J1))
+                  XS1 = XS1 + HEIGHT * FLOAT(1-ZSLM(I1,J1))
+               ENDIF
+C
+C === average the HX2, HY2 and HXY
+C === This will be done over all land
+C
+               ENDDO
+            ENDDO
+C
+C ===  HTENSR 
+C
+           IF(XNSUM.GT.1.) THEN
+               SLM(I,J) = FLOAT(NINT(XLAND/XNSUM))
+               IF(SLM(I,J).NE.0.) THEN
+                  ORO(I,J)= XL1 / XLAND
+                  HX2(I,J) =  xfp2  / XLAND
+                  HY2(I,J) =  yfp2  / XLAND
+		  HXY(I,J) =  xfpyfp / XLAND
+               ELSE
+                  ORO(I,J)= XS1 / XWATR
+               ENDIF
+C=== degub testing
+      if (debug) then
+          print *," I,J,i1,j1,HEIGHT:", I,J,i1,j1,HEIGHT,
+     1         XLAND,SLM(i,j)
+          print *," xfpyfp,xfp2,yfp2:",xfpyfp,xfp2,yfp2
+          print *," HX2,HY2,HXY:",HX2(I,J),HY2(I,J),HXY(I,J)
+      ENDIF
+C
+C === make the principal axes, theta, and the degree of anisotropy, 
+C === and sigma2, the slope parameter
+C
+               HK(I,J) = 0.5 * ( HX2(I,J) + HY2(I,J) )
+               HL(I,J) = 0.5 * ( HX2(I,J) - HY2(I,J) )
+               HLPRIM(I,J) = SQRT(HL(I,J)*HL(I,J) + HXY(I,J)*HXY(I,J))
+           IF( HL(I,J).NE. 0. .AND. SLM(I,J) .NE. 0. ) THEN
+C
+             THETA(I,J) = 0.5 * ATAN2(HXY(I,J),HL(I,J)) / D2R
+C ===   for testing print out in degrees
+C            THETA(I,J) = 0.5 * ATAN2(HXY(I,J),HL(I,J))
+            ENDIF
+             SIGMA2(I,J) =  ( HK(I,J) + HLPRIM(I,J) )
+        if ( SIGMA2(I,J) .GE. 0. ) then 
+             SIGMA(I,J) =  SQRT(SIGMA2(I,J) )
+             if (sigma2(i,j) .ne. 0. .and. 
+     &        HK(I,J) .GE. HLPRIM(I,J) ) 
+     1       GAMMA(I,J) = sqrt( (HK(I,J) - HLPRIM(I,J)) / SIGMA2(I,J) )
+        else
+             SIGMA(I,J)=0.
+        endif
+           ENDIF
+                  if (debug) then
+       print *," I,J,THETA,SIGMA,GAMMA,",I,J,THETA(I,J),
+     1                                       SIGMA(I,J),GAMMA(I,J)
+       print *," HK,HL,HLPRIM:",HK(I,J),HL(I,J),HLPRIM(I,J)
+                  endif
+        ENDDO
+      ENDDO
+!$omp end parallel do
+      WRITE(6,*) "! MAKE Principal Coord  DONE"
+C
+      RETURN
+      END
+      
+      SUBROUTINE MAKEOA(ZAVG,VAR,GLAT,OA4,OL,IOA4,ELVMAX,
+     1           ORO,oro1,XNSUM,XNSUM1,XNSUM2,XNSUM3,XNSUM4,
+     2           IST,IEN,JST,JEN,IM,JM,IMN,JMN,XLAT,numi)
+      DIMENSION GLAT(JMN),XLAT(JM)
+      INTEGER ZAVG(IMN,JMN)
+      DIMENSION ORO(IM,JM),ORO1(IM,JM),ELVMAX(IM,JM),ZMAX(IM,JM)
+      DIMENSION OA4(IM,JM,4),IOA4(IM,JM,4)
+      DIMENSION IST(IM,jm),IEN(IM,jm),JST(JM),JEN(JM)
+      DIMENSION XNSUM(IM,JM),XNSUM1(IM,JM),XNSUM2(IM,JM)
+      DIMENSION XNSUM3(IM,JM),XNSUM4(IM,JM)
+      DIMENSION VAR(IM,JM),OL(IM,JM,4),numi(jm)
+      LOGICAL FLAG
+C
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+! --- IM1 = IM - 1 removed (not used in this sub)
+      JM1 = JM - 1
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+      print *,' IM=',IM,' JM=',JM,' IMN=',IMN,' JMN=',JMN
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+      DO j=1,jm
+      DO I=1,numi(j)
+         DELX  = 360./numi(j)       ! GAUSSIAN GRID RESOLUTION
+         FACLON  = DELX / DELXN
+C ---  minus sign here in IST and IEN as in MAKEMT!
+         IST(I,j) = FACLON * FLOAT(I-1) - FACLON * 0.5
+         IST(I,j) = IST(I,j) + 1
+         IEN(I,j) = FACLON * FLOAT(I) - FACLON * 0.5
+!        IST(I,j) = FACLON * FLOAT(I-1) + 1.0001
+!        IEN(I,j) = FACLON * FLOAT(I)   + 0.0001
+         IF (IST(I,j) .LE. 0)      IST(I,j) = IST(I,j) + IMN
+         IF (IEN(I,j) .LT. IST(I,j)) IEN(I,j) = IEN(I,j) + IMN
+cx         PRINT*, ' I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+           if ( I .lt. 3  .and. J .lt. 3 )
+     1PRINT*,' MAKEOA: I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+           if ( I .lt. 3  .and. J .ge. JM-1 )
+     1PRINT*,' MAKEOA: I j IST IEN ',I,j,IST(I,j),IEN(I,j)
+      ENDDO
+      ENDDO
+      print *,'MAKEOA: DELXN,DELX,FACLON',DELXN,DELX,FACLON
+      print *, '  ***** ready to start JST JEN section '
+      DO J=1,JM-1
+         FLAG=.TRUE.
+         DO J1=1,JMN
+! --- XXLAT added as in MAKEMT and in next line as well
+            XXLAT = (XLAT(J)+XLAT(J+1))/2.
+            IF(FLAG.AND.GLAT(J1).GT.XXLAT) THEN
+              JST(J) = J1
+! ---         JEN(J+1) = J1 - 1
+              FLAG = .FALSE.
+           if ( J .eq. 1 )
+     1PRINT*,' MAKEOA: XX j JST JEN ',j,JST(j),JEN(j)
+            ENDIF
+         ENDDO
+           if ( J .lt. 3 )
+     1PRINT*,' MAKEOA: j JST JEN ',j,JST(j),JEN(j)
+           if ( J .ge. JM-2 )
+     1PRINT*,' MAKEOA: j JST JEN ',j,JST(j),JEN(j)
+C        FLAG=.TRUE.
+C        DO J1=JST(J),JMN
+C           IF(FLAG.AND.GLAT(J1).GT.XLAT(J)) THEN
+C             JEN(J) = J1 - 1
+C             FLAG = .FALSE.
+C           ENDIF
+C        ENDDO
+      ENDDO
+      JST(JM) = MAX(JST(JM-1) - (JEN(JM-1)-JST(JM-1)),1)
+      JEN(1)  = MIN(JEN(2) + (JEN(2)-JST(2)),JMN)
+      print *,' ***** JST(1) JEN(1) ',JST(1),JEN(1)
+      print *,' ***** JST(JM) JEN(JM) ',JST(JM),JEN(JM)
+C
+      DO J=1,JM
+        DO I=1,numi(j)
+          XNSUM(I,J) = 0.0
+          ELVMAX(I,J) = ORO(I,J)
+          ZMAX(I,J)   = 0.0
+        ENDDO
+      ENDDO
+!
+! --- # of peaks > ZAVG value and ZMAX(IM,JM) -- ORO is already avg.
+! ---  to JM or to JM1
+      DO J=1,JM
+        DO I=1,numi(j)
+            DO II1 = 1, IEN(I,J) - IST(I,J) + 1
+               I1 = IST(I,J) + II1 - 1
+! --- next line as in makemt (I1 not II1) (*j*) 20070701
+             IF(I1.LE.0.)  I1 = I1 + IMN
+             IF (I1 .GT. IMN) I1 = I1 - IMN
+             DO J1=JST(J),JEN(J)
+                HEIGHT = FLOAT(ZAVG(I1,J1))
+                IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                IF ( HEIGHT .gt. ORO(I,J) ) then
+                   if ( HEIGHT .gt. ZMAX(I,J) )ZMAX(I,J) = HEIGHT
+                   XNSUM(I,J) = XNSUM(I,J) + 1
+                  ENDIF
+             ENDDO
+            ENDDO
+           if ( I .lt. 5  .and. J .ge. JM-5 ) then
+      print *,' I,J,ORO(I,J),XNSUM(I,J),ZMAX(I,J):',
+     1         I,J,ORO(I,J),XNSUM(I,J),ZMAX(I,J)
+           endif
+        ENDDO
+      ENDDO
+!
+C....     make ELVMAX  ORO from MAKEMT sub
+C
+! ---  this will make work1 array take on oro's values on return
+      DO J=1,JM
+        DO I=1,numi(j)
+
+          ORO1(I,J) = ORO(I,J)
+          ELVMAX(I,J) = ZMAX(I,J) 
+        ENDDO
+      ENDDO
+C........
+C      The MAX elev peak (no averaging)
+C........
+!     DO J=1,JM
+!       DO I=1,numi(j)
+!           DO II1 = 1, IEN(I,J) - IST(I,J) + 1
+!              I1 = IST(I,J) + II1 - 1
+!              IF(I1.LE.0.)  I1 = I1 + IMN
+!              IF(I1.GT.IMN) I1 = I1 - IMN
+!              DO J1=JST(J),JEN(J)
+!              if ( ELVMAX(I,J) .lt. ZMAX(I1,J1)) 
+!    1              ELVMAX(I,J)   =  ZMAX(I1,J1)
+!              ENDDO
+!           ENDDO
+!        ENDDO
+!     ENDDO
+C
+C---- COUNT NUMBER OF MODE. HIGHER THAN THE HC, CRITICAL HEIGHT
+C     IN A GRID BOX
+      DO J=1,JM
+        DO I=1,numi(j)
+          XNSUM1(I,J) = 0.0
+          XNSUM2(I,J) = 0.0
+          XNSUM3(I,J) = 0.0
+          XNSUM4(I,J) = 0.0
+        ENDDO
+      ENDDO
+! ---                 loop 
+      DO J=1,JM1
+        DO I=1,numi(j)
+           HC = 1116.2 - 0.878 * VAR(I,J)
+!          print *,' I,J,HC,VAR:',I,J,HC,VAR(I,J)
+            DO II1 = 1, IEN(I,J) - IST(I,J) + 1
+               I1 = IST(I,J) + II1 - 1
+!     IF (I1.LE.0.) print *,' I1 less than 0',I1,II1,IST(I,J),IEN(I,J) 
+!               if ( J .lt. 3 .or. J .gt. JM-2 ) then 
+!     IF(I1 .GT. IMN)print *,' I1 > IMN',J,I1,II1,IMN,IST(I,J),IEN(I,J) 
+!               endif
+             IF(I1.GT.IMN) I1 = I1 - IMN
+             DO J1=JST(J),JEN(J)
+               IF(FLOAT(ZAVG(I1,J1)) .GT. HC)
+     1            XNSUM1(I,J) = XNSUM1(I,J) + 1
+               XNSUM2(I,J) = XNSUM2(I,J) + 1
+             ENDDO
+           ENDDO
+C
+           INCI = NINT((IEN(I,j)-IST(I,j)) * 0.5)
+           ISTTT = MIN(MAX(IST(I,j)-INCI,1),IMN)
+           IEDDD = MIN(MAX(IEN(I,j)-INCI,1),IMN)
+C
+           INCJ = NINT((JEN(J)-JST(J)) * 0.5)
+           JSTTT = MIN(MAX(JST(J)-INCJ,1),JMN)
+           JEDDD = MIN(MAX(JEN(J)-INCJ,1),JMN)
+!               if ( J .lt. 3 .or. J .gt. JM-3 )  then
+!                 if(I .lt. 3 .or. I .gt. IM-3) then
+!        print *,' INCI,ISTTT,IEDDD,INCJ,JSTTT,JEDDD:',
+!    1  I,J,INCI,ISTTT,IEDDD,INCJ,JSTTT,JEDDD  
+!                 endif
+!               endif
+C
+           DO I1=ISTTT,IEDDD
+             DO J1=JSTTT,JEDDD
+               IF(FLOAT(ZAVG(I1,J1)) .GT. HC)
+     1            XNSUM3(I,J) = XNSUM3(I,J) + 1
+               XNSUM4(I,J) = XNSUM4(I,J) + 1
+             ENDDO
+           ENDDO
+cx         print*,' i j hc var ',i,j,hc,var(i,j)
+cx         print*,'xnsum12 ',xnsum1(i,j),xnsum2(i,j)
+cx         print*,'xnsum34 ',xnsum3(i,j),xnsum4(i,j)
+        ENDDO
+      ENDDO
+C
+C---- CALCULATE THE 3D OROGRAPHIC ASYMMETRY FOR 4 WIND DIRECTIONS
+C---- AND THE 3D OROGRAPHIC SUBGRID OROGRAPHY FRACTION
+C     (KWD = 1  2  3  4)
+C     ( WD = W  S SW NW)
+C
+C
+      DO KWD = 1, 4
+        DO J=1,JM
+          DO I=1,numi(j)
+            OA4(I,J,KWD) = 0.0
+          ENDDO
+        ENDDO
+      ENDDO
+C
+      DO J=1,JM-2
+        DO I=1,numi(j)
+        II = I + 1
+        IF (II .GT. numi(j)) II = II - numi(j)
+          XNPU = XNSUM(I,J)    + XNSUM(I,J+1)
+          XNPD = XNSUM(II,J)   + XNSUM(II,J+1)
+          IF (XNPD .NE. XNPU) OA4(II,J+1,1) = 1. - XNPD / MAX(XNPU , 1.)
+          OL(II,J+1,1) = (XNSUM3(I,J+1)+XNSUM3(II,J+1))/
+     1                   (XNSUM4(I,J+1)+XNSUM4(II,J+1))
+!          if ( I .lt. 20  .and. J .ge. JM-19 ) then
+!        PRINT*,' MAKEOA: I J IST IEN ',I,j,IST(I,J),IEN(I,J)
+!        PRINT*,' HC VAR ',HC,VAR(i,j)
+!        PRINT*,' MAKEOA: XNSUM(I,J)=',XNSUM(I,J),XNPU, XNPD
+!        PRINT*,' MAKEOA: XNSUM3(I,J+1),XNSUM3(II,J+1)',
+!    1                    XNSUM3(I,J+1),XNSUM3(II,J+1)
+!        PRINT*,' MAKEOA: II, OA4(II,J+1,1), OL(II,J+1,1):',
+!    1                    II, OA4(II,J+1,1), OL(II,J+1,1)
+!          endif
+        ENDDO
+      ENDDO
+      DO J=1,JM-2
+        DO I=1,numi(j)
+        II = I + 1
+        IF (II .GT. numi(j)) II = II - numi(j)
+          XNPU = XNSUM(I,J+1)   + XNSUM(II,J+1)
+          XNPD = XNSUM(I,J)     + XNSUM(II,J)
+          IF (XNPD .NE. XNPU) OA4(II,J+1,2) = 1. - XNPD / MAX(XNPU , 1.)
+          OL(II,J+1,2) = (XNSUM3(II,J)+XNSUM3(II,J+1))/
+     1                   (XNSUM4(II,J)+XNSUM4(II,J+1))
+        ENDDO
+      ENDDO
+      DO J=1,JM-2
+        DO I=1,numi(j)
+        II = I + 1
+        IF (II .GT. numi(j)) II = II - numi(j)
+          XNPU = XNSUM(I,J+1)  + ( XNSUM(I,J) + XNSUM(II,J+1) )*0.5
+          XNPD = XNSUM(II,J)   + ( XNSUM(I,J) + XNSUM(II,J+1) )*0.5
+          IF (XNPD .NE. XNPU) OA4(II,J+1,3) = 1. - XNPD / MAX(XNPU , 1.)
+          OL(II,J+1,3) = (XNSUM1(II,J)+XNSUM1(I,J+1))/
+     1                   (XNSUM2(II,J)+XNSUM2(I,J+1))
+        ENDDO
+      ENDDO
+      DO J=1,JM-2
+        DO I=1,numi(j)
+        II = I + 1
+        IF (II .GT. numi(j)) II = II - numi(j)
+          XNPU = XNSUM(I,J)    + ( XNSUM(II,J) + XNSUM(I,J+1) )*0.5
+          XNPD = XNSUM(II,J+1) + ( XNSUM(II,J) + XNSUM(I,J+1) )*0.5
+          IF (XNPD .NE. XNPU) OA4(II,J+1,4) = 1. - XNPD / MAX(XNPU , 1.)
+          OL(II,J+1,4) = (XNSUM1(I,J)+XNSUM1(II,J+1))/
+     1                   (XNSUM2(I,J)+XNSUM2(II,J+1))
+        ENDDO
+      ENDDO
+C
+      DO KWD = 1, 4
+        DO I=1,numi(j)
+          OL(I,1,KWD)  = OL(I,2,KWD)
+          OL(I,JM,KWD) = OL(I,JM-1,KWD)
+        ENDDO
+      ENDDO
+C
+      DO KWD=1,4
+        DO J=1,JM
+          DO I=1,numi(j)
+            T = OA4(I,J,KWD)
+            OA4(I,J,KWD) = SIGN( MIN( ABS(T), 1. ), T )
+          ENDDO
+        ENDDO
+      ENDDO
+C
+      NS0 = 0
+      NS1 = 0
+      NS2 = 0
+      NS3 = 0
+      NS4 = 0
+      NS5 = 0
+      NS6 = 0
+      DO KWD=1,4
+      DO J=1,JM
+      DO I=1,numi(j)
+         T = ABS( OA4(I,J,KWD) )
+         IF(T .EQ. 0.) THEN
+            IOA4(I,J,KWD) = 0
+            NS0 = NS0 + 1
+         ELSE IF(T .GT. 0. .AND. T .LE. 1.) THEN
+            IOA4(I,J,KWD) = 1
+            NS1 = NS1 + 1
+         ELSE IF(T .GT. 1. .AND. T .LE. 10.) THEN
+            IOA4(I,J,KWD) = 2
+            NS2 = NS2 + 1
+         ELSE IF(T .GT. 10. .AND. T .LE. 100.) THEN
+            IOA4(I,J,KWD) = 3
+            NS3 = NS3 + 1
+         ELSE IF(T .GT. 100. .AND. T .LE. 1000.) THEN
+            IOA4(I,J,KWD) = 4
+            NS4 = NS4 + 1
+         ELSE IF(T .GT. 1000. .AND. T .LE. 10000.) THEN
+            IOA4(I,J,KWD) = 5
+            NS5 = NS5 + 1
+         ELSE IF(T .GT. 10000.) THEN
+            IOA4(I,J,KWD) = 6
+            NS6 = NS6 + 1
+         ENDIF
+      ENDDO
+      ENDDO
+      ENDDO
+C
+      WRITE(6,*) "! MAKEOA EXIT"
+C
+      RETURN
+      END
+
+
+      function get_lon_angle(dx,lat, DEGRAD)
+      implicit none
+      real dx, lat, DEGRAD
+      
+      real get_lon_angle
+         real, parameter :: RADIUS = 6371000
+
+         get_lon_angle = 2*asin( sin(dx/RADIUS*0.5)/cos(lat) )*DEGRAD
+         
+      end function get_lon_angle
+
+      function get_lat_angle(dy, DEGRAD)
+      implicit none
+      real dy, DEGRAD
+      
+      real get_lat_angle
+         real, parameter :: RADIUS = 6371000
+
+         get_lat_angle = dy/RADIUS*DEGRAD
+         
+      end function get_lat_angle
+      
+      SUBROUTINE MAKEOA2(ZAVG,zslm,VAR,GLAT,OA4,OL,IOA4,ELVMAX,
+     1           ORO,oro1,XNSUM,XNSUM1,XNSUM2,XNSUM3,XNSUM4,
+     2           IM,JM,IMN,JMN,lon_c,lat_c,lon_t,lat_t,dx,dy,
+     3           is_south_pole,is_north_pole )
+      implicit none
+      real, parameter :: MISSING_VALUE = -9999.
+      real, parameter :: D2R = 3.14159265358979/180.
+      real, PARAMETER :: R2D=180./3.14159265358979
+      integer IM,JM,IMN,JMN
+      real    GLAT(JMN)
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      real    ORO(IM,JM),ORO1(IM,JM),ELVMAX(IM,JM),ZMAX(IM,JM)
+      real    OA4(IM,JM,4)
+      integer IOA4(IM,JM,4)
+      real    lon_c(IM+1,JM+1), lat_c(IM+1,JM+1)
+      real    lon_t(IM,JM), lat_t(IM,JM)
+      real    dx(IM,JM), dy(IM,JM)
+      logical is_south_pole(IM,JM), is_north_pole(IM,JM)
+      real    XNSUM(IM,JM),XNSUM1(IM,JM),XNSUM2(IM,JM)
+      real    XNSUM3(IM,JM),XNSUM4(IM,JM)
+      real    VAR(IM,JM),OL(IM,JM,4)
+      LOGICAL FLAG
+      integer i,j,ilist(IMN),numx,i1,j1,ii1
+      integer KWD,II,npts
+      real    LONO(4),LATO(4),LONI,LATI
+      real    DELXN,HC,HEIGHT,XNPU,XNPD,T
+      integer NS0,NS1,NS2,NS3,NS4,NS5,NS6
+      logical inside_a_polygon
+      real    lon,lat,dlon,dlat,dlat_old
+      real    lon1,lat1,lon2,lat2
+      real    xnsum11,xnsum12,xnsum21,xnsum22,xnsumx
+      real    HC_11, HC_12, HC_21, HC_22
+      real    xnsum1_11,xnsum1_12,xnsum1_21,xnsum1_22
+      real    xnsum2_11,xnsum2_12,xnsum2_21,xnsum2_22
+      real    get_lon_angle, get_lat_angle, get_xnsum
+      integer ist, ien, jst, jen
+      real    xland,xwatr,xl1,xs1,oroavg,slm
+C   
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+      print *,' IM=',IM,' JM=',JM,' IMN=',IMN,' JMN=',JMN
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+C
+      DO J=1,JM
+        DO I=1,IM
+          XNSUM(I,J) = 0.0
+          ELVMAX(I,J) = ORO(I,J)
+          ZMAX(I,J)   = 0.0
+C---- COUNT NUMBER OF MODE. HIGHER THAN THE HC, CRITICAL HEIGHT
+C     IN A GRID BOX
+          XNSUM1(I,J) = 0.0
+          XNSUM2(I,J) = 0.0
+          XNSUM3(I,J) = 0.0
+          XNSUM4(I,J) = 0.0
+          ORO1(I,J) = ORO(I,J)
+          ELVMAX(I,J) = ZMAX(I,J) 
+        ENDDO
+      ENDDO
+
+! --- # of peaks > ZAVG value and ZMAX(IM,JM) -- ORO is already avg.
+! ---  to JM or to JM1
+!$omp parallel do
+!$omp* private (j,i,hc,lono,lato,jst,jen,ilist,numx,j1,ii1,i1,loni,
+!$omp*          lati,height)
+      DO J=1,JM
+!        print*, "J=", J 
+        DO I=1,IM
+          HC = 1116.2 - 0.878 * VAR(I,J) 
+          LONO(1) = lon_c(i,j) 
+          LONO(2) = lon_c(i+1,j) 
+          LONO(3) = lon_c(i+1,j+1) 
+          LONO(4) = lon_c(i,j+1) 
+          LATO(1) = lat_c(i,j) 
+          LATO(2) = lat_c(i+1,j) 
+          LATO(3) = lat_c(i+1,j+1) 
+          LATO(4) = lat_c(i,j+1) 
+          call get_index(IMN,JMN,4,LONO,LATO,DELXN,jst,jen,ilist,numx)
+          do j1 = jst, jen; do ii1 = 1, numx          
+            i1 = ilist(ii1)
+            LONI = i1*DELXN
+            LATI = -90 + j1*DELXN
+            if(inside_a_polygon(LONI*D2R,LATI*D2R,4,
+     &          LONO*D2R,LATO*D2R))then
+
+              HEIGHT = FLOAT(ZAVG(I1,J1))
+              IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+              IF ( HEIGHT .gt. ORO(I,J) ) then
+                 if ( HEIGHT .gt. ZMAX(I,J) )ZMAX(I,J) = HEIGHT
+              ENDIF   
+            endif
+          ENDDO ; ENDDO
+        ENDDO
+      ENDDO
+!$omp end parallel do      
+C
+! ---  this will make work1 array take on oro's values on return
+! ---  this will make work1 array take on oro's values on return
+      DO J=1,JM
+        DO I=1,IM
+
+          ORO1(I,J) = ORO(I,J)
+          ELVMAX(I,J) = ZMAX(I,J) 
+        ENDDO
+      ENDDO
+      
+      DO KWD = 1, 4
+        DO J=1,JM
+          DO I=1,IM
+            OA4(I,J,KWD) = 0.0
+            OL(I,J,KWD) = 0.0
+          ENDDO
+        ENDDO
+      ENDDO
+                                !
+! --- # of peaks > ZAVG value and ZMAX(IM,JM) -- ORO is already avg.
+C
+C---- CALCULATE THE 3D OROGRAPHIC ASYMMETRY FOR 4 WIND DIRECTIONS
+C---- AND THE 3D OROGRAPHIC SUBGRID OROGRAPHY FRACTION
+C     (KWD = 1  2  3  4)
+C     ( WD = W  S SW NW)
+C
+C
+!$omp parallel do
+!$omp* private (j,i,lon,lat,kwd,dlon,dlat,lon1,lon2,lat1,lat2,
+!$omp*          xnsum11,xnsum12,xnsum21,xnsum22,xnpu,xnpd,
+!$omp*          xnsum1_11,xnsum2_11,hc_11, xnsum1_12,xnsum2_12,
+!$omp*          hc_12,xnsum1_21,xnsum2_21,hc_21, xnsum1_22,
+!$omp*          xnsum2_22,hc_22)
+      DO J=1,JM
+!       print*, "j = ", j
+        DO I=1,IM
+          lon = lon_t(i,j)
+          lat = lat_t(i,j)
+          !--- for around north pole, oa and ol are all 0
+          
+          if(is_north_pole(i,j)) then
+             print*, "set oa1 = 0 and ol=0 at i,j=", i,j
+             do kwd = 1, 4
+                  oa4(i,j,kwd) = 0.
+                  ol(i,j,kwd) = 0.
+             enddo
+          else if(is_south_pole(i,j)) then
+             print*, "set oa1 = 0 and ol=1 at i,j=", i,j
+             do kwd = 1, 4
+                oa4(i,j,kwd) = 0.
+                ol(i,j,kwd) = 1.
+             enddo    
+          else
+             
+          !--- for each point, find a lat-lon grid box with same dx and dy as the cubic grid box
+          dlon = get_lon_angle(dx(i,j), lat*D2R, R2D  )
+          dlat = get_lat_angle(dy(i,j), R2D)
+          !--- adjust dlat if the points are close to pole.
+          if( lat-dlat*0.5<-90.) then
+             print*, "at i,j =", i,j, lat, dlat, lat-dlat*0.5
+             print*, "ERROR: lat-dlat*0.5<-90."
+             call ERREXIT(4)
+          endif
+          if( lat+dlat*2 > 90.) then
+             dlat_old = dlat
+             dlat = (90-lat)*0.5
+             print*, "at i,j=",i,j," adjust dlat from ",
+     &              dlat_old, " to ", dlat
+          endif   
+          !--- lower left 
+          lon1 = lon-dlon*1.5
+          lon2 = lon-dlon*0.5
+          lat1 = lat-dlat*0.5
+          lat2 = lat+dlat*0.5
+
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          xnsum11 = get_xnsum(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn)          
+
+          !--- upper left 
+          lon1 = lon-dlon*1.5
+          lon2 = lon-dlon*0.5
+          lat1 = lat+dlat*0.5
+          lat2 = lat+dlat*1.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          xnsum12 = get_xnsum(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn)          
+
+          !--- lower right
+          lon1 = lon-dlon*0.5
+          lon2 = lon+dlon*0.5
+          lat1 = lat-dlat*0.5
+          lat2 = lat+dlat*0.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          xnsum21 = get_xnsum(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn)          
+
+          !--- upper right 
+          lon1 = lon-dlon*0.5
+          lon2 = lon+dlon*0.5
+          lat1 = lat+dlat*0.5
+          lat2 = lat+dlat*1.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          
+          xnsum22 = get_xnsum(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn)          
+          
+           XNPU = xnsum11 + xnsum12
+           XNPD = xnsum21 + xnsum22
+           IF (XNPD .NE. XNPU) OA4(I,J,1) = 1. - XNPD / MAX(XNPU , 1.)
+
+           XNPU = xnsum11 + xnsum21
+           XNPD = xnsum12 + xnsum22
+           IF (XNPD .NE. XNPU) OA4(I,J,2) = 1. - XNPD / MAX(XNPU , 1.)
+
+           XNPU = xnsum11 + (xnsum12+xnsum21)*0.5
+           XNPD = xnsum22 + (xnsum12+xnsum21)*0.5
+           IF (XNPD .NE. XNPU) OA4(I,J,3) = 1. - XNPD / MAX(XNPU , 1.)
+
+           XNPU = xnsum12 + (xnsum11+xnsum22)*0.5
+           XNPD = xnsum21 + (xnsum11+xnsum22)*0.5
+           IF (XNPD .NE. XNPU) OA4(I,J,4) = 1. - XNPD / MAX(XNPU , 1.)
+
+           
+          !--- calculate OL3 and OL4
+          !--- lower left 
+          lon1 = lon-dlon*1.5
+          lon2 = lon-dlon*0.5
+          lat1 = lat-dlat*0.5
+          lat2 = lat+dlat*0.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif          
+          call get_xnsum2(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_11, xnsum2_11, HC_11)          
+
+          !--- upper left 
+          lon1 = lon-dlon*1.5
+          lon2 = lon-dlon*0.5
+          lat1 = lat+dlat*0.5
+          lat2 = lat+dlat*1.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          call get_xnsum2(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_12, xnsum2_12, HC_12)          
+
+          !--- lower right
+          lon1 = lon-dlon*0.5
+          lon2 = lon+dlon*0.5
+          lat1 = lat-dlat*0.5
+          lat2 = lat+dlat*0.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          call get_xnsum2(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_21, xnsum2_21, HC_21)          
+
+          !--- upper right 
+          lon1 = lon-dlon*0.5
+          lon2 = lon+dlon*0.5
+          lat1 = lat+dlat*0.5
+          lat2 = lat+dlat*1.5
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif          
+          call get_xnsum2(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_22, xnsum2_22, HC_22)           
+                  
+          OL(i,j,3) = (XNSUM1_22+XNSUM1_11)/(XNSUM2_22+XNSUM2_11)
+          OL(i,j,4) = (XNSUM1_12+XNSUM1_21)/(XNSUM2_12+XNSUM2_21)
+
+          !--- calculate OL1 and OL2
+          !--- lower left 
+          lon1 = lon-dlon*2.0
+          lon2 = lon-dlon
+          lat1 = lat
+          lat2 = lat+dlat
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          call get_xnsum3(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_11, xnsum2_11, HC_11)          
+
+          !--- upper left 
+          lon1 = lon-dlon*2.0
+          lon2 = lon-dlon
+          lat1 = lat+dlat
+          lat2 = lat+dlat*2.0
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower left i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          
+          call get_xnsum3(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_12, xnsum2_12, HC_12)          
+
+          !--- lower right
+          lon1 = lon-dlon
+          lon2 = lon
+          lat1 = lat
+          lat2 = lat+dlat
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at upper right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif          
+          call get_xnsum3(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_21, xnsum2_21, HC_21)          
+
+          !--- upper right 
+          lon1 = lon-dlon
+          lon2 = lon
+          lat1 = lat+dlat
+          lat2 = lat+dlat*2.0
+          if(lat1<-90 .or. lat2>90) then
+             print*, "at lower right i=,j=", i, j, lat, dlat,lat1,lat2
+          endif
+          
+          call get_xnsum3(lon1,lat1,lon2,lat2,IMN,JMN,GLAt,
+     &     zavg,zslm,delxn, xnsum1_22, xnsum2_22, HC_22)           
+                  
+          OL(i,j,1) = (XNSUM1_11+XNSUM1_21)/(XNSUM2_11+XNSUM2_21)
+          OL(i,j,2) = (XNSUM1_21+XNSUM1_22)/(XNSUM2_21+XNSUM2_22)         
+          ENDIF          
+        ENDDO
+      ENDDO
+!$omp end parallel do
+      DO KWD=1,4
+        DO J=1,JM
+          DO I=1,IM
+            T = OA4(I,J,KWD)
+            OA4(I,J,KWD) = SIGN( MIN( ABS(T), 1. ), T )
+          ENDDO
+        ENDDO
+      ENDDO
+C
+      NS0 = 0
+      NS1 = 0
+      NS2 = 0
+      NS3 = 0
+      NS4 = 0
+      NS5 = 0
+      NS6 = 0
+      DO KWD=1,4
+      DO J=1,JM
+      DO I=1,IM
+         T = ABS( OA4(I,J,KWD) )
+         IF(T .EQ. 0.) THEN
+            IOA4(I,J,KWD) = 0
+            NS0 = NS0 + 1
+         ELSE IF(T .GT. 0. .AND. T .LE. 1.) THEN
+            IOA4(I,J,KWD) = 1
+            NS1 = NS1 + 1
+         ELSE IF(T .GT. 1. .AND. T .LE. 10.) THEN
+            IOA4(I,J,KWD) = 2
+            NS2 = NS2 + 1
+         ELSE IF(T .GT. 10. .AND. T .LE. 100.) THEN
+            IOA4(I,J,KWD) = 3
+            NS3 = NS3 + 1
+         ELSE IF(T .GT. 100. .AND. T .LE. 1000.) THEN
+            IOA4(I,J,KWD) = 4
+            NS4 = NS4 + 1
+         ELSE IF(T .GT. 1000. .AND. T .LE. 10000.) THEN
+            IOA4(I,J,KWD) = 5
+            NS5 = NS5 + 1
+         ELSE IF(T .GT. 10000.) THEN
+            IOA4(I,J,KWD) = 6
+            NS6 = NS6 + 1
+         ENDIF
+      ENDDO
+      ENDDO
+      ENDDO
+C
+      WRITE(6,*) "! MAKEOA2 EXIT"
+C
+      RETURN
+      END
+
+
+C-----------------------------------------------------------------------
+      SUBROUTINE GL2ANY(IP,KM,G1,IM1,JM1,G2,IM2,JM2,IDRTI,RLON,RLAT)
+C$$$  SUBPROGRAM DOCUMENTATION BLOCK
+C
+C SUBPROGRAM:    GL2GL       INTERPOLATE GAUSSIAN GRID TO GAUSSIAN GRID
+C   PRGMMR: IREDELL          ORG: W/NMC23     DATE: 92-10-31
+C
+C ABSTRACT: LINEARLY INTERPOLATES GAUSSIAN GRID TO GAUSSIAN GRID.
+C
+C PROGRAM HISTORY LOG:
+C   91-10-31  MARK IREDELL
+C
+C USAGE:    CALL GL2GL(IP,KM,G1,IM1,JM1,G2,IM2,JM2)
+C   INPUT ARGUMENT LIST:
+C     IP           INTEGER INTERPOLATION TYPE
+C     KM           INTEGER NUMBER OF LEVELS
+C     G1           REAL (IM1,JM1,KM) INPUT GAUSSIAN FIELD
+C     IM1          INTEGER NUMBER OF INPUT LONGITUDES
+C     JM1          INTEGER NUMBER OF INPUT LATITUDES
+C     IM2          INTEGER NUMBER OF OUTPUT LONGITUDES
+C     JM2          INTEGER NUMBER OF OUTPUT LATITUDES
+C   OUTPUT ARGUMENT LIST:
+C     G2           REAL (IM2,JM2,KM) OUTPUT GAUSSIAN FIELD
+C
+C SUBPROGRAMS CALLED:
+C   IPOLATES     IREDELL'S POLATE FOR SCALAR FIELDS
+C
+C ATTRIBUTES:
+C   LANGUAGE: FORTRAN
+C
+CC$$$
+      REAL G1(IM1,JM1,KM),G2(IM2,JM2,KM)
+      LOGICAL*1 L1(IM1,JM1,KM),L2(IM2,JM2,KM)
+      REAL, intent(in) :: RLAT(IM2,JM2),RLON(IM2,JM2)
+      INTEGER IB1(KM),IB2(KM)
+      INTEGER KGDS1(200),KGDS2(200)
+      INTEGER IDRTI, IDRTO
+      DATA KGDS1/4,0,0,90000,0,0,-90000,193*0/
+      DATA KGDS2/4,0,0,90000,0,0,-90000,193*0/
+      INTEGER IPOPT(20)
+      DATA IPOPT/20*0/
+C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+      KGDS1(1) = IDRTI
+      KGDS2(1) = -1
+      NO = IM2*JM2
+      IF(IM1.NE.IM2.OR.JM1.NE.JM2) THEN
+        IB1=0
+        KGDS1(2)=IM1
+        KGDS1(3)=JM1
+        KGDS1(8)=NINT(-360000./IM1)
+        KGDS1(10)=JM1/2
+        KGDS2(2)=IM2
+        KGDS2(3)=JM2
+        KGDS2(8)=NINT(-360000./IM2)
+        KGDS2(10)=JM2/2
+        CALL IPOLATES(IP,IPOPT,KGDS1,KGDS2,IM1*JM1,IM2*JM2,KM,IB1,L1,G1,
+     &                NO,RLAT,RLON,IB2,L2,G2,IRET)
+      ELSE
+        G2=G1
+      ENDIF
+      END
+
+
+      function spherical_distance(theta1,phi1,theta2,phi2)
+
+      real, intent(in) :: theta1, phi1, theta2, phi2
+      real :: spherical_distance, dot
+
+      if(theta1 == theta2 .and. phi1 == phi2) then
+        spherical_distance = 0.0
+        return
+      endif
+  
+      dot = cos(phi1)*cos(phi2)*cos(theta1-theta2) + sin(phi1)*sin(phi2)
+      if(dot > 1. ) dot = 1.
+      if(dot < -1.) dot = -1.
+      spherical_distance = acos(dot)
+
+      return
+
+      end function spherical_distance
+      
+      subroutine get_mismatch_index(im_in, jm_in, geolon_in,geolat_in,
+     &           bitmap_in,num_out, lon_out,lat_out, iindx, jindx )
+      integer, intent(in) :: im_in, jm_in, num_out
+      real,    intent(in) :: geolon_in(im_in,jm_in)
+      real,    intent(in) :: geolat_in(im_in,jm_in)
+      logical*1, intent(in) :: bitmap_in(im_in,jm_in)   
+      real,    intent(in) :: lon_out(num_out), lat_out(num_out)
+      integer, intent(out):: iindx(num_out), jindx(num_out)
+      real, parameter :: MAX_DIST = 1.e+20
+      integer, parameter :: NUMNBR = 20
+      integer :: i_c,j_c,jstart,jend
+      real    :: lon,lat
+      
+      print*, "im_in,jm_in = ", im_in, jm_in
+      print*, "num_out = ", num_out
+      print*, "max and min of lon_in is", minval(geolon_in),
+     &                                    maxval(geolon_in)
+      print*, "max and min of lat_in is", minval(geolat_in),
+     &                                    maxval(geolat_in)   
+      print*, "max and min of lon_out is", minval(lon_out),
+     &                                     maxval(lon_out)
+      print*, "max and min of lat_out is", minval(lat_out),
+     &                                     maxval(lat_out)   
+      print*, "count(bitmap_in)= ", count(bitmap_in), MAX_DIST
+      
+      do n = 1, num_out
+        !      print*, "n = ", n
+        lon = lon_out(n)
+        lat = lat_out(n)
+        !--- find the j-index for the nearest point
+        i_c = 0; j_c = 0
+        do j = 1, jm_in-1
+          if(lat .LE. geolat_in(1,j) .and.
+     &       lat .GE. geolat_in(1,j+1)) then
+            j_c = j
+          endif
+        enddo
+        if(lat > geolat_in(1,1)) j_c = 1
+        if(lat < geolat_in(1,jm_in)) j_c = jm_in
+        !      print*, "lat =", lat, geolat_in(1,jm_in), geolat_in(1,jm_in-1)
+        ! The input is Gaussian grid.
+        jstart = max(j_c-NUMNBR,1)
+        jend = min(j_c+NUMNBR,jm_in)
+        dist = MAX_DIST
+        iindx(n) = 0
+        jindx(n) = 0
+        !      print*, "jstart, jend =", jstart, jend
+        do j = jstart, jend; do i = 1,im_in   
+          if(bitmap_in(i,j) ) then
+            !            print*, "bitmap_in is true"
+            d = spherical_distance(lon_out(n),lat_out(n),
+     &                             geolon_in(i,j), geolat_in(i,j))
+            if( dist > d ) then
+              iindx(n) = i; jindx(n) = j
+              dist = d
+            endif
+          endif
+        enddo; enddo
+        if(iindx(n) ==0) then
+          print*, "lon,lat=", lon,lat
+          print*, "jstart, jend=", jstart, jend, dist
+          print*, "ERROR in get mismatch_index: not find nearest points"
+          call ERREXIT(4)
+        endif
+      enddo   
+
+      end subroutine get_mismatch_index
+      
+
+      subroutine interpolate_mismatch(im_in, jm_in, data_in,
+     &                                num_out, data_out, iindx, jindx)
+      integer, intent(in) :: im_in, jm_in, num_out
+      real,    intent(in) :: data_in(im_in,jm_in)
+      real,    intent(out):: data_out(num_out)
+      integer, intent(in) :: iindx(num_out), jindx(num_out)
+      
+      do n = 1, num_out
+        data_out(n) = data_in(iindx(n),jindx(n))
+      enddo   
+
+      end subroutine interpolate_mismatch
+      
+      SUBROUTINE MAKEOA3(ZAVG,zslm,VAR,GLAT,OA4,OL,IOA4,ELVMAX,
+     1           ORO,SLM,oro1,XNSUM,XNSUM1,XNSUM2,XNSUM3,XNSUM4,
+     2           IM,JM,IMN,JMN,lon_c,lat_c,lon_t,lat_t,
+     3           is_south_pole,is_north_pole,IMI,JMI,OA_IN,OL_IN,
+     4           slm_in,lon_in,lat_in)
+      implicit none
+      real, parameter :: MISSING_VALUE = -9999.
+      real, parameter :: D2R = 3.14159265358979/180.
+      real, PARAMETER :: R2D=180./3.14159265358979
+      integer IM,JM,IMN,JMN,IMI,JMI
+      real    GLAT(JMN)
+      INTEGER ZAVG(IMN,JMN),ZSLM(IMN,JMN)
+      real    SLM(IM,JM)
+      real    ORO(IM,JM),ORO1(IM,JM),ELVMAX(IM,JM),ZMAX(IM,JM)
+      real    OA4(IM,JM,4)
+      integer IOA4(IM,JM,4)
+      real    OA_IN(IMI,JMI,4), OL_IN(IMI,JMI,4)
+      real    slm_in(IMI,JMI)
+      real    lon_in(IMI,JMI), lat_in(IMI,JMI)
+      real    lon_c(IM+1,JM+1), lat_c(IM+1,JM+1)
+      real    lon_t(IM,JM), lat_t(IM,JM)
+      logical is_south_pole(IM,JM), is_north_pole(IM,JM)
+      real    XNSUM(IM,JM),XNSUM1(IM,JM),XNSUM2(IM,JM)
+      real    XNSUM3(IM,JM),XNSUM4(IM,JM)
+      real    VAR(IM,JM),OL(IM,JM,4)
+      LOGICAL FLAG
+      integer i,j,ilist(IMN),numx,i1,j1,ii1
+      integer KWD,II,npts
+      real    LONO(4),LATO(4),LONI,LATI
+      real    DELXN,HC,HEIGHT,XNPU,XNPD,T
+      integer NS0,NS1,NS2,NS3,NS4,NS5,NS6
+      logical inside_a_polygon
+      real    lon,lat,dlon,dlat,dlat_old
+      real    lon1,lat1,lon2,lat2
+      real    xnsum11,xnsum12,xnsum21,xnsum22,xnsumx
+      real    HC_11, HC_12, HC_21, HC_22
+      real    xnsum1_11,xnsum1_12,xnsum1_21,xnsum1_22
+      real    xnsum2_11,xnsum2_12,xnsum2_21,xnsum2_22
+      real    get_lon_angle, get_lat_angle, get_xnsum
+      integer ist, ien, jst, jen
+      real    xland,xwatr,xl1,xs1,oroavg
+      integer int_opt, ipopt(20), kgds_input(200), kgds_output(200)
+      integer count_land_output
+      integer ij, ijmdl_output, iret, num_mismatch_land, num
+      integer ibo(1)
+      logical*1, allocatable :: bitmap_input(:,:)
+      logical*1, allocatable :: bitmap_output(:)
+      integer, allocatable :: ijsav_land_output(:)
+      real,    allocatable :: lats_land_output(:)
+      real,    allocatable :: lons_land_output(:)
+      real,    allocatable :: output_data_land(:)
+      real,    allocatable :: lons_mismatch_output(:)
+      real,    allocatable :: lats_mismatch_output(:)
+      real,    allocatable :: data_mismatch_output(:)
+      integer, allocatable :: iindx(:), jindx(:)
+C   
+C---- GLOBAL XLAT AND XLON ( DEGREE )
+C
+      DELXN = 360./IMN      ! MOUNTAIN DATA RESOLUTION
+C
+      ijmdl_output = IM*JM
+      
+      DO J=1,JMN
+         GLAT(J) = -90. + (J-1) * DELXN + DELXN * 0.5
+      ENDDO
+      print *,' IM=',IM,' JM=',JM,' IMN=',IMN,' JMN=',JMN
+C
+C---- FIND THE AVERAGE OF THE MODES IN A GRID BOX
+C
+C
+      DO J=1,JM
+        DO I=1,IM
+          XNSUM(I,J) = 0.0
+          ELVMAX(I,J) = ORO(I,J)
+          ZMAX(I,J)   = 0.0
+C---- COUNT NUMBER OF MODE. HIGHER THAN THE HC, CRITICAL HEIGHT
+C     IN A GRID BOX
+          XNSUM1(I,J) = 0.0
+          XNSUM2(I,J) = 0.0
+          XNSUM3(I,J) = 0.0
+          XNSUM4(I,J) = 0.0
+          ORO1(I,J) = ORO(I,J)
+          ELVMAX(I,J) = ZMAX(I,J) 
+        ENDDO
+      ENDDO
+
+! --- # of peaks > ZAVG value and ZMAX(IM,JM) -- ORO is already avg.
+! ---  to JM or to JM1
+      DO J=1,JM
+!        print*, "J=", J 
+        DO I=1,IM
+          HC = 1116.2 - 0.878 * VAR(I,J) 
+          LONO(1) = lon_c(i,j) 
+          LONO(2) = lon_c(i+1,j) 
+          LONO(3) = lon_c(i+1,j+1) 
+          LONO(4) = lon_c(i,j+1) 
+          LATO(1) = lat_c(i,j) 
+          LATO(2) = lat_c(i+1,j) 
+          LATO(3) = lat_c(i+1,j+1) 
+          LATO(4) = lat_c(i,j+1) 
+          call get_index(IMN,JMN,4,LONO,LATO,DELXN,jst,jen,ilist,numx)
+          do j1 = jst, jen; do ii1 = 1, numx          
+            i1 = ilist(ii1)
+            LONI = i1*DELXN
+            LATI = -90 + j1*DELXN
+            if(inside_a_polygon(LONI*D2R,LATI*D2R,4,
+     &          LONO*D2R,LATO*D2R))then
+
+              HEIGHT = FLOAT(ZAVG(I1,J1))
+              IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+              IF ( HEIGHT .gt. ORO(I,J) ) then
+                 if ( HEIGHT .gt. ZMAX(I,J) )ZMAX(I,J) = HEIGHT
+              ENDIF   
+            endif
+          ENDDO ; ENDDO
+        ENDDO
+      ENDDO
+      
+C
+! ---  this will make work1 array take on oro's values on return
+! ---  this will make work1 array take on oro's values on return
+      DO J=1,JM
+        DO I=1,IM
+
+          ORO1(I,J) = ORO(I,J)
+          ELVMAX(I,J) = ZMAX(I,J) 
+        ENDDO
+      ENDDO
+      
+      DO KWD = 1, 4
+        DO J=1,JM
+          DO I=1,IM
+            OA4(I,J,KWD) = 0.0
+            OL(I,J,KWD) = 0.0
+          ENDDO
+        ENDDO
+      ENDDO
+
+      !--- use the nearest point to do remapping.
+      int_opt = 2
+      ipopt=0
+      KGDS_INPUT = 0
+      KGDS_INPUT(1) = 4          ! OCT 6 - TYPE OF GRID (GAUSSIAN)
+      KGDS_INPUT(2) = IMI        ! OCT 7-8 - # PTS ON LATITUDE CIRCLE
+      KGDS_INPUT(3) = JMI        ! OCT 9-10 - # PTS ON LONGITUDE CIRCLE
+      KGDS_INPUT(4) = 90000      ! OCT 11-13 - LAT OF ORIGIN
+      KGDS_INPUT(5) = 0          ! OCT 14-16 - LON OF ORIGIN
+      KGDS_INPUT(6) = 128        ! OCT 17 - RESOLUTION FLAG
+      KGDS_INPUT(7) = -90000     ! OCT 18-20 - LAT OF EXTREME POINT
+      KGDS_INPUT(8) = NINT(-360000./IMI)  ! OCT 21-23 - LON OF EXTREME POINT
+      KGDS_INPUT(9)  = NINT((360.0 / FLOAT(IMI))*1000.0)
+                                 ! OCT 24-25 - LONGITUDE DIRECTION INCR.
+      KGDS_INPUT(10) = JMI /2    ! OCT 26-27 - NUMBER OF CIRCLES POLE TO EQUATOR
+      KGDS_INPUT(12) = 255       ! OCT 29 - RESERVED
+      KGDS_INPUT(20) = 255       ! OCT 5  - NOT USED, SET TO 255
+
+
+      KGDS_OUTPUT = -1
+!      KGDS_OUTPUT(1) = IDRT       ! OCT 6 - TYPE OF GRID (GAUSSIAN)
+      KGDS_OUTPUT(2) = IM        ! OCT 7-8 - # PTS ON LATITUDE CIRCLE
+      KGDS_OUTPUT(3) = JM        ! OCT 9-10 - # PTS ON LONGITUDE CIRCLE
+      KGDS_OUTPUT(4) = 90000      ! OCT 11-13 - LAT OF ORIGIN
+      KGDS_OUTPUT(5) = 0          ! OCT 14-16 - LON OF ORIGIN
+      KGDS_OUTPUT(6) = 128        ! OCT 17 - RESOLUTION FLAG
+      KGDS_OUTPUT(7) = -90000     ! OCT 18-20 - LAT OF EXTREME POINT
+      KGDS_OUTPUT(8) = NINT(-360000./IM)  ! OCT 21-23 - LON OF EXTREME POINT
+      KGDS_OUTPUT(9)  = NINT((360.0 / FLOAT(IM))*1000.0)
+                                  ! OCT 24-25 - LONGITUDE DIRECTION INCR.
+      KGDS_OUTPUT(10) = JM /2    ! OCT 26-27 - NUMBER OF CIRCLES POLE TO EQUATOR
+      KGDS_OUTPUT(12) = 255       ! OCT 29 - RESERVED
+      KGDS_OUTPUT(20) = 255       ! OCT 5  - NOT USED, SET TO 255
+
+      count_land_output=0    
+      print*, "sum(slm) = ", sum(slm)
+      do ij = 1, ijmdl_output
+        j = (ij-1)/IM + 1
+        i = mod(ij-1,IM) + 1         
+        if (slm(i,j) > 0.0) then
+          count_land_output=count_land_output+1
+        endif
+      enddo
+      allocate(bitmap_input(imi,jmi))
+      bitmap_input=.false.
+      print*, "number of land input=", sum(slm_in)
+      where(slm_in > 0.0) bitmap_input=.true.   
+      print*, "count(bitmap_input)", count(bitmap_input)
+      
+      allocate(bitmap_output(count_land_output))
+      allocate(output_data_land(count_land_output))
+      allocate(ijsav_land_output(count_land_output))
+      allocate(lats_land_output(count_land_output))
+      allocate(lons_land_output(count_land_output))
+
+      
+      
+      count_land_output=0
+      do ij = 1, ijmdl_output
+        j = (ij-1)/IM + 1
+        i = mod(ij-1,IM) + 1 
+        if (slm(i,j) > 0.0) then
+          count_land_output=count_land_output+1
+          ijsav_land_output(count_land_output)=ij
+          lats_land_output(count_land_output)=lat_t(i,j)
+          lons_land_output(count_land_output)=lon_t(i,j)
+        endif
+      enddo
+
+      oa4 = 0.0
+      ol = 0.0
+      
+      do KWD=1,4
+        bitmap_output = .false.
+         output_data_land = 0.0
+        call ipolates(int_opt, ipopt, kgds_input, kgds_output,   
+     &         (IMI*JMI), count_land_output,               
+     &          1, 1, bitmap_input, oa_in(:,:,KWD),  
+     &          count_land_output, lats_land_output,
+     &          lons_land_output, ibo,  
+     &          bitmap_output, output_data_land, iret)
+        if (iret /= 0) then
+          print*,'- ERROR IN IPOLATES ',iret
+          call ERREXIT(4)
+        endif
+
+        num_mismatch_land = 0     
+        do ij = 1, count_land_output
+          if (bitmap_output(ij)) then
+            j = (ijsav_land_output(ij)-1)/IM + 1
+            i = mod(ijsav_land_output(ij)-1,IM) + 1
+            oa4(i,j,KWD)=output_data_land(ij)
+          else  ! default value
+            num_mismatch_land =  num_mismatch_land + 1
+          endif
+        enddo  
+        print*, "num_mismatch_land = ", num_mismatch_land
+        
+        if(.not. allocated(data_mismatch_output)) then
+          allocate(lons_mismatch_output(num_mismatch_land))
+          allocate(lats_mismatch_output(num_mismatch_land))      
+          allocate(data_mismatch_output(num_mismatch_land))
+          allocate(iindx(num_mismatch_land))
+          allocate(jindx(num_mismatch_land))
+          
+          num = 0     
+          do ij = 1, count_land_output
+            if (.not. bitmap_output(ij)) then   
+              num = num+1
+              lons_mismatch_output(num) = lons_land_output(ij)
+              lats_mismatch_output(num) = lats_land_output(ij)
+            endif
+          enddo
+
+          ! For those land points that with bitmap_output=.false. use
+          ! the nearest land points to interpolate.
+          print*,"before get_mismatch_index", count(bitmap_input)
+          call get_mismatch_index(imi,jmi,lon_in*D2R,
+     &        lat_in*D2R,bitmap_input,num_mismatch_land, 
+     &        lons_mismatch_output*D2R,lats_mismatch_output*D2R,
+     &        iindx, jindx )
+        endif                
+ 
+        data_mismatch_output = 0
+        call interpolate_mismatch(imi,jmi,oa_in(:,:,KWD),
+     &        num_mismatch_land,data_mismatch_output,iindx,jindx)  
+       
+        num = 0
+        do ij = 1, count_land_output
+          if (.not. bitmap_output(ij)) then   
+            num = num+1
+            j = (ijsav_land_output(ij)-1)/IM + 1
+            i = mod(ijsav_land_output(ij)-1,IM) + 1
+            oa4(i,j,KWD) = data_mismatch_output(num)
+            if(i==372 .and. j== 611) then
+            print*, "ij=",ij, num, oa4(i,j,KWD),iindx(num),jindx(num)
+            endif
+          endif
+        enddo     
+       
+       
+      enddo
+
+      !OL
+      do KWD=1,4
+        bitmap_output = .false.
+        output_data_land = 0.0
+        call ipolates(int_opt, ipopt, kgds_input, kgds_output,   
+     &         (IMI*JMI), count_land_output,               
+     &          1, 1, bitmap_input, ol_in(:,:,KWD),  
+     &          count_land_output, lats_land_output,
+     &          lons_land_output, ibo,  
+     &          bitmap_output, output_data_land, iret)
+        if (iret /= 0) then
+          print*,'- ERROR IN IPOLATES ',iret
+          call ERREXIT(4)
+        endif
+
+        num_mismatch_land = 0     
+        do ij = 1, count_land_output
+          if (bitmap_output(ij)) then
+            j = (ijsav_land_output(ij)-1)/IM + 1
+            i = mod(ijsav_land_output(ij)-1,IM) + 1
+            ol(i,j,KWD)=output_data_land(ij)
+          else  ! default value
+            num_mismatch_land =  num_mismatch_land + 1
+          endif
+        enddo  
+        print*, "num_mismatch_land = ", num_mismatch_land
+        
+        data_mismatch_output = 0
+        call interpolate_mismatch(imi,jmi,ol_in(:,:,KWD),
+     &        num_mismatch_land,data_mismatch_output,iindx,jindx)  
+       
+        num = 0
+        do ij = 1, count_land_output
+          if (.not. bitmap_output(ij)) then   
+            num = num+1
+            j = (ijsav_land_output(ij)-1)/IM + 1
+            i = mod(ijsav_land_output(ij)-1,IM) + 1
+            ol(i,j,KWD) = data_mismatch_output(num)
+            if(i==372 .and. j== 611) then
+            print*, "ij=",ij, num, ol(i,j,KWD),iindx(num),jindx(num)
+            endif
+          endif
+        enddo     
+       
+       
+      enddo
+     
+      deallocate(lons_mismatch_output,lats_mismatch_output)
+      deallocate(data_mismatch_output,iindx,jindx)
+      deallocate(bitmap_output,output_data_land)
+      deallocate(ijsav_land_output,lats_land_output)
+      deallocate(lons_land_output)
+       
+      DO KWD=1,4
+        DO J=1,JM
+          DO I=1,IM
+            T = OA4(I,J,KWD)
+            OA4(I,J,KWD) = SIGN( MIN( ABS(T), 1. ), T )
+          ENDDO
+        ENDDO
+      ENDDO
+C
+      NS0 = 0
+      NS1 = 0
+      NS2 = 0
+      NS3 = 0
+      NS4 = 0
+      NS5 = 0
+      NS6 = 0
+      DO KWD=1,4
+      DO J=1,JM
+      DO I=1,IM
+         T = ABS( OA4(I,J,KWD) )
+         IF(T .EQ. 0.) THEN
+            IOA4(I,J,KWD) = 0
+            NS0 = NS0 + 1
+         ELSE IF(T .GT. 0. .AND. T .LE. 1.) THEN
+            IOA4(I,J,KWD) = 1
+            NS1 = NS1 + 1
+         ELSE IF(T .GT. 1. .AND. T .LE. 10.) THEN
+            IOA4(I,J,KWD) = 2
+            NS2 = NS2 + 1
+         ELSE IF(T .GT. 10. .AND. T .LE. 100.) THEN
+            IOA4(I,J,KWD) = 3
+            NS3 = NS3 + 1
+         ELSE IF(T .GT. 100. .AND. T .LE. 1000.) THEN
+            IOA4(I,J,KWD) = 4
+            NS4 = NS4 + 1
+         ELSE IF(T .GT. 1000. .AND. T .LE. 10000.) THEN
+            IOA4(I,J,KWD) = 5
+            NS5 = NS5 + 1
+         ELSE IF(T .GT. 10000.) THEN
+            IOA4(I,J,KWD) = 6
+            NS6 = NS6 + 1
+         ENDIF
+      ENDDO
+      ENDDO
+      ENDDO
+C
+      WRITE(6,*) "! MAKEOA3 EXIT"
+C
+      RETURN
+      END
+      
+      SUBROUTINE REVERS(IM, JM, numi, F, WRK)
+!
+      REAL F(IM,JM), WRK(IM,JM)
+      integer numi(jm)
+C
+C     reverse east-west and north-south
+c......  fix this routine up to take numi (*j*)
+C.....   at least have 5 variables ....and keep REVLAT .FALSE.
+       imb2 = im / 2
+      do i=1,im*jm
+         WRK(i,1) = F(i,1)
+      enddo
+      do j=1,jm
+         jr = jm - j + 1
+         do i=1,im
+            ir = i + imb2
+            if (ir .gt. im) ir = ir - im
+            f(ir,jr) = WRK(i,j)
+         enddo
+      enddo
+!
+      tem = 0.0
+      do i=1,im
+        tem= tem + F(I,1)
+      enddo
+      tem = tem / im
+      do i=1,im
+         F(I,1) = tem
+      enddo
+!
+      RETURN
+      END
+
+      subroutine rg2gg(im,jm,numi,a)
+        implicit none
+        integer,intent(in):: im,jm,numi(jm)
+        real,intent(inout):: a(im,jm)
+        integer j,ir,ig
+        real r,t(im)
+        do j=1,jm
+          r=real(numi(j))/real(im)
+          do ig=1,im
+            ir=mod(nint((ig-1)*r),numi(j))+1
+            t(ig)=a(ir,j)
+          enddo
+          do ig=1,im
+            a(ig,j)=t(ig)
+          enddo
+        enddo
+      end subroutine
+      subroutine gg2rg(im,jm,numi,a)
+        implicit none
+        integer,intent(in):: im,jm,numi(jm)
+        real,intent(inout):: a(im,jm)
+        integer j,ir,ig
+        real r,t(im)
+        do j=1,jm
+          r=real(numi(j))/real(im)
+          do ir=1,numi(j)
+            ig=nint((ir-1)/r)+1
+            t(ir)=a(ig,j)
+          enddo
+          do ir=1,numi(j)
+            a(ir,j)=t(ir)
+          enddo
+        enddo
+      end subroutine
+      SUBROUTINE minmxj(IM,JM,A,title)
+
+c this routine is using real*4 on the sp
+
+      implicit none
+
+      real A(IM,JM),rmin,rmax
+      integer i,j,IM,JM
+      character*8 title
+
+      rmin=1.e+10
+      rmax=-rmin
+csela....................................................
+csela if(rmin.eq.1.e+10)return
+csela....................................................
+      DO j=1,JM
+      DO i=1,IM
+        if(A(i,j).ge.rmax)rmax=A(i,j)
+        if(A(i,j).le.rmin)rmin=A(i,j)
+      ENDDO
+      ENDDO
+      write(6,150)rmin,rmax,title
+150   format('rmin=',e13.4,2x,'rmax=',e13.4,2x,a8,' ')
+C
+      RETURN
+      END
+      SUBROUTINE mnmxja(IM,JM,A,imax,jmax,title)
+
+c this routine is using real*4 on the sp
+
+      implicit none
+
+      real A(IM,JM),rmin,rmax
+      integer i,j,IM,JM,imax,jmax
+      character*8 title
+
+      rmin=1.e+10
+      rmax=-rmin
+csela....................................................
+csela if(rmin.eq.1.e+10)return
+csela....................................................
+      DO j=1,JM
+      DO i=1,IM
+        if(A(i,j).ge.rmax)then
+                         rmax=A(i,j)
+                        imax=i
+                        jmax=j
+        endif
+        if(A(i,j).le.rmin)rmin=A(i,j)
+      ENDDO
+      ENDDO
+      write(6,150)rmin,rmax,title
+150   format('rmin=',e13.4,2x,'rmax=',e13.4,2x,a8,' ')
+C
+      RETURN
+      END
+
+C-----------------------------------------------------------------------
+      SUBROUTINE SPFFT1(IMAX,INCW,INCG,KMAX,W,G,IDIR)
+C$$$  SUBPROGRAM DOCUMENTATION BLOCK
+C
+C SUBPROGRAM:  SPFFT1     PERFORM MULTIPLE FAST FOURIER TRANSFORMS
+C   PRGMMR: IREDELL       ORG: W/NMC23       DATE: 96-02-20
+C
+C ABSTRACT: THIS SUBPROGRAM PERFORMS MULTIPLE FAST FOURIER TRANSFORMS
+C           BETWEEN COMPLEX AMPLITUDES IN FOURIER SPACE AND REAL VALUES
+C           IN CYCLIC PHYSICAL SPACE.
+C           SUBPROGRAM SPFFT1 INITIALIZES TRIGONOMETRIC DATA EACH CALL.
+C           USE SUBPROGRAM SPFFT TO SAVE TIME AND INITIALIZE ONCE.
+C           THIS VERSION INVOKES THE IBM ESSL FFT.
+C
+C PROGRAM HISTORY LOG:
+C 1998-12-18  IREDELL
+C
+C USAGE:    CALL SPFFT1(IMAX,INCW,INCG,KMAX,W,G,IDIR)
+C
+C   INPUT ARGUMENT LIST:
+C     IMAX     - INTEGER NUMBER OF VALUES IN THE CYCLIC PHYSICAL SPACE
+C                (SEE LIMITATIONS ON IMAX IN REMARKS BELOW.)
+C     INCW     - INTEGER FIRST DIMENSION OF THE COMPLEX AMPLITUDE ARRAY
+C                (INCW >= IMAX/2+1)
+C     INCG     - INTEGER FIRST DIMENSION OF THE REAL VALUE ARRAY
+C                (INCG >= IMAX)
+C     KMAX     - INTEGER NUMBER OF TRANSFORMS TO PERFORM
+C     W        - COMPLEX(INCW,KMAX) COMPLEX AMPLITUDES IF IDIR>0
+C     G        - REAL(INCG,KMAX) REAL VALUES IF IDIR<0
+C     IDIR     - INTEGER DIRECTION FLAG
+C                IDIR>0 TO TRANSFORM FROM FOURIER TO PHYSICAL SPACE
+C                IDIR<0 TO TRANSFORM FROM PHYSICAL TO FOURIER SPACE
+C
+C   OUTPUT ARGUMENT LIST:
+C     W        - COMPLEX(INCW,KMAX) COMPLEX AMPLITUDES IF IDIR<0
+C     G        - REAL(INCG,KMAX) REAL VALUES IF IDIR>0
+C
+C SUBPROGRAMS CALLED:
+C   SCRFT        IBM ESSL COMPLEX TO REAL FOURIER TRANSFORM
+C   DCRFT        IBM ESSL COMPLEX TO REAL FOURIER TRANSFORM
+C   SRCFT        IBM ESSL REAL TO COMPLEX FOURIER TRANSFORM
+C   DRCFT        IBM ESSL REAL TO COMPLEX FOURIER TRANSFORM
+C
+C ATTRIBUTES:
+C   LANGUAGE: FORTRAN 90
+C
+C REMARKS:
+C   THE RESTRICTIONS ON IMAX ARE THAT IT MUST BE A MULTIPLE
+C   OF 1 TO 25 FACTORS OF TWO, UP TO 2 FACTORS OF THREE,
+C   AND UP TO 1 FACTOR OF FIVE, SEVEN AND ELEVEN.
+C
+C   THIS SUBPROGRAM IS THREAD-SAFE.
+C
+C$$$
+        IMPLICIT NONE
+        INTEGER,INTENT(IN):: IMAX,INCW,INCG,KMAX,IDIR
+        COMPLEX,INTENT(INOUT):: W(INCW,KMAX)
+        REAL,INTENT(INOUT):: G(INCG,KMAX)
+        REAL:: AUX1(25000+INT(0.82*IMAX))
+        REAL:: AUX2(20000+INT(0.57*IMAX))
+        INTEGER:: NAUX1,NAUX2
+C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+        NAUX1=25000+INT(0.82*IMAX)
+        NAUX2=20000+INT(0.57*IMAX)
+C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+C  FOURIER TO PHYSICAL TRANSFORM.
+        SELECT CASE(IDIR)
+        CASE(1:)
+          SELECT CASE(DIGITS(1.))
+          CASE(DIGITS(1._4))
+            CALL SCRFT(1,W,INCW,G,INCG,IMAX,KMAX,-1,1.,
+     &                 AUX1,NAUX1,AUX2,NAUX2,0.,0)
+            CALL SCRFT(0,W,INCW,G,INCG,IMAX,KMAX,-1,1.,
+     &                 AUX1,NAUX1,AUX2,NAUX2,0.,0)
+          CASE(DIGITS(1._8))
+            CALL DCRFT(1,W,INCW,G,INCG,IMAX,KMAX,-1,1.,
+     &                 AUX1,NAUX1,AUX2,NAUX2,0.,0)
+            CALL DCRFT(0,W,INCW,G,INCG,IMAX,KMAX,-1,1.,
+     &                 AUX1,NAUX1,AUX2,NAUX2,0.,0)
+          END SELECT
+C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+C  PHYSICAL TO FOURIER TRANSFORM.
+        CASE(:-1)
+          SELECT CASE(DIGITS(1.))
+          CASE(DIGITS(1._4))
+            CALL SRCFT(1,G,INCG,W,INCW,IMAX,KMAX,+1,1./IMAX,
+     &               AUX1,NAUX1,AUX2,NAUX2,0.,0)
+            CALL SRCFT(0,G,INCG,W,INCW,IMAX,KMAX,+1,1./IMAX,
+     &               AUX1,NAUX1,AUX2,NAUX2,0.,0)
+          CASE(DIGITS(1._8))
+            CALL DRCFT(1,G,INCG,W,INCW,IMAX,KMAX,+1,1./IMAX,
+     &               AUX1,NAUX1,AUX2,NAUX2,0.,0)
+            CALL DRCFT(0,G,INCG,W,INCW,IMAX,KMAX,+1,1./IMAX,
+     &               AUX1,NAUX1,AUX2,NAUX2,0.,0)
+          END SELECT
+        END SELECT
+      END SUBROUTINE
+      subroutine read_g(glob,ITOPO)
+!
+! --- if ITOPO = 1 then read gtopo30_gg.fine 43200X21600 30" file
+! --- if ITOPO = 2 then read  topo 30" .DEM tile files 
+! --- in either case, glob will be n Interger*2 array.
+! --- This routine write out a grads ctl file for displaying the 
+! --- tiles in the output working dir.  The glob array can not be 
+! --- acted on with grads, but the tiles can be if lat/lon are reduced slightly
+cc
+      implicit none
+cc
+      include 'machine.h'
+      include 'resevod.h'
+cc
+      integer*2    glob(360*120,180*120)
+cc
+      integer      ix,jx
+      integer      ia,ja
+cc
+      parameter   (ix=40*120,jx=50*120)
+      parameter   (ia=60*120,ja=30*120)
+cc
+      integer*2    idat(ix,jx)
+      integer      itopo
+cc
+ccmr  integer*2    m9999 
+ccmr  data         m9999    / -9999 /
+cc
+ccmr  integer      i_count(360*120)
+ccmr  integer      j_max_y(360*120)
+cc
+      integer      i,j,inttyp
+cc
+      real(kind=8) dloin,dlain,rlon,rlat
+cc
+      open(235, file="./fort.235", access='direct', recl=43200*21600*2)
+      read(235,rec=1)glob
+      close(235)
+cc
+cc
+      print*,' '
+      call maxmin     (glob,360*120*180*120,'global0')
+cc
+cc
+      dloin=1.d0/120.d0
+      dlain=1.d0/120.d0
+cc
+      rlon= -179.995833333333333333333333d0
+      rlat=   89.995833333333333333333333d0
+cc
+      inttyp=-1  !  average rectangular subset
+ccmr  inttyp= 1  !  take closest grid point value
+ccmr  inttyp= 0  !  interpolate from four closest grid point values
+cc
+!     call la2ga_gtopo30(glob,360*120,180*120,
+!    &           dloin,dlain,rlon,rlat,inttyp,
+!    &           .true.,glob,
+!    &           0,lonf,latg)
+cc
+      return
+      end
+      subroutine maxmin(ia,len,tile)
+ccmr
+      implicit none
+ccmr
+      integer*2 ia(len)
+      character*7 tile
+      integer iaamax, iaamin, len, j, m, ja, kount
+      integer(8) sum2,std,mean,isum
+      integer i_count_notset,kount_9
+! --- missing is -9999
+c
+      isum = 0
+      sum2 = 0
+      kount = 0
+      kount_9 = 0
+      iaamax = -9999999
+ccmr  iaamin = 1
+      iaamin =  9999999
+      i_count_notset=0
+           do 10 m=1,len
+      ja=ia(m)
+ccmr  if ( ja .lt. 0 ) print *,' ja < 0:',ja
+ccmr  if ( ja .eq. -9999 ) goto 10
+      if ( ja .eq. -9999 ) then
+           kount_9=kount_9+1
+           goto 10
+      endif
+      if ( ja .eq. -12345 ) i_count_notset=i_count_notset+1
+ccmr  if ( ja .eq. 0 ) goto 11
+      iaamax = max0( iaamax, ja )
+      iaamin = min0( iaamin, ja )
+!     iaamax = max0( iaamax, ia(m,j) )
+!     iaamin = min0( iaamin, ia(m,j) )
+  11  continue
+      kount = kount + 1
+      isum = isum + ja
+ccmr  sum2 = sum2 + ifix( float(ja) * float(ja) )
+      sum2 = sum2 + ja*ja
+  10  continue
+!
+      mean = isum/kount
+      std = ifix(sqrt(float((sum2/(kount))-mean**2)))
+      print*,tile,' max=',iaamax,' min=',iaamin,' sum=',isum,
+     &       ' i_count_notset=',i_count_notset
+      print*,tile,' mean=',mean,' std.dev=',std,
+     &       ' ko9s=',kount,kount_9,kount+kount_9 
+      return
+      end
+      SUBROUTINE minmaxj(IM,JM,A,title)
+
+c this routine is using real*4 on the sp
+
+      implicit none
+
+      real(kind=4) A(IM,JM),rmin,rmax,undef
+      integer i,j,IM,JM,imax,jmax,imin,jmin,iundef
+      character*8 title,chara
+      data chara/'        '/
+      chara=title
+      rmin=1.e+10
+      rmax=-rmin
+      imax=0
+      imin=0
+      jmax=0
+      jmin=0
+      iundef=0
+      undef=-9999.
+csela....................................................
+csela if(rmin.eq.1.e+10)return
+csela....................................................
+      DO j=1,JM
+      DO i=1,IM
+        if(A(i,j).ge.rmax)then
+                        rmax=A(i,j)
+                       imax=i
+                       jmax=j
+        endif
+         if(A(i,j).le.rmin)then
+            if ( A(i,j) .eq. undef ) then
+                iundef = iundef + 1
+            else
+                        rmin=A(i,j)
+                       imin=i
+                       jmin=j
+            endif
+        endif
+      ENDDO
+      ENDDO
+      write(6,150)chara,rmin,imin,jmin,rmax,imax,jmax,iundef
+150   format(1x,a8,2x,'rmin=',e13.4,2i6,2x,'rmax=',e13.4,3i6)
+C
+      RETURN
+      END
+
+      
+      !routine to map (lon, lat) to (x,y,z)
+      subroutine latlon2xyz(siz,lon, lat, x, y, z)
+      implicit none
+      integer, intent(in) :: siz
+      real, intent(in) :: lon(siz), lat(siz)
+      real, intent(out) :: x(siz), y(siz), z(siz)
+      
+      integer n
+
+      do n = 1, siz
+        x(n) = cos(lat(n))*cos(lon(n))
+        y(n) = cos(lat(n))*sin(lon(n))
+        z(n) = sin(lat(n))
+      enddo
+      end
+
+      FUNCTION spherical_angle(v1, v2, v3)
+        implicit none
+        real, parameter :: EPSLN30 = 1.e-30
+        real, parameter :: PI=3.1415926535897931
+        real v1(3), v2(3), v3(3)
+        real  spherical_angle
+ 
+        real px, py, pz, qx, qy, qz, ddd;
+  
+        ! vector product between v1 and v2 
+        px = v1(2)*v2(3) - v1(3)*v2(2)
+        py = v1(3)*v2(1) - v1(1)*v2(3)
+        pz = v1(1)*v2(2) - v1(2)*v2(1)
+        ! vector product between v1 and v3 
+        qx = v1(2)*v3(3) - v1(3)*v3(2);
+        qy = v1(3)*v3(1) - v1(1)*v3(3);
+        qz = v1(1)*v3(2) - v1(2)*v3(1);
+
+        ddd = (px*px+py*py+pz*pz)*(qx*qx+qy*qy+qz*qz);
+        if ( ddd <= 0.0 ) then
+          spherical_angle = 0. 
+        else 
+          ddd = (px*qx+py*qy+pz*qz) / sqrt(ddd);
+          if( abs(ddd-1) < EPSLN30 ) ddd = 1;
+          if( abs(ddd+1) < EPSLN30 ) ddd = -1;
+          if ( ddd>1. .or. ddd<-1. ) then
+            !FIX to correctly handle co-linear points (angle near pi or 0) */
+            if (ddd < 0.) then
+              spherical_angle = PI
+            else
+              spherical_angle = 0.
+            endif
+          else
+            spherical_angle = acos( ddd )
+          endif
+        endif  
+
+        return
+      END  
+      
+      FUNCTION inside_a_polygon(lon1, lat1, npts, lon2, lat2)
+        implicit none
+        real, parameter :: EPSLN10 = 1.e-10
+        real, parameter :: EPSLN8 = 1.e-8
+        real, parameter :: PI=3.1415926535897931
+        real, parameter :: RANGE_CHECK_CRITERIA=0.05
+        real :: anglesum, angle, spherical_angle
+        integer i, ip1
+        real lon1, lat1
+        integer npts
+        real lon2(npts), lat2(npts)
+        real x2(npts), y2(npts), z2(npts)
+        real lon1_1d(1), lat1_1d(1)
+        real x1(1), y1(1), z1(1)
+        real pnt0(3),pnt1(3),pnt2(3)
+        logical inside_a_polygon
+        real max_x2,min_x2,max_y2,min_y2,max_z2,min_z2
+        !first convert to cartesian grid */
+        call latlon2xyz(npts,lon2, lat2, x2, y2, z2);
+        lon1_1d(1) = lon1
+        lat1_1d(1) = lat1
+        call latlon2xyz(1,lon1_1d, lat1_1d, x1, y1, z1);
+        inside_a_polygon = .false.
+        max_x2 = maxval(x2)
+        if( x1(1) > max_x2+RANGE_CHECK_CRITERIA ) return
+        min_x2 = minval(x2)
+        if( x1(1)+RANGE_CHECK_CRITERIA < min_x2 ) return
+        max_y2 = maxval(y2)
+        if( y1(1) > max_y2+RANGE_CHECK_CRITERIA ) return
+        min_y2 = minval(y2)
+        if( y1(1)+RANGE_CHECK_CRITERIA < min_y2 ) return
+        max_z2 = maxval(z2)
+        if( z1(1) > max_z2+RANGE_CHECK_CRITERIA ) return
+        min_z2 = minval(z2)
+        if( z1(1)+RANGE_CHECK_CRITERIA < min_z2 ) return
+
+        pnt0(1) = x1(1)
+        pnt0(2) = y1(1)
+        pnt0(3) = z1(1)
+        
+        anglesum = 0;
+        do i = 1, npts
+           if(abs(x1(1)-x2(i)) < EPSLN10 .and.
+     &          abs(y1(1)-y2(i)) < EPSLN10 .and.
+     &         abs(z1(1)-z2(i)) < EPSLN10 ) then ! same as the corner point
+              inside_a_polygon = .true.
+              return
+           endif
+           ip1 = i+1
+           if(ip1>npts) ip1 = 1
+           pnt1(1) = x2(i)
+           pnt1(2) = y2(i)
+           pnt1(3) = z2(i)
+           pnt2(1) = x2(ip1)
+           pnt2(2) = y2(ip1)
+           pnt2(3) = z2(ip1)
+
+           angle = spherical_angle(pnt0, pnt2, pnt1);
+!           anglesum = anglesum + spherical_angle(pnt0, pnt2, pnt1);
+           anglesum = anglesum + angle
+        enddo
+
+        if(abs(anglesum-2*PI) < EPSLN8) then
+           inside_a_polygon = .true.
+        else
+           inside_a_polygon = .false.
+        endif
+
+        return
+        
+      end
+
+
+      function get_xnsum(lon1,lat1,lon2,lat2,IMN,JMN,
+     &                   glat,zavg,zslm,delxn)
+        implicit none
+
+        real get_xnsum
+        logical verbose
+        real lon1,lat1,lon2,lat2,oro,delxn
+        integer IMN,JMN
+        real    glat(JMN)
+        integer zavg(IMN,JMN),zslm(IMN,JMN)
+        integer i, j, ist, ien, jst, jen, i1
+        real    HEIGHT
+        real    xland,xwatr,xl1,xs1,slm,xnsum
+        !---figure out ist,ien,jst,jen
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat1 ) then
+              jst = j
+              exit
+           endif
+        enddo
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat2 ) then
+              jen = j
+              exit
+           endif
+        enddo
+
+        
+        ist = lon1/delxn + 1
+        ien = lon2/delxn
+        if(ist .le.0) ist = ist + IMN
+        if(ien < ist) ien = ien + IMN
+!        if(verbose) print*, "ist,ien=",ist,ien,jst,jen
+
+        !--- compute average oro
+          oro = 0.0
+          xnsum = 0
+          xland = 0
+          xwatr = 0
+          xl1 = 0
+          xs1 = 0
+          do j = jst,jen
+             do i1 = 1, ien - ist + 1
+                i = ist + i1 -1
+                if( i .LE. 0) i = i + imn
+                if( i .GT. IMN) i = i - imn
+                XLAND = XLAND + FLOAT(ZSLM(I,J))
+                XWATR = XWATR + FLOAT(1-ZSLM(I,J))
+                XNSUM = XNSUM + 1.
+                HEIGHT = FLOAT(ZAVG(I,J)) 
+                IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                XL1 = XL1 + HEIGHT * FLOAT(ZSLM(I,J))
+                XS1 = XS1 + HEIGHT * FLOAT(1-ZSLM(I,J))
+             enddo
+          enddo
+          if( XNSUM > 1.) THEN
+             SLM = FLOAT(NINT(XLAND/XNSUM))
+               IF(SLM.NE.0.) THEN
+                  ORO= XL1 / XLAND
+               ELSE
+                  ORO = XS1 / XWATR
+               ENDIF
+          ENDIF
+          
+         get_xnsum = 0
+         do j = jst, jen
+            do i1= 1, ien-ist+1
+               i = ist + i1 -1
+               if( i .LE. 0) i = i + imn
+               if( i .GT. IMN) i = i - imn
+               HEIGHT = FLOAT(ZAVG(I,J))
+               IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+               IF ( HEIGHT .gt. ORO ) get_xnsum = get_xnsum + 1
+            enddo       
+         enddo
+!         if(verbose) print*, "get_xnsum=", get_xnsum, oro
+         
+      end function get_xnsum  
+      
+
+      subroutine get_xnsum2(lon1,lat1,lon2,lat2,IMN,JMN,
+     &                   glat,zavg,zslm,delxn,xnsum1,xnsum2,HC)
+        implicit none
+
+        real, intent(out) :: xnsum1,xnsum2,HC
+        logical verbose
+        real lon1,lat1,lon2,lat2,oro,delxn
+        integer IMN,JMN
+        real    glat(JMN)
+        integer zavg(IMN,JMN),zslm(IMN,JMN)
+        integer i, j, ist, ien, jst, jen, i1
+        real    HEIGHT, var
+        real    XW1,XW2,slm,xnsum
+        !---figure out ist,ien,jst,jen
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat1 ) then
+              jst = j
+              exit
+           endif
+        enddo
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat2 ) then
+              jen = j
+              exit
+           endif
+        enddo
+
+        
+        ist = lon1/delxn + 1
+        ien = lon2/delxn
+        if(ist .le.0) ist = ist + IMN
+        if(ien < ist) ien = ien + IMN
+!        if(verbose) print*, "ist,ien=",ist,ien,jst,jen
+
+        !--- compute average oro
+          xnsum = 0
+          XW1 = 0
+          XW2 = 0
+          do j = jst,jen
+             do i1 = 1, ien - ist + 1
+                i = ist + i1 -1
+                if( i .LE. 0) i = i + imn
+                if( i .GT. IMN) i = i - imn
+                XNSUM = XNSUM + 1.
+                HEIGHT = FLOAT(ZAVG(I,J)) 
+                IF(HEIGHT.LT.-990.) HEIGHT = 0.0
+                XW1 = XW1 + HEIGHT
+                XW2 = XW2 + HEIGHT ** 2
+             enddo
+          enddo
+          var = SQRT(MAX(XW2/XNSUM-(XW1/XNSUM)**2,0.))
+          HC = 1116.2 - 0.878 * VAR
+         xnsum1 = 0
+         xnsum2 = 0
+         do j = jst, jen
+            do i1= 1, ien-ist+1
+               i = ist + i1 -1
+               if( i .LE. 0) i = i + imn
+               if( i .GT. IMN) i = i - imn
+               HEIGHT = FLOAT(ZAVG(I,J))
+               IF ( HEIGHT .gt. HC ) xnsum1 = xnsum1 + 1
+                xnsum2 = xnsum2 + 1
+            enddo       
+         enddo
+         
+      end subroutine get_xnsum2 
+
+
+      subroutine get_xnsum3(lon1,lat1,lon2,lat2,IMN,JMN,
+     &                   glat,zavg,zslm,delxn,xnsum1,xnsum2,HC)
+        implicit none
+
+        real, intent(out) :: xnsum1,xnsum2
+        real lon1,lat1,lon2,lat2,oro,delxn
+        integer IMN,JMN
+        real    glat(JMN)
+        integer zavg(IMN,JMN),zslm(IMN,JMN)
+        integer i, j, ist, ien, jst, jen, i1
+        real    HEIGHT, HC
+        real    XW1,XW2,slm,xnsum
+        !---figure out ist,ien,jst,jen
+        ! if lat1 or lat 2 is 90 degree. set jst = JMN
+        jst = JMN
+        jen = JMN
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat1 ) then
+              jst = j
+              exit
+           endif
+        enddo
+        do j = 1, JMN
+           if( GLAT(J) .GT. lat2 ) then
+              jen = j
+              exit
+           endif
+        enddo
+
+        
+        ist = lon1/delxn + 1
+        ien = lon2/delxn
+        if(ist .le.0) ist = ist + IMN
+        if(ien < ist) ien = ien + IMN
+!        if(verbose) print*, "ist,ien=",ist,ien,jst,jen
+
+         xnsum1 = 0
+         xnsum2 = 0
+         do j = jst, jen
+            do i1= 1, ien-ist+1
+               i = ist + i1 -1
+               if( i .LE. 0) i = i + imn
+               if( i .GT. IMN) i = i - imn
+               HEIGHT = FLOAT(ZAVG(I,J))
+               IF ( HEIGHT .gt. HC ) xnsum1 = xnsum1 + 1
+                xnsum2 = xnsum2 + 1
+            enddo       
+         enddo
+         
+      end subroutine get_xnsum3
+      
+      subroutine nanc(a,l,c)
+c compiler opt TRAPS= -qinitauto=FF911299 -qflttrap=ov:zero:inv:en -qsig trap
+c or call subroutine below
+c subroutine to report NaNS and NaNQ within an address
+c range for real*8 words.
+c  as written the routine prints a single line for each call
+c  and prints a message and returns to the caller  on detection of the FIRST
+c  NaN in the range.  The message is passed in the  third
+c  argument.  If no NaN values are found it returns silently.
+c  A real*4 version can be created by making A real*4
+
+c    arguments (all are input only)
+c
+c    A   real*8 variable or array
+c    L   number of words to scan (length of array)
+c    C   distinctive message set in caller to indicate where
+c        the routine was called.
+c 
+      integer inan1,inan2,inan3,inan4,inaq1,inaq2,inaq3,inaq4
+       real word
+       integer itest
+       equivalence (itest,word)
+c
+c signaling NaN
+      data inan1/x'7F800001'/
+      data inan2/x'7FBFFFFF'/
+      data inan3/x'FF800001'/
+      data inan4/x'FFBFFFFF'/
+c
+c  quiet NaN
+c
+      data inaq1/x'7FC00000'/
+      data inaq2/x'7FFFFFFF'/
+      data inaq3/x'FFC00000'/
+      data inaq4/x'FFFFFFFF'/
+c
+      real(kind=8)a(l),rtc,t1,t2
+      character*24 cn
+      character*(*) c
+c     t1=rtc()
+cgwv        print *, ' nanc call ',c
+      do k=1,l
+      word=a(k)
+       if( (itest  .GE. inan1 .AND. itest .LE. inan2) .OR.
+     *      (itest  .GE. inan3 .AND. itest .LE. inan4) ) then
+       print *,' NaNs detected at  word',k,' ',c
+       return
+         endif
+        if( (itest  .GE. inaq1 .AND. itest .LE. inaq2) .OR.
+     *      (itest  .GE. inaq3 .AND. itest .LE. inaq4) ) then
+       print *,' NaNq detected at  word',k,' ',c
+         return
+           endif
+
+ 101  format(e20.10)
+      end do
+c     t2=rtc()
+cgwv      print 102,l,t2-t1,c
+ 102  format(' time to check ',i9,' words is ',f10.4,' ',a24)
+      return
+       end
+      real function timef()
+      character(8) :: date
+      character(10) :: time
+      character(5) :: zone
+      integer,dimension(8) :: values
+      integer :: total
+      real :: elapsed
+      call date_and_time(date,time,zone,values)
+      total=(3600*values(5))+(60*values(6))
+     *      +values(7)
+      elapsed=float(total) + (1.0e-3*float(values(8)))
+      timef=elapsed
+      return
+      end
diff --git a/sorc/orog.fd/netcdf_io.F90 b/sorc/orog.fd/netcdf_io.F90
new file mode 100755
index 0000000..558945f
--- /dev/null
+++ b/sorc/orog.fd/netcdf_io.F90
@@ -0,0 +1,207 @@
+!-------------------------------------------------------------------------------
+! write out data in netcdf format
+  subroutine write_netcdf(im, jm, slm, land_frac, oro, orf, hprime, ntiles, tile, geolon, geolat, lon, lat)
+    implicit none
+    integer, intent(in):: im, jm, ntiles, tile
+    real, intent(in) :: lon(im), lat(jm)
+    real, intent(in), dimension(im,jm)  :: slm, oro, orf, geolon, geolat, land_frac
+    real, intent(in), dimension(im,jm,14):: hprime
+    character(len=128) :: outfile
+    integer            :: error, ncid, i
+    integer            :: header_buffer_val = 16384      
+    integer            :: fsize=65536, inital = 0  
+    integer            :: dim1, dim2
+    integer            :: dim_lon, dim_lat
+    integer            :: id_geolon,id_geolat
+    integer            :: id_slmsk,id_orog_raw,id_orog_filt,id_land_frac
+    integer            :: id_stddev,id_convex
+    integer            :: id_oa1,id_oa2,id_oa3,id_oa4
+    integer            :: id_ol1,id_ol2,id_ol3,id_ol4
+    integer            :: id_theta,id_gamma,id_sigma,id_elvmax
+    include "netcdf.inc"
+
+    if(ntiles > 1) then
+      write(outfile, '(a,i4.4,a)') 'out.oro.tile', tile, '.nc'
+    else
+      outfile = "out.oro.nc"
+    endif
+
+    dim1=size(lon,1)
+    dim2=size(lat,1)
+    write(6,*) ' netcdf dims are: ',dim1, dim2
+      
+    !--- open the file
+    error = NF__CREATE(outfile, IOR(NF_NETCDF4,NF_CLASSIC_MODEL), inital, fsize, ncid)
+    call netcdf_err(error, 'Creating file '//trim(outfile) )
+    !--- define dimension
+    error = nf_def_dim(ncid, 'lon', dim1, dim_lon)
+    call netcdf_err(error, 'define dimension lon for file='//trim(outfile) )
+    error = nf_def_dim(ncid, 'lat', dim2, dim_lat)
+    call netcdf_err(error, 'define dimension lat for file='//trim(outfile) )  
+
+    !--- define field
+!---geolon
+    error = nf_def_var(ncid, 'geolon', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_geolon)
+    call netcdf_err(error, 'define var geolon for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_geolon, "long_name", 9, "Longitude")
+    call netcdf_err(error, 'define geolon name for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_geolon, "units", 12, "degrees_east")
+    call netcdf_err(error, 'define geolon units for file='//trim(outfile) )
+!---geolat
+    error = nf_def_var(ncid, 'geolat', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_geolat)
+    call netcdf_err(error, 'define var geolat for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_geolat, "long_name", 8, "Latitude")
+    call netcdf_err(error, 'define geolat name for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_geolat, "units", 13, "degrees_north")
+    call netcdf_err(error, 'define geolat units for file='//trim(outfile) )
+!---slmsk
+    error = nf_def_var(ncid, 'slmsk', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_slmsk)
+    call netcdf_err(error, 'define var slmsk for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_slmsk, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define slmsk coordinates for file='//trim(outfile) )
+!--- land_frac
+    error = nf_def_var(ncid, 'land_frac', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_land_frac)
+    call netcdf_err(error, 'define var land_frac for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_land_frac, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define land_frac coordinates for file='//trim(outfile) )
+!---orography - raw
+    error = nf_def_var(ncid, 'orog_raw', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_orog_raw)
+    call netcdf_err(error, 'define var orog_raw for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_orog_raw, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define orog_raw coordinates for file='//trim(outfile) )
+!---orography - filtered
+    error = nf_def_var(ncid, 'orog_filt', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_orog_filt)
+    call netcdf_err(error, 'define var orog_filt for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_orog_filt, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define orog_filt coordinates for file='//trim(outfile) )
+!---stddev
+    error = nf_def_var(ncid, 'stddev', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_stddev)
+    call netcdf_err(error, 'define var stddev for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_stddev, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define stddev coordinates for file='//trim(outfile) )
+!---convexity
+    error = nf_def_var(ncid, 'convexity', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_convex)
+    call netcdf_err(error, 'define var convexity for file='//trim(outfile) )      
+    error = nf_put_att_text(ncid, id_convex, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define convexity coordinates for file='//trim(outfile) )
+!---oa1 -> oa4
+    error = nf_def_var(ncid, 'oa1', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_oa1)
+    call netcdf_err(error, 'define var oa1 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_oa1, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define oa1 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'oa2', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_oa2)
+    call netcdf_err(error, 'define var oa2 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_oa2, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define oa2 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'oa3', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_oa3)
+    call netcdf_err(error, 'define var oa3 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_oa3, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define oa3 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'oa4', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_oa4)
+    call netcdf_err(error, 'define var oa4 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_oa4, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define oa4 coordinates for file='//trim(outfile) )
+!---ol1 -> ol4
+    error = nf_def_var(ncid, 'ol1', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_ol1)
+    call netcdf_err(error, 'define var ol1 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_ol1, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define ol1 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'ol2', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_ol2)
+    call netcdf_err(error, 'define var ol2 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_ol2, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define ol2 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'ol3', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_ol3)
+    call netcdf_err(error, 'define var ol3 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_ol3, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define ol3 coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'ol4', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_ol4)
+    call netcdf_err(error, 'define var ol4 for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_ol4, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define ol4 coordinates for file='//trim(outfile) )
+!---theta gamma sigma elvmax
+    error = nf_def_var(ncid, 'theta', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_theta)
+    call netcdf_err(error, 'define var theta for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_theta, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define theta coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'gamma', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_gamma)
+    call netcdf_err(error, 'define var gamma for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_gamma, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define gamma coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'sigma', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_sigma)
+    call netcdf_err(error, 'define var sigma for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_sigma, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define sigma coordinates for file='//trim(outfile) )
+    error = nf_def_var(ncid, 'elvmax', NF_FLOAT, 2, (/dim_lon,dim_lat/), id_elvmax)
+    call netcdf_err(error, 'define var elvmax for file='//trim(outfile) )
+    error = nf_put_att_text(ncid, id_elvmax, "coordinates", 13, "geolon geolat")
+    call netcdf_err(error, 'define elvmax coordinates for file='//trim(outfile) )
+
+    error = nf__enddef(ncid, header_buffer_val,4,0,4)
+    call netcdf_err(error, 'end meta define for file='//trim(outfile) )
+      
+    !--- write out data
+    error = nf_put_var_double( ncid, id_geolon, geolon(:dim1,:dim2))
+    call netcdf_err(error, 'write var geolon for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_geolat, geolat(:dim1,:dim2))
+    call netcdf_err(error, 'write var geolat for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_slmsk, slm(:dim1,:dim2))
+    call netcdf_err(error, 'write var slmsk for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_land_frac, land_frac(:dim1,:dim2))
+    call netcdf_err(error, 'write var land_frac for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_orog_raw, oro(:dim1,:dim2))
+    call netcdf_err(error, 'write var orog_raw for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_orog_filt, orf(:dim1,:dim2))
+    call netcdf_err(error, 'write var orog_filt for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_stddev, hprime(:dim1,:dim2,1))
+    call netcdf_err(error, 'write var stddev for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_convex, hprime(:dim1,:dim2,2))
+    call netcdf_err(error, 'write var convex for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_oa1, hprime(:dim1,:dim2,3))
+    call netcdf_err(error, 'write var oa1 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_oa2, hprime(:dim1,:dim2,4))
+    call netcdf_err(error, 'write var oa2 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_oa3, hprime(:dim1,:dim2,5))
+    call netcdf_err(error, 'write var oa3 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_oa4, hprime(:dim1,:dim2,6))
+    call netcdf_err(error, 'write var oa4 for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_ol1, hprime(:dim1,:dim2,7))
+    call netcdf_err(error, 'write var ol1 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_ol2, hprime(:dim1,:dim2,8))
+    call netcdf_err(error, 'write var ol2 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_ol3, hprime(:dim1,:dim2,9))
+    call netcdf_err(error, 'write var ol3 for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_ol4, hprime(:dim1,:dim2,10))
+    call netcdf_err(error, 'write var ol4 for file='//trim(outfile) )
+
+    error = nf_put_var_double( ncid, id_theta, hprime(:dim1,:dim2,11))
+    call netcdf_err(error, 'write var theta for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_gamma, hprime(:dim1,:dim2,12))
+    call netcdf_err(error, 'write var gamma for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_sigma, hprime(:dim1,:dim2,13))
+    call netcdf_err(error, 'write var sigma for file='//trim(outfile) )
+    error = nf_put_var_double( ncid, id_elvmax, hprime(:dim1,:dim2,14))
+    call netcdf_err(error, 'write var elvmax for file='//trim(outfile) )
+
+    error = nf_close(ncid) 
+    call netcdf_err(error, 'close file='//trim(outfile) )  
+      
+  end subroutine
+
+!-------------------------------------------------------------------------------
+  subroutine netcdf_err( err, string )
+      integer, intent(in) :: err
+      character(len=*), intent(in) :: string
+      character(len=256) :: errmsg
+      include "netcdf.inc"
+
+      if( err.EQ.NF_NOERR )return
+      errmsg = NF_STRERROR(err)
+      print*, trim(string), ': ', trim(errmsg)
+
+      return
+    end subroutine netcdf_err
diff --git a/sorc/sfc_climo_gen.fd/CMakeLists.txt b/sorc/sfc_climo_gen.fd/CMakeLists.txt
new file mode 100644
index 0000000..b57f47f
--- /dev/null
+++ b/sorc/sfc_climo_gen.fd/CMakeLists.txt
@@ -0,0 +1,25 @@
+set(fortran_src
+    driver.F90
+    interp.F90
+    model_grid.F90
+    output.f90
+    program_setup.f90
+    search.f90
+    source_grid.F90
+    utils.f90)
+
+if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -r8 -convert big_endian")
+elseif(CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Clang|AppleClang)$")
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -ffree-line-length-0 -fdefault-real-8 -fconvert=big-endian")
+endif()
+
+set(exe_name sfc_climo_gen)
+add_executable(${exe_name} ${fortran_src})
+target_link_libraries(
+  ${exe_name}
+  esmf
+  MPI::MPI_Fortran
+  NetCDF::NetCDF_Fortran)
+
+install(TARGETS ${exe_name} RUNTIME DESTINATION ${exec_dir})
diff --git a/sorc/sfc_climo_gen.fd/interp.F90 b/sorc/sfc_climo_gen.fd/interp.F90
index 5ed80f1..67a8cc0 100644
--- a/sorc/sfc_climo_gen.fd/interp.F90
+++ b/sorc/sfc_climo_gen.fd/interp.F90
@@ -46,6 +46,8 @@
  real(esmf_kind_r4), allocatable    :: data_src_global(:,:)
  real(esmf_kind_r4), allocatable    :: data_mdl_one_tile(:,:)
  real(esmf_kind_r4), allocatable    :: vegt_mdl_one_tile(:,:)
+ real(esmf_kind_r4), allocatable    :: lat_mdl_one_tile(:,:)
+ real(esmf_kind_r4), allocatable    :: lon_mdl_one_tile(:,:)
 
  type(esmf_regridmethod_flag),intent(in) :: method
  type(esmf_field)                        :: data_field_src
@@ -93,9 +95,13 @@
  if (localpet == 0) then
    allocate(data_mdl_one_tile(i_mdl,j_mdl))
    allocate(mask_mdl_one_tile(i_mdl,j_mdl))
+   allocate(lat_mdl_one_tile(i_mdl,j_mdl))
+   allocate(lon_mdl_one_tile(i_mdl,j_mdl))
  else
    allocate(data_mdl_one_tile(0,0))
    allocate(mask_mdl_one_tile(0,0))
+   allocate(lat_mdl_one_tile(0,0))
+   allocate(lon_mdl_one_tile(0,0))
  endif
 
  record = 0
@@ -199,6 +205,16 @@
 
    OUTPUT_LOOP : do tile = 1, num_tiles
 
+     print*,"- CALL FieldGather FOR MODEL LATITUDE."
+     call ESMF_FieldGather(latitude_field_mdl, lat_mdl_one_tile, rootPet=0, tile=tile, rc=rc)
+     if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldGather.", rc)
+
+     print*,"- CALL FieldGather FOR MODEL LONGITUDE."
+     call ESMF_FieldGather(longitude_field_mdl, lon_mdl_one_tile, rootPet=0, tile=tile, rc=rc)
+     if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+        call error_handler("IN FieldGather.", rc)
+
      print*,"- CALL FieldGather FOR MODEL GRID DATA."
      call ESMF_FieldGather(data_field_mdl, data_mdl_one_tile, rootPet=0, tile=tile, rc=rc)
      if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
@@ -225,7 +241,7 @@
            call adjust_for_landice (data_mdl_one_tile, vegt_mdl_one_tile, i_mdl, j_mdl, field_names(n))
        end select
        where(mask_mdl_one_tile == 0) data_mdl_one_tile = missing
-       call output (data_mdl_one_tile, i_mdl, j_mdl, tile, record, t, n)
+       call output (data_mdl_one_tile, lat_mdl_one_tile, lon_mdl_one_tile, i_mdl, j_mdl, tile, record, t, n)
      endif
 
      if (field_names(n) == 'vegetation_type') then
@@ -245,7 +261,7 @@
  status=nf90_close(ncid)
 
  deallocate(data_mdl_one_tile, mask_mdl_one_tile)
- deallocate(data_src_global)
+ deallocate(data_src_global, lat_mdl_one_tile, lon_mdl_one_tile)
 
  print*,"- CALL FieldRegridRelease."
  call ESMF_FieldRegridRelease(routehandle=regrid_data, rc=rc)
diff --git a/sorc/sfc_climo_gen.fd/model_grid.F90 b/sorc/sfc_climo_gen.fd/model_grid.F90
index f281b64..b123b6b 100644
--- a/sorc/sfc_climo_gen.fd/model_grid.F90
+++ b/sorc/sfc_climo_gen.fd/model_grid.F90
@@ -26,6 +26,10 @@
 ! grid_mdl                     ESMF grid object for the model grid.
 ! grid_tiles                   Array of model grid tile names.
 ! i/j_mdl                      i/j dimensions of model tile.
+! latitude_field_mdl           ESMF field object that holds the
+!                              model grid latitude
+! longitude_field_mdl          ESMF field object that holds the
+!                              model grid longitude
 ! mdl_field_mdl                ESMF field object that holds the
 !                              model land mask.
 ! missing                      Value assigned to undefined points
@@ -51,6 +55,7 @@
 
  type(esmf_grid),  public      :: grid_mdl
  type(esmf_field), public      :: data_field_mdl, mask_field_mdl
+ type(esmf_field), public      :: latitude_field_mdl, longitude_field_mdl
  type(esmf_field), public      :: vegt_field_mdl
 
  public                        :: define_model_grid
@@ -92,10 +97,13 @@
  integer                          :: extra, rc, tile
  integer, allocatable             :: decomptile(:,:)
 
- integer, allocatable             :: mask_mdl_one_tile(:,:)
+ integer(esmf_kind_i4), allocatable :: mask_mdl_one_tile(:,:)
  integer(esmf_kind_i4), pointer   :: mask_field_mdl_ptr(:,:)
  integer(esmf_kind_i4), pointer   :: mask_mdl_ptr(:,:)
 
+ real(esmf_kind_r4), allocatable  :: latitude_one_tile(:,:)
+ real(esmf_kind_r4), allocatable  :: longitude_one_tile(:,:)
+
 !-----------------------------------------------------------------------
 ! Get the number of tiles from the mosaic file.
 !-----------------------------------------------------------------------
@@ -193,6 +201,24 @@
  if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
     call error_handler("IN FieldCreate", rc)
 
+ print*,"- CALL FieldCreate FOR MODEL GRID LATITUDE."
+ latitude_field_mdl = ESMF_FieldCreate(grid_mdl, &
+                                   typekind=ESMF_TYPEKIND_R4, &
+                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
+                                   name="latitude on model grid", &
+                                   rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldCreate", rc)
+
+ print*,"- CALL FieldCreate FOR MODEL GRID LONGITUDE."
+ longitude_field_mdl = ESMF_FieldCreate(grid_mdl, &
+                                   typekind=ESMF_TYPEKIND_R4, &
+                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
+                                   name="longitude on model grid", &
+                                   rc=rc)
+ if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+    call error_handler("IN FieldCreate", rc)
+
 !-----------------------------------------------------------------------
 ! Set model land mask.
 !-----------------------------------------------------------------------
@@ -216,22 +242,39 @@
 
  if (localpet == 0) then
    allocate(mask_mdl_one_tile(i_mdl,j_mdl))
+   allocate(latitude_one_tile(i_mdl,j_mdl))
+   allocate(longitude_one_tile(i_mdl,j_mdl))
  else
    allocate(mask_mdl_one_tile(0,0))
+   allocate(latitude_one_tile(0,0))
+   allocate(longitude_one_tile(0,0))
  endif
 
  do tile = 1, num_tiles
    if (localpet == 0) then
      the_file = trim(orog_dir_mdl) // trim(orog_files_mdl(tile))
-     call get_model_mask(trim(the_file), mask_mdl_one_tile, i_mdl, j_mdl)
+     call get_model_info(trim(the_file), mask_mdl_one_tile, & 
+                         latitude_one_tile, longitude_one_tile, i_mdl, j_mdl)
    endif
+
    print*,"- CALL FieldScatter FOR MODEL GRID MASK. TILE IS: ", tile
    call ESMF_FieldScatter(mask_field_mdl, mask_mdl_one_tile, rootpet=0, tile=tile, rc=rc)
    if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
       call error_handler("IN FieldScatter", rc)
+
+   print*,"- CALL FieldScatter FOR MODEL LATITUDE. TILE IS: ", tile
+   call ESMF_FieldScatter(latitude_field_mdl, latitude_one_tile, rootpet=0, tile=tile, rc=rc)
+   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
+
+   print*,"- CALL FieldScatter FOR MODEL LONGITUDE. TILE IS: ", tile
+   call ESMF_FieldScatter(longitude_field_mdl, longitude_one_tile, rootpet=0, tile=tile, rc=rc)
+   if(ESMF_logFoundError(rcToCheck=rc,msg=ESMF_LOGERR_PASSTHRU,line=__LINE__,file=__FILE__)) &
+      call error_handler("IN FieldScatter", rc)
+
  enddo
 
- deallocate(mask_mdl_one_tile)
+ deallocate(mask_mdl_one_tile, latitude_one_tile, longitude_one_tile)
 
  print*,"- CALL GridAddItem FOR MODEL GRID."
  call ESMF_GridAddItem(grid_mdl, &
@@ -254,17 +297,17 @@
 
  end subroutine define_model_grid
 
- subroutine get_model_mask(orog_file, mask, idim, jdim)
+ subroutine get_model_info(orog_file, mask, lat2d, lon2d, idim, jdim)
 
 !-----------------------------------------------------------------------
 !  subroutine documentation block
 !
-! Subroutine: get model mask
+! Subroutine: get model information
 !   prgmmr: gayno          org: w/np2           date: 2018
 !
-! Abstract: Read model land/sea mask from the orography file.
+! Abstract: Read model land/sea mask and lat/lon from the orography file.
 !
-! Usage:  call get_model_mask(orog_file, mask, idim, jdim)
+! Usage:  call get_model_info(orog_file, mask, lat2d, lon2d, idim, jdim)
 !
 !   input argument list:
 !     orog_file              the orography file
@@ -272,6 +315,8 @@
 !
 !   output argument list:
 !     mask                   land/sea mask
+!     lat2d                  latitude
+!     lon2d                  longitude
 !
 !-----------------------------------------------------------------------
 
@@ -286,16 +331,19 @@
  integer, intent(in)                :: idim, jdim
  integer(esmf_kind_i4), intent(out) :: mask(idim,jdim)
 
+ real(esmf_kind_r4), intent(out)    :: lat2d(idim,jdim)
+ real(esmf_kind_r4), intent(out)    :: lon2d(idim,jdim)
+
  integer                            :: error, lat, lon
  integer                            :: ncid, id_dim, id_var
 
  real(kind=4), allocatable          :: dummy(:,:)
 
- print*,"- READ MODEL LAND MASK FILE"
+ print*,"- READ MODEL OROGRAPHY FILE"
 
- print*,'- OPEN LAND MASK FILE: ', orog_file
+ print*,'- OPEN FILE: ', orog_file
  error=nf90_open(orog_file,nf90_nowrite,ncid)
- call netcdf_err(error, "OPENING MODEL LAND MASK FILE")
+ call netcdf_err(error, "OPENING MODEL OROGRAPHY FILE")
 
  print*,"- READ I-DIMENSION"
  error=nf90_inq_dimid(ncid, 'lon', id_dim)
@@ -322,14 +370,27 @@
  call netcdf_err(error, "READING SLMSK ID")
  error=nf90_get_var(ncid, id_var, dummy)
  call netcdf_err(error, "READING SLMSK")
+ mask = nint(dummy)
 
- error = nf90_close(ncid)
+ print*,"- READ LATITUDE"
+ error=nf90_inq_varid(ncid, 'geolat', id_var)
+ call netcdf_err(error, "READING GEOLAT ID")
+ error=nf90_get_var(ncid, id_var, dummy)
+ call netcdf_err(error, "READING GEOLAT")
+ lat2d=dummy
 
- mask = nint(dummy)
+ print*,"- READ LONGITUDE"
+ error=nf90_inq_varid(ncid, 'geolon', id_var)
+ call netcdf_err(error, "READING GEOLON ID")
+ error=nf90_get_var(ncid, id_var, dummy)
+ call netcdf_err(error, "READING GEOLON")
+ lon2d=dummy
+
+ error = nf90_close(ncid)
 
  deallocate (dummy)
 
- end subroutine get_model_mask
+ end subroutine get_model_info
 
  subroutine model_grid_cleanup
 
@@ -361,6 +422,12 @@
  print*,"- CALL FieldDestroy FOR MODEL GRID VEGETATION TYPE."
  call ESMF_FieldDestroy(vegt_field_mdl,rc=rc)
 
+ print*,"- CALL FieldDestroy FOR MODEL GRID LATITUDE."
+ call ESMF_FieldDestroy(latitude_field_mdl,rc=rc)
+
+ print*,"- CALL FieldDestroy FOR MODEL GRID LONGITUDE."
+ call ESMF_FieldDestroy(longitude_field_mdl,rc=rc)
+
  end subroutine model_grid_cleanup
 
  end module model_grid
diff --git a/sorc/sfc_climo_gen.fd/output.f90 b/sorc/sfc_climo_gen.fd/output.f90
new file mode 100644
index 0000000..b38aa8b
--- /dev/null
+++ b/sorc/sfc_climo_gen.fd/output.f90
@@ -0,0 +1,266 @@
+ subroutine output(data_one_tile, lat_one_tile, lon_one_tile, i_mdl, j_mdl, &
+                   tile, record, time, field_idx)
+
+!--------------------------------------------------------------------------
+!  subroutine documentation block
+!
+! Subroutine: output
+!   prgmmr: gayno             org: w/np2           date: 2018
+!
+! Abstract:  Output model data for a single tile and a single
+!    record in netcdf format.
+!
+! Usage: call output(data_one_tile, lat_one_tile, lon_one_tile, &
+!                    i_mdl, j_mdl, tile, record, &
+!                    time, field_idx)
+!
+!   input argument list:
+!     data_one_tile             Data to be output (single tile).
+!     lat_one_tile              Latitude of tile.
+!     lon_one_tile              Longitude of tile.
+!     field_idx                 Index of field within field name
+!                               array.
+!     i/j_mdl                   i/j dimensions of tile.
+!     record                    Record number to be output.
+!     tile                      Tile number.
+!     time                      Time period to be output.
+!--------------------------------------------------------------------------
+
+ use esmf
+ use netcdf
+ use utils
+ use source_grid, only             : field_names, source, num_fields, &
+                                     num_time_recs, num_records, day_of_rec
+ use model_grid, only              : missing, grid_tiles
+ use program_setup, only           : halo
+
+ implicit none
+
+ include 'mpif.h'
+
+ integer, intent(in)              :: i_mdl, j_mdl, tile
+ integer, intent(in)              :: record, time, field_idx
+
+ real(esmf_kind_r4), intent(in)   :: data_one_tile(i_mdl,j_mdl)
+ real(esmf_kind_r4), intent(in)   :: lat_one_tile(i_mdl,j_mdl)
+ real(esmf_kind_r4), intent(in)   :: lon_one_tile(i_mdl,j_mdl)
+
+ character(len=200)               :: out_file
+ character(len=200)               :: out_file_with_halo
+
+ integer                          :: initialsiz, fsize, error, j
+ integer                          :: dim_x, dim_y, id_data
+ integer                          :: dim_time, id_times
+ integer                          :: header_buffer_val = 16384
+ integer                          :: i_out, j_out, id_lat, id_lon
+ integer                          :: i_start, i_end, j_start, j_end
+ integer, save                    :: ncid(6), ncid_with_halo
+
+ select case (field_names(field_idx))
+   case ('substrate_temperature')
+     out_file = "./substrate_temperature." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./substrate_temperature." // grid_tiles(tile) // ".halo.nc"
+   case ('vegetation_greenness')
+     out_file = "./vegetation_greenness." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./vegetation_greenness." // grid_tiles(tile) // ".halo.nc"
+   case ('maximum_snow_albedo')
+     out_file = "./maximum_snow_albedo." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./maximum_snow_albedo." // grid_tiles(tile) // ".halo.nc"
+   case ('leaf_area_index')
+     out_file = "./leaf_area_index." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./leaf_area_index." // grid_tiles(tile) // ".halo.nc"
+   case ('visible_black_sky_albedo', 'visible_white_sky_albedo', 'near_IR_black_sky_albedo', 'near_IR_white_sky_albedo')
+     out_file = "./snowfree_albedo." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./snowfree_albedo." // grid_tiles(tile) // ".halo.nc"
+   case ('facsf')
+     out_file = "./facsf." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./facsf." // grid_tiles(tile) // ".halo.nc"
+   case ('slope_type')
+     out_file = "./slope_type." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./slope_type." // grid_tiles(tile) // ".halo.nc"
+   case ('soil_type')
+     out_file = "./soil_type." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./soil_type." // grid_tiles(tile) // ".halo.nc"
+   case ('vegetation_type')
+     out_file = "./vegetation_type." // grid_tiles(tile) // ".nc"
+     out_file_with_halo = "./vegetation_type." // grid_tiles(tile) // ".halo.nc"
+   case default
+     print*,'- FATAL ERROR IN ROUTINE OUTPUT.  UNIDENTIFIED FIELD : ', field_names(field_idx)
+     call mpi_abort(mpi_comm_world, 67)
+ end select
+
+!----------------------------------------------------------------------
+! If user specified a halo (for running stand-alone regional grid),
+! remove it.
+!----------------------------------------------------------------------
+
+ if (halo > 0) then
+   print*,"- WILL REMOVE HALO REGION OF ", halo, " ROWS/COLS."
+   i_start = 1 + halo
+   i_end   = i_mdl - halo
+   j_start = 1 + halo
+   j_end   = j_mdl - halo
+ else
+   i_start = 1
+   i_end   = i_mdl
+   j_start = 1
+   j_end   = j_mdl
+ endif
+
+ i_out = i_end - i_start + 1
+ j_out = j_end - j_start + 1
+
+ if (record == 1) then
+
+   initialsiz = 0
+   fsize      = 65536
+   error = nf90_create(out_file, IOR(NF90_NETCDF4,NF90_CLASSIC_MODEL), &
+                       ncid(tile), initialsize=initialsiz, chunksize=fsize)
+   call netcdf_err(error, 'ERROR IN NF90_CREATE' )
+   error = nf90_def_dim(ncid(tile), 'nx', i_out, dim_x)
+   call netcdf_err(error, 'DEFINING NX DIMENSION' )
+   error = nf90_def_dim(ncid(tile), 'ny', j_out, dim_y)
+   call netcdf_err(error, 'DEFINING NY DIMENSION' )
+   error = nf90_def_dim(ncid(tile), 'time', num_time_recs, dim_time)
+   call netcdf_err(error, 'DEFINING TIME DIMENSION' )
+   error = nf90_def_var(ncid(tile), 'time', NF90_FLOAT, dim_time, id_times)
+   call netcdf_err(error, 'DEFINING TIME VARIABLE' )
+   error = nf90_put_att(ncid(tile), id_times, "units", "days since 2015-1-1")
+   call netcdf_err(error, 'DEFINING TIME ATTRIBUTE' )
+   if (len_trim(source) > 0) then
+     error = nf90_put_att(ncid(tile), nf90_global, 'source', source)
+     call netcdf_err(error, 'DEFINING GLOBAL SOURCE ATTRIBUTE' )
+   endif
+
+   error = nf90_def_var(ncid(tile), 'geolat', NF90_FLOAT, (/dim_x,dim_y/), id_lat)
+   call netcdf_err(error, 'DEFINING GEOLAT FIELD' )
+   error = nf90_put_att(ncid(tile), id_lat, "long_name", "Latitude")
+   call netcdf_err(error, 'DEFINING GEOLAT NAME ATTRIBUTE' )
+   error = nf90_put_att(ncid(tile), id_lat, "units", "degrees_north")
+   call netcdf_err(error, 'DEFINING GEOLAT UNIT ATTRIBUTE' )
+   error = nf90_def_var(ncid(tile), 'geolon', NF90_FLOAT, (/dim_x,dim_y/), id_lon)
+   call netcdf_err(error, 'DEFINING GEOLON FIELD' )
+   error = nf90_put_att(ncid(tile), id_lon, "long_name", "Longitude")
+   call netcdf_err(error, 'DEFINING GEOLON NAME ATTRIBUTE' )
+   error = nf90_put_att(ncid(tile), id_lon, "units", "degrees_east")
+   call netcdf_err(error, 'DEFINING GEOLON UNIT ATTRIBUTE' )
+
+   do j = 1, num_fields
+     error = nf90_def_var(ncid(tile), trim(field_names(j)), NF90_FLOAT, (/dim_x,dim_y,dim_time/), id_data)
+     call netcdf_err(error, 'DEFINING FIELD' )
+     error = nf90_put_att(ncid(tile), id_data, "missing_value", missing)
+     call netcdf_err(error, 'DEFINING FIELD ATTRIBUTE' )
+     error = nf90_put_att(ncid(tile), id_data, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING COORD ATTRIBUTE' )
+   enddo
+
+   error = nf90_enddef(ncid(tile), header_buffer_val,4,0,4)
+   call netcdf_err(error, 'IN NF90_ENDDEF' )
+
+   error = nf90_put_var( ncid(tile), id_times, day_of_rec) 
+   call netcdf_err(error, 'WRITING TIME FIELD' )
+
+   error = nf90_put_var( ncid(tile), id_lat, lat_one_tile(i_start:i_end,j_start:j_end),  &
+                         start=(/1,1/), count=(/i_out,j_out/))
+   call netcdf_err(error, 'IN NF90_PUT_VAR FOR GEOLAT' )
+
+   error = nf90_put_var( ncid(tile), id_lon, lon_one_tile(i_start:i_end,j_start:j_end),  &
+                         start=(/1,1/), count=(/i_out,j_out/))
+   call netcdf_err(error, 'IN NF90_PUT_VAR FOR GEOLON' )
+
+ endif
+
+ print*,'- WRITE DATA FOR RECORD: ',record
+ error = nf90_inq_varid( ncid(tile), field_names(field_idx), id_data)
+ call netcdf_err(error, 'IN NF90_INQ_VARID' )
+ error = nf90_put_var( ncid(tile), id_data, data_one_tile(i_start:i_end,j_start:j_end),  &
+                            start=(/1,1,time/), count=(/i_out,j_out,1/))
+ call netcdf_err(error, 'IN NF90_PUT_VAR' )
+  
+ if (record == num_records) then
+   error = nf90_close(ncid(tile))
+ endif
+
+!----------------------------------------------------------------------
+! For regional nests, also output files including the halo
+!----------------------------------------------------------------------
+
+ if (halo == 0) return
+
+ print*,"- WRITE OUT FILES THAT INCLUDE HALO REGION."
+
+ if (record == 1) then
+
+   initialsiz = 0
+   fsize      = 65536
+   error = nf90_create(out_file_with_halo, IOR(NF90_NETCDF4,NF90_CLASSIC_MODEL), &
+                       ncid_with_halo, initialsize=initialsiz, chunksize=fsize)
+   call netcdf_err(error, 'IN NF90_CREATE' )
+   error = nf90_def_dim(ncid_with_halo, 'nx', i_mdl, dim_x)
+   call netcdf_err(error, 'DEFINING NX DIMENSION' )
+   error = nf90_def_dim(ncid_with_halo, 'ny', j_mdl, dim_y)
+   call netcdf_err(error, 'DEFINING NY DIMENSION' )
+   error = nf90_def_dim(ncid_with_halo, 'time', num_time_recs, dim_time)
+   call netcdf_err(error, 'DEFINING TIME DIMENSION' )
+   error = nf90_def_var(ncid_with_halo, 'time', NF90_FLOAT, dim_time, id_times)
+   call netcdf_err(error, 'DEFINING TIME VARIABLE' )
+   error = nf90_put_att(ncid_with_halo, id_times, "units", "days since 2015-1-1")
+   call netcdf_err(error, 'DEFINING TIME ATTRIBUTE' )
+   if (len_trim(source) > 0) then
+     error = nf90_put_att(ncid_with_halo, nf90_global, 'source', source)
+     call netcdf_err(error, 'DEFINING GLOBAL SOURCE ATTRIBUTE' )
+   endif
+
+   error = nf90_def_var(ncid_with_halo, 'geolat', NF90_FLOAT, (/dim_x,dim_y/), id_lat)
+   call netcdf_err(error, 'DEFINING GEOLAT FIELD' )
+   error = nf90_put_att(ncid_with_halo, id_lat, "long_name", "Latitude")
+   call netcdf_err(error, 'DEFINING GEOLAT NAME ATTRIBUTE' )
+   error = nf90_put_att(ncid_with_halo, id_lat, "units", "degrees_north")
+   call netcdf_err(error, 'DEFINING GEOLAT UNIT ATTRIBUTE' )
+   error = nf90_def_var(ncid_with_halo, 'geolon', NF90_FLOAT, (/dim_x,dim_y/), id_lon)
+   call netcdf_err(error, 'DEFINING GEOLON FIELD' )
+   error = nf90_put_att(ncid_with_halo, id_lon, "long_name", "Longitude")
+   call netcdf_err(error, 'DEFINING GEOLON NAME ATTRIBUTE' )
+   error = nf90_put_att(ncid_with_halo, id_lon, "units", "degrees_east")
+   call netcdf_err(error, 'DEFINING GEOLON UNIT ATTRIBUTE' )
+
+   do j = 1, num_fields
+     error = nf90_def_var(ncid_with_halo, field_names(j), NF90_FLOAT, (/dim_x,dim_y,dim_time/), id_data)
+     call netcdf_err(error, 'DEFINING FIELD VARIABLE' )
+     error = nf90_put_att(ncid_with_halo, id_data, "missing_value", missing)
+     call netcdf_err(error, 'DEFINING FIELD ATTRIBUTE' )
+     error = nf90_put_att(ncid_with_halo, id_data, "coordinates", "geolon geolat")
+     call netcdf_err(error, 'DEFINING COORD ATTRIBUTE' )
+   enddo
+
+   error = nf90_enddef(ncid_with_halo, header_buffer_val,4,0,4)
+   call netcdf_err(error, 'WRITING HEADER ENDDEF' )
+
+   error = nf90_put_var(ncid_with_halo, id_times, day_of_rec) 
+   call netcdf_err(error, 'WRITING TIME VARIABLE' )
+
+   error = nf90_put_var( ncid_with_halo, id_lat, lat_one_tile,  &
+                         start=(/1,1/), count=(/i_mdl,j_mdl/))
+   call netcdf_err(error, 'IN NF90_PUT_VAR FOR GEOLAT' )
+
+   error = nf90_put_var( ncid_with_halo, id_lon, lon_one_tile,  &
+                         start=(/1,1/), count=(/i_mdl,j_mdl/))
+   call netcdf_err(error, 'IN NF90_PUT_VAR FOR GEOLON' )
+
+ endif
+
+ print*,'- WRITE DATA FOR RECORD: ',record
+ error = nf90_inq_varid(ncid_with_halo, field_names(field_idx), id_data)
+ call netcdf_err(error, 'IN NF90_INQ_VARID' )
+
+ error = nf90_put_var(ncid_with_halo, id_data, data_one_tile,  &
+                      start=(/1,1,time/), count=(/i_mdl,j_mdl,1/))
+ call netcdf_err(error, 'IN NF90_PUT_VAR' )
+  
+ if (record == num_records) then
+   error = nf90_close(ncid_with_halo)
+ endif
+
+ return
+
+ end subroutine output
diff --git a/ush/chgres_cube.sh b/ush/chgres_cube.sh
index dec2797..fd036e5 100755
--- a/ush/chgres_cube.sh
+++ b/ush/chgres_cube.sh
@@ -62,11 +62,14 @@ HALO_BNDY=${HALO_BNDY:-0}
 HALO_BLEND=${HALO_BLEND:-0}
 
 #----------------------------------------------------------------------------
-# INPUT_TYPE - Input data type.  'history' for tiled fv3 history files.
-#              'restart' for tiled fv3 warm restart files.  'gfs_gaussian'
-#              for spectral gfs nemsio files.  'gfs_spectral' for 
-#              for spectral gfs sigio/sfcio files.  'gaussian' for fv3
-#              gaussian nemsio files. 'grib2' for gfs grib2 files.
+# INPUT_TYPE - Input data type:  
+#        'restart' for tiled fv3 warm restart files.  
+#        'history' for tiled fv3 history files.
+#        'gaussian_nemsio' for fv3 gaussian nemsio files.
+#        'gaussian_netcdf' for fv3 gaussian netcdf files.
+#        'grib2' for fv3gfs grib2 files.
+#        'gfs_gaussain_nemsio' for spectral gfs nemsio files.
+#        'gfs_sigio' for spectral gfs sigio/sfcio files.
 #
 # MOSAIC_FILE_INPUT_GRID - Path/Name of mosaic file for input grid.  Only
 #                          used for 'history' and 'restart' INPUT_TYPE.
@@ -81,7 +84,7 @@ HALO_BLEND=${HALO_BLEND:-0}
 #                         Set to NULL otherwise.
 #----------------------------------------------------------------------------
 
-INPUT_TYPE=${INPUT_TYPE:-"gaussian"}
+INPUT_TYPE=${INPUT_TYPE:-"gaussian_nemsio"}
 MOSAIC_FILE_INPUT_GRID=${MOSAIC_FILE_INPUT_GRID:-NULL}
 OROG_DIR_INPUT_GRID=${OROG_DIR_INPUT_GRID:-NULL}
 OROG_FILES_INPUT_GRID=${OROG_FILES_INPUT_GRID:-NULL}
@@ -101,7 +104,7 @@ COMIN=${COMIN:-$PWD}
 
 #----------------------------------------------------------------------------
 # ATM_FILES_INPUT - Input atmospheric data file(s).  Not used for 'restart'
-#                   and 'grib2' INPUT_TYPE.
+#                   or 'grib2' INPUT_TYPE.
 #
 # ATM_CORE_FILES - Input atmospheric core files.  Used for 'restart' 
 #                  INPUT_TYPE only.  The first six entries are the tiled
@@ -114,7 +117,7 @@ COMIN=${COMIN:-$PWD}
 # SFC_FILES_INPUT - Input surface data file(s).  Not used for 'grib2'
 #                   INPUT_TYPE.
 #
-# NST_FILES_INPUT - Input nst data file.  'gfs_gaussian' INPUT_TYPE only.
+# NST_FILES_INPUT - Input nst data file.  'gfs_gaussian_nemsio' INPUT_TYPE only.
 #
 # GRIB2_FILE_INPUT - Input gfs grib2 data file.  Only used for 'grib2'
 #                    INPUT_TYPE.
@@ -167,7 +170,7 @@ fi
 #----------------------------------------------------------------------------
 # APRUN - machine specific command to run program.
 # CHGRESEXEC - program executable.
-# OMP_NUM_THREADS - threads most useful for 'gfs_spectral' INPUT_TYPE.
+# OMP_NUM_THREADS - threads most useful for 'gfs_sigio' INPUT_TYPE.
 # DATA - working directory.
 # PGMOUT - standard output file
 # PGMERR - standard error file
@@ -176,9 +179,9 @@ fi
 #----------------------------------------------------------------------------
 
 APRUN=${APRUN:-time}
-CHGRESEXEC=${CHGRESEXEC:-${EXECufs}/chgres_cube.exe}
+CHGRESEXEC=${CHGRESEXEC:-${EXECufs}/chgres_cube}
 
-export OMP_NUM_THREADS=${OMP_NUM_THREADS_CY:-1}
+export OMP_NUM_THREADS=${OMP_NUM_THREADS_CH:-1}
 
 PGMOUT=${PGMOUT:-${pgmout:-'&1'}}
 PGMERR=${PGMERR:-${pgmerr:-'&2'}}
diff --git a/ush/fv3gfs_driver_grid.sh b/ush/fv3gfs_driver_grid.sh
index 3fd806c..4e7d909 100755
--- a/ush/fv3gfs_driver_grid.sh
+++ b/ush/fv3gfs_driver_grid.sh
@@ -360,8 +360,8 @@ elif [ $gtype = regional ]; then
   echo $npts_cgx $npts_cgy $halop1 \'$filter_dir/oro.C${res}.tile${tile}.nc\' \'$filter_dir/oro.C${res}.tile${tile}.shave.nc\' >input.shave.orog
   echo $npts_cgx $npts_cgy $halop1 \'$filter_dir/C${res}_grid.tile${tile}.nc\' \'$filter_dir/C${res}_grid.tile${tile}.shave.nc\' >input.shave.grid
 
-  $APRUN $exec_dir/shave.x <input.shave.orog
-  $APRUN $exec_dir/shave.x <input.shave.grid
+  $APRUN $exec_dir/shave <input.shave.orog
+  $APRUN $exec_dir/shave <input.shave.grid
 
   cp $filter_dir/oro.C${res}.tile${tile}.shave.nc   $out_dir/C${res}_oro_data.tile${tile}.halo${halop1}.nc
   cp $filter_dir/C${res}_grid.tile${tile}.shave.nc  $out_dir/C${res}_grid.tile${tile}.halo${halop1}.nc
@@ -374,8 +374,8 @@ elif [ $gtype = regional ]; then
   echo $npts_cgx $npts_cgy $halo \'$filter_dir/oro.C${res}.tile${tile}.nc\' \'$filter_dir/oro.C${res}.tile${tile}.shave.nc\' >input.shave.orog.halo$halo
   echo $npts_cgx $npts_cgy $halo \'$filter_dir/C${res}_grid.tile${tile}.nc\' \'$filter_dir/C${res}_grid.tile${tile}.shave.nc\' >input.shave.grid.halo$halo
 
-  $APRUN $exec_dir/shave.x <input.shave.orog.halo$halo
-  $APRUN $exec_dir/shave.x <input.shave.grid.halo$halo
+  $APRUN $exec_dir/shave <input.shave.orog.halo$halo
+  $APRUN $exec_dir/shave <input.shave.grid.halo$halo
  
   cp $filter_dir/oro.C${res}.tile${tile}.shave.nc $out_dir/C${res}_oro_data.tile${tile}.halo${halo}.nc
   cp $filter_dir/C${res}_grid.tile${tile}.shave.nc  $out_dir/C${res}_grid.tile${tile}.halo${halo}.nc
@@ -388,8 +388,8 @@ elif [ $gtype = regional ]; then
   echo $npts_cgx $npts_cgy 0 \'$filter_dir/oro.C${res}.tile${tile}.nc\' \'$filter_dir/oro.C${res}.tile${tile}.shave.nc\' >input.shave.orog.halo0
   echo $npts_cgx $npts_cgy 0 \'$filter_dir/C${res}_grid.tile${tile}.nc\' \'$filter_dir/C${res}_grid.tile${tile}.shave.nc\' >input.shave.grid.halo0
 
-  $APRUN $exec_dir/shave.x <input.shave.orog.halo0
-  $APRUN $exec_dir/shave.x <input.shave.grid.halo0
+  $APRUN $exec_dir/shave <input.shave.orog.halo0
+  $APRUN $exec_dir/shave <input.shave.grid.halo0
 
   cp $filter_dir/oro.C${res}.tile${tile}.shave.nc   $out_dir/C${res}_oro_data.tile${tile}.halo0.nc
   cp $filter_dir/C${res}_grid.tile${tile}.shave.nc  $out_dir/C${res}_grid.tile${tile}.halo0.nc
diff --git a/ush/fv3gfs_make_orog.sh b/ush/fv3gfs_make_orog.sh
index e5cec83..7e8960d 100755
--- a/ush/fv3gfs_make_orog.sh
+++ b/ush/fv3gfs_make_orog.sh
@@ -53,7 +53,7 @@ else
 fi
 
 export indir=$hist_dir
-export executable=$exec_dir/orog.x
+export executable=$exec_dir/orog
 if [ ! -s $executable ]; then
   echo "executable does not exist"
   exit 1 
diff --git a/util/gdas_init/driver.cray.sh b/util/gdas_init/driver.cray.sh
index 99e9bd0..93cae34 100755
--- a/util/gdas_init/driver.cray.sh
+++ b/util/gdas_init/driver.cray.sh
@@ -8,16 +8,8 @@
 
 set -x
 
-module purge
-module load PrgEnv-intel/5.2.56
-module rm intel
-module load intel/16.3.210
-module load cray-mpich/7.2.0
-module load craype-haswell
-module load cray-netcdf/4.3.3.1
-module load xt-lsfhpc/9.1.3
-module load prod_util/1.1.0
-module load hpss/4.1.0.3
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 module list
 
 PROJECT_CODE=GFS-DEV
diff --git a/util/gdas_init/driver.dell.sh b/util/gdas_init/driver.dell.sh
index 27af36e..ec18e09 100755
--- a/util/gdas_init/driver.dell.sh
+++ b/util/gdas_init/driver.dell.sh
@@ -8,16 +8,8 @@
 
 set -x
 
-module purge
-module load EnvVars/1.0.2
-module load ips/18.0.1.163
-module load impi/18.0.1
-module load lsf/10.1
-module load HPSS/5.0.2.5
-module use /usrx/local/dev/modulefiles
-module load NetCDF/4.5.0
-module load prod_util/1.1.3
-module list
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 
 PROJECT_CODE=GFS-DEV
 
diff --git a/util/gdas_init/driver.hera.sh b/util/gdas_init/driver.hera.sh
index 711bab9..02a703e 100755
--- a/util/gdas_init/driver.hera.sh
+++ b/util/gdas_init/driver.hera.sh
@@ -8,16 +8,8 @@
 
 set -x
 
-source /apps/lmod/lmod/init/sh
-module purge
-module use -a /scratch2/NCEPDEV/nwprod/NCEPLIBS/modulefiles
-module load intel/18.0.5.274
-module load impi/2018.0.4
-module load netcdf/4.7.0
-module load hpss
-module load prod_util
-module load nco/4.7.0
-module list
+source ../../sorc/machine-setup.sh > /dev/null 2>&1
+source ../../modulefiles/build.$target
 
 PROJECT_CODE=fv3-cpu
 QUEUE=batch
diff --git a/util/gdas_init/run_pre-v14.chgres.sh b/util/gdas_init/run_pre-v14.chgres.sh
index 95e5276..92cfe80 100755
--- a/util/gdas_init/run_pre-v14.chgres.sh
+++ b/util/gdas_init/run_pre-v14.chgres.sh
@@ -64,13 +64,13 @@ cat << EOF > fort.41
  convert_atm=.true.
  convert_sfc=.true.
  convert_nst=.false.
- input_type="gfs_spectral"
+ input_type="gfs_sigio"
  tracers_input="spfh","o3mr","clwmr"
  tracers="sphum","o3mr","liq_wat"
 /
 EOF
 
-$APRUN $UFS_DIR/exec/chgres_cube.exe
+$APRUN $UFS_DIR/exec/chgres_cube
 rc=$?
 
 if [ $rc != 0 ]; then
diff --git a/util/gdas_init/run_v14.chgres.sh b/util/gdas_init/run_v14.chgres.sh
index 9cd6116..c60c4b3 100755
--- a/util/gdas_init/run_v14.chgres.sh
+++ b/util/gdas_init/run_v14.chgres.sh
@@ -66,13 +66,13 @@ cat << EOF > fort.41
  convert_atm=.true.
  convert_sfc=.true.
  convert_nst=.true.
- input_type="gfs_gaussian"
+ input_type="gfs_gaussian_nemsio"
  tracers="sphum","liq_wat","o3mr"
  tracers_input="spfh","clwmr","o3mr"
 /
 EOF
 
-$APRUN $UFS_DIR/exec/chgres_cube.exe
+$APRUN $UFS_DIR/exec/chgres_cube
 rc=$?
 
 if [ $rc != 0 ]; then
diff --git a/util/gdas_init/run_v15.chgres.sh b/util/gdas_init/run_v15.chgres.sh
index 22cf94d..c26d92e 100755
--- a/util/gdas_init/run_v15.chgres.sh
+++ b/util/gdas_init/run_v15.chgres.sh
@@ -70,7 +70,7 @@ cat << EOF > fort.41
 /
 EOF
 
-$APRUN $UFS_DIR/exec/chgres_cube.exe
+$APRUN $UFS_DIR/exec/chgres_cube
 rc=$?
 
 if [ $rc != 0 ]; then
